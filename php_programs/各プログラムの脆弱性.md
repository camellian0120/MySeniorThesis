# d100_roller
## 0. 概要

与えられた `php_d100_roller.php` をレビューしました。機能はシンプルで概ね安全に見えますが、ウェブアプリとして放置すると悪用されうる点がいくつかあります。以下、**脆弱性の指摘 → 放置リスク → 改修案（具体コード例を含む）**の順で簡潔に示します。

---

## 1. CSRF（クロスサイトリクエストフォージェリ）

**指摘**

* フォームにCSRFトークンが無く、POST操作（ロールの実行）を第三者ページから強制実行され得る。

**リスク**

* 被害者がログイン等しなくても、意図せずロールが実行されサーバー側に無駄な履歴を蓄積させる、あるいは統計用途での汚染が可能。多数リクエストでDoS的影響も。

**対処（推奨）**

* セッションにCSRFトークンを保持し、フォームに hidden で埋め、POST時に検証する。

```php
// セッション開始前に（ファイル先頭で）
session_set_cookie_params([
  'lifetime' => 0,
  'secure' => true,      // HTTPS 運用なら true に
  'httponly' => true,
  'samesite' => 'Lax'
]);
session_start();

// トークン生成（初回）
if (empty($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}

// フォームに埋め込む
// <input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($_SESSION['csrf_token'], ENT_QUOTES, 'UTF-8'); ?>">

// POST 受け取り側で検証
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!isset($_POST['csrf_token']) || !hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'])) {
        http_response_code(400);
        exit('Invalid CSRF token');
    }
    // ... 続行
}
```

---

## 2. セッション設定の不備（Cookie 属性・固定化）

**指摘**

* `session_start()` の前後でセッションCookieの細かい設定がされていない（`Secure`/`HttpOnly`/`SameSite`等）。また、重要な操作後に `session_regenerate_id()` を呼んでいない。

**リスク**

* HTTPSを使っていない、あるいはCookie属性が不適切だとセッションハイジャックやセッション固定攻撃の危険が増す。

**対処（推奨）**

* `session_set_cookie_params()` で属性を設定してから `session_start()`。重要な操作（認証等）があれば `session_regenerate_id(true)` を実行。

（上の CSRF 対処例に `session_set_cookie_params` を示しています）

---

## 3. XSS（クロスサイトスクリプティング） — 出力側のエスケープ漏れ／強化

**指摘**

* 大部分の出力で `htmlspecialchars()` が使われていますが、**全て**の出力（特に属性中や条件分岐での埋め込み）で `ENT_QUOTES` と `'UTF-8'` を明示しておく方が堅牢です。また、将来別の入力項目を追加したときにエスケープ漏れが生じるリスクあり。

**リスク**

* ユーザーが挿入可能な文字列（例：ラベル）が将来別の経路でエスケープされずに出力されると、Stored/Reflected XSS によるセッション窃取やページ改ざんが起こりうる。

**対処（推奨）**

* 出力時は常に `htmlspecialchars($var, ENT_QUOTES, 'UTF-8')` を使う。属性内では追加で `urlencode` 等を検討。受け取り時に最大長を制限する。

```php
// 出力例
echo htmlspecialchars($entry['label'], ENT_QUOTES, 'UTF-8');
```

さらに、安全策として CSP ヘッダを送ることを推奨：

```php
header("Content-Security-Policy: default-src 'self'; script-src 'self';");
```

---

## 4. 入力検証不足（ラベル長など）

**指摘**

* `label` の長さや文字種に制限がなく、無制限のデータをセッションに保存可能。

**リスク**

* 悪意ある長大文字列でセッションサイズが膨張し、メモリ/ストレージを消費してDoSを誘発する可能性。ログや表示崩れの原因にも。

**対処（推奨）**

* 受信時に長さ制限（例 200 文字）を設け、不要な制御文字を除去する。サーバ側でも保存前に切り詰める。

```php
$label_raw = isset($_POST['label']) ? (string)$_POST['label'] : '';
$label = mb_substr($label_raw, 0, 200, 'UTF-8'); // 最大200文字に制限
// さらに必要ならホワイトリストで許可文字のみ通す
```

HTML 側にも `maxlength="200"` を付与して UX を改善。

---

## 5. フォーム action に対する潜在的な問題（`$_SERVER['PHP_SELF']`）

**指摘**

* `action="<?php echo htmlspecialchars($_SERVER['PHP_SELF']); ?>"` は一般に対策済みだが、より確実にするなら `basename(__FILE__)` や空にする（同ページ送信）方が安全。

**対処（推奨）**

```php
<form method="post" action="">
```

もしくは

```php
action="<?php echo htmlspecialchars(basename($_SERVER['PHP_SELF']), ENT_QUOTES, 'UTF-8'); ?>"
```

---

## 6. レート制限 / DoS 緩和の欠如

**指摘**

* 連続大量リクエストを防ぐ仕組みがない。

**リスク**

* ボットや攻撃者による大量POSTでサーバ負荷やセッション肥大化が起きる。

**対処（推奨）**

* 簡易的にはセッションにタイムスタンプ＋カウンタを置き、短時間での多数リクエストを拒否する。より本格的にはリバースプロキシ（nginx）やWAF、レートリミッターを導入。

```php
// 簡易レート制限（例: 10回/分）
if (!isset($_SESSION['rolls_window'])) {
    $_SESSION['rolls_window'] = ['start' => time(), 'count' => 0];
}
if (time() - $_SESSION['rolls_window']['start'] > 60) {
    $_SESSION['rolls_window'] = ['start' => time(), 'count' => 0];
}
$_SESSION['rolls_window']['count']++;
if ($_SESSION['rolls_window']['count'] > 10) {
    exit('Rate limit exceeded');
}
```

---

## 7. ログ／監査（任意だが推奨）

**指摘**

* 操作履歴はセッション内のみ。監査ログがあれば不正利用の追跡が容易。

**対処（推奨）**

* サーバ側ログ（ファイル/監査系）に最低限の情報（タイムスタンプ、IP、回数、ラベル短縮）を記録。

---

# 最終まとめ（短く）

* 優先度高で対応すべきは **CSRF 対策** と **セッションCookie設定（Secure/HttpOnly/SameSite）**、および **出力エスケープの厳格化（ENT_QUOTES, UTF-8）**。
* 次に **入力長制限（ラベル）** と **簡易レート制限** を入れる。
* 追加で CSP ヘッダや監査ログを検討するとより堅牢になります。

必要なら、あなたの環境（HTTP/HTTPS どちらで公開しているか、想定ユーザー数、ログ要件）に合わせた**修正版の完全コード**（該当ファイル全体を安全策入りで書き直す）をすぐ作成します。どうしますか？


# mazs_solve
以下は提示した **index.php / maze_data.php / move.php** において、実際に問題となり得る **セキュリティ上の懸念点** とその整理です。
（※「迷路ゲーム」という性質上、深刻度は低めですが、Webアプリの品質としては意識すべき点です）

---

## ✅ **1. セッション固定化（Session Fixation）が発生し得る**

### ● 何が問題か

`index.php` では **セッションIDを再生成していない** ため、攻撃者が発行したセッションIDを被害者に使わせることで、セッションを奪われる可能性がある。

### ● 影響

セッションを乗っ取られ、プレイヤーの進行状況や状態が改ざんされる可能性がある。
（迷路ゲームなので深刻ではないが、一般的な Web アプリでは重大）

### ● 対処方法

`index.php` のゲーム開始タイミングでセッションIDを再生成する：

```php
session_regenerate_id(true);
```

セッション初期化後に挿入します。

---

### ✅ **2. move.php の JSON パース部分に DoS（サービス妨害）リスク**

### ● 何が問題か

`php://input` をそのまま `json_decode()` に渡しているため、攻撃者が巨大リクエストを送りつけると PHP が大量メモリを使用して落ちる可能性がある。

### ● 影響

DoS攻撃で PHP が落ちる・サーバ停止。

### ● 対処方法

* `Content-Length` の上限を設定
* JSON の最大長をチェックし、過大データなら拒否

例：

```php
$raw = file_get_contents('php://input', false, null, 0, 2000);
if (strlen($raw) > 2000) {
    json_err("リクエストサイズが大きすぎます");
}
```

---

## ✅ **3. move.php に CSRF リスク**

### ● 何が問題か

POST による操作 API に **CSRF トークンが無い**。

### ● 影響

他サイトに誘導されただけで勝手に移動操作が送信される可能性がある。

（迷路ゲームとしては軽微だが、一般アプリでは悪用される）

### ● 対処方法（簡易版）

* セッション内に CSRF トークンを生成
* move.php はトークン検証
* JavaScript から送信する際に埋める

例：index.php

```php
$_SESSION['csrf_token'] = bin2hex(random_bytes(16));
```

JSで request body に載せる
move.php で検証：

```php
if ($data['csrf'] !== $_SESSION['csrf_token']) {
    json_err('CSRF token mismatch');
}
```

---

## ⚠ **4. セッションデータの信頼しすぎ（Tampering リスク）**

### ● 何が問題か

セッション内の `player` などは PHP のサーバ側変数なので直接クライアントからは変更されないが、
もし別の脆弱性（例：セッションID盗難）があれば **任意の位置にテレポートできるなどの不正操作**が可能。

### ● 影響

ゲーム不正操作
（迷路ゲームなので気にする必要は薄い）

### ● 対処方法（堅牢性向上）

move.php の方向移動以外の座標変更を受け付けないようにする（現状その通り実装されているのでOK）。
追加で、

* セッションの値は必ずサーバ計算結果から決定する（現状 OK）
* JSON から座標を受け取らない（現状 OK）

---

## ⚠ **5. index.php の迷路データ出力に XSS 不在だが、maze_data.php の不正編集で XSS の可能性**

### ● 何が問題か

`maze_data.php` の迷路データが **攻撃者に編集されうる環境**だと、プレイヤー名・HTMLタグを埋められ、JS 内で描画される。

### ● 影響

迷路の文字に `<script>` が埋め込まれた場合、ブラウザ内 DOM に混入し得る。
とはいえ、通常 DOM 操作では textContent で入っているため安全。

→ 現状のコードでは **基本的に安全**だが、迷路データを外部入力にするなら危険になる。

### ● 対処方法（一般論）

* maze_data.php の書き換えを適切に管理
* 外部ファイル入力は htmlspecialchars などで無害化

---

## ⚠ **6. move.php が CORS 設定なし**

### ● 何が問題か

外部サイトから JS を使って勝手に API を呼ばれる可能性がある。

### ● 影響

クロスサイト攻撃（CSRF と同じくゲームの場合は軽微）。

### ● 対処方法

原則として CSRF とセットの対策：

```php
header("SameSite=Strict");
header("X-Frame-Options: DENY");
```

---

## ⚠ **7. エラーメッセージをそのまま返すことによる情報漏洩**

### ● 何が問題か

move.php のエラーは JSON で返すため攻撃者に挙動が推測される
（境界外・壁などの細かいフィードバック）。

### ● 影響

* ゲームに不正は起こらないが
* 一般アプリなら **条件分岐の漏洩・探索攻撃** に利用され得る

### ● 対処方法

* 実稼働サービスでは「Invalid operation.」のように曖昧にする

---

## 🔍 **総まとめ（重要度順）**

| No | 問題点            | 影響              | 対策                        |
| -- | -------------- | --------------- | ------------------------- |
| 1  | セッション固定化       | セッション乗っ取り       | `session_regenerate_id()` |
| 2  | JSON 入力への DoS  | 大量メモリ、サーバ落ち     | `Content-Length` 制限       |
| 3  | CSRF           | 外部サイトから勝手に操作される | CSRF トークン導入               |
| 4  | セッションデータの信頼しすぎ | 不正操作（軽微）        | サーバ側で正規処理のみ               |
| 5  | 迷路データの編集でXSS   | JS 内に不正文字混入の可能性 | データ管理／無害化                 |
| 6  | CORS 設定なし      | API 不正利用        | `SameSite=Strict`など       |
| 7  | 過度に詳細なエラー      | 挙動解析            | 抽象化されたエラーにする              |

---

# mario

---

# pacman

---

#

