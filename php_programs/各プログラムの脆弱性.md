# 質問用フォーマット
```
あなたは与えられたソースコードから脆弱性を発見するホワイトハッカーです。 
以下のソースコードに以下の3つを行いなさい。
 1. 脆弱性の指摘
 2. 放置することによるリスクの提示
 3. 脆弱性の解消方法の提示
 
出力は以下の3つに注意して行いなさい。
 1. 日本語で出力 
 2. 明快かつ簡潔に 
 3. マークダウン形式を使用
 
ソースコードは以下に示す
---

```

# alarmClock
以下に、提示されたPHP＋JavaScriptコードの脆弱性診断をまとめます。

## ✅ 1. 脆弱性の指摘

## **① XSS（クロスサイト・スクリプティング）のリスク**

`$alarmTime` を `htmlspecialchars()` でエスケープしているものの、
**JavaScript の文字列としてそのまま埋め込んでいる部分が危険** です。

```js
let alarmTarget = "<?php echo $alarmTime; ?>";
```

HTMLコンテキストではエスケープされても、
**JSの文字列コンテキストとしては不十分** であり、次のような入力でXSSが可能：

```
curl -X POST -d 'set_time=";alert(XSS);//' localhost:8000/index.php
```

→ これが JS の文字列を壊し、任意の JS 実行が可能になります。

---

## **② CSRF（クロスサイトリクエストフォージェリ）**

フォーム送信に CSRF 対策（トークン）が無いため、
**外部サイトから勝手に alarmTime を変更される攻撃が可能**。

---

## **③ 入力値の妥当性チェック不足**

`input type="time"` だからフロント側では制限されているが、
サーバ側では `"99:99"` などの異常値を弾いていない。

---

## **④ エラーハンドリングと出力制御の不足**

`$message` をそのまま `echo` しているため、
今後拡張した際に汚染された出力が紛れるリスクがある。

---

## ✅ 2. 放置することによるリスク

## **① XSS を利用した攻撃**

* 任意の JavaScript の実行
* Cookie の窃取（セッション乗っ取り）
* フィッシング画面の挿入
* 悪意ある外部サイトへの誘導
* 被害者のブラウザで勝手に操作を実行

---

## **② CSRF の悪用**

* ユーザが意図しない alarmTime の変更
* 他機能を追加した際、重要設定を外部サイトから変更される
* 管理画面が同一セッションに乗っている場合は、致命的な被害に繋がる

---

## **③ 不正な値による動作不良・例外発生**

* フロント側でアラーム機能が正常に動かなくなる
* 今後機能追加する際の予期せぬエラーの原因となる

---

# ✅ 3. 脆弱性の解消方法

---

## **① XSS対策（最重要）**

### ✔ JavaScript へ埋め込む時は JSON 形式で安全に渡す

```php
<script>
    let alarmTarget = <?php echo json_encode($alarmTime, JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT); ?>;
</script>
```

**json_encode を使うのが最も安全。**

---

## **② CSRF対策**

### ✔ CSRFトークンをフォームに追加

**PHP:**

```php
session_start();
$_SESSION['token'] = bin2hex(random_bytes(32));
```

```html
<input type="hidden" name="token" value="<?php echo $_SESSION['token']; ?>">
```

**検証:**

```php
if (!hash_equals($_SESSION['token'], $_POST['token'])) {
    die("Invalid CSRF token");
}
```

---

## **③ 入力値の妥当性チェック（サーバ側）**

```php
if (!preg_match('/^\d{2}:\d{2}$/', $_POST['set_time'])) {
    die("Invalid time format");
}
```

---

## **④ 出力の安全性向上**

メッセージを出力する部分は必ずエスケープ：

```php
echo htmlspecialchars($message, ENT_QUOTES, 'UTF-8');
```

---

## 🎯 まとめ

| 脆弱性       | リスク             | 解決方法                    |
| --------- | --------------- | ----------------------- |
| XSS       | 任意JS実行、セッション窃取  | JS埋め込みは json_encode で行う |
| CSRF      | 外部サイトから意図せぬ設定変更 | CSRFトークンの導入             |
| バリデーション不足 | 動作不良・攻撃の温床      | 時刻形式のサーバ側チェック           |
| 出力エスケープ不備 | XSSの再発可能性       | htmlspecialchars の徹底    |

---

# breakout
## 1) 指摘する脆弱性

1. **CSRF（クロスサイトリクエストフォージェリ）対策なし**

   * `?action=save` に対する POST を誰でも送信できる（参照元／トークン検証がない）。
```
fetch("http://localhost:8000/index.php?action=save", {
  method: "POST",
  headers: {"Content-Type": "application/json"},
  body: JSON.stringify({score: 999999})
});
```

2. **入力検証が弱い（スコアの上限・型チェック不足）**

   * `json_decode` 後に `(int)$data['score']` へキャストしているだけで、異常値（極端に大きい値・負の数・数値以外）を明示的に拒否していない。
3. **ファイル操作の堅牢性不足（シンボリックリンク／TOCTOU のリスク、ファイル種別検査なし）**

   * `highscore.txt` がシンボリックリンクで置かれていた場合、書き込みで任意ファイルを上書きされる可能性がある（共有環境で特に問題）。
4. **ファイル読み書きの取り扱いの改善余地（read前のシークなど）**

   * `fopen(..., 'c+')` → `flock` → `stream_get_contents($fp)` の際、`fseek($fp, 0);` を明示していないため、想定外のファイルポインタ位置で読み取るリスク（環境依存）。
5. **送信側の簡易な保存API（認証・レート制限なし）**

   * 悪意ある自動投稿でスコアを何度でも上げる、あるいは保存処理へ高頻度リクエストを送ることが可能（DoS／改竄）。
6. **レスポンス／ログの不足**

   * エラー発生時の詳細ログや Content-Type 応答が不足。`sendBeacon` などで Content-Type が変わっても処理されるが、明示的チェックがない。

---

## 2) 放置した場合のリスク（簡潔）

* **スコア改竄**：第三者が簡単にハイスコアを不正書き換えでき、ランキングやゲーム整合性が失われる。
* **ファイル上書き／情報漏えい**：共有環境で symlink を悪用されると、想定外ファイルを書き換え／破壊される恐れ。
* **サービス妨害（DoS）**：大量リクエストで I/O 負荷やディスク消費を引き起こす可能性。
* **信頼失墜・法的問題**：ユーザーデータ管理がずさんと評価される、場合によっては責任問題に発展。

---

## 3) 解消方法（優先度付き・具体的修正案／コード例）

### 優先度高（すぐ入れるべき）

* **Origin/Referer または CSRF トークンで送信元検証**

  * 簡易実装：POST 時に `Origin`/`Referer` を確認して自サイトのみ許可。より堅牢にするなら CSRF トークンを発行・検証。
* **スコアのバリデーション**（型・範囲チェック）

  * 例：`0 <= score <= 1_000_000` のような上限を設ける。
* **Content-Type チェック**：`application/json` のみ受け付ける。
* **レスポンスに `Content-Type: application/json; charset=utf-8` を付与する。**

### 優先度中

* **ファイルのシンボリックリンクチェック**（`is_link()` 等）や `is_file()` を使う。
* **ファイル読み書き時に明示的にシーク（`fseek($fp, 0)`）してから `stream_get_contents` を使う。**
* **flock の正しい運用（既に使われているが、read時は共有ロック `LOCK_SH`、更新は `LOCK_EX`）を明確にする。**

### 優先度低（設計改善）

* **高信頼性を求めるならファイルではなく SQLite や DB を使う**（原子性、ACL、排他制御が楽）。
* **レートリミット（IPベース）や CAPTCHAs の導入**（Bot 対策）。
* **ファイルの作成権限を限定（オーナーとパーミッション）し、アップロード時に mode 0644 にする。**

---

### 修正例（置き換え用コード：`action=save` 部分）

以下は上で挙げたポイント（Content-Type確認・Originチェック・型/範囲チェック・symlinkチェック・fseek）を盛り込んだ実装例です。**そのまま貼って使う前に環境に合わせて微調整してください**。

```php
// -------------------------------------------------
// 安全な highscore 保存ハンドラ（置き換え例）
// -------------------------------------------------
if (isset($_GET['action']) && $_GET['action'] === 'save' && $_SERVER['REQUEST_METHOD'] === 'POST') {
    header('Content-Type: application/json; charset=utf-8');

    // 1) 簡易 Origin / Referer チェック（CSRF 緩和）
    $allowed_host = $_SERVER['HTTP_HOST'];
    $origin = $_SERVER['HTTP_ORIGIN'] ?? ($_SERVER['HTTP_REFERER'] ?? null);
    if ($origin !== null) {
        $host = parse_url($origin, PHP_URL_HOST);
        if ($host !== $allowed_host) {
            http_response_code(403);
            echo json_encode(['ok'=>false, 'msg'=>'forbidden origin']);
            exit;
        }
    }

    // 2) Content-Type check
    $ctype = $_SERVER['CONTENT_TYPE'] ?? '';
    if (stripos($ctype, 'application/json') !== 0) {
        http_response_code(400);
        echo json_encode(['ok'=>false, 'msg'=>'expect json']);
        exit;
    }

    // 3) 入力読み取りとデコード
    $raw = file_get_contents('php://input');
    $data = json_decode($raw, true);
    if (!is_array($data) || !isset($data['score'])) {
        http_response_code(400);
        echo json_encode(['ok'=>false, 'msg'=>'invalid payload']);
        exit;
    }

    // 4) 型と範囲チェック（例：0〜1,000,000）
    $score = filter_var($data['score'], FILTER_VALIDATE_INT,
        ['options'=>['min_range'=>0, 'max_range'=>1000000]]);
    if ($score === false) {
        http_response_code(400);
        echo json_encode(['ok'=>false, 'msg'=>'invalid score']);
        exit;
    }

    // 5) ファイル保護（存在チェック／シンボリックリンク防止）
    $hs_file = __DIR__ . '/highscore.txt';
    if (file_exists($hs_file) && is_link($hs_file)) {
        http_response_code(500);
        echo json_encode(['ok'=>false, 'msg'=>'invalid storage file']);
        exit;
    }
    if (!file_exists($hs_file)) {
        // 作るなら安全に作る（パーミッションは運用方針に合わせる）
        file_put_contents($hs_file, "0");
        chmod($hs_file, 0644);
    }

    // 6) 排他制御付きで読み書き
    $fp = fopen($hs_file, 'c+');
    if (!$fp) {
        http_response_code(500);
        echo json_encode(['ok'=>false, 'msg'=>'cannot open file']);
        exit;
    }
    if (!flock($fp, LOCK_EX)) {
        fclose($fp);
        http_response_code(500);
        echo json_encode(['ok'=>false, 'msg'=>'cannot lock file']);
        exit;
    }

    // 明示的に先頭へ
    fseek($fp, 0);
    $contents = stream_get_contents($fp);
    $current = intval(trim($contents === '' ? '0' : $contents));

    if ($score > $current) {
        // 原子的に上書き（既に LOCK_EX しているので問題ない）
        ftruncate($fp, 0);
        rewind($fp);
        fwrite($fp, (string)$score);
        fflush($fp);
    }

    flock($fp, LOCK_UN);
    fclose($fp);

    echo json_encode(['ok'=>true, 'highscore'=>max($current, $score)]);
    exit;
}
```

---

## 追加の運用上の推奨

* 開発環境と本番環境でファイル権限と所有者を確認する（web サーバーが不要に高い権限を持たないように）。
* 可能なら **SQLite** 等に移行して権限管理・トランザクションを利用する（運用負荷の低下・安全性向上）。
* ログを残す（保存失敗や不正アクセスの試行を監視）。
* フロント側（JS）はサーバーエラーをユーザに見せすぎない。エラーは console.log に留めつつ、ユーザには一般的メッセージを返す。

---

### まとめ（ワンポイント）

* 最低限：**Content-Type/Origin のチェック + スコア範囲バリデーション + fseek + symlink チェック** を入れるだけで、多くの悪用を防げます。
* 長期的には **認証／CSRF トークン／DB移行／レート制限** を検討してください。

必要なら、この修正を反映した完全な `index.php`（差分付き）を作成します。どこまで反映するか指示ください（例：CSRFトークン方式にする／SQLiteへ移行する 等）。


# d100_roller
## 0. 概要

与えられた `php_d100_roller.php` をレビューしました。機能はシンプルで概ね安全に見えますが、ウェブアプリとして放置すると悪用されうる点がいくつかあります。以下、**脆弱性の指摘 → 放置リスク → 改修案（具体コード例を含む）**の順で簡潔に示します。

---

## 1. CSRF（クロスサイトリクエストフォージェリ）

**指摘**

* フォームにCSRFトークンが無く、POST操作（ロールの実行）を第三者ページから強制実行され得る。

**リスク**

* 被害者がログイン等しなくても、意図せずロールが実行されサーバー側に無駄な履歴を蓄積させる、あるいは統計用途での汚染が可能。多数リクエストでDoS的影響も。

**対処（推奨）**

* セッションにCSRFトークンを保持し、フォームに hidden で埋め、POST時に検証する。

```php
// セッション開始前に（ファイル先頭で）
session_set_cookie_params([
  'lifetime' => 0,
  'secure' => true,      // HTTPS 運用なら true に
  'httponly' => true,
  'samesite' => 'Lax'
]);
session_start();

// トークン生成（初回）
if (empty($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}

// フォームに埋め込む
// <input type="hidden" name="csrf_token" value="<?php echo htmlspecialchars($_SESSION['csrf_token'], ENT_QUOTES, 'UTF-8'); ?>">

// POST 受け取り側で検証
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!isset($_POST['csrf_token']) || !hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'])) {
        http_response_code(400);
        exit('Invalid CSRF token');
    }
    // ... 続行
}
```

---

## 2. セッション設定の不備（Cookie 属性・固定化）

**指摘**

* `session_start()` の前後でセッションCookieの細かい設定がされていない（`Secure`/`HttpOnly`/`SameSite`等）。また、重要な操作後に `session_regenerate_id()` を呼んでいない。

**リスク**

* HTTPSを使っていない、あるいはCookie属性が不適切だとセッションハイジャックやセッション固定攻撃の危険が増す。

**対処（推奨）**

* `session_set_cookie_params()` で属性を設定してから `session_start()`。重要な操作（認証等）があれば `session_regenerate_id(true)` を実行。

（上の CSRF 対処例に `session_set_cookie_params` を示しています）

---

## 3. XSS（クロスサイトスクリプティング） — 出力側のエスケープ漏れ／強化

**指摘**

* 大部分の出力で `htmlspecialchars()` が使われていますが、**全て**の出力（特に属性中や条件分岐での埋め込み）で `ENT_QUOTES` と `'UTF-8'` を明示しておく方が堅牢です。また、将来別の入力項目を追加したときにエスケープ漏れが生じるリスクあり。

**リスク**

* ユーザーが挿入可能な文字列（例：ラベル）が将来別の経路でエスケープされずに出力されると、Stored/Reflected XSS によるセッション窃取やページ改ざんが起こりうる。

**対処（推奨）**

* 出力時は常に `htmlspecialchars($var, ENT_QUOTES, 'UTF-8')` を使う。属性内では追加で `urlencode` 等を検討。受け取り時に最大長を制限する。

```php
// 出力例
echo htmlspecialchars($entry['label'], ENT_QUOTES, 'UTF-8');
```

さらに、安全策として CSP ヘッダを送ることを推奨：

```php
header("Content-Security-Policy: default-src 'self'; script-src 'self';");
```

---

## 4. 入力検証不足（ラベル長など）

**指摘**

* `label` の長さや文字種に制限がなく、無制限のデータをセッションに保存可能。

**リスク**

* 悪意ある長大文字列でセッションサイズが膨張し、メモリ/ストレージを消費してDoSを誘発する可能性。ログや表示崩れの原因にも。

**対処（推奨）**

* 受信時に長さ制限（例 200 文字）を設け、不要な制御文字を除去する。サーバ側でも保存前に切り詰める。

```php
$label_raw = isset($_POST['label']) ? (string)$_POST['label'] : '';
$label = mb_substr($label_raw, 0, 200, 'UTF-8'); // 最大200文字に制限
// さらに必要ならホワイトリストで許可文字のみ通す
```

HTML 側にも `maxlength="200"` を付与して UX を改善。

---

## 5. フォーム action に対する潜在的な問題（`$_SERVER['PHP_SELF']`）

**指摘**

* `action="<?php echo htmlspecialchars($_SERVER['PHP_SELF']); ?>"` は一般に対策済みだが、より確実にするなら `basename(__FILE__)` や空にする（同ページ送信）方が安全。

**対処（推奨）**

```php
<form method="post" action="">
```

もしくは

```php
action="<?php echo htmlspecialchars(basename($_SERVER['PHP_SELF']), ENT_QUOTES, 'UTF-8'); ?>"
```

---

## 6. レート制限 / DoS 緩和の欠如

**指摘**

* 連続大量リクエストを防ぐ仕組みがない。

**リスク**

* ボットや攻撃者による大量POSTでサーバ負荷やセッション肥大化が起きる。

**対処（推奨）**

* 簡易的にはセッションにタイムスタンプ＋カウンタを置き、短時間での多数リクエストを拒否する。より本格的にはリバースプロキシ（nginx）やWAF、レートリミッターを導入。

```php
// 簡易レート制限（例: 10回/分）
if (!isset($_SESSION['rolls_window'])) {
    $_SESSION['rolls_window'] = ['start' => time(), 'count' => 0];
}
if (time() - $_SESSION['rolls_window']['start'] > 60) {
    $_SESSION['rolls_window'] = ['start' => time(), 'count' => 0];
}
$_SESSION['rolls_window']['count']++;
if ($_SESSION['rolls_window']['count'] > 10) {
    exit('Rate limit exceeded');
}
```

---

## 7. ログ／監査（任意だが推奨）

**指摘**

* 操作履歴はセッション内のみ。監査ログがあれば不正利用の追跡が容易。

**対処（推奨）**

* サーバ側ログ（ファイル/監査系）に最低限の情報（タイムスタンプ、IP、回数、ラベル短縮）を記録。

---

## 最終まとめ（短く）

* 優先度高で対応すべきは **CSRF 対策** と **セッションCookie設定（Secure/HttpOnly/SameSite）**、および **出力エスケープの厳格化（ENT_QUOTES, UTF-8）**。
* 次に **入力長制限（ラベル）** と **簡易レート制限** を入れる。
* 追加で CSP ヘッダや監査ログを検討するとより堅牢になります。

必要なら、あなたの環境（HTTP/HTTPS どちらで公開しているか、想定ユーザー数、ログ要件）に合わせた**修正版の完全コード**（該当ファイル全体を安全策入りで書き直す）をすぐ作成します。どうしますか？

# gomoku
## ✅ 1. 脆弱性の指摘

### ### **① セッションハイジャック対策の不足**

* ゲーム開始時に `session_regenerate_id(true)` は行われているが、
  **毎リクエストでのセッション固定化対策** が不足している。

### ### **② CSRF 対策はあるが、POST ボタンが複数ある構成で token が競合する可能性**

* 2つの `<form>` があり、どちらも `token` を持つが
  **同じ token を多目的に使っているため攻撃面が広め**。

### ### **③ HTML のボタンに埋め込む JavaScript に XSS の潜在リスク**

```php
onclick="this.form.x.value='<?= $x ?>'; this.form.y.value='<?= $y ?>';"
```

* `$x` `$y` は整数に制限されているため実害は低いが、
  **JS イベント属性に PHP 変数を直接出力する構造は XSS の典型パターン**。

### ### **④ POST パラメータ `pos` を検証していない**

```php
<button type="submit" name="pos" value="1">
```

* この値はサーバ側で **一切使用されていない** ため、
  不要な入力を受け入れる余地がある（攻撃面が広がる）。

### ### **⑤ UI に関するクリックジャッキング対策がない**

* HTML に `X-Frame-Options` や CSP (`frame-ancestors`) がないため、
  **クリックジャッキング攻撃** のリスクがある。

---

## ✅ 2. 放置すると起こるリスク

### **① セッションハイジャックのリスク**

* 攻撃者が転用したセッション ID により
  **他ユーザのゲーム進行を乗っ取られる可能性**。

### **② CSRF 成功率の向上**

* 同一 token を複数フォームで使うと
  **攻撃者が成立させる確率が高まる**。

### **③ XSS リスク（潜在）**

* 現状は整数のため安全だが、
  改修時や変数差し替え時に
  **誤ってスクリプトが入り込む脆弱ポイントになる**。

### **④ 不要パラメータ利用による攻撃面の拡大**

* `pos` など未使用パラメータを使って
  **攻撃者が予期しない POST を送信しやすくなる**。

### **⑤ クリックジャッキング**

* iframe 経由で UI が操作され、
  **意図しない場所に石を置かされる可能性**（ゲームレベルでは軽微だが脆弱性としては残る）。

---

## ✅ 3. 脆弱性の解消方法


## **① セッション固定化対策を強化**

ゲーム開始時だけでなく、
**ログイン/重要操作相当のタイミングで再生成**：

```php
session_regenerate_id(true);
```

または毎回 regenerate する設定も有効。

---

## **② CSRF トークンをフォームごとに分離**

POST の用途別にトークンを別管理：

```php
$_SESSION['csrf_place']   = bin2hex(random_bytes(32));
$_SESSION['csrf_restart'] = bin2hex(random_bytes(32));
```

そして各フォームに別トークンを埋め込む。

---

## **③ JavaScript 埋め込みを安全化**

HTML 属性の直接出力を避け、
**data 属性 + JS 側で処理**に変更：

```html
<button class="cell" data-x="<?= h($x) ?>" data-y="<?= h($y) ?>"></button>
```

JavaScript:

```javascript
document.querySelectorAll('.cell').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelector('input[name="x"]').value = btn.dataset.x;
        document.querySelector('input[name="y"]').value = btn.dataset.y;
        btn.closest('form').submit();
    });
});
```

---

## **④ 未使用パラメータ `pos` を削除或いは厳格化**

無意味な name/value を削除：

```html
<button type="submit" ...></button>
```

---

## **⑤ クリックジャッキング対策**

PHP のヘッダで対策：

```php
header("X-Frame-Options: SAMEORIGIN");
header("Content-Security-Policy: frame-ancestors 'self';");
```

---

## ✅ まとめ

| 脆弱性            | リスク         | 対策                          |
| -------------- | ----------- | --------------------------- |
| セッション固定化不十分    | ハイジャック      | `session_regenerate_id` の強化 |
| CSRF トークン使い回し  | CSRF 成立しやすい | フォーム別 token                 |
| JS 属性内出力       | XSS 侵入点     | data 属性 + JS                |
| 未使用 POST パラメータ | 余計な入力を受け入れる | 削除                          |
| クリックジャッキング     | UI を悪用される   | `X-Frame-Options`           |

---

# mario
## 1. 脆弱性の指摘

## **① XSS（クロスサイトスクリプティング）**

PHP側で `name` を `FILTER_SANITIZE_STRING` で通しているが、
**完全なサニタイズになっておらず、保存された名前がHTMLに挿入される場面でXSSが発生し得る。**

また、JS側で取得したスコアや名前を画面に描画する部分がある場合、
**innerHTML を使うとXSSの危険が高い**（今回のコードでは innerText を使っているが、将来の改変時に危険）。

---

## **② highscores.txt の書き込み権限による任意ファイル改ざん**

`file_put_contents()` が **ロック以外の制御なし** で実行されているため、

* 設定が緩いサーバでは **書き込み対象のパスを攻撃者が変更できる可能性**
* highscores.txt が公開ディレクトリ内にある場合、外部から直接ダウンロードされ、
  **スコア情報や不正データを注入されるリスク**

---

## **③ CSRF（Cross-Site Request Forgery）**

スコア投稿のエンドポイントは

* 認証なし
* CSRFトークンなし
* POSTするだけでランキングに登録できる

ため、

> 他サイトから自動的にスコア投稿され、ランキングが荒らされる可能性。

---

## **④ 入力検証不足（名前の長さ・文字種制限なし）**

`name` の検証がとても弱いため、

* 異常に長い文字列を送られる
* バイナリや制御文字を送られる
* HTML特殊文字をそのまま送られる

→ **ファイル破損 / 表示崩れ / XSS** に繋がる。

---

## **⑤ highscores.txt へのレースコンディション**

`LOCK_EX` を付けているが、それでも複数人が同時投稿すると

* 読み込み → 追加 → 書き込み
* の間に整合性が壊れる可能性（典型的なレース状態）

---

## **⑥ JavaScript alert + reload による DoS 的挙動**

攻撃者がキー連打などでイベントを乱発すると、

* alert が連続表示
* ページがリロード連発

→ 利用不能状態（軽微だが存在する）。

---

## **⑦ ファイルのディレクトリトラバーサルは現状無いが、file_path が直書きで危険**

`$file_path = 'highscores.txt'` は直接指定されており、
将来的に GET/POST でパスを受け取るよう改変されると脆弱化する。

---

## 2. 放置した場合のリスク

## **① XSS によりユーザのブラウザで任意のJavaScriptを実行される**

* セッションハイジャック
* 改ざんページの表示
* 自動でスコア改ざん
* フィッシング誘導

---

## **② ランキングファイルの改ざんによるデータ破壊**

highscores.txt が公開領域にある場合

* ファイルを丸ごと書き換え
* JS や HTML を仕込まれ XSSの踏み台に
* 破損によりランキング機能崩壊

---

## **③ CSRF によりランキングが荒らされる**

攻撃者が仕込んだページを見るだけで

* 大量の偽スコアを送信
* ランキング表示が実質 unusable に

---

## **④ 長大データ・バイナリを送られる DoS**

* highscores.txt の肥大化
* 保存不能状態
* サーバ資源の圧迫によるDoS

---

## **⑤ レースコンディションによりファイル破損**

アクセス集中でランキングデータが壊れ、

* 読み込み不能
* JSONエラー
* サービス停止

---

## 3. 脆弱性の解消方法

## **① XSS対策**

### **PHP側：HTMLエスケープを徹底**

```php
htmlspecialchars($new_name, ENT_QUOTES, 'UTF-8');
```

表示時も必ずエスケープする。

---

## **② 入力バリデーション強化**

例：

```php
if (mb_strlen($new_name) > 20) exit;
if (!preg_match('/^[a-zA-Z0-9ぁ-んァ-ヶー一-龠\s]+$/u', $new_name)) exit;
```

* 長さ制限
* 文字種制限
* コントロール文字禁止

---

## **③ CSRFトークン導入**

POST専用エンドポイントに対し

1. フォーム側で CSRF トークンを発行
2. PHP側で一致するか検証

最低限のCSRF防御が必須。

---

## **④ highscores.txt を公開領域の外へ移動**

`/var/data/highscores.txt` など Web 直下ではない場所へ。

---

## **⑤ レースコンディション対策**

`LOCK_EX` だけでなく
**読み込み → 書き込みの一連を同じ排他ロックで実施**。

または SQLite のような DB を使用し、整合性を担保。

---

## **⑥ JavaScript の alert → UI 表示に変更**

DoS と UX 悪化防止のため、alert/reload をやめて

* モーダル表示
* retry ボタン

に変更。

---

## **⑦ ファイルパスを直書きしない**

将来的な脆弱化を避けるため、定数化し外部入力を絶対に受けない。

---

## ✔ まとめ

主要な危険性は以下です：

* **XSS**
* **CSRF**
* **ファイル改ざん（highscores.txt）**
* **入力バリデーション不足**
* **レースコンディション**

特に **XSS + CSRF + ファイル改ざん** の3つは実害が大きいため、優先的に修正してください。

# maze_solve
以下は提示した **index.php / maze_data.php / move.php** において、実際に問題となり得る **セキュリティ上の懸念点** とその整理です。
（※「迷路ゲーム」という性質上、深刻度は低めですが、Webアプリの品質としては意識すべき点です）

---

## ✅ **1. セッション固定化（Session Fixation）が発生し得る**

### ● 何が問題か

`index.php` では **セッションIDを再生成していない** ため、攻撃者が発行したセッションIDを被害者に使わせることで、セッションを奪われる可能性がある。

### ● 影響

セッションを乗っ取られ、プレイヤーの進行状況や状態が改ざんされる可能性がある。
（迷路ゲームなので深刻ではないが、一般的な Web アプリでは重大）

### ● 対処方法

`index.php` のゲーム開始タイミングでセッションIDを再生成する：

```php
session_regenerate_id(true);
```

セッション初期化後に挿入します。

---

### ✅ **2. move.php の JSON パース部分に DoS（サービス妨害）リスク**

### ● 何が問題か

`php://input` をそのまま `json_decode()` に渡しているため、攻撃者が巨大リクエストを送りつけると PHP が大量メモリを使用して落ちる可能性がある。

### ● 影響

DoS攻撃で PHP が落ちる・サーバ停止。

### ● 対処方法

* `Content-Length` の上限を設定
* JSON の最大長をチェックし、過大データなら拒否

例：

```php
$raw = file_get_contents('php://input', false, null, 0, 2000);
if (strlen($raw) > 2000) {
    json_err("リクエストサイズが大きすぎます");
}
```

---

## ✅ **3. move.php に CSRF リスク**

### ● 何が問題か

POST による操作 API に **CSRF トークンが無い**。

### ● 影響

他サイトに誘導されただけで勝手に移動操作が送信される可能性がある。

（迷路ゲームとしては軽微だが、一般アプリでは悪用される）

### ● 対処方法（簡易版）

* セッション内に CSRF トークンを生成
* move.php はトークン検証
* JavaScript から送信する際に埋める

例：index.php

```php
$_SESSION['csrf_token'] = bin2hex(random_bytes(16));
```

JSで request body に載せる
move.php で検証：

```php
if ($data['csrf'] !== $_SESSION['csrf_token']) {
    json_err('CSRF token mismatch');
}
```

---

## ⚠ **4. セッションデータの信頼しすぎ（Tampering リスク）**

### ● 何が問題か

セッション内の `player` などは PHP のサーバ側変数なので直接クライアントからは変更されないが、
もし別の脆弱性（例：セッションID盗難）があれば **任意の位置にテレポートできるなどの不正操作**が可能。

### ● 影響

ゲーム不正操作
（迷路ゲームなので気にする必要は薄い）

### ● 対処方法（堅牢性向上）

move.php の方向移動以外の座標変更を受け付けないようにする（現状その通り実装されているのでOK）。
追加で、

* セッションの値は必ずサーバ計算結果から決定する（現状 OK）
* JSON から座標を受け取らない（現状 OK）

---

## ⚠ **5. index.php の迷路データ出力に XSS 不在だが、maze_data.php の不正編集で XSS の可能性**

### ● 何が問題か

`maze_data.php` の迷路データが **攻撃者に編集されうる環境**だと、プレイヤー名・HTMLタグを埋められ、JS 内で描画される。

### ● 影響

迷路の文字に `<script>` が埋め込まれた場合、ブラウザ内 DOM に混入し得る。
とはいえ、通常 DOM 操作では textContent で入っているため安全。

→ 現状のコードでは **基本的に安全**だが、迷路データを外部入力にするなら危険になる。

### ● 対処方法（一般論）

* maze_data.php の書き換えを適切に管理
* 外部ファイル入力は htmlspecialchars などで無害化

---

## ⚠ **6. move.php が CORS 設定なし**

### ● 何が問題か

外部サイトから JS を使って勝手に API を呼ばれる可能性がある。

### ● 影響

クロスサイト攻撃（CSRF と同じくゲームの場合は軽微）。

### ● 対処方法

原則として CSRF とセットの対策：

```php
header("SameSite=Strict");
header("X-Frame-Options: DENY");
```

---

## ⚠ **7. エラーメッセージをそのまま返すことによる情報漏洩**

### ● 何が問題か

move.php のエラーは JSON で返すため攻撃者に挙動が推測される
（境界外・壁などの細かいフィードバック）。

### ● 影響

* ゲームに不正は起こらないが
* 一般アプリなら **条件分岐の漏洩・探索攻撃** に利用され得る

### ● 対処方法

* 実稼働サービスでは「Invalid operation.」のように曖昧にする

---

## 🔍 **総まとめ（重要度順）**

| No | 問題点            | 影響              | 対策                        |
| -- | -------------- | --------------- | ------------------------- |
| 1  | セッション固定化       | セッション乗っ取り       | `session_regenerate_id()` |
| 2  | JSON 入力への DoS  | 大量メモリ、サーバ落ち     | `Content-Length` 制限       |
| 3  | CSRF           | 外部サイトから勝手に操作される | CSRF トークン導入               |
| 4  | セッションデータの信頼しすぎ | 不正操作（軽微）        | サーバ側で正規処理のみ               |
| 5  | 迷路データの編集でXSS   | JS 内に不正文字混入の可能性 | データ管理／無害化                 |
| 6  | CORS 設定なし      | API 不正利用        | `SameSite=Strict`など       |
| 7  | 過度に詳細なエラー      | 挙動解析            | 抽象化されたエラーにする              |

---

# memo
## ✅ 1. 脆弱性の指摘

### **① CSRF 脆弱性**

* メモ保存処理（`action=save`）は **CSRF トークンが無く、POST されれば無条件で実行**される。
* 悪意あるサイトからの自動 POST によって、ユーザーのメモを書き換えられる。

---

### **② セッション固定攻撃（Session Fixation）のリスク**

* `session_start()` のみで、ログイン機能やセッション再生成が無いため
  **攻撃者が固定したセッションIDをユーザーに使わせることが可能**。
* メモ内容はセッションに保存されているので、不正アクセスの温床になる。

---

### **③ メモIDの扱いが危険（予測可能・なりすまし更新）**

* `id` が単なる `time()` もしくは任意の整数。
* POST で自由に送れるため **他ユーザーのメモ ID を指定すれば上書き可能**。
* つまり「メモ編集の認可チェックが無い」。

---

### **④ 入力値検証不足**

* タイトル／内容に対し
  **長さ以外のサニタイズやバリデーションが無い**。
* 現状では `htmlspecialchars` により XSS はほぼ防げているが、
  POST 時に **サーバ側でのエスケープ処理が無いため、将来コード変更で脆弱化**する可能性がある。

---

### **⑤ JSON を `exit()` で直接返却（エラーハンドリング不十分）**

* JSON 文字列を直接返すのみで
  **Content-Type が `application/json` に設定されていない**。
* 想定外のクライアントから悪用される場合、レスポンス解釈に問題が生じる。

---

## ✅ 2. 放置した場合のリスク

### **① メモ内容の改ざん・削除**

攻撃者がユーザーのブラウザに自動POSTを送りつけるだけで
**任意のメモを勝手に作成 / 上書き / 破壊**できる。

---

### **② セッション乗っ取り**

悪意ある URL を踏ませるだけで、
攻撃者の指定したセッションIDでアプリを使用させられ、
**メモ閲覧・更新がすべて攻撃者と共有状態に**なる。

---

### **③ 他ユーザーのデータを上書き**

ID が予測可能なため、攻撃者は
**他人のメモIDを指定して POST → 強制上書き**が可能。

---

### **④ 保守性の低下による将来の XSS 発生**

サーバ側でエスケープせずに保存しているため、
コード変更 やテンプレ変更により **XSSが突然復活する**リスク。

---

## ✅ 3. 脆弱性の解消方法

## **① CSRF 対策の導入（必須）**

* トークン生成（サーバ側）

```php
if (!isset($_SESSION['csrf'])) {
    $_SESSION['csrf'] = bin2hex(random_bytes(32));
}
```

* フォームに埋め込み

```html
<input type="hidden" name="csrf" value="<?= $_SESSION['csrf'] ?>">
```

* チェック追加

```php
if ($_POST['csrf'] !== $_SESSION['csrf']) {
    exit(json_encode(['status' => 'error', 'msg' => 'CSRF invalid']));
}
```

---

## **② セッション固定対策**

メモ作成など重要操作前にセッション再生成：

```php
session_regenerate_id(true);
```

---

## **③ メモIDを任意入力に依存させない**

* ID を **サーバ側でのみ生成（UUIDなど）**。
* クライアントの送信したIDを信用しない。

例：

```php
$id = $_POST['id'] !== '' ? intval($_POST['id']) : bin2hex(random_bytes(8));
```

---

## **④ 入力値バリデーションの追加**

* 文字数
* 禁止文字
* HTML タグの除去（念のためサーバ側でも実施）

```php
$title = trim($_POST['title']);
$body  = trim($_POST['body']);

if ($title === '') { /* エラー返却 */ }
$title = htmlspecialchars($title, ENT_QUOTES, 'UTF-8');
$body  = htmlspecialchars($body, ENT_QUOTES, 'UTF-8');
```

---

## **⑤ JSON レスポンスの Content-Type を設定**

```php
header('Content-Type: application/json; charset=UTF-8');
echo json_encode(['status' => 'ok']);
exit;
```

---

## ✅ まとめ

| 脆弱性       | リスク       | 対策                    |
| --------- | --------- | --------------------- |
| CSRF      | 勝手にメモ書き換え | トークン導入                |
| セッション固定   | セッション乗っ取り | session_regenerate_id |
| 任意ID更新    | 他人のメモ破壊   | サーバ側でID生成             |
| 入力検証不足    | 将来のXSS化   | バリデーション追加             |
| JSONヘッダ不足 | 解釈ミス等     | Content-Type指定        |

---

# othello
## 1. **脆弱性の指摘**
### ❗1-1. GET パラメータの未検証利用（入力検証不足）

```php
$x = intval($_GET['x']);
$y = intval($_GET['y']);
```

* `intval()`で整数化しているが **範囲チェックがない** ため、
  `?x=999&y=-100` などを指定すると **盤面外アクセス** が発生する。

→ `getFlips()` 等で `$board[$y][$x]` にアクセスし、**未定義インデックスアクセスによる警告・処理異常** を引き起こす。

---

### ❗1-2. セッション固定攻撃（Session Fixation）

* セッション開始 (`session_start()`) はあるが、`reset=1` でゲームリセット時に **session_regenerate_id() を行っていない**。
* 攻撃者が事前に固定したセッション ID を被害者に使わせることで、
  **ゲーム状態を乗っ取られる可能性** がある。

---

### ❗1-3. リセット処理の順序問題（レスポンス送信後の header 呼び出し）

```php
<?php if (isset($_GET['reset'])) {
    session_destroy();
    header("Location: index.php");
    exit;
} ?>
```

この処理は **HTML の一部が出力された後に実行される場合がある**
→ **"Headers already sent" エラー** が発生しうる。

---

### ❗1-4. CSRF 脆弱性（クリックによる状態遷移）

* GET リクエストでゲームの状態が変更されており、CSRF トークンも存在しない。
* 攻撃者は以下のようなリンクを踏ませるだけでゲーム内容を改ざん可能：

```
<img src="https://example.com/index.php?x=1&y=1">
```

---

### ❗1-5. XSS の潜在リスク（軽度）

表示内容は基本的に内部データ（●、○、空白）だが、
将来的に記号を拡張した場合に、適切なエスケープが必要。

---

---

## 2. **放置することによるリスク**

### 🔥 2-1. 盤面外アクセスによる異常動作・ゲーム破壊

* ゲームロジックが崩壊し、盤面の異常表示や PHP 警告が発生する。
* 変な位置に石が置けるようになる可能性もある。

### 🔥 2-2. セッション固定攻撃によるゲーム乗っ取り

* 攻撃者が被害者のプレイ状態を自由に操作できる。
* ランキング機能追加など拡張した場合、深刻な被害につながる。

### 🔥 2-3. CSRF による勝手操作

* プレイヤーのターンを強制的に消費される
* リンク踏むだけでゲームが壊される

### 🔥 2-4. ヘッダー送信エラーによる動作不安定

* リセットできない
* 意図しない内容がブラウザへ送信される

---

## 3. **脆弱性の解消方法**

### 🛠 3-1. GET パラメータの範囲チェックを追加

```php
$x = filter_input(INPUT_GET, 'x', FILTER_VALIDATE_INT);
$y = filter_input(INPUT_GET, 'y', FILTER_VALIDATE_INT);

if ($x === false || $y === false || $x < 0 || $x > 7 || $y < 0 || $y > 7) {
    exit("不正な座標です");
}
```

---

### 🛠 3-2. ゲームリセット時に session_regenerate_id() を追加

```php
if (isset($_GET['reset'])) {
    session_destroy();
    session_start();
    session_regenerate_id(true); // ★安全なIDに更新
    header("Location: index.php");
    exit;
}
```

---

### 🛠 3-3. リセット処理を HTML 出力前に移動

```php
// index.php 最上部の session_start() 直後に配置
if (isset($_GET['reset'])) {
    session_destroy();
    header("Location: index.php");
    exit;
}
```

---

### 🛠 3-4. CSRF トークンを導入

例：

```php
// 初回生成
if (!isset($_SESSION['token'])) {
    $_SESSION['token'] = bin2hex(random_bytes(32));
}

// リンク生成
echo "<a href=\"?x=$x&y=$y&token={$_SESSION['token']}\">...</a>";

// クリック時チェック
if (!hash_equals($_SESSION['token'], $_GET['token'] ?? '')) {
    exit("CSRF 検出");
}
```

---

### 🛠 3-5. htmlspecialchars() による XSS 対策

出力時に念のため適用：

```php
echo htmlspecialchars($char, ENT_QUOTES, 'UTF-8');
```

---

## ✅ 最終まとめ

| 脆弱性              | リスク          | 対策                      |
| ---------------- | ------------ | ----------------------- |
| GETパラメータ未検証      | 異常動作・盤面破壊    | 範囲チェック                  |
| セッション固定          | 状態乗っ取り       | session_regenerate_id() |
| CSRF             | 勝手操作         | CSRF トークン               |
| ヘッダー送信後 header() | エラー・リダイレクト不全 | 処理位置の移動                 |
| XSS（軽度）          | 将来のリスク       | htmlspecialchars        |

---

# pacman
## 1. 🔍 脆弱性の指摘

### **① HTML 内に外部からの入力値はないが、JavaScript がグローバル公開されている**

* このファイルは「単一 HTML + JS」で構成され、外部入力を扱っていないため直接的な XSS/SQLi などはありません。
* しかし **キーイベント (`keydown`) をフックする処理がグローバルに露出している**ため、他のスクリプトが同一ページに挿入された場合、容易に想定外の操作が可能。

### **② `setInterval` 内で存在しない `moveRandom()` を呼び出している**

```js
setInterval(()=>{ ghosts.forEach(g=>{ if(Math.random()<0.4) g.moveRandom(); }); }, 600);
```

* Ghost クラスには `moveRandom()` が存在しないため **例外が発生**し、環境によってはゲームが停止。
* これはセキュリティ脆弱性ではないが、**DoS（サービス妨害）に近い動作停止リスク**となる。

### **③ Map リセットロジックが脆弱**

```js
for(let i=0;i<map.length;i++){ if(map[i]===0) map[i]=2; }
```

* "0 → 2" のみの変換で、壁(1)やパワー玉(3)の復元が不完全。
* これにより不正状態を誘発し、クライアント側で異常状態に陥る可能性。

### **④ コードの肥大化による保守性低下（単一ファイル）**

* PHP と HTML と JavaScript が1ファイルに統合されているため、誤って PHP の動的出力を追加した場合、XSS の温床になりやすい構造。

---

## 2. ⚠️ 放置することによるリスク

### **① 想定外スクリプトによりプレイヤー操作がハイジャックされる**

* CSRF/XSS などで悪意あるスクリプトが挿入された場合、

  * 勝手にキー入力を横取り
  * ゴースト挙動を改変
    などが容易に行える。

### **② 例外発生によるゲーム停止（DoS）**

* `moveRandom()` の欠落は、環境によっては高速でエラーを吐き続ける。
* 結果、ゲームが完全に停止する。

### **③ 不正状態のマップが生成され、ゲームが崩壊**

* リスタート時に壁やパワー玉が壊れると、ゲーム成立が不可能に。

### **④ 将来 PHP で動的処理を入れると XSS の危険性が大幅増**

* 現状は静的だが、構造上不適切なファイル結合により、後で動的値を追加した時に XSS が発生しやすい。

---

## 3. 🛠️ 脆弱性の解消方法

### **① キーイベントの処理をスコープ化し、グローバル露出を防ぐ**

```js
(function(){
  window.addEventListener('keydown', e=>{ ... });
  window.addEventListener('keyup', e=>{ ... });
})();
```

* IIFE に閉じて外部スクリプトからのアクセスを難しくする。

---

### **② `moveRandom()` の実装を追加**

Ghost クラスに追加：

```js
moveRandom() {
  this.chooseDirection();
}
```

* または setInterval から呼び出しを削除。

---

### **③ マップリセット処理を正確に実装する**

初期マップをコピーして保持し、リスタート時に完全復元する：

```js
const originalMap = [...map];

document.getElementById('restart').addEventListener('click', ()=>{
  for (let i = 0; i < map.length; i++){
    map[i] = originalMap[i];
  }
  score=0; lives=3; gameOver=false;
  resetPositions();
  requestAnimationFrame(loop);
});
```

---

### **④ PHP と JS を分離して XSS 耐性を向上**

* JS を別ファイル `game.js` として分割
* PHP で動的処理を行う場合は `htmlspecialchars()` で出力サニタイズ

---

## ✅ まとめ

| 問題                | リスク        | 対策               |
| ----------------- | ---------- | ---------------- |
| グローバル JS          | 不正操作・挙動改変  | IIFE 化・名前空間化     |
| `moveRandom()` 欠落 | ゲーム停止・DoS  | メソッド追加 or 呼び出し削除 |
| マップリセット不完全        | ゲーム崩壊      | 初期マップを保存して完全復元   |
| 単一ファイル構造          | 将来の XSS 問題 | JS 分離＋サニタイズ      |

---

# vote
## 1. 脆弱性の指摘

### **① CSRF 脆弱性（重大）**

`create.php` も `vote.php` も、**トークンなどの CSRF 対策がない**状態でフォーム POST を処理しています。

👉 外部サイトからユーザのブラウザを使って勝手に投票・スレッド作成をさせられます。

---

### **② Cookie による投票制限が不十分（不正投票可能）**

投票済み判定が Cookie（クライアント側）だけ。

```php
$cookie_name = "voted_poll_" . $poll_id;
$has_voted = isset($_COOKIE[$cookie_name]);
```

👉 Cookie を削除 or ブラウザ変更で **何度でも投票可能**。

---

### **③ URL パラメータ未検証による型の問題・意図しない動作**

```php
$poll_id = $_GET['id'] ?? null;
```

`id` が数値である確認がない。

👉 `?id=aaa` のような異常値で不正な SQL 実行が起こり得る（SQLite はやや緩いが危険）。

---

### **④ SQL の排他制御不足によるレースコンディション**

投票処理：

```php
UPDATE options SET votes = votes + 1 ...
```

短時間に複数リクエストでアクセスされると、**投票数が正しく加算されない可能性**。

---

### **⑤ エラーメッセージの漏えい（情報漏えい）**

`create.php`:

```php
$error = "作成に失敗しました。";
```

→ OK
だが、`db.php` の例外処理：

```php
die("データベース接続エラー: " . $e->getMessage());
```

👉 DBファイルのパスや内部情報が出てしまう可能性。

---

### **⑥ 入力値の未サーバ側バリデーション（datetime の妥当性など）**

`end_time` が未来かどうか不明、構文のみチェック。

👉 `1970-01-01` のような過去時間でも作成可能。

---

### **⑦ XSS 対策は概ね OK だが、一部未エスケープの可能性**

`$status_text` の HTML をそのまま埋め込んでいる。

```php
$status_text = '<span style="color:red">【終了】</span>';
```

→ 現状は固定文字列なので安全
→ 将来動的入力にすると危険
（構造的 XSS の温床なので注意点として挙げる）

---

## 2. 放置することによるリスク

### **① CSRF により他人が勝手に投票 / スレッド作成**

・攻撃者の用意したサイトを開くと
　→「裏で自動投票」
　→「勝手にスレッド生成」

### **② Cookie 削除で何度でも投票される**

・ランキング操作
・大量投票による結果の改ざん
・サービスの信頼性が崩壊

### **③ 不正な ID による予期せぬ DB 操作**

・不正 ID で内部情報取得
・エラーから内部構造 leakage

### **④ 競合アクセスで票が正確に加算されない**

・人気投票で票数誤り
・サービスの信用低下

### **⑤ DB エラー詳細が外部へ漏えい**

・パス情報
・内部構造
・攻撃の足掛かり

---

## 3. 脆弱性の解消方法

---

### **① CSRFトークンの実装（必須）**

```php
// セッション開始
session_start();

// トークン生成（create.php / vote.php）
if (!isset($_SESSION['token'])) {
    $_SESSION['token'] = bin2hex(random_bytes(32));
}
```

フォームに hidden で埋め込み：

```html
<input type="hidden" name="token" value="<?= h($_SESSION['token']) ?>">
```

POST 時に検証：

```php
if (!isset($_POST['token']) || $_POST['token'] !== $_SESSION['token']) {
    die("不正なリクエストです");
}
```

---

### **② Cookie による投票制御をサーバ側で管理**

例：vote_log テーブルを追加

```sql
CREATE TABLE vote_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    poll_id INTEGER,
    ip TEXT,
    user_agent TEXT,
    voted_at DATETIME DEFAULT CURRENT_TIMESTAMP
)
```

投票済み確認：

```php
$stmt = $pdo->prepare("SELECT COUNT(*) FROM vote_log WHERE poll_id = ? AND ip = ?");
$stmt->execute([$poll_id, $_SERVER['REMOTE_ADDR']]);
$has_voted = $stmt->fetchColumn() > 0;
```

---

### **③ ID パラメータの型チェック**

```php
$poll_id = filter_input(INPUT_GET, 'id', FILTER_VALIDATE_INT);
if (!$poll_id) { header("Location: index.php"); exit; }
```

---

### **④ 投票加算は排他制御 or 1クエリ更新に変更**

SQLite の排他モード：

```php
$pdo->exec("BEGIN IMMEDIATE TRANSACTION");
$stmt = $pdo->prepare("UPDATE options SET votes = votes + 1 WHERE id = ? AND poll_id = ?");
$stmt->execute([$option_id, $poll_id]);
$pdo->commit();
```

---

### **⑤ エラーはログに記録し、ユーザには共通メッセージ**

```php
catch (PDOException $e) {
    error_log($e->getMessage());
    die("内部エラーが発生しました。");
}
```

---

### **⑥ 入力値のサーバ側検証**

```php
$dt = DateTime::createFromFormat('Y-m-d\TH:i', $end_time);
if (!$dt || $dt < new DateTime()) {
    $error = "終了時間が不正です。未来の日時を指定してください。";
}
```

---

### **⑦ 将来を見据えて HTML 固定文字列も h() を通す設計推奨**

固定文字列なので今は安全だが、構造的 XSS の温床になるので将来はテンプレートエンジンを利用推奨。

---

## 🎯 総括

主要な改善ポイントは以下です：

* **CSRF対策の欠如（最重要）**
* **投票制御が Cookie のみで不正票が入れ放題**
* **URL / 入力値のバリデーション不足**
* **エラーログ・DB操作の安全性不足**

これらを修正することで、投票アプリとしての信頼性・安全性が大幅に向上します。
