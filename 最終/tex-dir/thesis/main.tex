%------------------------------------
%   basic settings
%------------------------------------
\documentclass[12pt,a4paper,oneside]{jsbook}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[dvipdfmx]{graphicx}
\usepackage{url}
\usepackage{here}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[ipaex]{pxchfon}
\usepackage{otf}
\usepackage{listings}
\usepackage[square, numbers]{natbib}
\usepackage{booktabs}
\usepackage{float} 
\usepackage{placeins}
% \usepackage{graphics}
\usepackage[dvipdfmx]{graphicx} % includegraphicsを使うためのパッケージを読み込む
% \usepackage{natbib}

% \bibpunct[:]{(}{)}{,}{a}{}{,}
%------------------------------------
%   listings settings (minted -> listings)
%------------------------------------
\lstset{
  basicstyle=\ttfamily\small,  % Font style
  numbers=left,                % Add line numbers
  numberstyle=\tiny,           % Line number style
  stepnumber=1,                % Line number increment
  frame=single,                % Add a frame around the code
  tabsize=4,                   % Tab size
  breaklines=true,             % Allow line breaking
  keywordstyle=\bfseries,      % Keywords in bold
  commentstyle=\itshape,       % Comments in italics
  stringstyle=\color{red},     % Strings in red
  showspaces=false,            % Do not mark spaces
  showstringspaces=false,      % Do not mark string spaces
  language=Python              % Default language
}

%------------------------------------
%   margin settings
%------------------------------------
\setlength{\topmargin}{-5mm}
\setlength{\fullwidth}{125mm}
\setlength{\textwidth}{\fullwidth}
\setlength{\oddsidemargin}{5mm}
\setlength{\evensidemargin}{\oddsidemargin}
%------------------------------------
%   newtheorems
%------------------------------------
\theoremstyle{plain}
\newtheorem{theorem}{定理}[chapter]
\newtheorem{corollary}[theorem]{系}
\newtheorem{lemma}[theorem]{補題}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{conjecture}[theorem]{予想}
\newtheorem{proposition}[theorem]{命題}
\newtheorem{problem}[theorem]{問題}
\newtheorem{definition}[theorem]{定義}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{claim}{Claim}
\newtheorem{subclaim}{Subclaim}[claim]
\newcommand{\resetclaim}{\setcounter{claim}{0}}
\newtheorem{case}{Case}
\newtheorem{subcase}{Subcase}[case]
\newcommand{\resetcase}{\setcounter{case}{0}}
\providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}
%------------------------------------
%   display figures
%   #1=width, #2=filename,
%   #3=caption, #4=label
%   \fig{0.8\linewidth}{aaa.pdf}{bbb}{ccc}
%------------------------------------
\renewcommand{\figurename}{図.}
\newcommand{\fig}[4]{
\begin{figure}[H]
\centering
\includegraphics[width=#1]{#2}
\caption{#3}
\label{#4}
\end{figure}
}
\newcommand{\figg}[4]{
\begin{figure*}[h!t]
\centering
\includegraphics[width=#1]{#2}
\caption{#3}
\label{#4}
\end{figure*}
}
%------------------------------------
%   setting of algorithms
%------------------------------------
\renewcommand{\algorithmicrequire}{\textbf{条件:}}
\renewcommand{\algorithmicensure}{\textbf{実行結果:}}
\algrenewcommand\algorithmicdo{}
\algrenewcommand\algorithmicthen{}
%------------------------------------
%   other renewcommands and newcommands
%------------------------------------
\renewcommand{\proofname}{\bf 証明.}
%------------------------------------
%   Title & Authors
%------------------------------------
\title{
卒業論文\\[1.5cm]
LLMによるソフトウェア脆弱性の検出\\[6cm]
}
\author{高知大学 理工学部 情報科学科\\[0.5cm]
B223R030P 横川武典}
\date{2025年度}

%------------------------------------
\begin{document}
%------------------------------------
%タイトルページの出力
\maketitle
%目次の作成・出力
\tableofcontents

%----------------------------------------------------------------------------
%   Chapter 1
\chapter{はじめに}
\label{chapter_1}
%----------------------------------------------------------------------------
\section{背景}
%------------------------------------
．

%----------------------------------------------------------------------------
\chapter{関連研究}
\label{chapter_2}
%----------------------------------------------------------------------------
本章では，本研究で提案する手法の妥当性を示すため，
既存のソフトウェア脆弱性検出手法および
大規模言語モデル（LLM）を用いた関連研究を整理し，
それらの課題を明確化する．
まず，従来のソフトウェア脆弱性検出手法について概観し，
その限界を明らかにする．
次に，大規模言語モデル（LLM）の概要と，
セキュリティ分野への応用例について述べる．
その後，LLMを用いた脆弱性検出に関する先行研究を整理し，
Retrieval-Augmented Generation（RAG）や
ファインチューニングといった代表的手法について説明する．
最後に，評価指標および既存研究の課題をまとめ，
本研究の位置づけを明確にする．


%------------------------------------
\section{従来のソフトウェア脆弱性検出}
%------------------------------------
ソフトウェアの脆弱性検出手法は，
大きく静的解析と動的解析に分類される \cite{chess_mcgraw}.
静的解析は，プログラムを実行せずにソースコードやバイナリを解析する手法であり，
代表的なものとしてデータフロー解析やルールベース解析が挙げられる．
静的解析の代表例としては，Lint系ツールや商用のSAST
（Static Application Security Testing）ツールなどが広く利用されている．
Lint系ツールは，
主にコーディング規約や単純な構文規則に基づいて
潜在的な不具合を検出する静的解析ツールであり，
SASTツールは，
より高度なデータフロー解析や制御フロー解析を用いて
脆弱性の検出を行う．
静的解析は網羅的な検査が可能である一方，実行時の文脈を考慮できないため
誤検知（False Positive）が多いという課題がある．

一方，動的解析はプログラムを実際に実行し，
その挙動を監視することで脆弱性を検出する手法である．
ファジングや実行時モニタリングなどが代表例であり，
AFL（American Fuzzy Lop）に代表されるファジング手法は，実際に悪用可能な脆弱性を検出できる利点を有する．
しかし，実行パスに依存するため，すべての脆弱性を網羅的に検出することは困難である．

近年では，静的解析と動的解析を組み合わせた
ハイブリッド解析手法も提案されており，
両者の欠点を補完するアプローチとして注目されている．
しかし，解析コストの増大や運用の複雑化といった課題も残されている．

これらの従来手法は，既知の脆弱性パターンに基づく検出には有効である一方で，
コードの文脈理解や実装意図の推定といった点に限界がある．
このような課題を背景として，
自然言語およびソースコードの文脈を同時に扱える
LLMを活用した手法が注目されている．

%------------------------------------
\section{Large Language Model（LLM）}
%------------------------------------
大規模言語モデル（Large Language Model: LLM）は，大量のテキストデータを用いて事前学習された
深層学習モデルであり，自然言語処理分野において高い性能を示している．
近年では，Transformer構造を基盤としたモデルが主流となっており，
自己注意機構によって文脈情報を効果的に捉えることが可能である．\cite{transformers}

Transformerにおける自己注意機構では，
入力系列の各トークンに対して
クエリ（Query），キー（Key），バリュー（Value）と呼ばれる
3種類のベクトル表現を線形変換によって生成する．
これらを用いて，あるトークンが
他のトークンとどの程度関連しているかを
内積演算によって算出し，
以下の式で注意重みを計算する．
\begin{equation}
\mathrm{Attention}(Q, K, V)
= \mathrm{softmax}\left(\frac{QK^{\top}}{\sqrt{d_k}}\right)V
\end{equation}
ここで，$d_k$はキーの次元数であり，
スケーリング項として用いられる．
この機構により，系列内の任意の位置にあるトークン同士の関係を
距離に依存せずに捉えることが可能となる．
また，複数の注意機構を並列に用いる
マルチヘッドアテンションにより，
異なる観点からの依存関係を同時に学習できる．
このようなTransformerの構造により，
LLMは長距離依存関係や文脈情報を効果的に表現でき，
従来のRNN（Recurrent Neural Network）系モデルと比較して
高い表現能力を有することが広く報告されている．\cite{transformers}

さらに，近年のLLMは自然言語だけでなくソースコードを含むデータで学習されており，
プログラムの構文構造や意味的関係を一定程度理解できることが報告されている．
CodeBERT\cite{codebert}やGraphCodeBERT\cite{graphcodebert}などのLLMは，
コードと自然言語の対応関係を学習することで，
プログラム理解タスクにおいて高い性能を示している\cite{llminsoftwaresecurity}．

このような特性から，LLMは単なる自然言語処理モデルにとどまらず，
ソフトウェア解析やセキュリティ分野への応用が期待されている．
次節では，セキュリティ分野におけるLLMの具体的な活用事例について述べる．

%------------------------------------
\section{セキュリティ分野とLLMの関連性および応用}
%------------------------------------
近年，LLMは自然言語処理分野にとどまらず，
サイバーセキュリティ分野においても幅広い応用が進んでいる．
LLMが脆弱性検出，マルウェア解析，ネットワーク侵入検知，フィッシング検出など，
多様なサイバーセキュリティタスクに適用されていることが報告されている\cite{llmcyber}．
このことから，LLMは特定用途に限定された技術ではなく，
セキュリティ分野全体に横断的に利用可能な基盤技術として位置づけられている．

一方で，LLMが生成した成果物そのものが新たなセキュリティリスクとなり得る点も指摘されている．
一部の研究では，LLMが生成したWeb言語向けJavaScriptコードを分析した結果，
24.5\%のコードにおいてセッションタイムアウトの欠如やHTTPセキュリティヘッダーの不足といった
不適切な実装が確認されたと報告されている\cite{hiddenriskllmgeneratedweb}．
この知見は，LLMの出力結果を無条件に信頼することの危険性を示している．

このように，セキュリティ分野におけるLLMの活用は，
防御・検出を支援する側面と，
新たな脆弱性を生み出す可能性という
両義的な性質を有している．
そのため，LLMとセキュリティの関係を論じる上では，
応用可能性だけでなく，
生成結果の検証やリスク評価を含めた
包括的な視点が不可欠である．

%------------------------------------
\section{LLMを用いた脆弱性検出の先行研究}
%------------------------------------
% この節の内容が弱いため要修正
\label{mustFix}
%------------------------------------
LLMを用いた脆弱性検出に関する先行研究では，
主にCやC++といった低レベル言語を対象としたものが多い．
これらの研究では，ソースコードを入力とし，
脆弱性の有無や種類を分類問題として扱う手法が主に提案されている．
特に，バッファオーバーフローやメモリ破壊といった脆弱性を対象とし，
LLMがコードの文脈情報を活用することで
従来手法よりも高い検出性能を示す可能性が報告されている．

近年では，脆弱性情報が頻繁に更新されるセキュリティ分野の特性を踏まえ，
外部知識ベースを活用する手法を組み合わせた研究も提案されている．
これらの研究では，CWE（Common Weakness Enumeration）やCVE（Common Vulnerabilities and Exposures）
といった既存の知識ベースを参照することで，
脆弱性検出やその説明の精度向上を図っている．

%------------------------------------
\section{埋め込みモデルと類似度検索}
%------------------------------------
本節では，
後述するRAG構成における検索機構の理解を目的として，
埋め込みモデルと類似度検索の基礎を説明する．

近年，情報検索や質問応答，および
Retrieval-Augmented Generation（RAG）といった手法において，
テキストを数値ベクトルとして表現する
埋め込み（Embedding）モデルが広く利用されている．
埋め込みモデルは，
入力されたテキストを高次元の実数ベクトル空間へ写像することで，
意味的な近さを数値的に比較可能にする．
このような分散表現に基づく意味検索は，
Sentence-BERT（SBERT）\cite{reimers2019sentencebert}
以降，多くの応用分野で用いられている．

一般に，埋め込みモデルは，
文や段落，あるいはソースコードといった
可変長の入力 $x$ を，
$d$ 次元のベクトル
$\mathbf{v} \in \mathbb{R}^d$
へ変換する写像
$f(\cdot)$ として定式化できる．
すなわち，
\begin{equation}
\mathbf{v} = f(x)
\end{equation}
である．
このとき，
意味的に類似したテキスト同士は，
ベクトル空間上でも近接するように学習される．

埋め込みベクトル間の類似度を測る指標としては，
コサイン類似度（Cosine Similarity）が一般的に用いられる．
二つのベクトル
$\mathbf{v}_1, \mathbf{v}_2 \in \mathbb{R}^d$
に対するコサイン類似度は，
次式で定義される．
\begin{equation}
\mathrm{sim}(\mathbf{v}_1, \mathbf{v}_2)
=
\frac{\mathbf{v}_1 \cdot \mathbf{v}_2}
{\lVert \mathbf{v}_1 \rVert \, \lVert \mathbf{v}_2 \rVert}
\end{equation}
この値は $-1$ から $1$ の範囲を取り，
値が大きいほど
二つのテキストが意味的に類似していることを示す．

類似度検索では，
あらかじめ知識ベース内の文書群
$\{x_1, x_2, \dots, x_n\}$
を埋め込みモデルによってベクトル化し，
クエリとなる入力 $q$ に対する埋め込み
$\mathbf{v}_q = f(q)$
との類似度を計算する．
その上で，
類似度が高い上位 $k$ 件の文書を検索結果として取得する．
このような密ベクトル検索の枠組みは，
Dense Passage Retrieval（DPR）\cite{karpukhin2020dense}
などにより体系化され，
RAGにおける検索機構の基盤技術となっている．

近年では，
多言語対応かつ汎用的な意味表現を獲得可能な
埋め込みモデルが多数提案されている．
その一例として，
e5-multilingual\cite{e5} は，
検索タスク向けに弱教師あり対照学習を用いて事前学習されたモデルであり，
クエリと文書の意味的対応関係を
高精度に捉えることが可能である．
自然言語を主対象としつつも，
技術文書やプログラムコードといった
専門的テキストに対しても
一定の有効性が報告されている．

本研究においては，
RAG構成における検索段階において
埋め込みモデルを用いた類似度検索を採用する．
具体的には，
解析対象のPHPコードまたはその一部をクエリとして埋め込み，
脆弱性に関する知識ベース内の文書を検索することで，
LLMが参照すべき関連情報を取得する．
このように，
埋め込みモデルと類似度検索は，
RAGにおける情報検索機構の基盤技術として
重要な役割を果たしている．

%------------------------------------
\section{Retrieval-Augmented Generation（RAG）}
%------------------------------------
Retrieval-Augmented Generation（RAG）は，
LLMによる生成時に，
外部の知識ベースから関連情報を検索し，
その結果を入力として利用することで，
生成性能の向上を図る手法である．
この枠組みにより，
モデル内部のパラメータに含まれない知識を
動的に参照することが可能となり，
事実性の向上やハルシネーションの抑制が期待されている\cite{rag}．

RAGは，
生成結果 $y$ を，
入力 $x$ および検索された文書集合 $z$ に条件づけた確率として
以下のように定式化できる．
\begin{equation}
p(y|x) = \sum_{z \in \mathcal{Z}} p(y|x,z)p(z|x)
\end{equation}
ここで，
$p(z|x)$ は入力 $x$ に基づいて
関連文書 $z$ を検索する確率分布を表し，
$p(y|x,z)$ は，
検索結果を条件として生成を行う
言語モデルの確率分布を表す．
このような確率モデルは，
Retrieval-Augmented Generation の原論文において
提案・定式化された枠組みに基づいている\cite{rag}．

セキュリティ分野においては，
CWEやCVEといった脆弱性知識ベースを
RAGによって参照することで，
脆弱性の検出や説明生成の精度を向上させる試みが報告されている．
特に，
コード片と既知の脆弱性パターンとの対応関係を
明示的に参照できる点は，
モデルの解釈性向上という観点からも有用である．

一方で，
RAGの性能は検索結果の品質に大きく依存しており，
不適切な文書が取得された場合には，
生成結果の誤りやノイズの増加につながる可能性がある．
そのため，
検索手法や知識ベースの設計が，
RAG全体の性能を左右する重要な要素となる．

%------------------------------------
\section{ファインチューニング（Fine-Tuning）}
%------------------------------------
%------------------------------------
\section{ファインチューニング（Fine-Tuning）}
%------------------------------------
ファインチューニング（Fine-Tuning）とは，
大規模コーパスを用いて事前学習されたモデルに対し，
特定タスクのデータを用いて追加学習を行うことで，
タスク固有の特徴に適応させる手法である．
この考え方は，深層ニューラルネットワークにおける
表現学習の枠組みに基づいており，
事前学習によって獲得された汎用的な中間表現を，
下流タスクに最適化する過程として位置づけられる．

Hintonらは，自己符号化器を用いた研究において，
高次元データから有用な低次元表現を事前に学習し，
その後のタスク適応によって性能が向上することを示している
\cite{hinton2006reducing}．
このような段階的学習の考え方は，
現在のLLMにおける事前学習とファインチューニングの関係と
本質的に共通している．

また，ファインチューニングに見られるような，
事前に獲得した表現を基盤として，
タスクや条件に応じた情報を追加的に学習するという考え方は，
他の機械学習分野においても広く見られる．
例えば，Uesakaらは，
マルチビュー学習において，
複数の異なる特徴量から得られる情報を統合しつつ，
ビュー間で共有される表現と各ビュー固有の表現を同時に学習する手法を提案し，
診断性能の向上を示している\cite{uesaka2017multi_view}．
このような枠組みは，
汎用的な表現を活用しながら，
対象に応じた特徴を適応的に学習するという点で，
事前学習モデルに対するファインチューニングの考え方と
共通する側面を持つと解釈できる．

この考え方は，近年の実応用分野にも取り入れられている．
ソフトウェア脆弱性検出分野においては，
脆弱なコードと安全なコードを用いた教師あり学習により，
特定の脆弱性パターンに対する識別性能が向上することが報告されている
\cite{devigneffectivesearchvulnerability}．
一方で，ファインチューニングには
大量のラベル付きデータを必要とする点や，
学習データに強く依存したバイアスが生じやすい点などの課題も存在し，
汎化性能の低下を招く可能性が指摘されている．

さらに，脆弱性検出を目的としたファインチューニングにおいては，
学習時点での知識が固定される点も課題となる．
CVEに代表される脆弱性情報は日々更新されており，
新たな攻撃手法や脆弱性種別が継続的に追加される．
ファインチューニング済みモデルは，
学習データに含まれない新規脆弱性に対しては対応が困難であり，
時間の経過とともに知識の陳腐化が生じる可能性がある．
このことは，
セキュリティ分野において
ファインチューニング単体を長期間運用することの
難しさを示している．

以上の課題から，
ファインチューニングは有効な手法である一方，
知識更新の柔軟性や運用性の観点では
制約が存在することが分かる．

%------------------------------------
\section{評価指標およびベンチマーク}
%------------------------------------
脆弱性検出手法の評価には，
Precision，Recall，F1-scoreといった指標が一般的に用いられる．
これらの指標は，検出結果を
真陽性（True Positive: TP），
偽陽性（False Positive: FP），
偽陰性（False Negative: FN）
に基づいて定義される．

Precisionは，検出された脆弱性のうち，実際に正しいものの割合を表す指標であり，
次式で定義される．
\begin{equation}
\mathrm{Precision} = \frac{TP}{TP + FP}
\end{equation}
Precisionが低い場合，誤検知が多く発生していることを意味し，
実運用においては解析コストの増大や運用負荷の増加につながる．
そのため，脆弱性検出タスクではPrecisionの高さが重要視される．

一方，Recallは，実際に存在する脆弱性のうち，正しく検出できた割合を表す指標であり，
次式で定義される．
\begin{equation}
\mathrm{Recall} = \frac{TP}{TP + FN}
\end{equation}
Recallが低い場合，脆弱性の見逃しが多いことを意味し，
セキュリティ上の重大なリスクにつながる可能性がある．
そのため，PrecisionだけでなくRecallとのバランスが重要である．

F1-scoreは，PrecisionとRecallの調和平均として定義され，
両者のバランスを総合的に評価する指標である．
\begin{equation}
\mathrm{F1\text{-}score} = 
\frac{2 \cdot \mathrm{Precision} \cdot \mathrm{Recall}}
{\mathrm{Precision} + \mathrm{Recall}}
\end{equation}
F1-scoreは，PrecisionとRecallのいずれか一方が極端に低い場合に値が低下するため，
両指標を同時に考慮した評価が可能となる．

なお，単一の評価指標のみで手法の有効性を判断することは難しく，
複数の指標を組み合わせて総合的に評価する必要がある．
特に，脆弱性検出のようにクラス不均衡が大きいタスクでは，
Accuracyのみでは実際の性能を適切に評価できない点に注意が必要である．

本研究においても，
PHPプログラムを対象とした脆弱性検出性能を評価するため，
これらの指標を用いて定量的な比較を行う．

%------------------------------------
\section{既存研究の課題と本研究の位置づけ}
%------------------------------------
以上のように，LLMを用いた脆弱性検出に関する研究は一定の成果を上げているが，
その多くはC/C++を対象とし，
バッファオーバーフローなどのメモリ管理に起因する脆弱性の検出に焦点を当てている．
この背景には，既存のベンチマークデータセットや先行研究の多くが，
低レベル言語を対象として構築されてきたという事情がある．

一方で，Web言語として広く利用されているPHPなどにおいては，
クロスサイトスクリプティング（XSS）やSQLインジェクションといった，
言語仕様や実行環境に依存した脆弱性が多数存在するにもかかわらず，
LLMを用いた包括的に扱った研究は依然として限定的である．
また，既存研究では特定の脆弱性クラスに偏った評価が多く，
検出可能な脆弱性の多様性という観点での分析も限定的である．

そこで本研究では，
Web言語であるPHPを対象としたLLMによる脆弱性検出の可能性を検討する．
さらに，メモリ関連脆弱性に限定せず複数の脆弱性種別を対象とすることで，
LLMが多様な脆弱性パターンをどの程度識別可能であるかを明らかにすることを目的とする．
Web言語特有の脆弱性を対象とし，
LLMを用いて複数種別の脆弱性を統一的に扱う点において，
既存研究とは異なる位置づけを持つ．

%----------------------------------------------------------------------------
\chapter{提案手法}
\label{chapter_3}
%----------------------------------------------------------------------------
本章では，本研究において提案する
LLMを用いたPHPプログラムの脆弱性検出手法について述べる．

PHPは，
Webアプリケーション開発において長年広く利用されてきた
サーバサイドスクリプト言語であり，
現在も多くの既存システムや中小規模Webサービスにおいて
重要な役割を担っている．
一方で，
動的型付けや簡潔な記述を特徴とする言語仕様，
および多様な実装慣習に起因して，
XSSやSQLインジェクションといった
Web特有の脆弱性が発生しやすいという課題を抱えている．

第2章で整理した関連研究より，
既存の脆弱性検出手法には
対象言語や脆弱性種別の偏りが存在することが明らかとなった．

このような背景を踏まえ，
本研究では
Webアプリケーションで広く利用されているPHPを対象とし，
LLMのコード理解能力を活用した
脆弱性検出手法を提案する．
特に，
言語仕様や実行文脈に依存する脆弱性に対して，
LLMがどの程度有効に機能するかを明らかにすることを目的とする．

本章ではまず，
本研究の概要および設計方針を示し，
続いて対象とする脆弱性および分析対象について説明する．
その後，
提案手法の全体構成，
LLMによるコード解析手法，
知識ベースの活用方法，
ならびに出力形式と判定方法について詳述し，
最後に実装上の留意点について述べる．

%------------------------------------
\section{本研究の概要}
%------------------------------------
本研究の目的は，
Webアプリケーション開発で広く利用されているPHPを対象として，
LLMを用いた脆弱性検出手法を構築し，
その有効性を検証することである．
特に，従来研究では十分に検討されてこなかった
Web言語特有の脆弱性に着目し，
LLMの自然言語理解能力およびコード理解能力を活用することで，
実用的かつ拡張性の高い検出手法の実現を目指す．

本研究では，
LLMの活用形態として以下の三つの構成を採用する．
\begin{itemize}
  \item 事前学習済み言語モデルをそのまま用いる構成（以下，素のLLM）
  \item 脆弱性データセットを用いてFine-Tuningを行った構成
  \item 素のLLMに対して知識ベースを接続したRAG構成
\end{itemize}
これら三構成を同一条件下で比較することで，
学習による知識獲得と，
外部知識の参照という
異なるアプローチの特性を明らかにする．

また，本研究では検出結果を
「脆弱性の種類」「想定されるリスク」「修正案」
といった形式で出力することで，
開発者が結果を理解しやすく，
実際の修正作業に活用しやすいことを重視している．
これにより，LLMを単なる分類器として用いるのではなく，
脆弱性分析を支援するツールとして位置付ける点に
本研究の特徴がある．

%------------------------------------
\section{設計方針}
%------------------------------------
第2章で述べた関連研究の整理より，
従来の脆弱性検出手法には
対象言語の偏りや，
検出対象の限定性といった課題が存在することが明らかとなった．
本研究では，これらの課題に対応するため，
以下の設計方針に基づいて提案手法を構築する．

まず，対象言語としてPHPを採用し，
Webアプリケーションにおいて頻発する
入力処理や外部データの取り扱いに起因する脆弱性を
重点的に扱うこととした．
これにより，
Web言語特有の脆弱性に対する
検出性能を評価可能な枠組みを構築する．

次に，解析手法としてLLMを中核に据え，
静的解析やルールベース手法では対応が困難であった
多様なコーディングスタイルや
文脈依存の脆弱性に対応することを目指す．

さらに，本研究では
LLMの活用形態の違いに着目し，
素のLLM，Fine-Tuning済みLLM，RAG構成の
三つの構成を比較対象とする．
この際，入力コード，プロンプト形式，
および出力形式を統一することで，
モデル構成以外の要因が
検出結果に影響を与えないよう設計した．

%------------------------------------
\section{対象脆弱性および分析対象}
%------------------------------------
本節では，本研究で対象とする脆弱性の種類および
分析対象とするプログラムの範囲について説明する．

%------------------------------------
\subsection{対象脆弱性}
%------------------------------------
本研究では，Webアプリケーションにおいて
発生頻度が高く，
かつ実害につながりやすい脆弱性を主な対象とする．
具体的には，以下の脆弱性を扱う．
\begin{itemize}
  \item クロスサイトスクリプティング（XSS）
  \item クロスサイトリクエストフォージェリ（CSRF）
  \item セッション管理の不備（セッション固定化，ハイジャック等）
  \item SQLインジェクション
\end{itemize}

これらの脆弱性は，
ユーザ入力の検証不足や
不適切なデータ処理に起因することが多く，
コードの文脈や処理の流れを考慮した解析が求められる．
そのため，LLMによる解析が有効であると考えられる．

%------------------------------------
\subsection{分析対象プログラム}
%------------------------------------
分析対象としては，
PHPで記述されたサーバサイドプログラムを対象とする．
関数定義，条件分岐，
データベースアクセス，
外部入力処理などを解析対象とし，
フレームワーク固有の機構や
実行環境依存の設定については考慮しない．

%------------------------------------
\section{提案手法の全体構成}
%------------------------------------
% 手法の全体のフローを作成する
%------------------------------------
提案手法の全体構成を図\ref{fig:system_overview}に示す．
本手法は，
入力となるPHPソースコード，
LLMによる解析処理，
および検出結果の出力から構成される．

解析対象のPHPコードは，
ファイル単位で前処理を施した後，
LLMへの入力として与えられる．
LLMはコードの構造や処理内容を解析し，
脆弱性の有無および種類を判定する．

RAG構成では，
解析対象コードに関連する脆弱性知識を
知識ベースから検索し，
その内容をプロンプトに付加した上で
LLMによる解析を行う．
これにより，
LLMはコード単体の情報だけでなく，
外部知識を参照した判断を行うことが可能となる．

%------------------------------------
\section{LLMによるコード解析手法}
%------------------------------------
本研究では，
LLMによるコード解析手法として，
以下の三種類の構成を用いる．

素のLLM構成では，
事前学習済みの言語モデルに対して
PHPコードと解析指示を直接入力し，
脆弱性の有無および種類を出力させる．
この構成は追加学習を必要としないため，
導入が容易である一方，
専門知識の不足による誤検出が生じる可能性がある．

Fine-Tuning構成では，
脆弱性データセットを用いて
事前学習済みモデルを微調整し，
Webアプリケーション脆弱性に関する知識を
モデル内部に獲得させる．
これにより，
特定の脆弱性パターンに対する
検出精度の向上が期待される．

RAG構成では，
LLM自体は素のLLMと同一のモデルを用い，
解析時に外部知識ベースを検索・参照する．
これにより，
モデルを再学習することなく，
最新かつ体系化された知識を
解析に反映可能とする．


%------------------------------------
\section{知識ベースの活用方法}
%------------------------------------
本研究では，
LLMによる脆弱性検出の精度および一貫性を向上させるため，
脆弱性に関する知識を体系的に整理した
知識ベースを構築し，これを解析に活用する．
知識ベースには，
各脆弱性の発生条件，
代表的な脆弱コード例，
安全な実装例，
および修正方針に関する情報を含める．

RAG構成においては，
解析対象となるPHPコード，
もしくはその一部をクエリとして用い，
知識ベース内の文書から
関連性の高い情報を検索する．
この検索処理には，
第2章で述べた埋め込みモデルと類似度検索を用い，
入力コードと意味的に近い知識文書を抽出する．

検索によって得られた知識は，
そのまま出力として用いるのではなく，
LLMへの入力プロンプトに付加情報として与えられる．
これにより，
LLMはコード単体の解析結果に加えて，
脆弱性に関する明示的な知識を参照しながら
判断を行うことが可能となる．

このような構成により，
Fine-Tuningを行わない場合であっても，
外部知識の更新や拡張が容易となり，
新たな脆弱性情報への追従性を確保できる．
また，
モデル内部に知識を固定的に保持させる
Fine-Tuning構成との比較を通じて，
知識付与手法の違いが
脆弱性検出性能に与える影響を
評価可能な設計となっている．

%------------------------------------
\section{出力形式および判定方法}
%------------------------------------
LLMの出力は，
脆弱性の種類，
リスクの説明，
修正案の三要素から構成される．

また，本研究では，
LLMの出力結果に対して
以下の基準に基づき判定を行う．

まず，脆弱性の有無については，
対象コードに対して
正解データとして付与された
脆弱性ラベルと比較し，
一致した場合を正検出とする．

次に，脆弱性の種類については，
出力された脆弱性分類が
正解ラベルと一致しているかどうかを判定する．
複数の脆弱性が存在する場合には，
いずれか一つでも正しく指摘されていれば
検出成功とみなす．

本研究では，
脆弱性の有無および種類の判定を
定量評価の対象とし，
リスク説明および修正案については
補助的な定性評価として扱う．

一方で，
存在しない脆弱性を指摘した場合は
過検出（False Positive）として扱う．
これらの判定結果に基づき，
第4章において
各構成の検出性能を定量的に評価する．


%------------------------------------
\section{実装上の留意点}
%------------------------------------
実装にあたっては，
LLM構成間の比較を公平に行うため，
プロンプトの指示内容および
出力形式をすべての構成で統一した．

また，
長大なPHPコードを解析する場合に備え，
入力長制限を考慮し，
ファイル単位で解析を行う設計とした．

これらの工夫により，
モデル構成以外の要因が
検出結果に影響を与えないよう配慮した．

%----------------------------------------------------------------------------
\chapter{実験設定と評価方法}
\label{chapter_4}
%----------------------------------------------------------------------------
本章では，第3章で提案したLLMを用いた脆弱性解析手法の有効性を検証するため，
実験設定および評価方法について述べる．
提案手法の妥当性を定量的に評価するため，
複数のLLM構成を同一条件下で比較する実験を実施する．

本研究では，汎用的なLLM，Fine-Tuningを施したLLM，
および知識ベースを併用するRAG構成LLMを対象とし，
同一のPHPプログラム群に対して脆弱性検出を行う．
本章では，実験の目的，使用データセット，
実験対象モデル，実験手順，評価指標，
および実験条件の公平性について順に説明する．

%------------------------------------
\section{実験の目的}
%------------------------------------
本研究における実験の目的は，
第3章で提案した
LLMを用いたPHPプログラムの脆弱性検出手法について，
その有効性および特性を定量的に評価することである．

特に，
事前学習済みLLM単体による解析能力の限界を明らかにするとともに，
Fine-TuningおよびRAG構成が
脆弱性検出結果にどのような影響を与えるかを比較・分析する．

本実験では，
厳密な汎化性能の最適化を目的とするのではなく，
LLMの活用形態の違いが
脆弱性検出挙動および出力傾向に与える影響を
相対的に評価することを主眼とする．


%------------------------------------
\section{使用データセット}
%------------------------------------
本研究では，
Fine-Tuning用データセットと
RAG構成で使用する知識ベースを，
異なる情報源から構築し，
それぞれ異なる目的で使用する．

Fine-Tuning用データセットには，
JVNおよびCVEに公開されている
PHPに関連する脆弱性情報を基に収集した事例を用いた．
各データには，
脆弱性の概要および脆弱性種別ラベルを付与し，
モデルに対して
Webアプリケーション脆弱性に関する知識を付与することを目的とした．

本研究では，
データ規模の制約および
比較実験を主目的とする設計方針から，
Fine-Tuning用データの分割
（学習用・検証用・評価用）を行っていない．
そのため，
本構成は一般的な機械学習における
汎化性能評価を目的としたものではなく，
脆弱性知識をモデル内部に付与した場合の
検出挙動の変化を観察するための
実験的設定として位置付ける．

RAG構成で使用する知識ベースには，
rules.sonarsource.comにおいて公開されている
脆弱なコード記法，
検出ルール，
および修正指針に関する情報を収集した．
なお，
評価対象とするPHPプログラムは，
Fine-Tuning用データおよび
RAG用知識ベースのいずれにも含めないことで，
情報漏洩を防止し，
比較実験の公平性を確保している．


%------------------------------------
\section{実験対象モデル}
%------------------------------------
本研究では，基礎モデルとして
\texttt{unsloth/qwen3-14b} を使用する．
以下に，各構成について説明する．

%------------------------------------
\subsection{素のLLM}
%------------------------------------
素のLLMでは，
事前学習済みモデルをそのまま用い，
追加学習や外部知識の参照を行わない．
この構成は，
LLM本来の汎化能力を評価するための
ベースラインとして位置付ける．

%------------------------------------
\subsection{Fine-Tuning済みLLM}
%------------------------------------
Fine-Tuning構成では，
JVNおよびCVEから収集した
PHP脆弱性データセットを用いて，
基礎モデルに対する追加学習を行う．
これにより，
モデル内部に
Webアプリケーション脆弱性に関する知識を直接獲得させ，
脆弱性種別の識別性能向上を図る．

Fine-Tuningは，
事前学習済みの大規模言語モデルに対して
80エポックの学習を行い，
実験の再現性を確保するため，
乱数シードを3407に固定した．
なお，本研究では，
収集したデータセット全体を用いて
Fine-Tuningを実施しており，
学習用データと検証用データの分割は行っていない．
これは，本研究の目的が
Fine-Tuning単体の汎化性能評価ではなく，
RAG構成との比較を通じて，
知識付加手法の違いが
脆弱性検出結果に与える影響を分析することにあるためである．

そのため，本構成は，
Fine-Tuningによる性能向上の絶対値を示すものではなく，
RAG構成との相対的な比較を目的としたものである．

%------------------------------------
\subsection{RAG構成LLM}
%------------------------------------
RAG構成では，
LLM自体は素のLLMと同一のモデルを用い，
解析時に外部知識ベースを検索・参照する．
入力されたPHPコードを埋め込み空間に写像し，
知識ベース内の文書との類似度に基づいて
関連情報を検索し，
その結果をプロンプトに付加する．

この類似度検索には，
埋め込みモデルとして
\texttt{e5-multilingual}\cite{e5}
を使用する．
\texttt{e5-multilingual}は，
検索タスク向けに事前学習された
多言語対応の埋め込みモデルであり，
クエリと文書の意味的対応関係を
高精度に捉えることが可能である．

なお，知識ベース検索においては，
入力コードをクエリとして埋め込みベクトルに変換し，
コサイン類似度に基づく類似度検索を行った．
本研究では，検索件数を top-k = 5 に固定し，
類似度に対する明示的な閾値は設定していない．

そのため，検索結果には，
入力コードとの関連性が必ずしも高くない文書が
含まれる可能性があり，
この点が後述する検出結果および誤検知傾向に
影響を与える可能性がある．

%------------------------------------
\section{実験手順}
%------------------------------------
実験は以下の手順で実施する．

\begin{enumerate}
  \item 対象プログラムをLLMに入力する
  \item 定義したプロンプトに基づき，脆弱性の有無および種類を出力させる
  \item 出力結果を保存し，正解ラベルと比較する
\end{enumerate}

なお，LLMの非決定性による影響を低減するため，
同一条件で複数回実行し，その結果を集計する．

%------------------------------------
\section{評価指標}
%------------------------------------
本研究では，
第2章で述べた評価指標に基づき，
脆弱性検出性能を定量的に評価する．
具体的には，
Precision，Recall，F1-scoreを用い，
各LLM構成の検出性能を比較する．

また，
数値指標に加えて，
出力されたリスク説明および修正案の妥当性についても，
定性的な評価を行う．

さらに，本研究における評価では，
LLMの出力結果が一回の実行において
複数の脆弱性を含む場合がある点を考慮し，
評価単位を
「脆弱性種別 × 試行回数」
と定義する．

LLMが出力した脆弱性指摘のうち，
正解ラベルに含まれる脆弱性を検出した場合を
True Positive（TP）とする．
この際，修正案の成否や説明の完全性にかかわらず，
脆弱性そのものを正しく指摘していれば
検出成功として扱う．

一方，正解ラベルに含まれない脆弱性を指摘した場合は，
誤検知として
False Positive（FP）と定義する．
また，正解ラベルに含まれる脆弱性を
検出できなかった試行については，
False Negative（FN）として扱う．

これらの定義に基づき，
Precision，Recall，F1-score を
micro-average により算出する．


%------------------------------------
\section{実験条件の統一と公平性}
%------------------------------------
本研究では，
異なるLLM構成間で脆弱性検出性能を比較するため，
可能な限り実験条件を統一した．

入力として与えるPHPコード，
評価対象とする脆弱性ラベル，
および最終的な出力形式
（脆弱性の種類，リスク説明，修正案）は，
すべての構成において共通とした．

一方で，
RAG構成においては，
脆弱性診断の過程において
以下の中間処理が追加される点で，
他の構成と処理フローが異なる．

\begin{enumerate}
  \item LLMによる脆弱性の有無および種類の判定
  \item 判定結果および入力コードに基づく
        関連知識文書の検索
  \item 検索結果を付加した上での
        リスク説明および修正案の生成
\end{enumerate}

この中間処理は，
外部知識を活用した説明生成を目的としたものであり，
脆弱性の有無そのものの判定基準には
直接影響しないよう設計している．

評価においては，
最初の脆弱性判定結果のみを
正解ラベルと比較することで，
処理段階数の違いが
検出性能評価に影響を与えないよう配慮した．

また，RAG構成における知識検索では，
検索件数を top-k = 5 に固定し，
類似度閾値を設けない設定とした．
この設定は，全ての実験において共通とし，
RAG構成内での条件差が生じないよう統一した．

%----------------------------------------------------------------------------
\chapter{実験結果と考察}
\label{chapter_5}
%----------------------------------------------------------------------------
本章では，第4章で述べた実験設定および評価方法に基づき実施した
脆弱性検出実験の結果を示し，提案手法の有効性について考察を行う．
まず，各手法における検出性能を定量的に比較し，
次に脆弱性種別ごとの検出傾向や誤検知の分析を行う．
さらに，Fine-TuningおよびRAGを用いた手法の特性を比較し，
最後に本手法の有効性と限界について議論する．

%------------------------------------
\section{検出性能の比較結果}
%------------------------------------
本節では，素のLLM，Fine-Tuning済みLLM，およびRAG構成LLMの
脆弱性検出性能を比較する．
評価指標としては，第4章で述べたPrecision，Recall，F1-scoreを用いる．

表\ref{tab:overall_performance}に示す数値は，
正解ラベルとして定義された脆弱性に対する
検出成否を基準として算出したものであり，
誤検知された脆弱性は
False Positive として Precision を低下させる要因となる．

そのため，本研究における Precision は，
LLMが不要な脆弱性を指摘せず，
適切な脆弱性のみを抽出できているかを示す指標として解釈できる．
一方，Recall は，
正解ラベルに含まれる脆弱性を
どの程度網羅的に検出できているかを示す．

結果から，いずれの構成においても
Recall は比較的低い値に留まっており，
正解ラベルとして定義された脆弱性を
十分に網羅できていないことが分かる．
また，本実験条件においては，
Fine-TuningおよびRAGを導入したモデルは，
素のLLMと比較して
Precision および Recall の双方において
顕著な改善は見られなかった．

この結果は，
脆弱性検出タスクにおいて，
モデルの知識拡張や外部知識の参照だけでは，
検出精度の向上が必ずしも保証されないことを示唆している．

\begin{table}[t]
\centering
\caption{各手法の検出性能比較}
\label{tab:overall_performance}
\begin{tabular}{lccc}
\hline
手法 & Precision & Recall & F1-score \\
\hline
素のLLM & 0.407 & 0.219 & 0.285 \\
Fine-Tuning済みLLM & 0.382 & 0.186 & 0.250 \\
RAG構成LLM & 0.36 & 0.171 & 0.231 \\
\hline
\end{tabular}
\end{table}

%------------------------------------
\section{脆弱性種別ごとの検出傾向}
%------------------------------------
本節では，脆弱性種別ごとの検出傾向について分析する．
対象とした脆弱性は，
SQLインジェクション，XSS，CSRFなど，
Webアプリケーションにおいて
頻繁に問題となるものとした．

Fine-Tuning済みLLMでは，
XSSやCSRFといった
比較的文献や事例が多く，
パターン化しやすい脆弱性については，
一定の検出が行われる傾向が確認された．
一方で，
正解ラベルに含まれない脆弱性種別を
同時に指摘するケースも多く，
結果として Precision の低下につながっている．

一方，RAG構成LLMでは，
知識ベースに含まれるルールや記法に影響を受け，
特定の脆弱性種別に対する指摘が
集中する傾向が見られた．
しかし，
正解ラベルと一致しない指摘も多く，
全体として検出性能の向上には
直結しなかった．

%------------------------------------
\section{誤検知の分析}
%------------------------------------
本節では，各手法における
誤検知（False Positive）の傾向について分析する．

素のLLMでは，
入力コードの文脈を過度に一般化し，
実際には成立しない脆弱性を
指摘するケースが多く見られた．
特に，
入力値検証やセッション管理に関する
抽象的な指摘が頻発する傾向が確認された．

Fine-Tuning済みLLMでは，
学習データに含まれる脆弱性パターンを
過剰に適用することで，
コードの実際の挙動とは一致しない
脆弱性を検出する例が見られた．
このことは，
Fine-Tuningによって知識量は増加するものの，
適用範囲の判断が難しくなる可能性を示している．

一方，RAG構成LLMでは，
検索された知識ベースの内容に強く影響され，
入力コードと直接的な関係が薄い脆弱性を
指摘するケースが確認された．
これは，
知識検索の段階で取得される文書の適合度が，
最終的な出力品質に大きく影響することを示唆している．

特に今回のRAG構成LLMでは，
類似度検索において明示的な閾値を設けていないため，
入力コードとの関連性が十分でない文書が
プロンプトに含まれる場合がある．
このことが，
入力コードと直接対応しない脆弱性の指摘を誘発し，
False Positive の増加につながった可能性がある．

%------------------------------------
\section{Fine-TuningとRAGの比較考察}
%------------------------------------
本節では，
Fine-TuningとRAGという
二つのアプローチの特性を比較し，
それぞれの利点と課題について考察する．

Fine-Tuningは，
モデル内部に脆弱性知識を直接獲得させるため，
推論時に外部知識への依存が不要であるという利点を持つ．
しかし，
本実験結果からは，
知識の適用範囲を適切に制御できない場合，
誤検知が増加する可能性が示された．

一方，RAGは，
知識ベースを更新することで
比較的容易に知識の追加・修正が可能であり，
説明生成の補助としては有効である．
しかし，
脆弱性検出そのものの精度向上については，
知識検索の精度や
プロンプト設計に大きく依存することが明らかとなった．

%------------------------------------
\section{本手法の有効性と限界}
%------------------------------------
以上の実験結果から，
Fine-TuningおよびRAGを用いた手法は，
脆弱性のリスク説明や修正案の生成といった
補助的なタスクにおいては一定の有効性を持つものの，
脆弱性検出精度の向上という観点では，
素のLLMに対して
明確な優位性を示すには至らなかった．

一方で，本手法にはいくつかの限界も存在する．
まず，評価対象がPHPコードに限定されており，
他言語への一般化については
今後の検討が必要である．
また，正解ラベルの定義や粒度が
評価結果に大きく影響する点も，
本研究の制約として挙げられる．
さらに，RAGにおける知識ベースの品質や更新頻度が，
検出結果に与える影響についても，
より詳細な分析が求められる．

これらの課題を踏まえ，
次章では本研究のまとめと今後の展望について述べる．

%------------------------------------
%   Chapter 6
\chapter{まとめと今後の展望}
\label{chapter_6}
%------------------------------------

%------------------------------------
\section{本研究のまとめ}
%------------------------------------

%------------------------------------
\section{研究成果の整理}
%------------------------------------

%------------------------------------
\section{本研究の貢献}
%------------------------------------

%------------------------------------
\section{限界と課題}
%------------------------------------

%------------------------------------
\section{今後の展望}
%------------------------------------

%------------------------------------
%   Acknowledgements
\chapter*{謝辞}
\label{chapter_}
%------------------------------------
．

%------------------------------------
%   References
%------------------------------------
\bibliography{main} %hoge.bibから拡張子を外した名前
\bibliographystyle{plainnat} %参考文献出力スタイル
%------------------------------------
% \appendix
%------------------------------------

%------------------------------------
\end{document}
%------------------------------------
