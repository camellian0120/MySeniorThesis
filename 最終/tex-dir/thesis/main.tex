%------------------------------------
%   basic settings
%------------------------------------
\documentclass[12pt,a4paper,oneside]{jsbook}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[dvipdfmx]{graphicx}
\usepackage{url}
\usepackage{here}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[ipaex]{pxchfon}
\usepackage{otf}
\usepackage{listings}
\usepackage[square, numbers]{natbib}
\usepackage{booktabs}
\usepackage{float} 
\usepackage{placeins}
% \usepackage{graphics}
\usepackage[dvipdfmx]{graphicx} % includegraphicsを使うためのパッケージを読み込む
% \usepackage{natbib}

% \bibpunct[:]{(}{)}{,}{a}{}{,}
%------------------------------------
%   listings settings (minted -> listings)
%------------------------------------
\lstset{
  basicstyle=\ttfamily\small,  % Font style
  numbers=left,                % Add line numbers
  numberstyle=\tiny,           % Line number style
  stepnumber=1,                % Line number increment
  frame=single,                % Add a frame around the code
  tabsize=4,                   % Tab size
  breaklines=true,             % Allow line breaking
  keywordstyle=\bfseries,      % Keywords in bold
  commentstyle=\itshape,       % Comments in italics
  stringstyle=\color{red},     % Strings in red
  showspaces=false,            % Do not mark spaces
  showstringspaces=false,      % Do not mark string spaces
  language=Python              % Default language
}

%------------------------------------
%   margin settings
%------------------------------------
\setlength{\topmargin}{-5mm}
\setlength{\fullwidth}{125mm}
\setlength{\textwidth}{\fullwidth}
\setlength{\oddsidemargin}{5mm}
\setlength{\evensidemargin}{\oddsidemargin}
%------------------------------------
%   newtheorems
%------------------------------------
\theoremstyle{plain}
\newtheorem{theorem}{定理}[chapter]
\newtheorem{corollary}[theorem]{系}
\newtheorem{lemma}[theorem]{補題}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{conjecture}[theorem]{予想}
\newtheorem{proposition}[theorem]{命題}
\newtheorem{problem}[theorem]{問題}
\newtheorem{definition}[theorem]{定義}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{claim}{Claim}
\newtheorem{subclaim}{Subclaim}[claim]
\newcommand{\resetclaim}{\setcounter{claim}{0}}
\newtheorem{case}{Case}
\newtheorem{subcase}{Subcase}[case]
\newcommand{\resetcase}{\setcounter{case}{0}}
\providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}
%------------------------------------
%   display figures
%   #1=width, #2=filename,
%   #3=caption, #4=label
%   \fig{0.8\linewidth}{aaa.pdf}{bbb}{ccc}
%------------------------------------
\renewcommand{\figurename}{図.}
\newcommand{\fig}[4]{
\begin{figure}[H]
\centering
\includegraphics[width=#1]{#2}
\caption{#3}
\label{#4}
\end{figure}
}
\newcommand{\figg}[4]{
\begin{figure*}[h!t]
\centering
\includegraphics[width=#1]{#2}
\caption{#3}
\label{#4}
\end{figure*}
}
%------------------------------------
%   setting of algorithms
%------------------------------------
\renewcommand{\algorithmicrequire}{\textbf{条件:}}
\renewcommand{\algorithmicensure}{\textbf{実行結果:}}
\algrenewcommand\algorithmicdo{}
\algrenewcommand\algorithmicthen{}
%------------------------------------
%   other renewcommands and newcommands
%------------------------------------
\renewcommand{\proofname}{\bf 証明.}
%------------------------------------
%   Title & Authors
%------------------------------------
\title{
卒業論文\\[1.5cm]
LLMによるソフトウェア脆弱性の検出\\[6cm]
}
\author{高知大学 理工学部 情報科学科\\[0.5cm]
B223R030P 横川武典}
\date{2025年度}

%------------------------------------
\begin{document}
%------------------------------------
%タイトルページの出力
\maketitle
%目次の作成・出力
\tableofcontents

%----------------------------------------------------------------------------
%   Chapter 1
\chapter{はじめに}
\label{chapter_1}
%----------------------------------------------------------------------------
\section{背景}
%------------------------------------
．

%----------------------------------------------------------------------------
\chapter{関連研究}
\label{chapter_2}
%----------------------------------------------------------------------------
本章では，本研究に関連する既存研究および技術について整理する．
まず，従来のソフトウェア脆弱性検出手法について概観し，その課題を明らかにする．
次に，大規模言語モデル（LLM）の概要と，セキュリティ分野への応用例について述べる．
その後，LLMを用いた脆弱性検出に関する先行研究を整理し，Retrieval-Augmented Generation（RAG）や
ファインチューニングといった手法について説明する．
最後に，評価指標および既存研究の課題をまとめ，本研究の位置づけを明確にする．

%------------------------------------
\section{従来のソフトウェア脆弱性検出}
\label{chapter_2:conventional-method}
%------------------------------------
ソフトウェアの脆弱性検出手法は，
大きく静的解析と動的解析に分類される \cite{chess_mcgraw}.
静的解析は，プログラムを実行せずにソースコードやバイナリを解析する手法であり，
代表的なものとしてデータフロー解析やルールベース解析が挙げられる．
静的解析の代表例としては，Lint系ツールや商用のSASTツールなどが広く利用されている．
静的解析は網羅的な検査が可能である一方，実行時の文脈を考慮できないため
誤検知（False Positive）が多いという課題がある．

一方，動的解析はプログラムを実際に実行し，
その挙動を監視することで脆弱性を検出する手法である．
ファジングや実行時モニタリングなどが代表例であり，
AFLに代表されるファジング手法は，実際に悪用可能な脆弱性を検出できる利点を有する．
しかし，実行パスに依存するため，すべての脆弱性を網羅的に検出することは困難である．

近年では，静的解析と動的解析を組み合わせた
ハイブリッド解析手法も提案されており，
両者の欠点を補完するアプローチとして注目されている．
しかし，解析コストの増大や運用の複雑化といった課題も残されている．

これらの従来手法は，既知の脆弱性パターンに基づく検出には有効であるが，
新種の脆弱性や文脈依存性の高い問題に対しては十分な性能を発揮できないという課題が指摘されている．

%------------------------------------
\section{Large Language Model（LLM）}
\label{chapter_2:llm}
%------------------------------------
大規模言語モデル（Large Language Model: LLM）は，大量のテキストデータを用いて事前学習された
深層学習モデルであり，自然言語処理分野において高い性能を示している．
近年では，Transformer構造を基盤としたモデルが主流となっており，
自己注意機構によって文脈情報を効果的に捉えることが可能である\cite{transformers}．

さらに，近年のLLMは自然言語だけでなくソースコードを含むデータで学習されており，
プログラムの構文構造や意味的関係を一定程度理解できることが報告されている．
CodeBERT\cite{codebert}やGraphCodeBERT\cite{graphcodebert}などのLLMは，
コードと自然言語の対応関係を学習することで，
プログラム理解タスクにおいて高い性能を示している\cite{llminsoftwaresecurity}．

このような特性から，LLMは単なる自然言語処理モデルにとどまらず，
ソフトウェア解析やセキュリティ分野への応用が期待されている．
次節では，セキュリティ分野におけるLLMの具体的な活用事例について述べる．

%------------------------------------
\section{セキュリティ分野とLLMの関連性および応用}
\label{chapter_2:llm_security}
%------------------------------------
近年，大規模言語モデル（LLM）は自然言語処理分野にとどまらず，
サイバーセキュリティ分野においても幅広い応用が進んでいる．
LLMが脆弱性検出，マルウェア解析，ネットワーク侵入検知，フィッシング検出など，
多様なサイバーセキュリティタスクに適用されていることが報告されている\cite{llmcyber}．
このことから，LLMは特定用途に限定された技術ではなく，
セキュリティ分野全体に横断的に利用可能な基盤技術として位置づけられている．

一方で，LLMが生成した成果物そのものが新たなセキュリティリスクとなり得る点も指摘されている．
LLMが生成したWeb言語向けJavaScriptコードを分析した研究では，
24.5\%のコードにおいてセッションタイムアウトの欠如やHTTPセキュリティヘッダーの不足といった
不適切な実装が確認されたと報告されている\cite{hiddenriskllmgeneratedweb}．
この知見は，LLMの出力結果を無条件に信頼することの危険性を示している．

このように，セキュリティ分野におけるLLMの活用は，
防御・検出を支援する側面と，新たな脆弱性を生み出す可能性という
両義的な性質を有している．
そのため，LLMとセキュリティの関係を論じる上では，
応用可能性だけでなく，出力結果の検証やリスク評価を含めた
包括的な視点が不可欠である．

%------------------------------------
\section{LLMを用いた脆弱性検出の先行研究}
\label{chapter_2:related_llm_vuln}
%------------------------------------
LLMを用いた脆弱性検出に関する先行研究では，
主にCやC++といった低レベル言語を対象としたものが多い．
これらの研究では，ソースコードを入力とし，
脆弱性の有無や種類を分類問題として扱う手法が主に提案されている．
特に，バッファオーバーフローやメモリ破壊といった脆弱性を対象とし，
LLMがコードの文脈情報を活用することで
従来手法よりも高い検出性能を示す可能性が報告されている．

近年では，脆弱性情報が頻繁に更新されるセキュリティ分野の特性を踏まえ，
外部知識ベースを活用する手法を組み合わせた研究も提案されている．
これらの研究では，CWEやCVEといった既存の知識ベースを参照することで，
脆弱性検出やその説明の精度向上を図っている．

%------------------------------------
\section{Retrieval-Augmented Generation（RAG）}
\label{chapter_2:rag}
%------------------------------------
Retrieval-Augmented Generation（RAG）は，
LLMによる生成時に外部知識ベースから関連情報を検索し，
その結果を入力として利用する手法である．
RAGを用いることで，モデル内部に含まれない知識を動的に参照でき，
事実性の向上やハルシネーションの抑制が期待される\cite{rag}．

セキュリティ分野においては，CWEやCVEなどの知識ベースをRAGによって参照することで，
脆弱性検出や説明生成の精度を向上させる試みが報告されている．
一方で，検索結果の品質が全体性能に大きく影響するという課題も存在する．

%------------------------------------
\section{ファインチューニング（Fine-Tuning）}
\label{chapter_2:finetuning}
%------------------------------------
ファインチューニング（Fine-Tuning）とは，
事前学習済みの言語モデルを特定タスクに適応させるために
追加学習を行う手法であり，BERT以降，標準的なアプローチとして
広く用いられている\cite{finetuning}．
脆弱性検出分野では，
脆弱なコードと安全なコードを用いた教師あり学習により，
特定の脆弱性パターンに対する識別性能の向上が報告されている\cite{devigneffectivesearchvulnerability}．

一方で，ファインチューニングは大量のラベル付きデータを必要とし，
学習データに依存したバイアスや汎化性能の低下といった課題を抱えている．

%------------------------------------
\section{評価指標およびベンチマーク}
\label{chapter_2:evalution}
%------------------------------------
脆弱性検出手法の評価には，
Precision，Recall，F1-scoreといった指標が一般的に用いられる．
特に，誤検知の多さは実運用において大きな負担となるため，
Precisionの高さが重要視される．
一方で，脆弱性の見逃しは重大なリスクにつながるため，
Recallの低下にも注意が必要である．

なお，単一の評価指標のみで手法の有効性を判断することは難しく，
複数の指標を組み合わせて総合的に評価する必要がある．
特に，データセットのクラス不均衡が大きい場合には，
Accuracyのみでは実性能を適切に評価できない点に注意が必要である．

%------------------------------------
\section{既存研究の課題と本研究の位置づけ}
\label{chapter_2:potisioning}
%------------------------------------
以上のように，LLMを用いた脆弱性検出に関する研究は一定の成果を上げているが，
その多くはC/C++を対象とし，
バッファオーバーフローなどのメモリ管理に起因する脆弱性の検出に焦点を当てている．
この背景には，既存のベンチマークデータセットや先行研究の多くが，
低レベル言語を対象として構築されてきたという事情がある．

一方で，Web言語として広く利用されているPHPなどにおいては，
クロスサイトスクリプティング（XSS）やSQLインジェクションといった，
言語仕様や実行環境に依存した脆弱性が多数存在するにもかかわらず，
LLMを用いた包括的な検出手法に関する検討は十分に行われていない．
また，既存研究では特定の脆弱性クラスに偏った評価が多く，
検出可能な脆弱性の多様性という観点での分析も限定的である．

そこで本研究では，
Web言語であるPHPを対象としたLLMによる脆弱性検出の可能性を検討する．
さらに，メモリ関連脆弱性に限定せず複数の脆弱性種別を対象とすることで，
LLMが多様な脆弱性パターンをどの程度識別可能であるかを明らかにすることを目的とする．

%----------------------------------------------------------------------------
\chapter{提案手法}
\label{chapter_3}
%----------------------------------------------------------------------------
本章では，ソフトウェア脆弱性検出に関する従来手法および
大規模言語モデル（LLM）を用いた先行研究について整理した．
その結果，既存研究の多くはC/C++を対象とした
メモリ関連脆弱性の検出に焦点を当てており，
Web言語に特有の脆弱性を包括的に扱った検討は十分とは言えないことが明らかとなった．

また，RAGやファインチューニングといった手法は
LLMの性能向上に寄与する一方で，
適用対象や評価範囲には依然として課題が残されている．
これらの背景を踏まえ，
次章ではWeb言語であるPHPを対象とした
LLMによる脆弱性検出手法を提案し，
その設計方針および実装について詳述する．

%------------------------------------
\section{本研究の概要}
\label{chapter_3:method_overview}
%------------------------------------

%------------------------------------
\section{設計方針}
\label{chapter_3:design_policy}
%------------------------------------

%------------------------------------
\section{対象脆弱性および分析対象}
\label{chapter_3:target_vulnerability}
%------------------------------------

%------------------------------------
\section{提案手法の全体構成}
\label{chapter_3:system_overview}
%------------------------------------

%------------------------------------
\section{LLMによるコード解析手法}
\label{chapter_3:llm_analysis}
%------------------------------------

%------------------------------------
\section{知識ベースの活用方法}
\label{chapter_3:knowledge_base}
%------------------------------------

%------------------------------------
\section{出力形式および判定方法}
\label{chapter_3:output_definition}
%------------------------------------

%------------------------------------
\section{実装上の留意点}
\label{chapter_3:implementation_notes}
%------------------------------------


%----------------------------------------------------------------------------
\chapter{実験}
\label{chapter_4}
%----------------------------------------------------------------------------
また最適な正則化パラメータは，20foldの交差検証\citep{islp}で探索した．
実装には，sklearn.linear\_model.LassoCV\cite{scikit-learn}を用いた．

モデルが予測した犯罪発生リスクを，
高リスク（$平均+1標準偏差以上$）と低リスク（$平均+1標準偏差未満$）にカテゴリー化する．
各手法の予測精度は，犯罪予測の文脈で一般的な
的中率\citep{joshi2020considerationsdevelopingpredictivemodels}と
PAI（Predictive Accuracy Index）\citep{chainey2008utility}と
ROC-AUC\citep{islp}の3つの指標で年単位の評価を行う．

的中率とは，予測モデルが「高リスク」と特定したエリアの中で、実際に犯罪が発生した割合である．
(\ref{hitrate})式に的中率の計算式を示す．

\begin{equation}\label{hitrate}
  的中率=\frac{高リスクと予測されたエリア内で実際に発生した犯罪の数}{実際に発生した犯罪の総数}
\end{equation}

的中率では，低リスクエリアを高リスクエリアと誤識別する偽陽性（False Positive）を
評価できない．そのため的中率を最大とするモデルは，
高リスクエリアが広がりすぎて実用上の有用性が下がる可能性があるため，
これに加えて\citet{chainey2008utility}が考案したPAI（Predictive Accuracy Index）を評価に用いる．

%------------------------------------
%   Chapter 5
\chapter{おわりに}
%------------------------------------
あ．

%------------------------------------
%   Acknowledgements
\chapter*{謝辞}
%------------------------------------
\addcontentsline{toc}{chapter}{謝辞}
あ．

%------------------------------------
%   References
%------------------------------------
\bibliography{main} %hoge.bibから拡張子を外した名前
\bibliographystyle{plainnat} %参考文献出力スタイル
%------------------------------------
% \appendix
%------------------------------------

%------------------------------------
\end{document}
%------------------------------------
