%------------------------------------
%   basic settings
%------------------------------------
\documentclass[12pt,a4paper,oneside]{jsbook}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[dvipdfmx]{graphicx}
\usepackage{url}
\usepackage{here}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[ipaex]{pxchfon}
\usepackage{otf}
\usepackage{listings}
\usepackage[square, numbers]{natbib}
\usepackage{booktabs}
\usepackage{float} 
\usepackage{placeins}
% \usepackage{graphics}
\usepackage[dvipdfmx]{graphicx} % includegraphicsを使うためのパッケージを読み込む
% \usepackage{natbib}

% \bibpunct[:]{(}{)}{,}{a}{}{,}
%------------------------------------
%   listings settings (minted -> listings)
%------------------------------------
\lstset{
  basicstyle=\ttfamily\small,  % Font style
  numbers=left,                % Add line numbers
  numberstyle=\tiny,           % Line number style
  stepnumber=1,                % Line number increment
  frame=single,                % Add a frame around the code
  tabsize=4,                   % Tab size
  breaklines=true,             % Allow line breaking
  keywordstyle=\bfseries,      % Keywords in bold
  commentstyle=\itshape,       % Comments in italics
  stringstyle=\color{red},     % Strings in red
  showspaces=false,            % Do not mark spaces
  showstringspaces=false,      % Do not mark string spaces
  language=Python              % Default language
}

%------------------------------------
%   margin settings
%------------------------------------
\setlength{\topmargin}{-5mm}
\setlength{\fullwidth}{125mm}
\setlength{\textwidth}{\fullwidth}
\setlength{\oddsidemargin}{5mm}
\setlength{\evensidemargin}{\oddsidemargin}
%------------------------------------
%   newtheorems
%------------------------------------
\theoremstyle{plain}
\newtheorem{theorem}{定理}[chapter]
\newtheorem{corollary}[theorem]{系}
\newtheorem{lemma}[theorem]{補題}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{conjecture}[theorem]{予想}
\newtheorem{proposition}[theorem]{命題}
\newtheorem{problem}[theorem]{問題}
\newtheorem{definition}[theorem]{定義}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{claim}{Claim}
\newtheorem{subclaim}{Subclaim}[claim]
\newcommand{\resetclaim}{\setcounter{claim}{0}}
\newtheorem{case}{Case}
\newtheorem{subcase}{Subcase}[case]
\newcommand{\resetcase}{\setcounter{case}{0}}
\providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}
%------------------------------------
%   display figures
%   #1=width, #2=filename,
%   #3=caption, #4=label
%   \fig{0.8\linewidth}{aaa.pdf}{bbb}{ccc}
%------------------------------------
\renewcommand{\figurename}{図.}
\newcommand{\fig}[4]{
\begin{figure}[H]
\centering
\includegraphics[width=#1]{#2}
\caption{#3}
\label{#4}
\end{figure}
}
\newcommand{\figg}[4]{
\begin{figure*}[h!t]
\centering
\includegraphics[width=#1]{#2}
\caption{#3}
\label{#4}
\end{figure*}
}
%------------------------------------
%   setting of algorithms
%------------------------------------
\renewcommand{\algorithmicrequire}{\textbf{条件:}}
\renewcommand{\algorithmicensure}{\textbf{実行結果:}}
\algrenewcommand\algorithmicdo{}
\algrenewcommand\algorithmicthen{}
%------------------------------------
%   other renewcommands and newcommands
%------------------------------------
\renewcommand{\proofname}{\bf 証明.}
%------------------------------------
%   Title & Authors
%------------------------------------
\title{
卒業論文\\[1.5cm]
LLMによるソフトウェア脆弱性の検出\\[6cm]
}
\author{高知大学 理工学部 情報科学科\\[0.5cm]
B223R030P 横川武典}
\date{2025年度}

%------------------------------------
\begin{document}
%------------------------------------
%タイトルページの出力
\maketitle
%目次の作成・出力
\tableofcontents

%----------------------------------------------------------------------------
%   Chapter 1
\chapter{はじめに}
\label{chapter_1}
%----------------------------------------------------------------------------
\section{背景}
%------------------------------------
．

%----------------------------------------------------------------------------
\chapter{関連研究}
\label{chapter_2}
%----------------------------------------------------------------------------
本章では，本研究で提案する手法の妥当性を示すため，
既存のソフトウェア脆弱性検出手法および
大規模言語モデル（LLM）を用いた関連研究を整理し，
それらの課題を明確化する．
まず，従来のソフトウェア脆弱性検出手法について概観し，
その限界を明らかにする．
次に，大規模言語モデル（LLM）の概要と，
セキュリティ分野への応用例について述べる．
その後，LLMを用いた脆弱性検出に関する先行研究を整理し，
Retrieval-Augmented Generation（RAG）や
ファインチューニングといった代表的手法について説明する．
最後に，評価指標および既存研究の課題をまとめ，
本研究の位置づけを明確にする．


%------------------------------------
\section{従来のソフトウェア脆弱性検出}
%------------------------------------
ソフトウェアの脆弱性検出手法は，
大きく静的解析と動的解析に分類される \cite{chess_mcgraw}.
静的解析は，プログラムを実行せずにソースコードやバイナリを解析する手法であり，
代表的なものとしてデータフロー解析やルールベース解析が挙げられる．
静的解析の代表例としては，Lint系ツールや商用のSAST
（Static Application Security Testing）ツールなどが広く利用されている．
Lint系ツールは，
主にコーディング規約や単純な構文規則に基づいて
潜在的な不具合を検出する静的解析ツールであり，
SASTツールは，
より高度なデータフロー解析や制御フロー解析を用いて
脆弱性の検出を行う．
静的解析は網羅的な検査が可能である一方，実行時の文脈を考慮できないため
誤検知（False Positive）が多いという課題がある．

一方，動的解析はプログラムを実際に実行し，
その挙動を監視することで脆弱性を検出する手法である．
ファジングや実行時モニタリングなどが代表例であり，
AFL（American Fuzzy Lop）に代表されるファジング手法は，実際に悪用可能な脆弱性を検出できる利点を有する．
しかし，実行パスに依存するため，すべての脆弱性を網羅的に検出することは困難である．

近年では，静的解析と動的解析を組み合わせた
ハイブリッド解析手法も提案されており，
両者の欠点を補完するアプローチとして注目されている．
しかし，解析コストの増大や運用の複雑化といった課題も残されている．

これらの従来手法は，既既知の脆弱性パターンに基づく検出には有効である一方で，
コードの文脈理解や実装意図の推定といった点に限界がある．
このような課題を背景として，
自然言語およびソースコードの文脈を同時に扱える
LLMを活用した手法が注目されている．

%------------------------------------
\section{Large Language Model（LLM）}
%------------------------------------
大規模言語モデル（Large Language Model: LLM）は，大量のテキストデータを用いて事前学習された
深層学習モデルであり，自然言語処理分野において高い性能を示している．
近年では，Transformer構造を基盤としたモデルが主流となっており，
自己注意機構によって文脈情報を効果的に捉えることが可能である．\cite{transformers}

Transformerにおける自己注意機構では，
入力系列の各トークンに対して
クエリ（Query），キー（Key），バリュー（Value）と呼ばれる
3種類のベクトル表現を線形変換によって生成する．
これらを用いて，あるトークンが
他のトークンとどの程度関連しているかを
内積演算によって算出し，
以下の式で注意重みを計算する．
\begin{equation}
\mathrm{Attention}(Q, K, V)
= \mathrm{softmax}\left(\frac{QK^{\top}}{\sqrt{d_k}}\right)V
\end{equation}
ここで，$d_k$はキーの次元数であり，
スケーリング項として用いられる．
この機構により，系列内の任意の位置にあるトークン同士の関係を
距離に依存せずに捉えることが可能となる．
また，複数の注意機構を並列に用いる
マルチヘッドアテンションにより，
異なる観点からの依存関係を同時に学習できる．
このようなTransformerの構造により，
LLMは長距離依存関係や文脈情報を効果的に表現でき，
従来のRNN（Recurrent Neural Network）系モデルと比較して
高い表現能力を有することが広く報告されている．\cite{transformers}

さらに，近年のLLMは自然言語だけでなくソースコードを含むデータで学習されており，
プログラムの構文構造や意味的関係を一定程度理解できることが報告されている．
CodeBERT\cite{codebert}やGraphCodeBERT\cite{graphcodebert}などのLLMは，
コードと自然言語の対応関係を学習することで，
プログラム理解タスクにおいて高い性能を示している\cite{llminsoftwaresecurity}．

このような特性から，LLMは単なる自然言語処理モデルにとどまらず，
ソフトウェア解析やセキュリティ分野への応用が期待されている．
次節では，セキュリティ分野におけるLLMの具体的な活用事例について述べる．

%------------------------------------
\section{セキュリティ分野とLLMの関連性および応用}
%------------------------------------
近年，LLMは自然言語処理分野にとどまらず，
サイバーセキュリティ分野においても幅広い応用が進んでいる．
LLMが脆弱性検出，マルウェア解析，ネットワーク侵入検知，フィッシング検出など，
多様なサイバーセキュリティタスクに適用されていることが報告されている\cite{llmcyber}．
このことから，LLMは特定用途に限定された技術ではなく，
セキュリティ分野全体に横断的に利用可能な基盤技術として位置づけられている．

一方で，LLMが生成した成果物そのものが新たなセキュリティリスクとなり得る点も指摘されている．
一部の研究では，LLMが生成したWeb言語向けJavaScriptコードを分析した結果，
24.5\%のコードにおいてセッションタイムアウトの欠如やHTTPセキュリティヘッダーの不足といった
不適切な実装が確認されたと報告されている\cite{hiddenriskllmgeneratedweb}．
この知見は，LLMの出力結果を無条件に信頼することの危険性を示している．

このように，セキュリティ分野におけるLLMの活用は，
防御・検出を支援する側面と，
新たな脆弱性を生み出す可能性という
両義的な性質を有している．
そのため，LLMとセキュリティの関係を論じる上では，
応用可能性だけでなく，
生成結果の検証やリスク評価を含めた
包括的な視点が不可欠である．

%------------------------------------
\section{LLMを用いた脆弱性検出の先行研究}
%------------------------------------
LLMを用いた脆弱性検出に関する先行研究では，
主にCやC++といった低レベル言語を対象としたものが多い．
これらの研究では，ソースコードを入力とし，
脆弱性の有無や種類を分類問題として扱う手法が主に提案されている．
特に，バッファオーバーフローやメモリ破壊といった脆弱性を対象とし，
LLMがコードの文脈情報を活用することで
従来手法よりも高い検出性能を示す可能性が報告されている．

近年では，脆弱性情報が頻繁に更新されるセキュリティ分野の特性を踏まえ，
外部知識ベースを活用する手法を組み合わせた研究も提案されている．
これらの研究では，CWE（Common Weakness Enumeration）やCVE（Common Vulnerabilities and Exposures）
といった既存の知識ベースを参照することで，
脆弱性検出やその説明の精度向上を図っている．

%------------------------------------
\section{埋め込みモデルと類似度検索}
%------------------------------------
近年，情報検索や質問応答，および
Retrieval-Augmented Generation（RAG）といった手法において，
テキストを数値ベクトルとして表現する
埋め込み（Embedding）モデルが広く利用されている．
埋め込みモデルは，
入力されたテキストを高次元の実数ベクトル空間へ写像することで，
意味的な近さを数値的に比較可能にする．
このような分散表現に基づく意味検索は，
Sentence-BERT（SBERT）\cite{reimers2019sentencebert}
以降，多くの応用分野で用いられている．

一般に，埋め込みモデルは，
文や段落，あるいはソースコードといった
可変長の入力 $x$ を，
$d$ 次元のベクトル
$\mathbf{v} \in \mathbb{R}^d$
へ変換する写像
$f(\cdot)$ として定式化できる．
すなわち，
\begin{equation}
\mathbf{v} = f(x)
\end{equation}
である．
このとき，
意味的に類似したテキスト同士は，
ベクトル空間上でも近接するように学習される．

埋め込みベクトル間の類似度を測る指標としては，
コサイン類似度（Cosine Similarity）が一般的に用いられる．
二つのベクトル
$\mathbf{v}_1, \mathbf{v}_2 \in \mathbb{R}^d$
に対するコサイン類似度は，
次式で定義される．
\begin{equation}
\mathrm{sim}(\mathbf{v}_1, \mathbf{v}_2)
=
\frac{\mathbf{v}_1 \cdot \mathbf{v}_2}
{\lVert \mathbf{v}_1 \rVert \, \lVert \mathbf{v}_2 \rVert}
\end{equation}
この値は $-1$ から $1$ の範囲を取り，
値が大きいほど
二つのテキストが意味的に類似していることを示す．

類似度検索では，
あらかじめ知識ベース内の文書群
$\{x_1, x_2, \dots, x_n\}$
を埋め込みモデルによってベクトル化し，
クエリとなる入力 $q$ に対する埋め込み
$\mathbf{v}_q = f(q)$
との類似度を計算する．
その上で，
類似度が高い上位 $k$ 件の文書を検索結果として取得する．
このような密ベクトル検索の枠組みは，
Dense Passage Retrieval（DPR）\cite{karpukhin2020dense}
などにより体系化され，
RAGにおける検索機構の基盤技術となっている．

近年では，
多言語対応かつ汎用的な意味表現を獲得可能な
埋め込みモデルが多数提案されている．
その一例として，
e5-multilingual\cite{e5} は，
検索タスク向けに弱教師あり対照学習を用いて事前学習されたモデルであり，
クエリと文書の意味的対応関係を
高精度に捉えることが可能である．
自然言語を主対象としつつも，
技術文書やプログラムコードといった
専門的テキストに対しても
一定の有効性が報告されている．

本研究においては，
RAG構成における検索段階において
埋め込みモデルを用いた類似度検索を採用する．
具体的には，
解析対象のPHPコードまたはその一部をクエリとして埋め込み，
脆弱性に関する知識ベース内の文書を検索することで，
LLMが参照すべき関連情報を取得する．
このように，
埋め込みモデルと類似度検索は，
RAGにおける情報検索機構の基盤技術として
重要な役割を果たしている．

%------------------------------------
\section{Retrieval-Augmented Generation（RAG）}
%------------------------------------
Retrieval-Augmented Generation（RAG）は，
LLMによる生成時に，
外部の知識ベースから関連情報を検索し，
その結果を入力として利用することで，
生成性能の向上を図る手法である．
この枠組みにより，
モデル内部のパラメータに含まれない知識を
動的に参照することが可能となり，
事実性の向上やハルシネーションの抑制が期待されている\cite{rag}．

RAGは，
生成結果 $y$ を，
入力 $x$ および検索された文書集合 $z$ に条件づけた確率として
以下のように定式化できる．
\begin{equation}
p(y|x) = \sum_{z \in \mathcal{Z}} p(y|x,z)p(z|x)
\end{equation}
ここで，
$p(z|x)$ は入力 $x$ に基づいて
関連文書 $z$ を検索する確率分布を表し，
$p(y|x,z)$ は，
検索結果を条件として生成を行う
言語モデルの確率分布を表す．
このような確率モデルは，
Retrieval-Augmented Generation の原論文において
提案・定式化された枠組みに基づいている\cite{rag}．

セキュリティ分野においては，
CWEやCVEといった脆弱性知識ベースを
RAGによって参照することで，
脆弱性の検出や説明生成の精度を向上させる試みが報告されている．
特に，
コード片と既知の脆弱性パターンとの対応関係を
明示的に参照できる点は，
モデルの解釈性向上という観点からも有用である．

一方で，
RAGの性能は検索結果の品質に大きく依存しており，
不適切な文書が取得された場合には，
生成結果の誤りやノイズの増加につながる可能性がある．
そのため，
検索手法や知識ベースの設計が，
RAG全体の性能を左右する重要な要素となる．

%------------------------------------
\section{ファインチューニング（Fine-Tuning）}
%------------------------------------
ファインチューニング（Fine-Tuning）とは，
大規模コーパスを用いて事前学習されたモデルに対し，
特定タスクのデータを用いて追加学習を行うことで，
タスク固有の特徴に適応させる手法である．
この考え方は，深層ニューラルネットワークにおける
表現学習の枠組みに基づいており，
事前学習によって獲得された汎用的な中間表現を，
下流タスクに最適化する過程として位置づけられる．

Hintonらは，自己符号化器を用いた研究において，
高次元データから有用な低次元表現を事前に学習し，
その後のタスク適応によって性能が向上することを示している
\cite{hinton2006reducing}．
このような段階的学習の考え方は，
現在のLLMにおける事前学習とファインチューニングの関係と
本質的に共通している．

また，Uesakaらは，
複数の異なる特徴量（ビュー）を統合するマルチビュー学習において，
ビュー間で共有される表現と，各ビュー固有の表現を同時に学習することで，
診断性能を向上させている\cite{uesaka2017multi_view}．
このような考え方は，
汎用的な表現を基盤としつつ，
特定の対象や条件に応じた情報を付加的に学習するという点で，
事前学習モデルに対するファインチューニングの概念と
類似した構造を持つと解釈できる．

ソフトウェア脆弱性検出分野においては，
脆弱なコードと安全なコードを用いた教師あり学習により，
特定の脆弱性パターンに対する識別性能が向上することが報告されている
\cite{devigneffectivesearchvulnerability}．
一方で，ファインチューニングには
大量のラベル付きデータを必要とする点や，
学習データに強く依存したバイアスが生じやすい点などの課題も存在し，
汎化性能の低下を招く可能性が指摘されている．

%------------------------------------
\section{評価指標およびベンチマーク}
%------------------------------------
脆弱性検出手法の評価には，
Precision，Recall，F1-scoreといった指標が一般的に用いられる．
これらの指標は，検出結果を
真陽性（True Positive: TP），
偽陽性（False Positive: FP），
偽陰性（False Negative: FN）
に基づいて定義される．

Precisionは，検出された脆弱性のうち，実際に正しいものの割合を表す指標であり，
次式で定義される．
\begin{equation}
\mathrm{Precision} = \frac{TP}{TP + FP}
\end{equation}
Precisionが低い場合，誤検知が多く発生していることを意味し，
実運用においては解析コストの増大や運用負荷の増加につながる．
そのため，脆弱性検出タスクではPrecisionの高さが重要視される．

一方，Recallは，実際に存在する脆弱性のうち，正しく検出できた割合を表す指標であり，
次式で定義される．
\begin{equation}
\mathrm{Recall} = \frac{TP}{TP + FN}
\end{equation}
Recallが低い場合，脆弱性の見逃しが多いことを意味し，
セキュリティ上の重大なリスクにつながる可能性がある．
そのため，PrecisionだけでなくRecallとのバランスが重要である．

F1-scoreは，PrecisionとRecallの調和平均として定義され，
両者のバランスを総合的に評価する指標である．
\begin{equation}
\mathrm{F1\text{-}score} = 
\frac{2 \cdot \mathrm{Precision} \cdot \mathrm{Recall}}
{\mathrm{Precision} + \mathrm{Recall}}
\end{equation}
F1-scoreは，PrecisionとRecallのいずれか一方が極端に低い場合に値が低下するため，
両指標を同時に考慮した評価が可能となる．

なお，単一の評価指標のみで手法の有効性を判断することは難しく，
複数の指標を組み合わせて総合的に評価する必要がある．
特に，脆弱性検出のようにクラス不均衡が大きいタスクでは，
Accuracyのみでは実際の性能を適切に評価できない点に注意が必要である．

本研究においても，
PHPプログラムを対象とした脆弱性検出性能を評価するため，
これらの指標を用いて定量的な比較を行う．

%------------------------------------
\section{既存研究の課題と本研究の位置づけ}
%------------------------------------
以上のように，LLMを用いた脆弱性検出に関する研究は一定の成果を上げているが，
その多くはC/C++を対象とし，
バッファオーバーフローなどのメモリ管理に起因する脆弱性の検出に焦点を当てている．
この背景には，既存のベンチマークデータセットや先行研究の多くが，
低レベル言語を対象として構築されてきたという事情がある．

一方で，Web言語として広く利用されているPHPなどにおいては，
クロスサイトスクリプティング（XSS）やSQLインジェクションといった，
言語仕様や実行環境に依存した脆弱性が多数存在するにもかかわらず，
LLMを用いた包括的に扱った研究は依然として限定的である．
また，既存研究では特定の脆弱性クラスに偏った評価が多く，
検出可能な脆弱性の多様性という観点での分析も限定的である．

そこで本研究では，
Web言語であるPHPを対象としたLLMによる脆弱性検出の可能性を検討する．
さらに，メモリ関連脆弱性に限定せず複数の脆弱性種別を対象とすることで，
LLMが多様な脆弱性パターンをどの程度識別可能であるかを明らかにすることを目的とする．
Web言語特有の脆弱性を対象とし，
LLMを用いて複数種別の脆弱性を統一的に扱う点において，
既存研究とは異なる位置づけを持つ．

%----------------------------------------------------------------------------
\chapter{提案手法}
\label{chapter_3}
%----------------------------------------------------------------------------
本章では，本研究において提案する
LLMを用いたPHPプログラムの脆弱性検出手法について述べる．
第2章で整理した関連研究より，
既存の脆弱性検出手法は
C/C++を対象としたメモリ関連脆弱性に重点が置かれており，
Webアプリケーションで広く利用されている
PHPなどのスクリプト言語に特有の脆弱性を
包括的に扱う研究は十分とは言えないことが明らかとなった．

このような背景を踏まえ，本研究では
LLMのコード理解能力を活用し，
PHPコードを対象とした脆弱性検出を行う手法を提案する．
特に，本研究では単一のLLM構成に依存するのではなく，
LLMの活用形態の違いが
脆弱性検出性能に与える影響を比較・評価することを目的とする．

本章ではまず，本研究の概要および設計方針を示し，
続いて対象とする脆弱性および分析対象について説明する．
その後，提案手法の全体構成，
LLMによるコード解析手法，
知識ベースの活用方法，
ならびに出力形式と判定方法について詳述し，
最後に実装上の留意点について述べる．
%------------------------------------
\section{本研究の概要}
%------------------------------------
本研究の目的は，
Webアプリケーション開発で広く利用されているPHPを対象として，
LLMを用いた脆弱性検出手法を構築し，
その有効性を検証することである．
特に，従来研究では十分に検討されてこなかった
Web言語特有の脆弱性に着目し，
LLMの自然言語理解能力およびコード理解能力を活用することで，
実用的かつ拡張性の高い検出手法の実現を目指す．

本研究では，
LLMの活用形態として以下の三つの構成を採用する．
\begin{itemize}
  \item 事前学習済み言語モデルをそのまま用いる構成（以下，素のLLM）
  \item 脆弱性データセットを用いてFine-Tuningを行った構成
  \item 素のLLMに対して知識ベースを接続したRAG構成
\end{itemize}
これら三構成を同一条件下で比較することで，
学習による知識獲得と，
外部知識の参照という
異なるアプローチの特性を明らかにする．

また，本研究では検出結果を
「脆弱性の種類」「想定されるリスク」「修正案」
といった形式で出力することで，
開発者が結果を理解しやすく，
実際の修正作業に活用しやすいことを重視している．
これにより，LLMを単なる分類器として用いるのではなく，
脆弱性分析を支援するツールとして位置付ける点に
本研究の特徴がある．

%------------------------------------
\section{設計方針}
%------------------------------------
第2章で述べた関連研究の整理より，
従来の脆弱性検出手法には
対象言語の偏りや，
検出対象の限定性といった課題が存在することが明らかとなった．
本研究では，これらの課題に対応するため，
以下の設計方針に基づいて提案手法を構築する．

まず，対象言語としてPHPを採用し，
Webアプリケーションにおいて頻発する
入力処理や外部データの取り扱いに起因する脆弱性を
重点的に扱うこととした．
これにより，
Web言語特有の脆弱性に対する
検出性能を評価可能な枠組みを構築する．

次に，解析手法としてLLMを中核に据え，
静的解析やルールベース手法では対応が困難であった
多様なコーディングスタイルや
文脈依存の脆弱性に対応することを目指す．

さらに，本研究では
LLMの活用形態の違いに着目し，
素のLLM，Fine-Tuning済みLLM，RAG構成の
三つの構成を比較対象とする．
この際，入力コード，プロンプト形式，
および出力形式を統一することで，
モデル構成以外の要因が
検出結果に影響を与えないよう設計した．

%------------------------------------
\section{対象脆弱性および分析対象}
%------------------------------------
本節では，本研究で対象とする脆弱性の種類および
分析対象とするプログラムの範囲について説明する．

%------------------------------------
\subsection{対象脆弱性}
%------------------------------------
本研究では，Webアプリケーションにおいて
発生頻度が高く，
かつ実害につながりやすい脆弱性を主な対象とする．
具体的には，以下の脆弱性を扱う．
\begin{itemize}
  \item クロスサイトスクリプティング（XSS）
  \item クロスサイトリクエストフォージェリ（CSRF）
  \item セッション管理の不備（セッション固定化，ハイジャック等）
  \item SQLインジェクション
\end{itemize}

これらの脆弱性は，
ユーザ入力の検証不足や
不適切なデータ処理に起因することが多く，
コードの文脈や処理の流れを考慮した解析が求められる．
そのため，LLMによる解析が有効であると考えられる．

%------------------------------------
\subsection{分析対象プログラム}
%------------------------------------
分析対象としては，
PHPで記述されたサーバサイドプログラムを対象とする．
関数定義，条件分岐，
データベースアクセス，
外部入力処理などを解析対象とし，
フレームワーク固有の機構や
実行環境依存の設定については考慮しない．

%------------------------------------
\section{提案手法の全体構成}
%------------------------------------
% 手法の全体のフローを作成する
%------------------------------------
提案手法の全体構成を図\ref{fig:system_overview}に示す．
本手法は，
入力となるPHPソースコード，
LLMによる解析処理，
および検出結果の出力から構成される．

解析対象のPHPコードは，
ファイル単位で前処理を施した後，
LLMへの入力として与えられる．
LLMはコードの構造や処理内容を解析し，
脆弱性の有無および種類を判定する．

RAG構成では，
解析対象コードに関連する脆弱性知識を
知識ベースから検索し，
その内容をプロンプトに付加した上で
LLMによる解析を行う．
これにより，
LLMはコード単体の情報だけでなく，
外部知識を参照した判断を行うことが可能となる．

%------------------------------------
\section{LLMによるコード解析手法}
%------------------------------------
本研究では，
LLMによるコード解析手法として，
以下の三種類の構成を用いる．

素のLLM構成では，
事前学習済みの言語モデルに対して
PHPコードと解析指示を直接入力し，
脆弱性の有無および種類を出力させる．
この構成は追加学習を必要としないため，
導入が容易である一方，
専門知識の不足による誤検出が生じる可能性がある．

Fine-Tuning構成では，
脆弱性データセットを用いて
事前学習済みモデルを微調整し，
Webアプリケーション脆弱性に関する知識を
モデル内部に獲得させる．
これにより，
特定の脆弱性パターンに対する
検出精度の向上が期待される．

RAG構成では，
LLM自体は素のLLMと同一のモデルを用い，
解析時に外部知識ベースを検索・参照する．
これにより，
モデルを再学習することなく，
最新かつ体系化された知識を
解析に反映可能とする．


%------------------------------------
\section{知識ベースの活用方法}
%------------------------------------
本研究では，
LLMによる脆弱性検出の精度および一貫性を向上させるため，
脆弱性に関する知識を体系的に整理した
知識ベースを構築し，これを解析に活用する．
知識ベースには，
各脆弱性の発生条件，
代表的な脆弱コード例，
安全な実装例，
および修正方針に関する情報を含める．

RAG構成においては，
解析対象となるPHPコード，
もしくはその一部をクエリとして用い，
知識ベース内の文書から
関連性の高い情報を検索する．
この検索処理には，
第2章で述べた埋め込みモデルと類似度検索を用い，
入力コードと意味的に近い知識文書を抽出する．

検索によって得られた知識は，
そのまま出力として用いるのではなく，
LLMへの入力プロンプトに付加情報として与えられる．
これにより，
LLMはコード単体の解析結果に加えて，
脆弱性に関する明示的な知識を参照しながら
判断を行うことが可能となる．

このような構成により，
Fine-Tuningを行わない場合であっても，
外部知識の更新や拡張が容易となり，
新たな脆弱性情報への追従性を確保できる．
また，
モデル内部に知識を固定的に保持させる
Fine-Tuning構成との比較を通じて，
知識付与手法の違いが
脆弱性検出性能に与える影響を
評価可能な設計となっている．

%------------------------------------
\section{出力形式および判定方法}
%------------------------------------
LLMの出力は，
脆弱性の種類，
リスクの説明，
修正案の三要素から構成される．

また，本研究では，
LLMの出力結果に対して
以下の基準に基づき判定を行う．

まず，脆弱性の有無については，
対象コードに対して
正解データとして付与された
脆弱性ラベルと比較し，
一致した場合を正検出とする．

次に，脆弱性の種類については，
出力された脆弱性分類が
正解ラベルと一致しているかどうかを判定する．
複数の脆弱性が存在する場合には，
いずれか一つでも正しく指摘されていれば
検出成功とみなす．

本研究では，
脆弱性の有無および種類の判定を
定量評価の対象とし，
リスク説明および修正案については
補助的な定性評価として扱う．

一方で，
存在しない脆弱性を指摘した場合は
過検出（False Positive）として扱う．
これらの判定結果に基づき，
第4章において
各構成の検出性能を定量的に評価する．


%------------------------------------
\section{実装上の留意点}
%------------------------------------
実装にあたっては，
LLM構成間の比較を公平に行うため，
プロンプトの指示内容および
出力形式をすべての構成で統一した．

また，
長大なPHPコードを解析する場合に備え，
入力長制限を考慮し，
ファイル単位で解析を行う設計とした．

これらの工夫により，
モデル構成以外の要因が
検出結果に影響を与えないよう配慮した．

%----------------------------------------------------------------------------
\chapter{実験設定と評価方法}
\label{chapter_4}
%----------------------------------------------------------------------------
本章では，第3章で提案したLLMを用いた脆弱性解析手法の有効性を検証するため，
実験設定および評価方法について述べる．
提案手法の妥当性を定量的に評価するため，
複数のLLM構成を同一条件下で比較する実験を実施する．

本研究では，汎用的なLLM，Fine-Tuningを施したLLM，
および知識ベースを併用するRAG構成LLMを対象とし，
同一のPHPプログラム群に対して脆弱性検出を行う．
本章では，実験の目的，使用データセット，
実験対象モデル，実験手順，評価指標，
および実験条件の公平性について順に説明する．

%------------------------------------
\section{実験の目的}
%------------------------------------
本研究における実験の目的は，第3章で提案した脆弱性解析手法の有効性を検証することである．
特に，LLM単体による解析能力の限界を明らかにするとともに，
Fine-TuningおよびRAG構成が脆弱性検出性能に与える影響を評価する．

これにより，
Webアプリケーション脆弱性解析において，
学習による知識獲得と
外部知識参照という
異なるアプローチの有効性を
定量的に比較・検討することを目的とする．

%------------------------------------
\section{使用データセット}
%------------------------------------
本研究では，
Fine-Tuning用データセットと
RAG用知識ベースを
異なる情報源から構築し，
それぞれ異なる目的で使用する．

Fine-Tuning用データセットには，
JVN（Japan Vulnerability Notes）および
CVEに公開されている
脆弱性情報を基に，
PHPに関連する脆弱性事例をクローリングして収集した．
これらのデータには，
脆弱性の概要，
影響を受けるコードの特徴，
および想定される脆弱性種別が含まれており，
Fine-Tuningにより
モデル内部に脆弱性知識を獲得させることを目的とする．

一方，
RAG構成で使用する知識ベースには，
RuleSonar において公開されている
脆弱なコード記法や検出ルール，
および修正指針に関する情報を収集した．
これらの情報は，
脆弱性の発生条件や
安全な実装との対比を含んでおり，
LLMによるリスク説明および修正案生成を支援するために用いられる．

なお，
評価対象とするPHPプログラムは，
Fine-Tuning用データおよび
RAG用知識ベースのいずれにも含めないことで，
情報漏洩を防止し，
評価の公平性を確保している．

%------------------------------------
\section{実験対象モデル}
%------------------------------------
本研究では，基礎モデルとして
\texttt{unsloth/qwen3-14b} を使用する．
以下に，各構成について説明する．

%------------------------------------
\subsection{素のLLM}
%------------------------------------
素のLLMでは，
事前学習済みモデルをそのまま用い，
追加学習や外部知識の参照を行わない．
この構成は，
LLM本来の汎化能力を評価するための
ベースラインとして位置付ける．

%------------------------------------
\subsection{Fine-Tuning済みLLM}
%------------------------------------
Fine-Tuning構成では，
JVNおよびCVEから収集した
PHP脆弱性データセットを用いて，
基礎モデルに対する追加学習を行う．
これにより，
モデル内部に
Webアプリケーション脆弱性に関する知識を直接獲得させ，
脆弱性種別の識別性能向上を図る．

%------------------------------------
\subsection{RAG構成LLM}
%------------------------------------
RAG構成では，
LLM自体は素のLLMと同一のモデルを用い，
解析時に外部知識ベースを検索・参照する．
入力されたPHPコードを埋め込み空間に写像し，
知識ベース内の文書との類似度に基づいて
関連情報を検索し，
その結果をプロンプトに付加する．

この類似度検索には，
埋め込みモデルとして
\texttt{e5-multilingual}\cite{e5}
を使用する．
\texttt{e5-multilingual}は，
検索タスク向けに事前学習された
多言語対応の埋め込みモデルであり，
クエリと文書の意味的対応関係を
高精度に捉えることが可能である．

%------------------------------------
\section{実験手順}
%------------------------------------
実験は以下の手順で実施する．

\begin{enumerate}
  \item 対象プログラムをLLMに入力する
  \item 定義したプロンプトに基づき，脆弱性の有無および種類を出力させる
  \item 出力結果を保存し，正解ラベルと比較する
\end{enumerate}

なお，LLMの非決定性による影響を低減するため，
同一条件で複数回実行し，その結果を集計する．

%------------------------------------
\section{評価指標}
%------------------------------------
本研究では，
第2章で述べた評価指標に基づき，
脆弱性検出性能を定量的に評価する．
具体的には，
Precision，Recall，F1-scoreを用い，
各LLM構成の検出性能を比較する．

また，
数値指標に加えて，
出力されたリスク説明および修正案の妥当性についても，
定性的な評価を行う．

%------------------------------------
\section{実験条件の統一と公平性}
%------------------------------------
本研究では，
異なるLLM構成間で脆弱性検出性能を比較するため，
可能な限り実験条件を統一した．

入力として与えるPHPコード，
評価対象とする脆弱性ラベル，
および最終的な出力形式
（脆弱性の種類，リスク説明，修正案）は，
すべての構成において共通とした．

一方で，
RAG構成においては，
脆弱性診断の過程において
以下の中間処理が追加される点で，
他の構成と処理フローが異なる．

\begin{enumerate}
  \item LLMによる脆弱性の有無および種類の判定
  \item 判定結果および入力コードに基づく
        関連知識文書の検索
  \item 検索結果を付加した上での
        リスク説明および修正案の生成
\end{enumerate}

この中間処理は，
外部知識を活用した説明生成を目的としたものであり，
脆弱性の有無そのものの判定基準には
直接影響しないよう設計している．

評価においては，
最初の脆弱性判定結果のみを
正解ラベルと比較することで，
処理段階数の違いが
検出性能評価に影響を与えないよう配慮した．

%----------------------------------------------------------------------------
\chapter{実験結果と考察}
\label{chapter_5}
%----------------------------------------------------------------------------
本章では，第4章で述べた実験設定および評価方法に基づき実施した
脆弱性検出実験の結果を示し，提案手法の有効性について考察を行う．
まず，各手法における検出性能を定量的に比較し，
次に脆弱性種別ごとの検出傾向や誤検知の分析を行う．
さらに，Fine-TuningおよびRAGを用いた手法の特性を比較し，
最後に本手法の有効性と限界について議論する．

%------------------------------------
\section{検出性能の比較結果}
%------------------------------------
% 表を作ること
%------------------------------------
本節では，素のLLM，Fine-Tuning済みLLM，およびRAG構成LLMの
脆弱性検出性能を比較する．
評価指標としては，第4章で述べたPrecision，Recall，F1-scoreを用いる．

表\ref{tab:overall_performance}に，各手法の全体的な検出性能を示す．
結果から，素のLLMと比較して，
Fine-TuningおよびRAGを導入したモデルでは



\begin{table}[t]
\centering
\caption{各手法の検出性能比較}
\label{tab:overall_performance}
\begin{tabular}{lccc}
\hline
手法 & Precision & Recall & F1-score \\
\hline
素のLLM & -- & -- & -- \\
Fine-Tuning済みLLM & -- & -- & -- \\
RAG構成LLM & -- & -- & -- \\
\hline
\end{tabular}
\end{table}

%------------------------------------
\section{脆弱性種別ごとの検出傾向}
%------------------------------------
本節では，脆弱性種別ごとの検出性能の違いについて分析する．
対象とした脆弱性は，SQLインジェクション，XSS，CSRFなど，
Webアプリケーションで頻出するものとした．

Fine-Tuning済みLLMでは，

一方で，RAG構成LLMでは，

%------------------------------------
\section{誤検知の分析}
%------------------------------------
本節では，各手法における誤検知（False Positive）の傾向を分析する．


素のLLMでは，

Fine-Tuning済みLLMでは，

一方，RAG構成LLMでは，

%------------------------------------
\section{Fine-TuningとRAGの比較考察}
%------------------------------------
本節では，Fine-TuningとRAGの特性を比較し，
それぞれの利点と欠点について考察する．

Fine-Tuningは，

RAGは，

%------------------------------------
\section{本手法の有効性と限界}
%------------------------------------
以上の実験結果から，
Fine-TuningおよびRAGを組み合わせた提案手法は，
従来の素のLLMと比較して
% 脆弱性検出性能および説明性の両面で有効であることが示された．

一方で，本手法にはいくつかの限界も存在する．
まず，評価対象がPHPコードに限定されており，
他言語への一般化については今後の検討が必要である．
また，RAGにおける知識ベースの品質や更新頻度が，
検出結果に大きな影響を与える点も課題として挙げられる．

これらの課題を踏まえ，
次章では本研究のまとめと，
今後の展望について述べる．

%------------------------------------
%   Chapter 6
\chapter{まとめと今後の展望}
\label{chapter_6}
%------------------------------------

%------------------------------------
\section{本研究のまとめ}
%------------------------------------

%------------------------------------
\section{研究成果の整理}
%------------------------------------

%------------------------------------
\section{本研究の貢献}
%------------------------------------

%------------------------------------
\section{限界と課題}
%------------------------------------

%------------------------------------
\section{今後の展望}
%------------------------------------

%------------------------------------
%   Acknowledgements
\chapter*{謝辞}
\label{chapter_}
%------------------------------------
．

%------------------------------------
%   References
%------------------------------------
\bibliography{main} %hoge.bibから拡張子を外した名前
\bibliographystyle{plainnat} %参考文献出力スタイル
%------------------------------------
% \appendix
%------------------------------------

%------------------------------------
\end{document}
%------------------------------------
