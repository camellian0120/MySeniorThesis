{
    "JVNDB-2025-002562": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Fix use-after free in init error and remove paths devm_blk_crypto_profile_init() registers a cleanup handler to run when the associated (platform-) device is being released. For UFS, the crypto private data and pointers are stored as part of the ufs_hba's data structure 'struct ufs_hba::crypto_profile'. This structure is allocated as part of the underlying ufshcd and therefore Scsi_host allocation. During driver release or during error handling in ufshcd_pltfrm_init(), this structure is released as part of ufshcd_dealloc_host() before the (platform-) device associated with the crypto call above is released. Once this device is released, the crypto cleanup code will run, using the just-released 'struct ufs_hba::crypto_profile'. This causes a use-after-free situation: Call trace: kfree+0x60/0x2d8 (P) kvfree+0x44/0x60 blk_crypto_profile_destroy_callback+0x28/0x70 devm_action_release+0x1c/0x30 release_nodes+0x6c/0x108 devres_release_all+0x98/0x100 device_unbind_cleanup+0x20/0x70 really_probe+0x218/0x2d0 In other words, the initialisation code flow is: platform-device probe ufshcd_pltfrm_init() ufshcd_alloc_host() scsi_host_alloc() allocation of struct ufs_hba creation of scsi-host devices devm_blk_crypto_profile_init() devm registration of cleanup handler using platform-device and during error handling of ufshcd_pltfrm_init() or during driver removal: ufshcd_dealloc_host() scsi_host_put() put_device(scsi-host) release of struct ufs_hba put_device(platform-device) crypto cleanup handler To fix this use-after free, change ufshcd_alloc_host() to register a devres action to automatically cleanup the underlying SCSI device on ufshcd destruction, without requiring explicit calls to ufshcd_dealloc_host(). This way: * the crypto profile and all other ufs_hba-owned resources are destroyed before SCSI (as they've been registered after) * a memleak is plugged in tc-dwc-g210-pci.c remove() as a side-effect * EXPORT_SYMBOL_GPL(ufshcd_dealloc_host) can be removed fully as it's not needed anymore * no future drivers using ufshcd_alloc_host() could ever forget adding the cleanup",
        "technologies": "Linux\nLinux Kernel 5.12 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002560": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: fix race between cancel_hw_scan and hw_scan completion The rtwdev->scanning flag isn't protected by mutex originally, so cancel_hw_scan can pass the condition, but suddenly hw_scan completion unset the flag and calls ieee80211_scan_completed() that will free local->hw_scan_req. Then, cancel_hw_scan raises null-ptr-deref and use-after-free. Fix it by moving the check condition to where protected by mutex. KASAN: null-ptr-deref in range [0x0000000000000088-0x000000000000008f] CPU: 2 PID: 6922 Comm: kworker/2:2 Tainted: G OE Hardware name: LENOVO 2356AD1/2356AD1, BIOS G7ETB6WW (2.76 ) 09/10/2019 Workqueue: events cfg80211_conn_work [cfg80211] RIP: 0010:rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core] Code: 00 45 89 6c 24 1c 0f 85 23 01 00 00 48 8b 85 20 ff ff ff 48 8d RSP: 0018:ffff88811fd9f068 EFLAGS: 00010206 RAX: dffffc0000000000 RBX: ffff88811fd9f258 RCX: 0000000000000001 RDX: 0000000000000011 RSI: 0000000000000001 RDI: 0000000000000089 RBP: ffff88811fd9f170 R08: 0000000000000000 R09: 0000000000000000 R10: ffff88811fd9f108 R11: 0000000000000000 R12: ffff88810e47f960 R13: 0000000000000000 R14: 000000000000ffff R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff8881d6f00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007531dfca55b0 CR3: 00000001be296004 CR4: 00000000001706e0 Call Trace: <TASK> ? show_regs+0x61/0x73 ? __die_body+0x20/0x73 ? die_addr+0x4f/0x7b ? exc_general_protection+0x191/0x1db ? asm_exc_general_protection+0x27/0x30 ? rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core] ? rtw89_fw_h2c_scan_offload_be+0x458/0x13c3 [rtw89_core] ? __pfx_rtw89_fw_h2c_scan_offload_be+0x10/0x10 [rtw89_core] ? do_raw_spin_lock+0x75/0xdb ? __pfx_do_raw_spin_lock+0x10/0x10 rtw89_hw_scan_offload+0xb5e/0xbf7 [rtw89_core] ? _raw_spin_unlock+0xe/0x24 ? __mutex_lock.constprop.0+0x40c/0x471 ? __pfx_rtw89_hw_scan_offload+0x10/0x10 [rtw89_core] ? __mutex_lock_slowpath+0x13/0x1f ? mutex_lock+0xa2/0xdc ? __pfx_mutex_lock+0x10/0x10 rtw89_hw_scan_abort+0x58/0xb7 [rtw89_core] rtw89_ops_cancel_hw_scan+0x120/0x13b [rtw89_core] ieee80211_scan_cancel+0x468/0x4d0 [mac80211] ieee80211_prep_connection+0x858/0x899 [mac80211] ieee80211_mgd_auth+0xbea/0xdde [mac80211] ? __pfx_ieee80211_mgd_auth+0x10/0x10 [mac80211] ? cfg80211_find_elem+0x15/0x29 [cfg80211] ? is_bss+0x1b7/0x1d7 [cfg80211] ieee80211_auth+0x18/0x27 [mac80211] cfg80211_mlme_auth+0x3bb/0x3e7 [cfg80211] cfg80211_conn_do_work+0x410/0xb81 [cfg80211] ? __pfx_cfg80211_conn_do_work+0x10/0x10 [cfg80211] ? __kasan_check_read+0x11/0x1f ? psi_group_change+0x8bc/0x944 ? __kasan_check_write+0x14/0x22 ? mutex_lock+0x8e/0xdc ? __pfx_mutex_lock+0x10/0x10 ? __pfx___radix_tree_lookup+0x10/0x10 cfg80211_conn_work+0x245/0x34d [cfg80211] ? __pfx_cfg80211_conn_work+0x10/0x10 [cfg80211] ? update_cfs_rq_load_avg+0x3bc/0x3d7 ? sched_clock_noinstr+0x9/0x1a ? sched_clock+0x10/0x24 ? sched_clock_cpu+0x7e/0x42e ? newidle_balance+0x796/0x937 ? __pfx_sched_clock_cpu+0x10/0x10 ? __pfx_newidle_balance+0x10/0x10 ? __kasan_check_read+0x11/0x1f ? psi_group_change+0x8bc/0x944 ? _raw_spin_unlock+0xe/0x24 ? raw_spin_rq_unlock+0x47/0x54 ? raw_spin_rq_unlock_irq+0x9/0x1f ? finish_task_switch.isra.0+0x347/0x586 ? __schedule+0x27bf/0x2892 ? mutex_unlock+0x80/0xd0 ? do_raw_spin_lock+0x75/0xdb ? __pfx___schedule+0x10/0x10 process_scheduled_works+0x58c/0x821 worker_thread+0x4c7/0x586 ? __kasan_check_read+0x11/0x1f kthread+0x285/0x294 ? __pfx_worker_thread+0x10/0x10 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x29/0x6f ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK>",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002563": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vsock: Keep the binding until socket destruction Preserve sockets bindings; this includes both resulting from an explicit bind() and those implicitly bound through autobind during connect(). Prevents socket unbinding during a transport reassignment, which fixes a use-after-free: 1. vsock_create() (refcnt=1) calls vsock_insert_unbound() (refcnt=2) 2. transport->release() calls vsock_remove_bound() without checking if sk was bound and moved to bound list (refcnt=1) 3. vsock_bind() assumes sk is in unbound list and before __vsock_insert_bound(vsock_bound_sockets()) calls __vsock_remove_bound() which does: list_del_init(&vsk->bound_table); // nop sock_put(&vsk->sk); // refcnt=0 BUG: KASAN: slab-use-after-free in __vsock_bind+0x62e/0x730 Read of size 4 at addr ffff88816b46a74c by task a.out/2057 dump_stack_lvl+0x68/0x90 print_report+0x174/0x4f6 kasan_report+0xb9/0x190 __vsock_bind+0x62e/0x730 vsock_bind+0x97/0xe0 __sys_bind+0x154/0x1f0 __x64_sys_bind+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e Allocated by task 2057: kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 __kasan_slab_alloc+0x85/0x90 kmem_cache_alloc_noprof+0x131/0x450 sk_prot_alloc+0x5b/0x220 sk_alloc+0x2c/0x870 __vsock_create.constprop.0+0x2e/0xb60 vsock_create+0xe4/0x420 __sock_create+0x241/0x650 __sys_socket+0xf2/0x1a0 __x64_sys_socket+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 2057: kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x60 __kasan_slab_free+0x4b/0x70 kmem_cache_free+0x1a1/0x590 __sk_destruct+0x388/0x5a0 __vsock_bind+0x5e1/0x730 vsock_bind+0x97/0xe0 __sys_bind+0x154/0x1f0 __x64_sys_bind+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e refcount_t: addition on 0; use-after-free. WARNING: CPU: 7 PID: 2057 at lib/refcount.c:25 refcount_warn_saturate+0xce/0x150 RIP: 0010:refcount_warn_saturate+0xce/0x150 __vsock_bind+0x66d/0x730 vsock_bind+0x97/0xe0 __sys_bind+0x154/0x1f0 __x64_sys_bind+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e refcount_t: underflow; use-after-free. WARNING: CPU: 7 PID: 2057 at lib/refcount.c:28 refcount_warn_saturate+0xee/0x150 RIP: 0010:refcount_warn_saturate+0xee/0x150 vsock_remove_bound+0x187/0x1e0 __vsock_release+0x383/0x4a0 vsock_release+0x90/0x120 __sock_release+0xa3/0x250 sock_close+0x14/0x20 __fput+0x359/0xa80 task_work_run+0x107/0x1d0 do_exit+0x847/0x2560 do_group_exit+0xb8/0x250 __x64_sys_exit_group+0x3a/0x50 x64_sys_call+0xfec/0x14f0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満"
    },
    "JVNDB-2025-002582": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: Disallow replacing of child qdisc from one parent to another Lion Ackermann was able to create a UAF which can be abused for privilege escalation with the following script Step 1. create root qdisc tc qdisc add dev lo root handle 1:0 drr step2. a class for packet aggregation do demonstrate uaf tc class add dev lo classid 1:1 drr step3. a class for nesting tc class add dev lo classid 1:2 drr step4. a class to graft qdisc to tc class add dev lo classid 1:3 drr step5. tc qdisc add dev lo parent 1:1 handle 2:0 plug limit 1024 step6. tc qdisc add dev lo parent 1:2 handle 3:0 drr step7. tc class add dev lo classid 3:1 drr step 8. tc qdisc add dev lo parent 3:1 handle 4:0 pfifo step 9. Display the class/qdisc layout tc class ls dev lo class drr 1:1 root leaf 2: quantum 64Kb class drr 1:2 root leaf 3: quantum 64Kb class drr 3:1 root leaf 4: quantum 64Kb tc qdisc ls qdisc drr 1: dev lo root refcnt 2 qdisc plug 2: dev lo parent 1:1 qdisc pfifo 4: dev lo parent 3:1 limit 1000p qdisc drr 3: dev lo parent 1:2 step10. trigger the bug <=== prevented by this patch tc qdisc replace dev lo parent 1:3 handle 4:0 step 11. Redisplay again the qdiscs/classes tc class ls dev lo class drr 1:1 root leaf 2: quantum 64Kb class drr 1:2 root leaf 3: quantum 64Kb class drr 1:3 root leaf 4: quantum 64Kb class drr 3:1 root leaf 4: quantum 64Kb tc qdisc ls qdisc drr 1: dev lo root refcnt 2 qdisc plug 2: dev lo parent 1:1 qdisc pfifo 4: dev lo parent 3:1 refcnt 2 limit 1000p qdisc drr 3: dev lo parent 1:2 Observe that a) parent for 4:0 does not change despite the replace request. There can only be one parent. b) refcount has gone up by two for 4:0 and c) both class 1:3 and 3:1 are pointing to it. Step 12. send one packet to plug echo \"\" | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888,priority=$((0x10001)) step13. send one packet to the grafted fifo echo \"\" | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888,priority=$((0x10003)) step14. lets trigger the uaf tc class delete dev lo classid 1:3 tc class delete dev lo classid 1:1 The semantics of \"replace\" is for a del/add _on the same node_ and not a delete from one node(3:1) and add to another node (1:3) as in step10. While we could \"fix\" with a more complex approach there could be consequences to expectations so the patch takes the preventive approach of \"disallow such config\". Joint work with Lion Ackermann <nnamrec@gmail.com>",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002561": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nbd: don't allow reconnect after disconnect Following process can cause nbd_config UAF: 1) grab nbd_config temporarily; 2) nbd_genl_disconnect() flush all recv_work() and release the initial reference: nbd_genl_disconnect nbd_disconnect_and_put nbd_disconnect flush_workqueue(nbd->recv_workq) if (test_and_clear_bit(NBD_RT_HAS_CONFIG_REF, ...)) nbd_config_put -> due to step 1), reference is still not zero 3) nbd_genl_reconfigure() queue recv_work() again; nbd_genl_reconfigure config = nbd_get_config_unlocked(nbd) if (!config) -> succeed if (!test_bit(NBD_RT_BOUND, ...)) -> succeed nbd_reconnect_socket queue_work(nbd->recv_workq, &args->work) 4) step 1) release the reference; 5) Finially, recv_work() will trigger UAF: recv_work nbd_config_put(nbd) -> nbd_config is freed atomic_dec(&config->recv_threads) -> UAF Fix the problem by clearing NBD_RT_BOUND in nbd_genl_disconnect(), so that nbd_genl_reconfigure() will fail.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002566": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ndisc: use RCU protection in ndisc_alloc_skb() ndisc_alloc_skb() can be called without RTNL or RCU being held. Add RCU protection to avoid possible UAF.",
        "technologies": "Linux\nLinux Kernel 3.9 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-017351": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipmr: do not call mr_mfc_uses_dev() for unres entries syzbot found that calling mr_mfc_uses_dev() for unres entries would crash [1], because c->mfc_un.res.minvif / c->mfc_un.res.maxvif alias to \"struct sk_buff_head unresolved\", which contain two pointers. This code never worked, lets remove it. [1] Unable to handle kernel paging request at virtual address ffff5fff2d536613 KASAN: maybe wild-memory-access in range [0xfffefff96a9b3098-0xfffefff96a9b309f] Modules linked in: CPU: 1 UID: 0 PID: 7321 Comm: syz.0.16 Not tainted 6.13.0-rc7-syzkaller-g1950a0af2d55 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline] pc : mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334 lr : mr_mfc_uses_dev net/ipv4/ipmr_base.c:289 [inline] lr : mr_table_dump+0x694/0x8b0 net/ipv4/ipmr_base.c:334 Call trace: mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline] (P) mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334 (P) mr_rtm_dumproute+0x254/0x454 net/ipv4/ipmr_base.c:382 ipmr_rtm_dumproute+0x248/0x4b4 net/ipv4/ipmr.c:2648 rtnl_dump_all+0x2e4/0x4e8 net/core/rtnetlink.c:4327 rtnl_dumpit+0x98/0x1d0 net/core/rtnetlink.c:6791 netlink_dump+0x4f0/0xbc0 net/netlink/af_netlink.c:2317 netlink_recvmsg+0x56c/0xe64 net/netlink/af_netlink.c:1973 sock_recvmsg_nosec net/socket.c:1033 [inline] sock_recvmsg net/socket.c:1055 [inline] sock_read_iter+0x2d8/0x40c net/socket.c:1125 new_sync_read fs/read_write.c:484 [inline] vfs_read+0x740/0x970 fs/read_write.c:565 ksys_read+0x15c/0x26c fs/read_write.c:708",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002504": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: protect access to buffers with no active references nilfs_lookup_dirty_data_buffers(), which iterates through the buffers attached to dirty data folios/pages, accesses the attached buffers without locking the folios/pages. For data cache, nilfs_clear_folio_dirty() may be called asynchronously when the file system degenerates to read only, so nilfs_lookup_dirty_data_buffers() still has the potential to cause use after free issues when buffers lose the protection of their dirty state midway due to this asynchronous clearing and are unintentionally freed by try_to_free_buffers(). Eliminate this race issue by adjusting the lock section in this function.",
        "technologies": "Linux\nLinux Kernel 3.10 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002558": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Fix implicit ODP use after free Prevent double queueing of implicit ODP mr destroy work by using __xa_cmpxchg() to make sure this is the only time we are destroying this specific mr. Without this change, we could try to invalidate this mr twice, which in turn could result in queuing a MR work destroy twice, and eventually the second work could execute after the MR was freed due to the first work, causing a user after free and trace below. refcount_t: underflow; use-after-free. WARNING: CPU: 2 PID: 12178 at lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130 Modules linked in: bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [last unloaded: ib_uverbs] CPU: 2 PID: 12178 Comm: kworker/u20:5 Not tainted 6.5.0-rc1_net_next_mlx5_58c644e #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Workqueue: events_unbound free_implicit_child_mr_work [mlx5_ib] RIP: 0010:refcount_warn_saturate+0x12b/0x130 Code: 48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ff RSP: 0018:ffff8881008e3e40 EFLAGS: 00010286 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000027 RDX: ffff88852c91b5c8 RSI: 0000000000000001 RDI: ffff88852c91b5c0 RBP: ffff8881dacd4e00 R08: 00000000ffffffff R09: 0000000000000019 R10: 000000000000072e R11: 0000000063666572 R12: ffff88812bfd9e00 R13: ffff8881c792d200 R14: ffff88810011c005 R15: ffff8881002099c0 FS: 0000000000000000(0000) GS:ffff88852c900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f5694b5e000 CR3: 00000001153f6003 CR4: 0000000000370ea0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? refcount_warn_saturate+0x12b/0x130 free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib] process_one_work+0x1cc/0x3c0 worker_thread+0x218/0x3c0 kthread+0xc6/0xf0 ret_from_fork+0x1f/0x30 </TASK>",
        "technologies": "Linux\nLinux Kernel 5.5 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002604": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: do not force clear folio if buffer is referenced Patch series \"nilfs2: protect busy buffer heads from being force-cleared\". This series fixes the buffer head state inconsistency issues reported by syzbot that occurs when the filesystem is corrupted and falls back to read-only, and the associated buffer head use-after-free issue. This patch (of 2): Syzbot has reported that after nilfs2 detects filesystem corruption and falls back to read-only, inconsistencies in the buffer state may occur. One of the inconsistencies is that when nilfs2 calls mark_buffer_dirty() to set a data or metadata buffer as dirty, but it detects that the buffer is not in the uptodate state: WARNING: CPU: 0 PID: 6049 at fs/buffer.c:1177 mark_buffer_dirty+0x2e5/0x520 fs/buffer.c:1177 ... Call Trace: <TASK> nilfs_palloc_commit_alloc_entry+0x4b/0x160 fs/nilfs2/alloc.c:598 nilfs_ifile_create_inode+0x1dd/0x3a0 fs/nilfs2/ifile.c:73 nilfs_new_inode+0x254/0x830 fs/nilfs2/inode.c:344 nilfs_mkdir+0x10d/0x340 fs/nilfs2/namei.c:218 vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257 do_mkdirat+0x264/0x3a0 fs/namei.c:4280 __do_sys_mkdirat fs/namei.c:4295 [inline] __se_sys_mkdirat fs/namei.c:4293 [inline] __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The other is when nilfs_btree_propagate(), which propagates the dirty state to the ancestor nodes of a b-tree that point to a dirty buffer, detects that the origin buffer is not dirty, even though it should be: WARNING: CPU: 0 PID: 5245 at fs/nilfs2/btree.c:2089 nilfs_btree_propagate+0xc79/0xdf0 fs/nilfs2/btree.c:2089 ... Call Trace: <TASK> nilfs_bmap_propagate+0x75/0x120 fs/nilfs2/bmap.c:345 nilfs_collect_file_data+0x4d/0xd0 fs/nilfs2/segment.c:587 nilfs_segctor_apply_buffers+0x184/0x340 fs/nilfs2/segment.c:1006 nilfs_segctor_scan_file+0x28c/0xa50 fs/nilfs2/segment.c:1045 nilfs_segctor_collect_blocks fs/nilfs2/segment.c:1216 [inline] nilfs_segctor_collect fs/nilfs2/segment.c:1540 [inline] nilfs_segctor_do_construct+0x1c28/0x6b90 fs/nilfs2/segment.c:2115 nilfs_segctor_construct+0x181/0x6b0 fs/nilfs2/segment.c:2479 nilfs_segctor_thread_construct fs/nilfs2/segment.c:2587 [inline] nilfs_segctor_thread+0x69e/0xe80 fs/nilfs2/segment.c:2701 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Both of these issues are caused by the callbacks that handle the page/folio write requests, forcibly clear various states, including the working state of the buffers they hold, at unexpected times when they detect read-only fallback. Fix these issues by checking if the buffer is referenced before clearing the page/folio state, and skipping the clear if it is.",
        "technologies": "Linux\nLinux Kernel 3.10 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002518": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arp: use RCU protection in arp_xmit() arp_xmit() can be called without RTNL or RCU protection. Use RCU protection to avoid potential UAF.",
        "technologies": "Linux\nLinux Kernel 4.4 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003596": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm-flakey: Fix memory corruption in optional corrupt_bio_byte feature Fix memory corruption due to incorrect parameter being passed to bio_init",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003590": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: davicom: fix UAF in dm9000_drv_remove dm is netdev private data and it cannot be used after free_netdev() call. Using dm after free_netdev() can cause UAF bug. Fix it by moving free_netdev() at the end of the function. This is similar to the issue fixed in commit ad297cd2db89 (\"net: qcom/emac: fix UAF in emac_remove\"). This bug is detected by our static analysis tool.",
        "technologies": "Linux\nLinux Kernel 4.4.262 以上 4.5 未満\nLinux Kernel 4.9.262 以上 4.10 未満\nLinux Kernel 4.14.226 以上 4.15 未満\nLinux Kernel 4.19.181 以上 4.20 未満\nLinux Kernel 5.4.106 以上 5.4.291 未満\nLinux Kernel 5.10.24 以上 5.10.235 未満\nLinux Kernel 5.11.7 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002581": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: zswap: properly synchronize freeing resources during CPU hotunplug In zswap_compress() and zswap_decompress(), the per-CPU acomp_ctx of the current CPU at the beginning of the operation is retrieved and used throughout. However, since neither preemption nor migration are disabled, it is possible that the operation continues on a different CPU. If the original CPU is hotunplugged while the acomp_ctx is still in use, we run into a UAF bug as some of the resources attached to the acomp_ctx are freed during hotunplug in zswap_cpu_comp_dead() (i.e. acomp_ctx.buffer, acomp_ctx.req, or acomp_ctx.acomp). The problem was introduced in commit 1ec3b5fe6eec (\"mm/zswap: move to use crypto_acomp API for hardware acceleration\") when the switch to the crypto_acomp API was made. Prior to that, the per-CPU crypto_comp was retrieved using get_cpu_ptr() which disables preemption and makes sure the CPU cannot go away from under us. Preemption cannot be disabled with the crypto_acomp API as a sleepable context is needed. Use the acomp_ctx.mutex to synchronize CPU hotplug callbacks allocating and freeing resources with compression/decompression paths. Make sure that acomp_ctx.req is NULL when the resources are freed. In the compression/decompression paths, check if acomp_ctx.req is NULL after acquiring the mutex (meaning the CPU was offlined) and retry on the new CPU. The initialization of acomp_ctx.mutex is moved from the CPU hotplug callback to the pool initialization where it belongs (where the mutex is allocated). In addition to adding clarity, this makes sure that CPU hotplug cannot reinitialize a mutex that is already locked by compression/decompression. Previously a fix was attempted by holding cpus_read_lock() [1]. This would have caused a potential deadlock as it is possible for code already holding the lock to fall into reclaim and enter zswap (causing a deadlock). A fix was also attempted using SRCU for synchronization, but Johannes pointed out that synchronize_srcu() cannot be used in CPU hotplug notifiers [2]. Alternative fixes that were considered/attempted and could have worked: - Refcounting the per-CPU acomp_ctx. This involves complexity in handling the race between the refcount dropping to zero in zswap_[de]compress() and the refcount being re-initialized when the CPU is onlined. - Disabling migration before getting the per-CPU acomp_ctx [3], but that's discouraged and is a much bigger hammer than needed, and could result in subtle performance issues. [1]https://lkml.kernel.org/20241219212437.2714151-1-yosryahmed@google.com/ [2]https://lkml.kernel.org/20250107074724.1756696-2-yosryahmed@google.com/ [3]https://lkml.kernel.org/20250107222236.2715883-2-yosryahmed@google.com/ [yosryahmed@google.com: remove comment]",
        "technologies": "Linux\nLinux Kernel 5.11 以上 6.12.12 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-002564": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ndisc: extend RCU protection in ndisc_send_skb() ndisc_send_skb() can be called without RTNL or RCU held. Acquire rcu_read_lock() earlier, so that we can use dev_net_rcu() and avoid a potential UAF.",
        "technologies": "Linux\nLinux Kernel 2.6.26 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002605": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: padata: fix UAF in padata_reorder A bug was found when run ltp test: BUG: KASAN: slab-use-after-free in padata_find_next+0x29/0x1a0 Read of size 4 at addr ffff88bbfe003524 by task kworker/u113:2/3039206 CPU: 0 PID: 3039206 Comm: kworker/u113:2 Kdump: loaded Not tainted 6.6.0+ Workqueue: pdecrypt_parallel padata_parallel_worker Call Trace: <TASK> dump_stack_lvl+0x32/0x50 print_address_description.constprop.0+0x6b/0x3d0 print_report+0xdd/0x2c0 kasan_report+0xa5/0xd0 padata_find_next+0x29/0x1a0 padata_reorder+0x131/0x220 padata_parallel_worker+0x3d/0xc0 process_one_work+0x2ec/0x5a0 If 'mdelay(10)' is added before calling 'padata_find_next' in the 'padata_reorder' function, this issue could be reproduced easily with ltp test (pcrypt_aead01). This can be explained as bellow: pcrypt_aead_encrypt ... padata_do_parallel refcount_inc(&pd->refcnt); // add refcnt ... padata_do_serial padata_reorder // pd while (1) { padata_find_next(pd, true); // using pd queue_work_on ... padata_serial_worker crypto_del_alg padata_put_pd_cnt // sub refcnt padata_free_shell padata_put_pd(ps->pd); // pd is freed // loop again, but pd is freed // call padata_find_next, UAF } In the padata_reorder function, when it loops in 'while', if the alg is deleted, the refcnt may be decreased to 0 before entering 'padata_find_next', which leads to UAF. As mentioned in [1], do_serial is supposed to be called with BHs disabled and always happen under RCU protection, to address this issue, add synchronize_rcu() in 'padata_free_shell' wait for all _do_serial calls to finish. [1] https://lore.kernel.org/all/20221028160401.cccypv4euxikusiq@parnassus.localdomain/ [2] https://lore.kernel.org/linux-kernel/jfjz5d7zwbytztackem7ibzalm5lnxldi2eofeiczqmqs2m7o6@fq426cwnjtkm/",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-028175": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix shift-out-of-bounds in dbSplit When dmt_budmin is less than zero, it causes errors in the later stages. Added a check to return an error beforehand in dbAllocCtl itself.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-028179": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to shrink read extent node in batches We use rwlock to protect core structure data of extent tree during its shrink, however, if there is a huge number of extent nodes in extent tree, during shrink of extent tree, it may hold rwlock for a very long time, which may trigger kernel hang issue. This patch fixes to shrink read extent node in batches, so that, critical region of the rwlock can be shrunk to avoid its extreme long time hold.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-028172": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: clk: clk-loongson2: Fix memory corruption bug in struct loongson2_clk_provider Some heap space is allocated for the flexible structure `struct clk_hw_onecell_data` and its flexible-array member `hws` through the composite structure `struct loongson2_clk_provider` in function `loongson2_clk_probe()`, as shown below: 289 struct loongson2_clk_provider *clp; ... 296 for (p = data; p->name; p++) 297 clks_num++; 298 299 clp = devm_kzalloc(dev, struct_size(clp, clk_data.hws, clks_num), 300 GFP_KERNEL); Then some data is written into the flexible array: 350 clp->clk_data.hws[p->id] = hw; This corrupts `clk_lock`, which is the spinlock variable immediately following the `clk_data` member in `struct loongson2_clk_provider`: struct loongson2_clk_provider { void __iomem *base; struct device *dev; struct clk_hw_onecell_data clk_data; spinlock_t clk_lock; /* protect access to DIV registers */ }; The problem is that the flexible structure is currently placed in the middle of `struct loongson2_clk_provider` instead of at the end. Fix this by moving `struct clk_hw_onecell_data clk_data;` to the end of `struct loongson2_clk_provider`. Also, add a code comment to help prevent this from happening again in case new members are added to the structure in the future. This change also fixes the following -Wflex-array-member-not-at-end warning: drivers/clk/clk-loongson2.c:32:36: warning: structure containing a flexible array member is not at the end of another structure [-Wflex-array-member-not-at-end]",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-028211": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/dp_mst: Fix MST sideband message body length check Fix the MST sideband message body length check, which must be at least 1 byte accounting for the message body CRC (aka message data CRC) at the end of the message. This fixes a case where an MST branch device returns a header with a correct header CRC (indicating a correctly received body length), with the body length being incorrectly set to 0. This will later lead to a memory corruption in drm_dp_sideband_append_payload() and the following errors in dmesg: UBSAN: array-index-out-of-bounds in drivers/gpu/drm/display/drm_dp_mst_topology.c:786:25 index -1 is out of range for type 'u8 [48]' Call Trace: drm_dp_sideband_append_payload+0x33d/0x350 [drm_display_helper] drm_dp_get_one_sb_msg+0x3ce/0x5f0 [drm_display_helper] drm_dp_mst_hpd_irq_handle_event+0xc8/0x1580 [drm_display_helper] memcpy: detected field-spanning write (size 18446744073709551615) of single field \"&msg->msg[msg->curlen]\" at drivers/gpu/drm/display/drm_dp_mst_topology.c:791 (size 256) Call Trace: drm_dp_sideband_append_payload+0x324/0x350 [drm_display_helper] drm_dp_get_one_sb_msg+0x3ce/0x5f0 [drm_display_helper] drm_dp_mst_hpd_irq_handle_event+0xc8/0x1580 [drm_display_helper]",
        "technologies": "Linux\nLinux Kernel 5.10.233 未満\nLinux Kernel 5.11 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028168": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: swiotlb: Fix double-allocation of slots due to broken alignment handling Commit bbb73a103fbb (\"swiotlb: fix a braino in the alignment check fix\"), which was a fix for commit 0eee5ae10256 (\"swiotlb: fix slot alignment checks\"), causes a functional regression with vsock in a virtual machine using bouncing via a restricted DMA SWIOTLB pool. When virtio allocates the virtqueues for the vsock device using dma_alloc_coherent(), the SWIOTLB search can return page-unaligned allocations if 'area->index' was left unaligned by a previous allocation from the buffer: # Final address in brackets is the SWIOTLB address returned to the caller | virtio-pci 0000:00:07.0: orig_addr 0x0 alloc_size 0x2000, iotlb_align_mask 0x800 stride 0x2: got slot 1645-1649/7168 (0x98326800) | virtio-pci 0000:00:07.0: orig_addr 0x0 alloc_size 0x2000, iotlb_align_mask 0x800 stride 0x2: got slot 1649-1653/7168 (0x98328800) | virtio-pci 0000:00:07.0: orig_addr 0x0 alloc_size 0x2000, iotlb_align_mask 0x800 stride 0x2: got slot 1653-1657/7168 (0x9832a800) This ends badly (typically buffer corruption and/or a hang) because swiotlb_alloc() is expecting a page-aligned allocation and so blindly returns a pointer to the 'struct page' corresponding to the allocation, therefore double-allocating the first half (2KiB slot) of the 4KiB page. Fix the problem by treating the allocation alignment separately to any additional alignment requirements from the device, using the maximum of the two as the stride to search the buffer slots and taking care to ensure a minimum of page-alignment for buffers larger than a page. This also resolves swiotlb allocation failures occuring due to the inclusion of ~PAGE_MASK in 'iotlb_align_mask' for large allocations and resulting in alignment requirements exceeding swiotlb_max_mapping_size().",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-028197": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: exfat: fix out-of-bounds access of directory entries In the case of the directory size is greater than or equal to the cluster size, if start_clu becomes an EOF cluster(an invalid cluster) due to file system corruption, then the directory entry where ei->hint_femp.eidx hint is outside the directory, resulting in an out-of-bounds access, which may cause further file system corruption. This commit adds a check for start_clu, if it is an invalid cluster, the file or directory will be treated as empty.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-028207": {
        "title": "Linux の Linux Kernel における入力で指定された数量の不適切な検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix not validating setsockopt user input Check user input length before copying data.",
        "technologies": "Linux\nLinux Kernel 2.6.39 以上 5.10.227 未満\nLinux Kernel 5.11 以上 6.1.87 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028380": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: use aligned address in copy_user_gigantic_page() In current kernel, hugetlb_wp() calls copy_user_large_folio() with the fault address. Where the fault address may be not aligned with the huge page size. Then, copy_user_large_folio() may call copy_user_gigantic_page() with the address, while copy_user_gigantic_page() requires the address to be huge page size aligned. So, this may cause memory corruption or information leak, addtional, use more obvious naming 'addr_hint' instead of 'addr' for copy_user_gigantic_page().",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.12.7 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028378": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfs: Fix the pre-flush when appending to a file in writethrough mode In netfs_perform_write(), when the file is marked NETFS_ICTX_WRITETHROUGH or O_*SYNC or RWF_*SYNC was specified, write-through caching is performed on a buffered file. When setting up for write-through, we flush any conflicting writes in the region and wait for the write to complete, failing if there's a write error to return. The issue arises if we're writing at or above the EOF position because we skip the flush and - more importantly - the wait. This becomes a problem if there's a partial folio at the end of the file that is being written out and we want to make a write to it too. Both the already-running write and the write we start both want to clear the writeback mark, but whoever is second causes a warning looking something like: ------------[ cut here ]------------ R=00000012: folio 11 is not under writeback WARNING: CPU: 34 PID: 654 at fs/netfs/write_collect.c:105 ... CPU: 34 PID: 654 Comm: kworker/u386:27 Tainted: G S ... ... Workqueue: events_unbound netfs_write_collection_worker ... RIP: 0010:netfs_writeback_lookup_folio Fix this by making the flush-and-wait unconditional. It will do nothing if there are no folios in the pagecache and will return quickly if there are no folios in the region specified. Further, move the WBC attachment above the flush call as the flush is going to attach a WBC and detach it again if it is not present - and since we need one anyway we might as well share it.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028374": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: fix memory corruption bug with suspend and rebuild The ice driver would previously panic after suspend. This is caused from the driver *only* calling the ice_vsi_free_q_vectors() function by itself, when it is suspending. Since commit b3e7b3a6ee92 (\"ice: prevent NULL pointer deref during reload\") the driver has zeroed out num_q_vectors, and only restored it in ice_vsi_cfg_def(). This further causes the ice_rebuild() function to allocate a zero length buffer, after which num_q_vectors is updated, and then the new value of num_q_vectors is used to index into the zero length buffer, which corrupts memory. The fix entails making sure all the code referencing num_q_vectors only does so after it has been reset via ice_vsi_cfg_def(). I didn't perform a full bisect, but I was able to test against 6.1.77 kernel and that ice driver works fine for suspend/resume with no panic, so sometime since then, this problem was introduced. Also clean up an un-needed init of a local variable in the function being modified. PANIC from 6.8.0-rc1: [1026674.915596] PM: suspend exit [1026675.664697] ice 0000:17:00.1: PTP reset successful [1026675.664707] ice 0000:17:00.1: 2755 msecs passed between update to cached PHC time [1026675.667660] ice 0000:b1:00.0: PTP reset successful [1026675.675944] ice 0000:b1:00.0: 2832 msecs passed between update to cached PHC time [1026677.137733] ixgbe 0000:31:00.0 ens787: NIC Link is Up 1 Gbps, Flow Control: None [1026677.190201] BUG: kernel NULL pointer dereference, address: 0000000000000010 [1026677.192753] ice 0000:17:00.0: PTP reset successful [1026677.192764] ice 0000:17:00.0: 4548 msecs passed between update to cached PHC time [1026677.197928] #PF: supervisor read access in kernel mode [1026677.197933] #PF: error_code(0x0000) - not-present page [1026677.197937] PGD 1557a7067 P4D 0 [1026677.212133] ice 0000:b1:00.1: PTP reset successful [1026677.212143] ice 0000:b1:00.1: 4344 msecs passed between update to cached PHC time [1026677.212575] [1026677.243142] Oops: 0000 [#1] PREEMPT SMP NOPTI [1026677.247918] CPU: 23 PID: 42790 Comm: kworker/23:0 Kdump: loaded Tainted: G W 6.8.0-rc1+ #1 [1026677.257989] Hardware name: Intel Corporation M50CYP2SBSTD/M50CYP2SBSTD, BIOS SE5C620.86B.01.01.0005.2202160810 02/16/2022 [1026677.269367] Workqueue: ice ice_service_task [ice] [1026677.274592] RIP: 0010:ice_vsi_rebuild_set_coalesce+0x130/0x1e0 [ice] [1026677.281421] Code: 0f 84 3a ff ff ff 41 0f b7 74 ec 02 66 89 b0 22 02 00 00 81 e6 ff 1f 00 00 e8 ec fd ff ff e9 35 ff ff ff 48 8b 43 30 49 63 ed <41> 0f b7 34 24 41 83 c5 01 48 8b 3c e8 66 89 b7 aa 02 00 00 81 e6 [1026677.300877] RSP: 0018:ff3be62a6399bcc0 EFLAGS: 00010202 [1026677.306556] RAX: ff28691e28980828 RBX: ff28691e41099828 RCX: 0000000000188000 [1026677.314148] RDX: 0000000000000000 RSI: 0000000000000010 RDI: ff28691e41099828 [1026677.321730] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 [1026677.329311] R10: 0000000000000007 R11: ffffffffffffffc0 R12: 0000000000000010 [1026677.336896] R13: 0000000000000000 R14: 0000000000000000 R15: ff28691e0eaa81a0 [1026677.344472] FS: 0000000000000000(0000) GS:ff28693cbffc0000(0000) knlGS:0000000000000000 [1026677.353000] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [1026677.359195] CR2: 0000000000000010 CR3: 0000000128df4001 CR4: 0000000000771ef0 [1026677.366779] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [1026677.374369] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [1026677.381952] PKRU: 55555554 [1026677.385116] Call Trace: [1026677.388023] <TASK> [1026677.390589] ? __die+0x20/0x70 [1026677.394105] ? page_fault_oops+0x82/0x160 [1026677.398576] ? do_user_addr_fault+0x65/0x6a0 [1026677.403307] ? exc_page_fault+0x6a/0x150 [1026677.407694] ? asm_exc_page_fault+0x22/0x30 [1026677.412349] ? ice_vsi_rebuild_set_coalesce+0x130/0x1e0 [ice] [1026677.4186 ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.4.7 以上 6.5 未満\nLinux Kernel 6.5.1 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.5\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028358": {
        "title": "Linux の Linux Kernel における入力で指定された数量の不適切な検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: ISO: Fix not validating setsockopt user input Check user input length before copying data.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.119 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028371": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: qca: add missing firmware sanity checks Add the missing sanity checks when parsing the firmware files before downloading them to avoid accessing and corrupting memory beyond the vmalloced buffer.",
        "technologies": "Linux\nLinux Kernel 4.3 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028355": {
        "title": "Linux の Linux Kernel における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/entry: Mark IRQ entries to fix stack depot warnings The stack depot filters out everything outside of the top interrupt context as an uninteresting or irrelevant part of the stack traces. This helps with stack trace de-duplication, avoiding an explosion of saved stack traces that share the same IRQ context code path but originate from different randomly interrupted points, eventually exhausting the stack depot. Filtering uses in_irqentry_text() to identify functions within the .irqentry.text and .softirqentry.text sections, which then become the last stack trace entries being saved. While __do_softirq() is placed into the .softirqentry.text section by common code, populating .irqentry.text is architecture-specific. Currently, the .irqentry.text section on s390 is empty, which prevents stack depot filtering and de-duplication and could result in warnings like: Stack depot reached limit capacity WARNING: CPU: 0 PID: 286113 at lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8 with PREEMPT and KASAN enabled. Fix this by moving the IO/EXT interrupt handlers from .kprobes.text into the .irqentry.text section and updating the kprobes blacklist to include the .irqentry.text section. This is done only for asynchronous interrupts and explicitly not for program checks, which are synchronous and where the context beyond the program check is important to preserve. Despite machine checks being somewhat in between, they are extremely rare, and preserving context when possible is also of value. SVCs and Restart Interrupts are not relevant, one being always at the boundary to user space and the other being a one-time thing. IRQ entries filtering is also optionally used in ftrace function graph, where the same logic applies.",
        "technologies": "Linux\nLinux Kernel 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.12.4 未満"
    },
    "JVNDB-2024-028353": {
        "title": "Linux の Linux Kernel における入力で指定された数量の不適切な検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_sock: Fix not validating setsockopt user input Check user input length before copying data.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028314": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vc4: don't check if plane->state->fb == state->fb Currently, when using non-blocking commits, we can see the following kernel warning: [ 110.908514] ------------[ cut here ]------------ [ 110.908529] refcount_t: underflow; use-after-free. [ 110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0 [ 110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6 [ 110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G C 6.1.66-v8+ #32 [ 110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT) [ 110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 110.909132] pc : refcount_dec_not_one+0xb8/0xc0 [ 110.909152] lr : refcount_dec_not_one+0xb4/0xc0 [ 110.909170] sp : ffffffc00913b9c0 [ 110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60 [ 110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480 [ 110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78 [ 110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000 [ 110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004 [ 110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003 [ 110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00 [ 110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572 [ 110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000 [ 110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001 [ 110.909434] Call trace: [ 110.909441] refcount_dec_not_one+0xb8/0xc0 [ 110.909461] vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4] [ 110.909903] vc4_cleanup_fb+0x44/0x50 [vc4] [ 110.910315] drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper] [ 110.910669] vc4_atomic_commit_tail+0x390/0x9dc [vc4] [ 110.911079] commit_tail+0xb0/0x164 [drm_kms_helper] [ 110.911397] drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper] [ 110.911716] drm_atomic_commit+0xb0/0xdc [drm] [ 110.912569] drm_mode_atomic_ioctl+0x348/0x4b8 [drm] [ 110.913330] drm_ioctl_kernel+0xec/0x15c [drm] [ 110.914091] drm_ioctl+0x24c/0x3b0 [drm] [ 110.914850] __arm64_sys_ioctl+0x9c/0xd4 [ 110.914873] invoke_syscall+0x4c/0x114 [ 110.914897] el0_svc_common+0xd0/0x118 [ 110.914917] do_el0_svc+0x38/0xd0 [ 110.914936] el0_svc+0x30/0x8c [ 110.914958] el0t_64_sync_handler+0x84/0xf0 [ 110.914979] el0t_64_sync+0x18c/0x190 [ 110.914996] ---[ end trace 0000000000000000 ]--- This happens because, although `prepare_fb` and `cleanup_fb` are perfectly balanced, we cannot guarantee consistency in the check plane->state->fb == state->fb. This means that sometimes we can increase the refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. The opposite can also be true. In fact, the struct drm_plane .state shouldn't be accessed directly but instead, the `drm_atomic_get_new_plane_state()` helper function should be used. So, we could stick to this check, but using `drm_atomic_get_new_plane_state()`. But actually, this check is not re ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.1.86 未満\nLinux Kernel 6.2 以上 6.6.27 未満\nLinux Kernel 6.7 以上 6.8.6 未満"
    },
    "JVNDB-2024-028351": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dma-direct: Leak pages on dma_set_decrypted() failure On TDX it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues. DMA could free decrypted/shared pages if dma_set_decrypted() fails. This should be a rare case. Just leak the pages in this case instead of freeing them.",
        "technologies": "Linux\nLinux Kernel 6.1.86 未満\nLinux Kernel 6.2 以上 6.6.27 未満\nLinux Kernel 6.7 以上 6.8.6 未満"
    },
    "JVNDB-2024-021002": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: make sure exp active before svc_export_show The function `e_show` was called with protection from RCU. This only ensures that `exp` will not be freed. Therefore, the reference count for `exp` can drop to zero, which will trigger a refcount use-after-free warning when `exp_get` is called. To resolve this issue, use `cache_get_rcu` to ensure that `exp` remains active. ------------[ cut here ]------------ refcount_t: addition on 0; use-after-free. WARNING: CPU: 3 PID: 819 at lib/refcount.c:25 refcount_warn_saturate+0xb1/0x120 CPU: 3 UID: 0 PID: 819 Comm: cat Not tainted 6.12.0-rc3+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 RIP: 0010:refcount_warn_saturate+0xb1/0x120 ... Call Trace: <TASK> e_show+0x20b/0x230 [nfsd] seq_read_iter+0x589/0x770 seq_read+0x1e5/0x270 vfs_read+0x125/0x530 ksys_read+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e",
        "technologies": "Linux\nLinux Kernel 3.17 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.12.4 未満"
    },
    "JVNDB-2024-020999": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: prevent use-after-free due to open_cached_dir error paths If open_cached_dir() encounters an error parsing the lease from the server, the error handling may race with receiving a lease break, resulting in open_cached_dir() freeing the cfid while the queued work is pending. Update open_cached_dir() to drop refs rather than directly freeing the cfid. Have cached_dir_lease_break(), cfids_laundromat_worker(), and invalidate_all_cached_dirs() clear has_lease immediately while still holding cfids->cfid_list_lock, and then use this to also simplify the reference counting in cfids_laundromat_worker() and invalidate_all_cached_dirs(). Fixes this KASAN splat (which manually injects an error and lease break in open_cached_dir()): ================================================================== BUG: KASAN: slab-use-after-free in smb2_cached_lease_break+0x27/0xb0 Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65 CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Workqueue: cifsiod smb2_cached_lease_break Call Trace: <TASK> dump_stack_lvl+0x77/0xb0 print_report+0xce/0x660 kasan_report+0xd3/0x110 smb2_cached_lease_break+0x27/0xb0 process_one_work+0x50a/0xc50 worker_thread+0x2ba/0x530 kthread+0x17c/0x1c0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 2464: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 open_cached_dir+0xa7d/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 2464: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x51/0x70 kfree+0x174/0x520 open_cached_dir+0x97f/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e Last potentially related work creation: kasan_save_stack+0x33/0x60 __kasan_record_aux_stack+0xad/0xc0 insert_work+0x32/0x100 __queue_work+0x5c9/0x870 queue_work_on+0x82/0x90 open_cached_dir+0x1369/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e The buggy address belongs to the object at ffff88811cc24c00 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 16 bytes inside of freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)",
        "technologies": "Linux\nLinux Kernel 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-021483": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: of: module: add buffer overflow check in of_modalias() In of_modalias(), if the buffer happens to be too small even for the 1st snprintf() call, the len parameter will become negative and str parameter (if not NULL initially) will point beyond the buffer's end. Add the buffer overflow check after the 1st snprintf() call and fix such check after the strlen() call (accounting for the terminating NUL char).",
        "technologies": "Linux\nLinux Kernel 4.14 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-021477": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix global oob in ksmbd_nl_policy Similar to a reported issue (check the commit b33fb5b801c6 (\"net: qualcomm: rmnet: fix global oob in rmnet_policy\"), my local fuzzer finds another global out-of-bounds read for policy ksmbd_nl_policy. See bug trace below: ================================================================== BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline] BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600 Read of size 1 at addr ffffffff8f24b100 by task syz-executor.1/62810 CPU: 0 PID: 62810 Comm: syz-executor.1 Tainted: G N 6.1.0 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:284 [inline] print_report+0x172/0x475 mm/kasan/report.c:395 kasan_report+0xbb/0x1c0 mm/kasan/report.c:495 validate_nla lib/nlattr.c:386 [inline] __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600 __nla_parse+0x3e/0x50 lib/nlattr.c:697 __nlmsg_parse include/net/netlink.h:748 [inline] genl_family_rcv_msg_attrs_parse.constprop.0+0x1b0/0x290 net/netlink/genetlink.c:565 genl_family_rcv_msg_doit+0xda/0x330 net/netlink/genetlink.c:734 genl_family_rcv_msg net/netlink/genetlink.c:833 [inline] genl_rcv_msg+0x441/0x780 net/netlink/genetlink.c:850 netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540 genl_rcv+0x24/0x40 net/netlink/genetlink.c:861 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg+0x154/0x190 net/socket.c:734 ____sys_sendmsg+0x6df/0x840 net/socket.c:2482 ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536 __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fdd66a8f359 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fdd65e00168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007fdd66bbcf80 RCX: 00007fdd66a8f359 RDX: 0000000000000000 RSI: 0000000020000500 RDI: 0000000000000003 RBP: 00007fdd66ada493 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007ffc84b81aff R14: 00007fdd65e00300 R15: 0000000000022000 </TASK> The buggy address belongs to the variable: ksmbd_nl_policy+0x100/0xa80 The buggy address belongs to the physical page: page:0000000034f47940 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1ccc4b flags: 0x200000000001000(reserved|node=0|zone=2) raw: 0200000000001000 ffffea00073312c8 ffffea00073312c8 0000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffffffff8f24b000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffffffff8f24b080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffffffff8f24b100: f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9 00 00 07 f9 ^ ffffffff8f24b180: f9 f9 f9 f9 00 05 f9 f9 f9 f9 f9 f9 00 00 00 05 ffffffff8f24b200: f9 f9 f9 f9 00 00 03 f9 f9 f9 f9 f9 00 00 04 f9 ================================================================== To fix it, add a placeholder named __KSMBD_EVENT_MAX and let KSMBD_EVENT_MAX to be its original value - 1 according to what other netlink families do. Also change two sites that refer the KSMBD_EVENT_MAX to correct value.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-021495": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: octeontx2-af: fix the double free in rvu_npc_freemem() Clang static checker(scan-build) warning： drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c:line 2184, column 2 Attempt to free released memory. npc_mcam_rsrcs_deinit() has released 'mcam->counters.bmap'. Deleted this redundant kfree() to fix this double free problem.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021482": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: af_unix: Update unix_sk(sk)->oob_skb under sk_receive_queue lock. Billy Jheng Bing-Jhong reported a race between __unix_gc() and queue_oob(). __unix_gc() tries to garbage-collect close()d inflight sockets, and then if the socket has MSG_OOB in unix_sk(sk)->oob_skb, GC will drop the reference and set NULL to it locklessly. However, the peer socket still can send MSG_OOB message and queue_oob() can update unix_sk(sk)->oob_skb concurrently, leading NULL pointer dereference. [0] To fix the issue, let's update unix_sk(sk)->oob_skb under the sk_receive_queue's lock and take it everywhere we touch oob_skb. Note that we defer kfree_skb() in manage_oob() to silence lockdep false-positive (See [1]). [0]: BUG: kernel NULL pointer dereference, address: 0000000000000008 PF: supervisor write access in kernel mode PF: error_code(0x0002) - not-present page PGD 8000000009f5e067 P4D 8000000009f5e067 PUD 9f5d067 PMD 0 Oops: 0002 [#1] PREEMPT SMP PTI CPU: 3 PID: 50 Comm: kworker/3:1 Not tainted 6.9.0-rc5-00191-gd091e579b864 #110 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 Workqueue: events delayed_fput RIP: 0010:skb_dequeue (./include/linux/skbuff.h:2386 ./include/linux/skbuff.h:2402 net/core/skbuff.c:3847) Code: 39 e3 74 3e 8b 43 10 48 89 ef 83 e8 01 89 43 10 49 8b 44 24 08 49 c7 44 24 08 00 00 00 00 49 8b 14 24 49 c7 04 24 00 00 00 00 <48> 89 42 08 48 89 10 e8 e7 c5 42 00 4c 89 e0 5b 5d 41 5c c3 cc cc RSP: 0018:ffffc900001bfd48 EFLAGS: 00000002 RAX: 0000000000000000 RBX: ffff8880088f5ae8 RCX: 00000000361289f9 RDX: 0000000000000000 RSI: 0000000000000206 RDI: ffff8880088f5b00 RBP: ffff8880088f5b00 R08: 0000000000080000 R09: 0000000000000001 R10: 0000000000000003 R11: 0000000000000001 R12: ffff8880056b6a00 R13: ffff8880088f5280 R14: 0000000000000001 R15: ffff8880088f5a80 FS: 0000000000000000(0000) GS:ffff88807dd80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000008 CR3: 0000000006314000 CR4: 00000000007506f0 PKRU: 55555554 Call Trace: <TASK> unix_release_sock (net/unix/af_unix.c:654) unix_release (net/unix/af_unix.c:1050) __sock_release (net/socket.c:660) sock_close (net/socket.c:1423) __fput (fs/file_table.c:423) delayed_fput (fs/file_table.c:444 (discriminator 3)) process_one_work (kernel/workqueue.c:3259) worker_thread (kernel/workqueue.c:3329 kernel/workqueue.c:3416) kthread (kernel/kthread.c:388) ret_from_fork (arch/x86/kernel/process.c:153) ret_from_fork_asm (arch/x86/entry/entry_64.S:257) </TASK> Modules linked in: CR2: 0000000000000008",
        "technologies": "Linux\nLinux Kernel 5.15.149 以上 5.15.161 未満\nLinux Kernel 6.1.78 以上 6.1.93 未満\nLinux Kernel 6.6.17 以上 6.6.33 未満\nLinux Kernel 6.7.5 以上 6.9.4 未満"
    },
    "JVNDB-2024-021005": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: f_tcm: Don't free command immediately Don't prematurely free the command. Wait for the status completion of the sense status. It can be freed then. Otherwise we will double-free the command.",
        "technologies": "Linux\nLinux Kernel 4.6 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-021481": {
        "title": "Linux の Linux Kernel における未クリアのデバッグ情報による重要なシステム情報の公開に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Drivers: hv: vmbus: Track decrypted status in vmbus_gpadl In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues. In order to make sure callers of vmbus_establish_gpadl() and vmbus_teardown_gpadl() don't return decrypted/shared pages to allocators, add a field in struct vmbus_gpadl to keep track of the decryption status of the buffers. This will allow the callers to know if they should free or leak the pages.",
        "technologies": "Linux\nLinux Kernel 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021004": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pps: Fix a use-after-free On a board running ntpd and gpsd, I'm seeing a consistent use-after-free in sys_exit() from gpsd when rebooting: pps pps1: removed ------------[ cut here ]------------ kobject: '(null)' (00000000db4bec24): is not initialized, yet kobject_put() is being called. WARNING: CPU: 2 PID: 440 at lib/kobject.c:734 kobject_put+0x120/0x150 CPU: 2 UID: 299 PID: 440 Comm: gpsd Not tainted 6.11.0-rc6-00308-gb31c44928842 #1 Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT) pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : kobject_put+0x120/0x150 lr : kobject_put+0x120/0x150 sp : ffffffc0803d3ae0 x29: ffffffc0803d3ae0 x28: ffffff8042dc9738 x27: 0000000000000001 x26: 0000000000000000 x25: ffffff8042dc9040 x24: ffffff8042dc9440 x23: ffffff80402a4620 x22: ffffff8042ef4bd0 x21: ffffff80405cb600 x20: 000000000008001b x19: ffffff8040b3b6e0 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: 696e6920746f6e20 x14: 7369203a29343263 x13: 205d303434542020 x12: 0000000000000000 x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000 x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000 x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000 Call trace: kobject_put+0x120/0x150 cdev_put+0x20/0x3c __fput+0x2c4/0x2d8 ____fput+0x1c/0x38 task_work_run+0x70/0xfc do_exit+0x2a0/0x924 do_group_exit+0x34/0x90 get_signal+0x7fc/0x8c0 do_signal+0x128/0x13b4 do_notify_resume+0xdc/0x160 el0_svc+0xd4/0xf8 el0t_64_sync_handler+0x140/0x14c el0t_64_sync+0x190/0x194 ---[ end trace 0000000000000000 ]--- ...followed by more symptoms of corruption, with similar stacks: refcount_t: underflow; use-after-free. kernel BUG at lib/list_debug.c:62! Kernel panic - not syncing: Oops - BUG: Fatal exception This happens because pps_device_destruct() frees the pps_device with the embedded cdev immediately after calling cdev_del(), but, as the comment above cdev_del() notes, fops for previously opened cdevs are still callable even after cdev_del() returns. I think this bug has always been there: I can't explain why it suddenly started happening every time I reboot this particular board. In commit d953e0e837e6 (\"pps: Fix a use-after free bug when unregistering a source.\"), George Spelvin suggested removing the embedded cdev. That seems like the simplest way to fix this, so I've implemented his suggestion, using __register_chrdev() with pps_idr becoming the source of truth for which minor corresponds to which device. But now that pps_idr defines userspace visibility instead of cdev_add(), we need to be sure the pps->dev refcount can't reach zero while userspace can still find it again. So, the idr_remove() call moves to pps_unregister_cdev(), and pps_idr now holds a reference to pps->dev. pps_core: source serial1 got cdev (251:1) <...> pps pps1: removed pps_core: unregistering pps1 pps_core: deallocating pps1",
        "technologies": "Linux\nLinux Kernel 3.2.40 以上 3.3 未満\nLinux Kernel 3.4.87 以上 3.5 未満\nLinux Kernel 3.8.1 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-021003": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: brd: defer automatic disk creation until module initialization succeeds My colleague Wupeng found the following problems during fault injection: BUG: unable to handle page fault for address: fffffbfff809d073 PGD 6e648067 P4D 123ec8067 PUD 123ec4067 PMD 100e38067 PTE 0 Oops: Oops: 0000 [#1] PREEMPT SMP KASAN NOPTI CPU: 5 UID: 0 PID: 755 Comm: modprobe Not tainted 6.12.0-rc3+ #17 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 RIP: 0010:__asan_load8+0x4c/0xa0 ... Call Trace: <TASK> blkdev_put_whole+0x41/0x70 bdev_release+0x1a3/0x250 blkdev_release+0x11/0x20 __fput+0x1d7/0x4a0 task_work_run+0xfc/0x180 syscall_exit_to_user_mode+0x1de/0x1f0 do_syscall_64+0x6b/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e loop_init() is calling loop_add() after __register_blkdev() succeeds and is ignoring disk_add() failure from loop_add(), for loop_add() failure is not fatal and successfully created disks are already visible to bdev_open(). brd_init() is currently calling brd_alloc() before __register_blkdev() succeeds and is releasing successfully created disks when brd_init() returns an error. This can cause UAF for the latter two case: case 1: T1: modprobe brd brd_init brd_alloc(0) // success add_disk disk_scan_partitions bdev_file_open_by_dev // alloc file fput // won't free until back to userspace brd_alloc(1) // failed since mem alloc error inject // error path for modprobe will release code segment // back to userspace __fput blkdev_release bdev_release blkdev_put_whole bdev->bd_disk->fops->release // fops is freed now, UAF! case 2: T1: T2: modprobe brd brd_init brd_alloc(0) // success open(/dev/ram0) brd_alloc(1) // fail // error path for modprobe close(/dev/ram0) ... /* UAF! */ bdev->bd_disk->fops->release Fix this problem by following what loop_init() does. Besides, reintroduce brd_devices_mutex to help serialize modifications to brd_list.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-021496": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: USB: core: Fix access violation during port device removal Testing with KASAN and syzkaller revealed a bug in port.c:disable_store(): usb_hub_to_struct_hub() can return NULL if the hub that the port belongs to is concurrently removed, but the function does not check for this possibility before dereferencing the returned value. It turns out that the first dereference is unnecessary, since hub->intfdev is the parent of the port device, so it can be changed easily. Adding a check for hub == NULL prevents further problems. The same bug exists in the disable_show() routine, and it can be fixed the same way.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021554": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: arm64/neonbs - fix out-of-bounds access on short input The bit-sliced implementation of AES-CTR operates on blocks of 128 bytes, and will fall back to the plain NEON version for tail blocks or inputs that are shorter than 128 bytes to begin with. It will call straight into the plain NEON asm helper, which performs all memory accesses in granules of 16 bytes (the size of a NEON register). For this reason, the associated plain NEON glue code will copy inputs shorter than 16 bytes into a temporary buffer, given that this is a rare occurrence and it is not worth the effort to work around this in the asm code. The fallback from the bit-sliced NEON version fails to take this into account, potentially resulting in out-of-bounds accesses. So clone the same workaround, and use a temp buffer for short in/outputs.",
        "technologies": "Linux\nLinux Kernel 5.18 から 6.1.81\nLinux Kernel 6.2 から 6.6.21\nLinux Kernel 6.2 から 6.7.9\nLinux Kernel 6.8"
    },
    "JVNDB-2024-021540": {
        "title": "Linux の Linux Kernel における情報漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: hda: intel-sdw-acpi: fix usage of device_get_named_child_node() The documentation for device_get_named_child_node() mentions this important point: \" The caller is responsible for calling fwnode_handle_put() on the returned fwnode pointer. \" Add fwnode_handle_put() to avoid a leaked reference.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021537": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: lan966x: Fix crash when adding interface under a lag There is a crash when adding one of the lan966x interfaces under a lag interface. The issue can be reproduced like this: ip link add name bond0 type bond miimon 100 mode balance-xor ip link set dev eth0 master bond0 The reason is because when adding a interface under the lag it would go through all the ports and try to figure out which other ports are under that lag interface. And the issue is that lan966x can have ports that are NULL pointer as they are not probed. So then iterating over these ports it would just crash as they are NULL pointers. The fix consists in actually checking for NULL pointers before accessing something from the ports. Like we do in other places.",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.79 未満\nLinux Kernel 6.2 以上 6.6.18 未満\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-021497": {
        "title": "Linux の Linux Kernel における未クリアのデバッグ情報による重要なシステム情報の公開に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Drivers: hv: vmbus: Leak pages if set_memory_encrypted() fails In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues. VMBus code could free decrypted pages if set_memory_encrypted()/decrypted() fails. Leak the pages if this happens.",
        "technologies": "Linux\nLinux Kernel 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021499": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: carl9170: re-fix fortified-memset warning The carl9170_tx_release() function sometimes triggers a fortified-memset warning in my randconfig builds: In file included from include/linux/string.h:254, from drivers/net/wireless/ath/carl9170/tx.c:40: In function 'fortify_memset_chk', inlined from 'carl9170_tx_release' at drivers/net/wireless/ath/carl9170/tx.c:283:2, inlined from 'kref_put' at include/linux/kref.h:65:3, inlined from 'carl9170_tx_put_skb' at drivers/net/wireless/ath/carl9170/tx.c:342:9: include/linux/fortify-string.h:493:25: error: call to '__write_overflow_field' declared with attribute warning: detected write beyond size of field (1st parameter); maybe use struct_group()? [-Werror=attribute-warning] 493 | __write_overflow_field(p_size_field, size); Kees previously tried to avoid this by using memset_after(), but it seems this does not fully address the problem. I noticed that the memset_after() here is done on a different part of the union (status) than the original cast was from (rate_driver_data), which may confuse the compiler. Unfortunately, the memset_after() trick does not work on driver_rates[] because that is part of an anonymous struct, and I could not get struct_group() to do this either. Using two separate memset() calls on the two members does address the warning though.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-021556": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: mediatek: vcodec: adding lock to protect encoder context list Add a lock for the ctx_list, to avoid accessing a NULL pointer within the 'vpu_enc_ipi_handler' function when the ctx_list has been deleted due to an unexpected behavior on the SCP IP block.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.27 未満\nLinux Kernel 6.7 以上 6.8.6 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021559": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kprobes: Fix possible use-after-free issue on kprobe registration When unloading a module, its state is changing MODULE_STATE_LIVE -> MODULE_STATE_GOING -> MODULE_STATE_UNFORMED. Each change will take a time. `is_module_text_address()` and `__module_text_address()` works with MODULE_STATE_LIVE and MODULE_STATE_GOING. If we use `is_module_text_address()` and `__module_text_address()` separately, there is a chance that the first one is succeeded but the next one is failed because module->state becomes MODULE_STATE_UNFORMED between those operations. In `check_kprobe_address_safe()`, if the second `__module_text_address()` is failed, that is ignored because it expected a kernel_text address. But it may have failed simply because module->state has been changed to MODULE_STATE_UNFORMED. In this case, arm_kprobe() will try to modify non-exist module text address (use-after-free). To fix this problem, we should not use separated `is_module_text_address()` and `__module_text_address()`, but use only `__module_text_address()` once and do `try_module_get(module)` which is only available with MODULE_STATE_LIVE.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.14.291 以上 4.15 未満\nLinux Kernel 4.19.256 以上 4.19.313 未満\nLinux Kernel 5.4.211 以上 5.4.275 未満\nLinux Kernel 5.10.137 以上 5.10.216 未満\nLinux Kernel 5.15.61 以上 5.15.157 未満\nLinux Kernel 5.18.18 以上 5.19 未満\nLinux Kernel 5.19.2 以上 6.1.87 未満\nLinux Kernel 6.2 以上 6.6.28 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021547": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cppc_cpufreq: Fix possible null pointer dereference cppc_cpufreq_get_rate() and hisi_cppc_cpufreq_get_rate() can be called from different places with various parameters. So cpufreq_cpu_get() can return null as 'policy' in some circumstances. Fix this bug by adding null return check. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-021575": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Properly link new fs rules into the tree Previously, add_rule_fg would only add newly created rules from the handle into the tree when they had a refcount of 1. On the other hand, create_flow_handle tries hard to find and reference already existing identical rules instead of creating new ones. These two behaviors can result in a situation where create_flow_handle 1) creates a new rule and references it, then 2) in a subsequent step during the same handle creation references it again, resulting in a rule with a refcount of 2 that is not linked into the tree, will have a NULL parent and root and will result in a crash when the flow group is deleted because del_sw_hw_rule, invoked on rule deletion, assumes node->parent is != NULL. This happened in the wild, due to another bug related to incorrect handling of duplicate pkt_reformat ids, which lead to the code in create_flow_handle incorrectly referencing a just-added rule in the same flow handle, resulting in the problem described above. Full details are at [1]. This patch changes add_rule_fg to add new rules without parents into the tree, properly initializing them and avoiding the crash. This makes it more consistent with how rules are added to an FTE in create_flow_handle.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.10 以上 4.19.313 未満\nLinux Kernel 4.20 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.156 未満\nLinux Kernel 5.16 以上 6.1.87 未満\nLinux Kernel 6.2 以上 6.6.28 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021914": {
        "title": "Linux Foundation の Kuadrant における権限管理に関する脆弱性",
        "description": "Insecure permissions in kuadrant v0.11.3 allow attackers to gain access to the service account's token, leading to escalation of privileges via the secretes component in the k8s cluster",
        "technologies": "Linux Foundation\nKuadrant 0.11.3 およびそれ以前"
    },
    "JVNDB-2024-021555": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Prevent potential buffer overflow in map_hw_resources Adds a check in the map_hw_resources function to prevent a potential buffer overflow. The function was accessing arrays using an index that could potentially be greater than the size of the arrays, leading to a buffer overflow. Adds a check to ensure that the index is within the bounds of the arrays. If the index is out of bounds, an error message is printed and break it will continue execution with just ignoring extra data early to prevent the buffer overflow. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:79 map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id' 6 <= 7 drivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:81 map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id' 6 <= 7",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-021821": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: ncm: Avoid dropping datagrams of properly parsed NTBs It is observed sometimes when tethering is used over NCM with Windows 11 as host, at some instances, the gadget_giveback has one byte appended at the end of a proper NTB. When the NTB is parsed, unwrap call looks for any leftover bytes in SKB provided by u_ether and if there are any pending bytes, it treats them as a separate NTB and parses it. But in case the second NTB (as per unwrap call) is faulty/corrupt, all the datagrams that were parsed properly in the first NTB and saved in rx_list are dropped. Adding a few custom traces showed the following: [002] d..1 7828.532866: dwc3_gadget_giveback: ep1out: req 000000003868811a length 1025/16384 zsI ==> 0 [002] d..1 7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb toprocess: 1025 [002] d..1 7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342 [002] d..1 7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb seq: 0xce67 [002] d..1 7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x400 [002] d..1 7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb ndp_len: 0x10 [002] d..1 7828.532869: ncm_unwrap_ntb: K: Parsed NTB with 1 frames In this case, the giveback is of 1025 bytes and block length is 1024. The rest 1 byte (which is 0x00) won't be parsed resulting in drop of all datagrams in rx_list. Same is case with packets of size 2048: [002] d..1 7828.557948: dwc3_gadget_giveback: ep1out: req 0000000011dfd96e length 2049/16384 zsI ==> 0 [002] d..1 7828.557949: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342 [002] d..1 7828.557950: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x800 Lecroy shows one byte coming in extra confirming that the byte is coming in from PC: Transfer 2959 - Bytes Transferred(1025) Timestamp((18.524 843 590) - Transaction 8391 - Data(1025 bytes) Timestamp(18.524 843 590) --- Packet 4063861 Data(1024 bytes) Duration(2.117us) Idle(14.700ns) Timestamp(18.524 843 590) --- Packet 4063863 Data(1 byte) Duration(66.160ns) Time(282.000ns) Timestamp(18.524 845 722) According to Windows driver, no ZLP is needed if wBlockLength is non-zero, because the non-zero wBlockLength has already told the function side the size of transfer to be expected. However, there are in-market NCM devices that rely on ZLP as long as the wBlockLength is multiple of wMaxPacketSize. To deal with such devices, it pads an extra 0 at end so the transfer is no longer multiple of wMaxPacketSize.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.38 以上 4.19.308 未満\nLinux Kernel 4.20 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.211 未満\nLinux Kernel 5.11 以上 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-021736": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()' Fixes the below: drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368) 357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev, enum amdgpu_mca_error_type type, 358 int idx, struct mca_bank_entry *entry) 359 { 360 const struct amdgpu_mca_smu_funcs *mca_funcs = adev->mca.mca_funcs; 361 int count; 362 363 switch (type) { 364 case AMDGPU_MCA_ERROR_TYPE_UE: 365 count = mca_funcs->max_ue_count; mca_funcs is dereferenced here. 366 break; 367 case AMDGPU_MCA_ERROR_TYPE_CE: 368 count = mca_funcs->max_ce_count; mca_funcs is dereferenced here. 369 break; 370 default: 371 return -EINVAL; 372 } 373 374 if (idx >= count) 375 return -EINVAL; 376 377 if (mca_funcs && mca_funcs->mca_get_mca_entry) ^^^^^^^^^ Checked too late!",
        "technologies": "Linux\nLinux Kernel 6.7.4 未満"
    },
    "JVNDB-2024-021714": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: Always flush async #PF workqueue when vCPU is being destroyed Always flush the per-vCPU async #PF workqueue when a vCPU is clearing its completion queue, e.g. when a VM and all its vCPUs is being destroyed. KVM must ensure that none of its workqueue callbacks is running when the last reference to the KVM _module_ is put. Gifting a reference to the associated VM prevents the workqueue callback from dereferencing freed vCPU/VM memory, but does not prevent the KVM module from being unloaded before the callback completes. Drop the misguided VM refcount gifting, as calling kvm_put_kvm() from async_pf_execute() if kvm_put_kvm() flushes the async #PF workqueue will result in deadlock. async_pf_execute() can't return until kvm_put_kvm() finishes, and kvm_put_kvm() can't return until async_pf_execute() finishes: WARNING: CPU: 8 PID: 251 at virt/kvm/kvm_main.c:1435 kvm_put_kvm+0x2d/0x320 [kvm] Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel kvm irqbypass CPU: 8 PID: 251 Comm: kworker/8:1 Tainted: G W 6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 Workqueue: events async_pf_execute [kvm] RIP: 0010:kvm_put_kvm+0x2d/0x320 [kvm] Call Trace: <TASK> async_pf_execute+0x198/0x260 [kvm] process_one_work+0x145/0x2d0 worker_thread+0x27e/0x3a0 kthread+0xba/0xe0 ret_from_fork+0x2d/0x50 ret_from_fork_asm+0x11/0x20 </TASK> ---[ end trace 0000000000000000 ]--- INFO: task kworker/8:1:251 blocked for more than 120 seconds. Tainted: G W 6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119 \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. task:kworker/8:1 state:D stack:0 pid:251 ppid:2 flags:0x00004000 Workqueue: events async_pf_execute [kvm] Call Trace: <TASK> __schedule+0x33f/0xa40 schedule+0x53/0xc0 schedule_timeout+0x12a/0x140 __wait_for_common+0x8d/0x1d0 __flush_work.isra.0+0x19f/0x2c0 kvm_clear_async_pf_completion_queue+0x129/0x190 [kvm] kvm_arch_destroy_vm+0x78/0x1b0 [kvm] kvm_put_kvm+0x1c1/0x320 [kvm] async_pf_execute+0x198/0x260 [kvm] process_one_work+0x145/0x2d0 worker_thread+0x27e/0x3a0 kthread+0xba/0xe0 ret_from_fork+0x2d/0x50 ret_from_fork_asm+0x11/0x20 </TASK> If kvm_clear_async_pf_completion_queue() actually flushes the workqueue, then there's no need to gift async_pf_execute() a reference because all invocations of async_pf_execute() will be forced to complete before the vCPU and its VM are destroyed/freed. And that in turn fixes the module unloading bug as __fput() won't do module_put() on the last vCPU reference until the vCPU has been freed, e.g. if closing the vCPU file also puts the last reference to the KVM module. Note that kvm_check_async_pf_completion() may also take the work item off the completion queue and so also needs to flush the work queue, as the work will not be seen by kvm_clear_async_pf_completion_queue(). Waiting on the workqueue could theoretically delay a vCPU due to waiting for the work to complete, but that's a very, very small chance, and likely a very small delay. kvm_arch_async_page_present_queued() unconditionally makes a new request, i.e. will effectively delay entering the guest, so the remaining work is really just: trace_kvm_async_pf_completed(addr, cr2_or_gpa); __kvm_vcpu_wake_up(vcpu); mmput(mm); and mmput() can't drop the last reference to the page tables if the vCPU is still alive, i.e. the vCPU won't get stuck tearing down page tables. Add a helper to do the flushing, specifically to deal with \"wakeup all\" work items, as they aren't actually work items, i.e. are never placed in a workqueue. Trying to flush a bogus workqueue entry rightly makes __flush_work() complain (kudos to whoever added that sanity check). Note, commit 5f6de5cbebee (\"KVM: Prevent module exit until al ---truncated---",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.38 以上 4.19.312 未満\nLinux Kernel 4.20 以上 5.4.274 未満\nLinux Kernel 5.5 以上 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-021652": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: guarantee refcounted children from parent session Avoid potential use-after-free bugs when walking DFS referrals, mounting and performing DFS failover by ensuring that all children from parent @tcon->ses are also refcounted. They're all needed across the entire DFS mount. Get rid of @tcon->dfs_ses_list while we're at it, too.",
        "technologies": "Linux\nLinux Kernel 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021822": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fixed overflow check in mi_enum_attr()",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-021994": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: spectrum_acl_tcam: Fix possible use-after-free during rehash The rehash delayed work migrates filters from one region to another according to the number of available credits. The migrated from region is destroyed at the end of the work if the number of credits is non-negative as the assumption is that this is indicative of migration being complete. This assumption is incorrect as a non-negative number of credits can also be the result of a failed migration. The destruction of a region that still has filters referencing it can result in a use-after-free [1]. Fix by not destroying the region if migration failed. [1] BUG: KASAN: slab-use-after-free in mlxsw_sp_acl_ctcam_region_entry_remove+0x21d/0x230 Read of size 8 at addr ffff8881735319e8 by task kworker/0:31/3858 CPU: 0 PID: 3858 Comm: kworker/0:31 Tainted: G W 6.9.0-rc2-custom-00782-gf2275c2157d8 #5 Hardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019 Workqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work Call Trace: <TASK> dump_stack_lvl+0xc6/0x120 print_report+0xce/0x670 kasan_report+0xd7/0x110 mlxsw_sp_acl_ctcam_region_entry_remove+0x21d/0x230 mlxsw_sp_acl_ctcam_entry_del+0x2e/0x70 mlxsw_sp_acl_atcam_entry_del+0x81/0x210 mlxsw_sp_acl_tcam_vchunk_migrate_all+0x3cd/0xb50 mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300 process_one_work+0x8eb/0x19b0 worker_thread+0x6c9/0xf70 kthread+0x2c9/0x3b0 ret_from_fork+0x4d/0x80 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 174: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 __kmalloc+0x19c/0x360 mlxsw_sp_acl_tcam_region_create+0xdf/0x9c0 mlxsw_sp_acl_tcam_vregion_rehash_work+0x954/0x1300 process_one_work+0x8eb/0x19b0 worker_thread+0x6c9/0xf70 kthread+0x2c9/0x3b0 ret_from_fork+0x4d/0x80 ret_from_fork_asm+0x1a/0x30 Freed by task 7: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 poison_slab_object+0x102/0x170 __kasan_slab_free+0x14/0x30 kfree+0xc1/0x290 mlxsw_sp_acl_tcam_region_destroy+0x272/0x310 mlxsw_sp_acl_tcam_vregion_rehash_work+0x731/0x1300 process_one_work+0x8eb/0x19b0 worker_thread+0x6c9/0xf70 kthread+0x2c9/0x3b0 ret_from_fork+0x4d/0x80 ret_from_fork_asm+0x1a/0x30",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.1 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.158 未満\nLinux Kernel 5.16 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021715": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/vma: Fix UAF on destroy against retire race Object debugging tools were sporadically reporting illegal attempts to free a still active i915 VMA object when parking a GT believed to be idle. [161.359441] ODEBUG: free active (active state 0) object: ffff88811643b958 object type: i915_active hint: __i915_vma_active+0x0/0x50 [i915] [161.360082] WARNING: CPU: 5 PID: 276 at lib/debugobjects.c:514 debug_print_object+0x80/0xb0 ... [161.360304] CPU: 5 PID: 276 Comm: kworker/5:2 Not tainted 6.5.0-rc1-CI_DRM_13375-g003f860e5577+ #1 [161.360314] Hardware name: Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022 [161.360322] Workqueue: i915-unordered __intel_wakeref_put_work [i915] [161.360592] RIP: 0010:debug_print_object+0x80/0xb0 ... [161.361347] debug_object_free+0xeb/0x110 [161.361362] i915_active_fini+0x14/0x130 [i915] [161.361866] release_references+0xfe/0x1f0 [i915] [161.362543] i915_vma_parked+0x1db/0x380 [i915] [161.363129] __gt_park+0x121/0x230 [i915] [161.363515] ____intel_wakeref_put_last+0x1f/0x70 [i915] That has been tracked down to be happening when another thread is deactivating the VMA inside __active_retire() helper, after the VMA's active counter has been already decremented to 0, but before deactivation of the VMA's object is reported to the object debugging tool. We could prevent from that race by serializing i915_active_fini() with __active_retire() via ref->tree_lock, but that wouldn't stop the VMA from being used, e.g. from __i915_vma_retire() called at the end of __active_retire(), after that VMA has been already freed by a concurrent i915_vma_destroy() on return from the i915_active_fini(). Then, we should rather fix the issue at the VMA level, not in i915_active. Since __i915_vma_parked() is called from __gt_park() on last put of the GT's wakeref, the issue could be addressed by holding the GT wakeref long enough for __active_retire() to complete before that wakeref is released and the GT parked. I believe the issue was introduced by commit d93939730347 (\"drm/i915: Remove the vma refcount\") which moved a call to i915_active_fini() from a dropped i915_vma_release(), called on last put of the removed VMA kref, to i915_vma_parked() processing path called on last put of a GT wakeref. However, its visibility to the object debugging tool was suppressed by a bug in i915_active that was fixed two weeks later with commit e92eb246feb9 (\"drm/i915/active: Fix missing debug object activation\"). A VMA associated with a request doesn't acquire a GT wakeref by itself. Instead, it depends on a wakeref held directly by the request's active intel_context for a GT associated with its VM, and indirectly on that intel_context's engine wakeref if the engine belongs to the same GT as the VMA's VM. Those wakerefs are released asynchronously to VMA deactivation. Fix the issue by getting a wakeref for the VMA's GT when activating it, and putting that wakeref only after the VMA is deactivated. However, exclude global GTT from that processing path, otherwise the GPU never goes idle. Since __i915_vma_retire() may be called from atomic contexts, use async variant of wakeref put. Also, to avoid circular locking dependency, take care of acquiring the wakeref before VM mutex when both are needed. v7: Add inline comments with justifications for: - using untracked variants of intel_gt_pm_get/put() (Nirmoy), - using async variant of _put(), - not getting the wakeref in case of a global GTT, - always getting the first wakeref outside vm->mutex. v6: Since __i915_vma_active/retire() callbacks are not serialized, storing a wakeref tracking handle inside struct i915_vma is not safe, and there is no other good place for that. Use untracked variants of intel_gt_pm_get/put_async(). v5: Replace \"tile\" with \"GT\" across commit description (Rodrigo), - ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-022010": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: wilc1000: fix RCU usage in connect path With lockdep enabled, calls to the connect function from cfg802.11 layer lead to the following warning: ============================= WARNING: suspicious RCU usage 6.7.0-rc1-wt+ #333 Not tainted ----------------------------- drivers/net/wireless/microchip/wilc1000/hif.c:386 suspicious rcu_dereference_check() usage! [...] stack backtrace: CPU: 0 PID: 100 Comm: wpa_supplicant Not tainted 6.7.0-rc1-wt+ #333 Hardware name: Atmel SAMA5 unwind_backtrace from show_stack+0x18/0x1c show_stack from dump_stack_lvl+0x34/0x48 dump_stack_lvl from wilc_parse_join_bss_param+0x7dc/0x7f4 wilc_parse_join_bss_param from connect+0x2c4/0x648 connect from cfg80211_connect+0x30c/0xb74 cfg80211_connect from nl80211_connect+0x860/0xa94 nl80211_connect from genl_rcv_msg+0x3fc/0x59c genl_rcv_msg from netlink_rcv_skb+0xd0/0x1f8 netlink_rcv_skb from genl_rcv+0x2c/0x3c genl_rcv from netlink_unicast+0x3b0/0x550 netlink_unicast from netlink_sendmsg+0x368/0x688 netlink_sendmsg from ____sys_sendmsg+0x190/0x430 ____sys_sendmsg from ___sys_sendmsg+0x110/0x158 ___sys_sendmsg from sys_sendmsg+0xe8/0x150 sys_sendmsg from ret_fast_syscall+0x0/0x1c This warning is emitted because in the connect path, when trying to parse target BSS parameters, we dereference a RCU pointer whithout being in RCU critical section. Fix RCU dereference usage by moving it to a RCU read critical section. To avoid wrapping the whole wilc_parse_join_bss_param under the critical section, just use the critical section to copy ies data",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.1 以上 5.4.273 未満\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-022009": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp: Fix Use-After-Free in tcp_ao_connect_init Since call_rcu, which is called in the hlist_for_each_entry_rcu traversal of tcp_ao_connect_init, is not part of the RCU read critical section, it is possible that the RCU grace period will pass during the traversal and the key will be free. To prevent this, it should be changed to hlist_for_each_entry_safe.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021932": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bcachefs: Check for journal entries overruning end of sb clean section Fix a missing bounds check in superblock validation. Note that we don't yet have repair code for this case - repair code for individual items is generally low priority, since the whole superblock is checksummed, validated prior to write, and we have backups.",
        "technologies": "Linux\nLinux Kernel 6.9"
    },
    "JVNDB-2024-021995": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における書式文字列に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: dbg-tlv: ensure NUL termination The iwl_fw_ini_debug_info_tlv is used as a string, so we must ensure the string is terminated correctly before using it.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-022308": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: sr: fix invalid unregister error path The error path of seg6_init() is wrong in case CONFIG_IPV6_SEG6_LWTUNNEL is not defined. In that case if seg6_hmac_init() fails, the genl_unregister_family() isn't called. This issue exist since commit 46738b1317e1 (\"ipv6: sr: add option to control lwtunnel support\"), and commit 5559cea2d5aa (\"ipv6: sr: fix possible use-after-free and null-ptr-deref\") replaced unregister_pernet_subsys() with genl_unregister_family() in this error path.",
        "technologies": "Linux\nLinux Kernel 4.10 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-022307": {
        "title": "Linux の Linux Kernel における有効期限を過ぎた鍵の使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: keys: Fix overwrite of key expiration on instantiation The expiry time of a key is unconditionally overwritten during instantiation, defaulting to turn it permanent. This causes a problem for DNS resolution as the expiration set by user-space is overwritten to TIME64_MAX, disabling further DNS updates. Fix this by restoring the condition that key_set_expiry is only called when the pre-parser sets a specific expiry.",
        "technologies": "Linux\nLinux Kernel 5.10.206 以上 5.10.217 未満\nLinux Kernel 5.15.146 以上 5.15.159 未満\nLinux Kernel 6.1.70 以上 6.1.91 未満\nLinux Kernel 6.6.9 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9 以上 6.9.1 未満"
    },
    "JVNDB-2024-022305": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vmwgfx: Fix invalid reads in fence signaled events Correctly set the length of the drm_event to the size of the structure that's actually used. The length of the drm_event was set to the parent structure instead of to the drm_vmw_event_fence which is supposed to be read. drm_read uses the length parameter to copy the event to the user space thus resuling in oob reads.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.4 以上 4.19.314 未満\nLinux Kernel 4.20 以上 5.4.276 未満\nLinux Kernel 5.5 以上 5.10.217 未満\nLinux Kernel 5.11 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-022309": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rcu: Fix buffer overflow in print_cpu_stall_info() The rcuc-starvation output from print_cpu_stall_info() might overflow the buffer if there is a huge difference in jiffies difference. The situation might seem improbable, but computers sometimes get very confused about time, which can result in full-sized integers, and, in this case, buffer overflow. Also, the unsigned jiffies difference is printed using %ld, which is normally for signed integers. This is intentional for debugging purposes, but it is not obvious from the code. This commit therefore changes sprintf() to snprintf() and adds a clarifying comment about intention of %ld format. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-022049": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtl8xxxu: add cancel_work_sync() for c2hcmd_work The workqueue might still be running, when the driver is stopped. To avoid a use-after-free, call cancel_work_sync() in rtl8xxxu_stop().",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-022391": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tty: n_gsm: fix possible out-of-bounds in gsm0_receive() Assuming the following: - side A configures the n_gsm in basic option mode - side B sends the header of a basic option mode frame with data length 1 - side A switches to advanced option mode - side B sends 2 data bytes which exceeds gsm->len Reason: gsm->len is not used in advanced option mode. - side A switches to basic option mode - side B keeps sending until gsm0_receive() writes past gsm->buf Reason: Neither gsm->state nor gsm->len have been reset after reconfiguration. Fix this by changing gsm->count to gsm->len comparison from equal to less than. Also add upper limit checks against the constant MAX_MRU in gsm0_receive() and gsm1_receive() to harden against memory corruption of gsm->len and gsm->mru. All other checks remain as we still need to limit the data according to the user configuration and actual payload size.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-022400": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: Explicitly verify target vCPU is online in kvm_get_vcpu() Explicitly verify the target vCPU is fully online _prior_ to clamping the index in kvm_get_vcpu(). If the index is \"bad\", the nospec clamping will generate '0', i.e. KVM will return vCPU0 instead of NULL. In practice, the bug is unlikely to cause problems, as it will only come into play if userspace or the guest is buggy or misbehaving, e.g. KVM may send interrupts to vCPU0 instead of dropping them on the floor. However, returning vCPU0 when it shouldn't exist per online_vcpus is problematic now that KVM uses an xarray for the vCPUs array, as KVM needs to insert into the xarray before publishing the vCPU to userspace (see commit c5b077549136 (\"KVM: Convert the kvm->vcpus array to a xarray\")), i.e. before vCPU creation is guaranteed to succeed. As a result, incorrectly providing access to vCPU0 will trigger a use-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu() bails out of vCPU creation due to an error and frees vCPU0. Commit afb2acb2e3a3 (\"KVM: Fix vcpu_array[0] races\") papered over that issue, but in doing so introduced an unsolvable teardown conundrum. Preventing accesses to vCPU0 before it's fully online will allow reverting commit afb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.",
        "technologies": "Linux\nLinux Kernel 4.14.120 以上 4.15 未満\nLinux Kernel 4.19.44 以上 4.20 未満\nLinux Kernel 5.0.17 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2024-022420": {
        "title": "Linux Foundation の PipeCD における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "Insecure permissions in pipecd v0.49 allow attackers to gain access to the service account's token, leading to escalation of privileges.",
        "technologies": "Linux Foundation\nPipeCD 0.49.3 およびそれ以前"
    },
    "JVNDB-2024-022397": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: core: Fix NULL module pointer assignment at card init The commit 81033c6b584b (\"ALSA: core: Warn on empty module\") introduced a WARN_ON() for a NULL module pointer passed at snd_card object creation, and it also wraps the code around it with '#ifdef MODULE'. This works in most cases, but the devils are always in details. \"MODULE\" is defined when the target code (i.e. the sound core) is built as a module; but this doesn't mean that the caller is also built-in or not. Namely, when only the sound core is built-in (CONFIG_SND=y) while the driver is a module (CONFIG_SND_USB_AUDIO=m), the passed module pointer is ignored even if it's non-NULL, and card->module remains as NULL. This would result in the missing module reference up/down at the device open/close, leading to a race with the code execution after the module removal. For addressing the bug, move the assignment of card->module again out of ifdef. The WARN_ON() is still wrapped with ifdef because the module can be really NULL when all sound drivers are built-in. Note that we keep 'ifdef MODULE' for WARN_ON(), otherwise it would lead to a false-positive NULL module check. Admittedly it won't catch perfectly, i.e. no check is performed when CONFIG_SND=y. But, it's no real problem as it's only for debugging, and the condition is pretty rare.",
        "technologies": "Linux\nLinux Kernel 5.9 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-022394": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/mana_ib: boundary check before installing cq callbacks Add a boundary check inside mana_ib_install_cq_cb to prevent index overflow.",
        "technologies": "Linux\nLinux Kernel 6.8.2 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-022809": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In flashc, there is a possible out of bounds write due to an uncaught exception. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS08541757; Issue ID: ALPS08541764.",
        "technologies": "Google\nAndroid 12.0\nAndroid 13.0\nAndroid 14.0\nLinux Foundation\nYocto 3.3\nOpenWrt Project\nOpenWrt 19.07.0\nOpenWrt 21.02.0\nRDK Management, LLC\nrdk-b 2022q3"
    },
    "JVNDB-2024-022421": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: think-lmi: Fix password opcode ordering for workstations The Lenovo workstations require the password opcode to be run before the attribute value is changed (if Admin password is enabled). Tested on some Thinkpads to confirm they are OK with this order too.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-022872": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In da, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS09073261; Issue ID: MSV-1772.",
        "technologies": "Google\nAndroid 12.0\nAndroid 13.0\nAndroid 14.0\nAndroid 15.0\nLinux Foundation\nYocto 4.0\nOpenWrt Project\nOpenWrt 19.07.0\nOpenWrt 21.02.0\nOpenWrt 23.05\nRDK Management, LLC\nrdk-b 2022q3\nrdk-b 2024q1"
    },
    "JVNDB-2024-022893": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Fix potential out-of-bound accesses for Extigy and Mbox devices A bogus device can provide a bNumConfigurations value that exceeds the initial value used in usb_get_configuration for allocating dev->config. This can lead to out-of-bounds accesses later, e.g. in usb_destroy_configuration.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-018117": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: mpc52xx: Add cancel_work_sync before module remove If we remove the module which will call mpc52xx_spi_remove it will free 'ms' through spi_unregister_controller. while the work ms->work will be used. The sequence of operations that may lead to a UAF bug. Fix it by ensuring that the work is canceled before proceeding with the cleanup in mpc52xx_spi_remove.",
        "technologies": "Linux\nLinux Kernel 3.1 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-018201": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/mediatek: Set private->all_drm_private[i]->drm to NULL if mtk_drm_bind returns err The pointer need to be set to NULL, otherwise KASAN complains about use-after-free. Because in mtk_drm_bind, all private's drm are set as follows. private->all_drm_private[i]->drm = drm; And drm will be released by drm_dev_put in case mtk_drm_kms_init returns failure. However, the shutdown path still accesses the previous allocated memory in drm_atomic_helper_shutdown. [ 84.874820] watchdog: watchdog0: watchdog did not stop! [ 86.512054] ================================================================== [ 86.513162] BUG: KASAN: use-after-free in drm_atomic_helper_shutdown+0x33c/0x378 [ 86.514258] Read of size 8 at addr ffff0000d46fc068 by task shutdown/1 [ 86.515213] [ 86.515455] CPU: 1 UID: 0 PID: 1 Comm: shutdown Not tainted 6.13.0-rc1-mtk+gfa1a78e5d24b-dirty #55 [ 86.516752] Hardware name: Unknown Product/Unknown Product, BIOS 2022.10 10/01/2022 [ 86.517960] Call trace: [ 86.518333] show_stack+0x20/0x38 (C) [ 86.518891] dump_stack_lvl+0x90/0xd0 [ 86.519443] print_report+0xf8/0x5b0 [ 86.519985] kasan_report+0xb4/0x100 [ 86.520526] __asan_report_load8_noabort+0x20/0x30 [ 86.521240] drm_atomic_helper_shutdown+0x33c/0x378 [ 86.521966] mtk_drm_shutdown+0x54/0x80 [ 86.522546] platform_shutdown+0x64/0x90 [ 86.523137] device_shutdown+0x260/0x5b8 [ 86.523728] kernel_restart+0x78/0xf0 [ 86.524282] __do_sys_reboot+0x258/0x2f0 [ 86.524871] __arm64_sys_reboot+0x90/0xd8 [ 86.525473] invoke_syscall+0x74/0x268 [ 86.526041] el0_svc_common.constprop.0+0xb0/0x240 [ 86.526751] do_el0_svc+0x4c/0x70 [ 86.527251] el0_svc+0x4c/0xc0 [ 86.527719] el0t_64_sync_handler+0x144/0x168 [ 86.528367] el0t_64_sync+0x198/0x1a0 [ 86.528920] [ 86.529157] The buggy address belongs to the physical page: [ 86.529972] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0xffff0000d46fd4d0 pfn:0x1146fc [ 86.531319] flags: 0xbfffc0000000000(node=0|zone=2|lastcpupid=0xffff) [ 86.532267] raw: 0bfffc0000000000 0000000000000000 dead000000000122 0000000000000000 [ 86.533390] raw: ffff0000d46fd4d0 0000000000000000 00000000ffffffff 0000000000000000 [ 86.534511] page dumped because: kasan: bad access detected [ 86.535323] [ 86.535559] Memory state around the buggy address: [ 86.536265] ffff0000d46fbf00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 86.537314] ffff0000d46fbf80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 86.538363] >ffff0000d46fc000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 86.544733] ^ [ 86.551057] ffff0000d46fc080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 86.557510] ffff0000d46fc100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 86.563928] ================================================================== [ 86.571093] Disabling lock debugging due to kernel taint [ 86.577642] Unable to handle kernel paging request at virtual address e0e9c0920000000b [ 86.581834] KASAN: maybe wild-memory-access in range [0x0752049000000058-0x075204900000005f] ...",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-018184": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: sh: aica: reorder cleanup operations to avoid UAF bugs The dreamcastcard->timer could schedule the spu_dma_work and the spu_dma_work could also arm the dreamcastcard->timer. When the snd_pcm_substream is closing, the aica_channel will be deallocated. But it could still be dereferenced in the worker thread. The reason is that del_timer() will return directly regardless of whether the timer handler is running or not and the worker could be rescheduled in the timer handler. As a result, the UAF bug will happen. The racy situation is shown below: (Thread 1) | (Thread 2) snd_aicapcm_pcm_close() | ... | run_spu_dma() //worker | mod_timer() flush_work() | del_timer() | aica_period_elapsed() //timer kfree(dreamcastcard->channel) | schedule_work() | run_spu_dma() //worker ... | dreamcastcard->channel-> //USE In order to mitigate this bug and other possible corner cases, call mod_timer() conditionally in run_spu_dma(), then implement PCM sync_stop op to cancel both the timer and worker. The sync_stop op will be called from PCM core appropriately when needed.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.23 以上 4.19.312 未満\nLinux Kernel 4.20 以上 5.4.274 未満\nLinux Kernel 5.5 以上 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-018115": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req() While receiving an MST up request message from one thread in drm_dp_mst_handle_up_req(), the MST topology could be removed from another thread via drm_dp_mst_topology_mgr_set_mst(false), freeing mst_primary and setting drm_dp_mst_topology_mgr::mst_primary to NULL. This could lead to a NULL deref/use-after-free of mst_primary in drm_dp_mst_handle_up_req(). Avoid the above by holding a reference for mst_primary in drm_dp_mst_handle_up_req() while it's used. v2: Fix kfreeing the request if getting an mst_primary reference fails.",
        "technologies": "Linux\nLinux Kernel 6.1.123 未満\nLinux Kernel 6.2 以上 6.6.69 未満\nLinux Kernel 6.7 以上 6.12.8 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-019050": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hrtimers: Handle CPU state correctly on hotplug Consider a scenario where a CPU transitions from CPUHP_ONLINE to halfway through a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to CPUHP_ONLINE: Since hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set to 1 throughout. However, during a CPU unplug operation, the tick and the clockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online state, for instance CFS incorrectly assumes that the hrtick is already active, and the chance of the clockevent device to transition to oneshot mode is also lost forever for the CPU, unless it goes back to a lower state than CPUHP_HRTIMERS_PREPARE once. This round-trip reveals another issue; cpu_base.online is not set to 1 after the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer(). Aside of that, the bulk of the per CPU state is not reset either, which means there are dangling pointers in the worst case. Address this by adding a corresponding startup() callback, which resets the stale per CPU state and sets the online flag. [ tglx: Make the new callback unconditionally available, remove the online modification in the prepare() callback and clear the remaining state in the starting callback instead of the prepare callback ]",
        "technologies": "Linux\nLinux Kernel 4.19.302 以上 4.20 未満\nLinux Kernel 5.4.264 以上 5.4.290 未満\nLinux Kernel 5.10.204 以上 5.10.234 未満\nLinux Kernel 5.15.143 以上 5.15.177 未満\nLinux Kernel 6.1.68 以上 6.1.127 未満\nLinux Kernel 6.6.7 以上 6.6.74 未満\nLinux Kernel 6.7 以上 6.12.11 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-019045": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/vfio-ap: always filter entire AP matrix The vfio_ap_mdev_filter_matrix function is called whenever a new adapter or domain is assigned to the mdev. The purpose of the function is to update the guest's AP configuration by filtering the matrix of adapters and domains assigned to the mdev. When an adapter or domain is assigned, only the APQNs associated with the APID of the new adapter or APQI of the new domain are inspected. If an APQN does not reference a queue device bound to the vfio_ap device driver, then it's APID will be filtered from the mdev's matrix when updating the guest's AP configuration. Inspecting only the APID of the new adapter or APQI of the new domain will result in passing AP queues through to a guest that are not bound to the vfio_ap device driver under certain circumstances. Consider the following: guest's AP configuration (all also assigned to the mdev's matrix): 14.0004 14.0005 14.0006 16.0004 16.0005 16.0006 unassign domain 4 unbind queue 16.0005 assign domain 4 When domain 4 is re-assigned, since only domain 4 will be inspected, the APQNs that will be examined will be: 14.0004 16.0004 Since both of those APQNs reference queue devices that are bound to the vfio_ap device driver, nothing will get filtered from the mdev's matrix when updating the guest's AP configuration. Consequently, queue 16.0005 will get passed through despite not being bound to the driver. This violates the linux device model requirement that a guest shall only be given access to devices bound to the device driver facilitating their pass-through. To resolve this problem, every adapter and domain assigned to the mdev will be inspected when filtering the mdev's matrix.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2024-018479": {
        "title": "Linux Foundation の Node.js 用 @backstage/backend-common におけるパストラバーサルの脆弱性",
        "description": "`@backstage/backend-common` is a common functionality library for backends for Backstage, an open platform for building developer portals. In `@backstage/backend-common` prior to versions 0.21.1, 0.20.2, and 0.19.10, paths checks with the `resolveSafeChildPath` utility were not exhaustive enough, leading to risk of path traversal vulnerabilities if symlinks can be injected by attackers. This issue is patched in `@backstage/backend-common` versions 0.21.1, 0.20.2, and 0.19.10.",
        "technologies": "Linux Foundation\n@backstage/backend-common 0.19.10 未満\n@backstage/backend-common 0.20.0 以上 0.20.2 未満\n@backstage/backend-common 0.21.0"
    },
    "JVNDB-2024-018309": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Skip parsing frames of type UVC_VS_UNDEFINED in uvc_parse_format This can lead to out of bounds writes since frames of this type were not taken into account when calculating the size of the frames buffer in uvc_parse_streaming.",
        "technologies": "Linux\nLinux Kernel 2.6.26 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12 以上 6.12.1 未満"
    },
    "JVNDB-2024-018202": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: dummy: iio_simply_dummy_buffer: fix information leak in triggered buffer The 'data' array is allocated via kmalloc() and it is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Use kzalloc for the memory allocation to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 4.5 以上 5.4.290 未満\nLinux Kernel 5.5 以上 5.10.234 未満\nLinux Kernel 5.11 以上 5.15.177 未満\nLinux Kernel 5.16 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-018421": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sunrpc: fix one UAF issue caused by sunrpc kernel tcp socket BUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0 Read of size 1 at addr ffff888111f322cd by task swapper/0/0 CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 Call Trace: <IRQ> dump_stack_lvl+0x68/0xa0 print_address_description.constprop.0+0x2c/0x3d0 print_report+0xb4/0x270 kasan_report+0xbd/0xf0 tcp_write_timer_handler+0x156/0x3e0 tcp_write_timer+0x66/0x170 call_timer_fn+0xfb/0x1d0 __run_timers+0x3f8/0x480 run_timer_softirq+0x9b/0x100 handle_softirqs+0x153/0x390 __irq_exit_rcu+0x103/0x120 irq_exit_rcu+0xe/0x20 sysvec_apic_timer_interrupt+0x76/0x90 </IRQ> <TASK> asm_sysvec_apic_timer_interrupt+0x1a/0x20 RIP: 0010:default_idle+0xf/0x20 Code: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 RSP: 0018:ffffffffa2007e28 EFLAGS: 00000242 RAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590f RBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835d R10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000 R13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0 default_idle_call+0x6b/0xa0 cpuidle_idle_call+0x1af/0x1f0 do_idle+0xbc/0x130 cpu_startup_entry+0x33/0x40 rest_init+0x11f/0x210 start_kernel+0x39a/0x420 x86_64_start_reservations+0x18/0x30 x86_64_start_kernel+0x97/0xa0 common_startup_64+0x13e/0x141 </TASK> Allocated by task 595: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_slab_alloc+0x87/0x90 kmem_cache_alloc_noprof+0x12b/0x3f0 copy_net_ns+0x94/0x380 create_new_namespaces+0x24c/0x500 unshare_nsproxy_namespaces+0x75/0xf0 ksys_unshare+0x24e/0x4f0 __x64_sys_unshare+0x1f/0x30 do_syscall_64+0x70/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 100: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x54/0x70 kmem_cache_free+0x156/0x5d0 cleanup_net+0x5d3/0x670 process_one_work+0x776/0xa90 worker_thread+0x2e2/0x560 kthread+0x1a8/0x1f0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30 Reproduction script: mkdir -p /mnt/nfsshare mkdir -p /mnt/nfs/netns_1 mkfs.ext4 /dev/sdb mount /dev/sdb /mnt/nfsshare systemctl restart nfs-server chmod 777 /mnt/nfsshare exportfs -i -o rw,no_root_squash *:/mnt/nfsshare ip netns add netns_1 ip link add name veth_1_peer type veth peer veth_1 ifconfig veth_1_peer 11.11.0.254 up ip link set veth_1 netns netns_1 ip netns exec netns_1 ifconfig veth_1 11.11.0.1 ip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp \\ --tcp-flags FIN FIN -j DROP (note: In my environment, a DESTROY_CLIENTID operation is always sent immediately, breaking the nfs tcp connection.) ip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1 \\ 11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1 ip netns del netns_1 The reason here is that the tcp socket in netns_1 (nfs side) has been shutdown and closed (done in xs_destroy), but the FIN message (with ack) is discarded, and the nfsd side keeps sending retransmission messages. As a result, when the tcp sock in netns_1 processes the received message, it sends the message (FIN message) in the sending queue, and the tcp timer is re-established. When the network namespace is deleted, the net structure accessed by tcp's timer handler function causes problems. To fix this problem, let's hold netns refcnt for the tcp kernel socket as done in other modules. This is an ugly hack which can easily be backported to earlier kernels. A proper fix which cleans up the interfaces will follow, but may not be so easy to backport.",
        "technologies": "Linux\nLinux Kernel 4.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-018203": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: avoid potential UAF in default_operstate() syzbot reported an UAF in default_operstate() [1] Issue is a race between device and netns dismantles. After calling __rtnl_unlock() from netdev_run_todo(), we can not assume the netns of each device is still alive. Make sure the device is not in NETREG_UNREGISTERED state, and add an ASSERT_RTNL() before the call to __dev_get_by_index(). We might move this ASSERT_RTNL() in __dev_get_by_index() in the future. [1] BUG: KASAN: slab-use-after-free in __dev_get_by_index+0x5d/0x110 net/core/dev.c:852 Read of size 8 at addr ffff888043eba1b0 by task syz.0.0/5339 CPU: 0 UID: 0 PID: 5339 Comm: syz.0.0 Not tainted 6.12.0-syzkaller-10296-gaaf20f870da0 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 __dev_get_by_index+0x5d/0x110 net/core/dev.c:852 default_operstate net/core/link_watch.c:51 [inline] rfc2863_policy+0x224/0x300 net/core/link_watch.c:67 linkwatch_do_dev+0x3e/0x170 net/core/link_watch.c:170 netdev_run_todo+0x461/0x1000 net/core/dev.c:10894 rtnl_unlock net/core/rtnetlink.c:152 [inline] rtnl_net_unlock include/linux/rtnetlink.h:133 [inline] rtnl_dellink+0x760/0x8d0 net/core/rtnetlink.c:3520 rtnetlink_rcv_msg+0x791/0xcf0 net/core/rtnetlink.c:6911 netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2541 netlink_unicast_kernel net/netlink/af_netlink.c:1321 [inline] netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1347 netlink_sendmsg+0x8e4/0xcb0 net/netlink/af_netlink.c:1891 sock_sendmsg_nosec net/socket.c:711 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:726 ____sys_sendmsg+0x52a/0x7e0 net/socket.c:2583 ___sys_sendmsg net/socket.c:2637 [inline] __sys_sendmsg+0x269/0x350 net/socket.c:2669 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f2a3cb80809 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f2a3d9cd058 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f2a3cd45fa0 RCX: 00007f2a3cb80809 RDX: 0000000000000000 RSI: 0000000020000000 RDI: 0000000000000008 RBP: 00007f2a3cbf393e R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f2a3cd45fa0 R15: 00007ffd03bc65c8 </TASK> Allocated by task 5339: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314 kmalloc_noprof include/linux/slab.h:901 [inline] kmalloc_array_noprof include/linux/slab.h:945 [inline] netdev_create_hash net/core/dev.c:11870 [inline] netdev_init+0x10c/0x250 net/core/dev.c:11890 ops_init+0x31e/0x590 net/core/net_namespace.c:138 setup_net+0x287/0x9e0 net/core/net_namespace.c:362 copy_net_ns+0x33f/0x570 net/core/net_namespace.c:500 create_new_namespaces+0x425/0x7b0 kernel/nsproxy.c:110 unshare_nsproxy_namespaces+0x124/0x180 kernel/nsproxy.c:228 ksys_unshare+0x57d/0xa70 kernel/fork.c:3314 __do_sys_unshare kernel/fork.c:3385 [inline] __se_sys_unshare kernel/fork.c:3383 [inline] __x64_sys_unshare+0x38/0x40 kernel/fork.c:3383 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x8 ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-018116": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix warning when unbinding If there is an error during some initialization related to firmware, the buffers dp->tx_ring[i].tx_status are released. However this is released again when the device is unbinded (ath12k_pci), and we get: WARNING: CPU: 0 PID: 2098 at mm/slub.c:4689 free_large_kmalloc+0x4d/0x80 Call Trace: free_large_kmalloc ath12k_dp_free ath12k_core_deinit ath12k_pci_remove ... The issue is always reproducible from a VM because the MSI addressing initialization is failing. In order to fix the issue, just set the buffers to NULL after releasing in order to avoid the double free.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-018200": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: 6fire: Release resources at card release The current 6fire code tries to release the resources right after the call of usb6fire_chip_abort(). But at this moment, the card object might be still in use (as we're calling snd_card_free_when_closed()). For avoid potential UAFs, move the release of resources to the card's private_free instead of the manual call of usb6fire_chip_destroy() at the USB disconnect callback.",
        "technologies": "Linux\nLinux Kernel 2.6.39 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-018112": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: mxs-dcp - Ensure payload is zero when using key slot We could leak stack memory through the payload field when running AES with a key from one of the hardware's key slots. Fix this by ensuring the payload field is set to 0 in such cases. This does not affect the common use case when the key is supplied from main memory via the descriptor payload.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.3 未満"
    },
    "JVNDB-2024-017947": {
        "title": "Linux Foundation の Yocto における OS コマンドインジェクションの脆弱性",
        "description": "Yocto Project is an open source collaboration project that helps developers create custom Linux-based systems regardless of the hardware architecture. In Yocto Projects Bitbake before 2.6.2 (before and included Yocto Project 4.3.1), with the Toaster server (included in bitbake) running, missing input validation allows an attacker to perform a remote code execution in the server's shell via a crafted HTTP request. Authentication is not necessary. Toaster server execution has to be specifically run and is not the default for Bitbake command line builds, it is only used for the Toaster web based user interface to Bitbake. The fix has been backported to the bitbake included with Yocto Project 5.0, 3.1.31, 4.0.16, and 4.3.2.",
        "technologies": "Linux Foundation\nYocto 3.1.31 未満\nYocto 3.2 以上 4.0.16 未満\nYocto 4.1 以上 4.3.2 未満"
    },
    "JVNDB-2024-018047": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: clk: mediatek: mt7622-apmixedsys: Fix an error handling path in clk_mt8135_apmixed_probe() 'clk_data' is allocated with mtk_devm_alloc_clk_data(). So calling mtk_free_clk_data() explicitly in the remove function would lead to a double-free. Remove the redundant call.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-018069": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: light: vcnl4035: fix information leak in triggered buffer The 'buffer' local array is used to push data to userspace from a triggered buffer, but it does not set an initial value for the single data element, which is an u16 aligned to 8 bytes. That leaves at least 4 bytes uninitialized even after writing an integer value with regmap_read(). Initialize the array to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 5.4.132 以上 5.4.290 未満\nLinux Kernel 5.10.50 以上 5.10.234 未満\nLinux Kernel 5.12.17 以上 5.13 未満\nLinux Kernel 5.13.2 以上 5.15.177 未満\nLinux Kernel 5.16 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-018088": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix information leak in btrfs_ioctl_logical_to_ino() Syzbot reported the following information leak for in btrfs_ioctl_logical_to_ino(): BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_user+0xbc/0x110 lib/usercopy.c:40 instrument_copy_to_user include/linux/instrumented.h:114 [inline] _copy_to_user+0xbc/0x110 lib/usercopy.c:40 copy_to_user include/linux/uaccess.h:191 [inline] btrfs_ioctl_logical_to_ino+0x440/0x750 fs/btrfs/ioctl.c:3499 btrfs_ioctl+0x714/0x1260 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:904 [inline] __se_sys_ioctl+0x261/0x450 fs/ioctl.c:890 __x64_sys_ioctl+0x96/0xe0 fs/ioctl.c:890 x64_sys_call+0x1883/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:17 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: __kmalloc_large_node+0x231/0x370 mm/slub.c:3921 __do_kmalloc_node mm/slub.c:3954 [inline] __kmalloc_node+0xb07/0x1060 mm/slub.c:3973 kmalloc_node include/linux/slab.h:648 [inline] kvmalloc_node+0xc0/0x2d0 mm/util.c:634 kvmalloc include/linux/slab.h:766 [inline] init_data_container+0x49/0x1e0 fs/btrfs/backref.c:2779 btrfs_ioctl_logical_to_ino+0x17c/0x750 fs/btrfs/ioctl.c:3480 btrfs_ioctl+0x714/0x1260 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:904 [inline] __se_sys_ioctl+0x261/0x450 fs/ioctl.c:890 __x64_sys_ioctl+0x96/0xe0 fs/ioctl.c:890 x64_sys_call+0x1883/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:17 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Bytes 40-65535 of 65536 are uninitialized Memory access of size 65536 starts at ffff888045a40000 This happens, because we're copying a 'struct btrfs_data_container' back to user-space. This btrfs_data_container is allocated in 'init_data_container()' via kvmalloc(), which does not zero-fill the memory. Fix this by using kvzalloc() which zeroes out the memory on allocation.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19.313 未満\nLinux Kernel 4.20 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.158 未満\nLinux Kernel 5.16 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-019108": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: ti-ads8688: fix information leak in triggered buffer The 'buffer' local array is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the array to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 4.19.198 以上 4.20 未満\nLinux Kernel 5.4.132 以上 5.5 未満\nLinux Kernel 5.10.50 以上 5.11 未満\nLinux Kernel 5.12.17 以上 5.13 未満\nLinux Kernel 5.13.2 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-019120": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: pressure: zpa2326: fix information leak in triggered buffer The 'sample' local struct is used to push data to user space from a triggered buffer, but it has a hole between the temperature and the timestamp (u32 pressure, u16 temperature, GAP, u64 timestamp). This hole is never initialized. Initialize the struct to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015793": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: blk-cgroup: Fix UAF in blkcg_unpin_online() blkcg_unpin_online() walks up the blkcg hierarchy putting the online pin. To walk up, it uses blkcg_parent(blkcg) but it was calling that after blkcg_destroy_blkgs(blkcg) which could free the blkcg, leading to the following UAF: ================================================================== BUG: KASAN: slab-use-after-free in blkcg_unpin_online+0x15a/0x270 Read of size 8 at addr ffff8881057678c0 by task kworker/9:1/117 CPU: 9 UID: 0 PID: 117 Comm: kworker/9:1 Not tainted 6.13.0-rc1-work-00182-gb8f52214c61a-dirty #48 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS unknown 02/02/2022 Workqueue: cgwb_release cgwb_release_workfn Call Trace: <TASK> dump_stack_lvl+0x27/0x80 print_report+0x151/0x710 kasan_report+0xc0/0x100 blkcg_unpin_online+0x15a/0x270 cgwb_release_workfn+0x194/0x480 process_scheduled_works+0x71b/0xe20 worker_thread+0x82a/0xbd0 kthread+0x242/0x2c0 ret_from_fork+0x33/0x70 ret_from_fork_asm+0x1a/0x30 </TASK> ... Freed by task 1944: kasan_save_track+0x2b/0x70 kasan_save_free_info+0x3c/0x50 __kasan_slab_free+0x33/0x50 kfree+0x10c/0x330 css_free_rwork_fn+0xe6/0xb30 process_scheduled_works+0x71b/0xe20 worker_thread+0x82a/0xbd0 kthread+0x242/0x2c0 ret_from_fork+0x33/0x70 ret_from_fork_asm+0x1a/0x30 Note that the UAF is not easy to trigger as the free path is indirected behind a couple RCU grace periods and a work item execution. I could only trigger it with artifical msleep() injected in blkcg_unpin_online(). Fix it by reading the parent pointer before destroying the blkcg's blkg's.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 6.1.121 未満\nLinux Kernel 6.2 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015890": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btusb: mediatek: Fix double free of skb in coredump hci_devcd_append() would free the skb on error so the caller don't have to free it again otherwise it would cause the double free of skb. Reported-by : Dan Carpenter <dan.carpenter@linaro.org>",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015893": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rds: tcp: Fix use-after-free of net in reqsk_timer_handler(). syzkaller reported a warning of netns tracker [0] followed by KASAN splat [1] and another ref tracker warning [1]. syzkaller could not find a repro, but in the log, the only suspicious sequence was as follows: 18:26:22 executing program 1: r0 = socket$inet6_mptcp(0xa, 0x1, 0x106) ... connect$inet6(r0, &(0x7f0000000080)={0xa, 0x4001, 0x0, @loopback}, 0x1c) (async) The notable thing here is 0x4001 in connect(), which is RDS_TCP_PORT. So, the scenario would be: 1. unshare(CLONE_NEWNET) creates a per netns tcp listener in rds_tcp_listen_init(). 2. syz-executor connect()s to it and creates a reqsk. 3. syz-executor exit()s immediately. 4. netns is dismantled. [0] 5. reqsk timer is fired, and UAF happens while freeing reqsk. [1] 6. listener is freed after RCU grace period. [2] Basically, reqsk assumes that the listener guarantees netns safety until all reqsk timers are expired by holding the listener's refcount. However, this was not the case for kernel sockets. Commit 740ea3c4a0b2 (\"tcp: Clean up kernel listener's reqsk in inet_twsk_purge()\") fixed this issue only for per-netns ehash. Let's apply the same fix for the global ehash. [0]: ref_tracker: net notrefcnt@0000000065449cc3 has 1/1 users at sk_alloc (./include/net/net_namespace.h:337 net/core/sock.c:2146) inet6_create (net/ipv6/af_inet6.c:192 net/ipv6/af_inet6.c:119) __sock_create (net/socket.c:1572) rds_tcp_listen_init (net/rds/tcp_listen.c:279) rds_tcp_init_net (net/rds/tcp.c:577) ops_init (net/core/net_namespace.c:137) setup_net (net/core/net_namespace.c:340) copy_net_ns (net/core/net_namespace.c:497) create_new_namespaces (kernel/nsproxy.c:110) unshare_nsproxy_namespaces (kernel/nsproxy.c:228 (discriminator 4)) ksys_unshare (kernel/fork.c:3429) __x64_sys_unshare (kernel/fork.c:3496) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129) ... WARNING: CPU: 0 PID: 27 at lib/ref_tracker.c:179 ref_tracker_dir_exit (lib/ref_tracker.c:179) [1]: BUG: KASAN: slab-use-after-free in inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966) Read of size 8 at addr ffff88801b370400 by task swapper/0/0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 Call Trace: <IRQ> dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1)) print_report (mm/kasan/report.c:378 mm/kasan/report.c:488) kasan_report (mm/kasan/report.c:603) inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966) reqsk_timer_handler (net/ipv4/inet_connection_sock.c:979 net/ipv4/inet_connection_sock.c:1092) call_timer_fn (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/timer.h:127 kernel/time/timer.c:1701) __run_timers.part.0 (kernel/time/timer.c:1752 kernel/time/timer.c:2038) run_timer_softirq (kernel/time/timer.c:2053) __do_softirq (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/irq.h:142 kernel/softirq.c:554) irq_exit_rcu (kernel/softirq.c:427 kernel/softirq.c:632 kernel/softirq.c:644) sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1076 (discriminator 14)) </IRQ> Allocated by task 258 on cpu 0 at 83.612050s: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:68) __kasan_slab_alloc (mm/kasan/common.c:343) kmem_cache_alloc (mm/slub.c:3813 mm/slub.c:3860 mm/slub.c:3867) copy_net_ns (./include/linux/slab.h:701 net/core/net_namespace.c:421 net/core/net_namespace.c:480) create_new_namespaces (kernel/nsproxy.c:110) unshare_nsproxy_name ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.3 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015976": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_dump_full_key() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015994": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: msft: fix slab-use-after-free in msft_do_close() Tying the msft->data lifetime to hdev by freeing it in hci_release_dev() to fix the following case: [use] msft_do_close() msft = hdev->msft_data; if (!msft) ...(1) <- passed. return; mutex_lock(&msft->filter_lock); ...(4) <- used after freed. [free] msft_unregister() msft = hdev->msft_data; hdev->msft_data = NULL; ...(2) kfree(msft); ...(3) <- msft is freed. ================================================================== BUG: KASAN: slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c:587 [inline] BUG: KASAN: slab-use-after-free in __mutex_lock+0x8f/0xc30 kernel/locking/mutex.c:752 Read of size 8 at addr ffff888106cbbca8 by task kworker/u5:2/309",
        "technologies": "Linux\nLinux Kernel 5.12 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015982": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: llc: call sock_orphan() at release time syzbot reported an interesting trace [1] caused by a stale sk->sk_wq pointer in a closed llc socket. In commit ff7b11aa481f (\"net: socket: set sock->sk to NULL after calling proto_ops::release()\") Eric Biggers hinted that some protocols are missing a sock_orphan(), we need to perform a full audit. In net-next, I plan to clear sock->sk from sock_orphan() and amend Eric patch to add a warning. [1] BUG: KASAN: slab-use-after-free in list_empty include/linux/list.h:373 [inline] BUG: KASAN: slab-use-after-free in waitqueue_active include/linux/wait.h:127 [inline] BUG: KASAN: slab-use-after-free in sock_def_write_space_wfree net/core/sock.c:3384 [inline] BUG: KASAN: slab-use-after-free in sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468 Read of size 8 at addr ffff88802f4fc880 by task ksoftirqd/1/27 CPU: 1 PID: 27 Comm: ksoftirqd/1 Not tainted 6.8.0-rc1-syzkaller-00049-g6098d87eaf31 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:377 [inline] print_report+0xc4/0x620 mm/kasan/report.c:488 kasan_report+0xda/0x110 mm/kasan/report.c:601 list_empty include/linux/list.h:373 [inline] waitqueue_active include/linux/wait.h:127 [inline] sock_def_write_space_wfree net/core/sock.c:3384 [inline] sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468 skb_release_head_state+0xa3/0x2b0 net/core/skbuff.c:1080 skb_release_all net/core/skbuff.c:1092 [inline] napi_consume_skb+0x119/0x2b0 net/core/skbuff.c:1404 e1000_unmap_and_free_tx_resource+0x144/0x200 drivers/net/ethernet/intel/e1000/e1000_main.c:1970 e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3860 [inline] e1000_clean+0x4a1/0x26e0 drivers/net/ethernet/intel/e1000/e1000_main.c:3801 __napi_poll.constprop.0+0xb4/0x540 net/core/dev.c:6576 napi_poll net/core/dev.c:6645 [inline] net_rx_action+0x956/0xe90 net/core/dev.c:6778 __do_softirq+0x21a/0x8de kernel/softirq.c:553 run_ksoftirqd kernel/softirq.c:921 [inline] run_ksoftirqd+0x31/0x60 kernel/softirq.c:913 smpboot_thread_fn+0x660/0xa10 kernel/smpboot.c:164 kthread+0x2c6/0x3a0 kernel/kthread.c:388 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242 </TASK> Allocated by task 5167: kasan_save_stack+0x33/0x50 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 unpoison_slab_object mm/kasan/common.c:314 [inline] __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:340 kasan_slab_alloc include/linux/kasan.h:201 [inline] slab_post_alloc_hook mm/slub.c:3813 [inline] slab_alloc_node mm/slub.c:3860 [inline] kmem_cache_alloc_lru+0x142/0x6f0 mm/slub.c:3879 alloc_inode_sb include/linux/fs.h:3019 [inline] sock_alloc_inode+0x25/0x1c0 net/socket.c:308 alloc_inode+0x5d/0x220 fs/inode.c:260 new_inode_pseudo+0x16/0x80 fs/inode.c:1005 sock_alloc+0x40/0x270 net/socket.c:634 __sock_create+0xbc/0x800 net/socket.c:1535 sock_create net/socket.c:1622 [inline] __sys_socket_create net/socket.c:1659 [inline] __sys_socket+0x14c/0x260 net/socket.c:1706 __do_sys_socket net/socket.c:1720 [inline] __se_sys_socket net/socket.c:1718 [inline] __x64_sys_socket+0x72/0xb0 net/socket.c:1718 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xd3/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b Freed by task 0: kasan_save_stack+0x33/0x50 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 kasan_save_free_info+0x3f/0x60 mm/kasan/generic.c:640 poison_slab_object mm/kasan/common.c:241 [inline] __kasan_slab_free+0x121/0x1b0 mm/kasan/common.c:257 kasan_slab_free include/linux/kasan.h:184 [inline] slab_free_hook mm/slub.c:2121 [inlin ---truncated---",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.35 以上 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-015892": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: fix double-free bug The storage for the TLV PC register data wasn't done like all the other storage in the drv->fw area, which is cleared at the end of deallocation. Therefore, the freeing must also be done differently, explicitly NULL'ing it out after the free, since otherwise there's a nasty double-free bug here if a file fails to load after this has been parsed, and we get another free later (e.g. because no other file exists.) Fix that by adding the missing NULL assignment.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.18 未満\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-015898": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath9k: add range check for conn_rsp_epid in htc_connect_service() I found the following bug in my fuzzer: UBSAN: array-index-out-of-bounds in drivers/net/wireless/ath/ath9k/htc_hst.c:26:51 index 255 is out of range for type 'htc_endpoint [22]' CPU: 0 UID: 0 PID: 8 Comm: kworker/0:0 Not tainted 6.11.0-rc6-dirty #14 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Workqueue: events request_firmware_work_func Call Trace: <TASK> dump_stack_lvl+0x180/0x1b0 __ubsan_handle_out_of_bounds+0xd4/0x130 htc_issue_send.constprop.0+0x20c/0x230 ? _raw_spin_unlock_irqrestore+0x3c/0x70 ath9k_wmi_cmd+0x41d/0x610 ? mark_held_locks+0x9f/0xe0 ... Since this bug has been confirmed to be caused by insufficient verification of conn_rsp_epid, I think it would be appropriate to add a range check for conn_rsp_epid to htc_connect_service() to prevent the bug from occurring.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-015975": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in smb2_is_valid_lease_break() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015897": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Fix out of bounds reads when finding clock sources The current USB-audio driver code doesn't check bLength of each descriptor at traversing for clock descriptors. That is, when a device provides a bogus descriptor with a shorter bLength, the driver might hit out-of-bounds reads. For addressing it, this patch adds sanity checks to the validator functions for the clock descriptor traversal. When the descriptor length is shorter than expected, it's skipped in the loop. For the clock source and clock multiplier descriptors, we can just check bLength against the sizeof() of each descriptor type. OTOH, the clock selector descriptor of UAC2 and UAC3 has an array of bNrInPins elements and two more fields at its tail, hence those have to be checked in addition to the sizeof() check.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016007": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: fix uninitialized value in ocfs2_file_read_iter() Syzbot has reported the following KMSAN splat: BUG: KMSAN: uninit-value in ocfs2_file_read_iter+0x9a4/0xf80 ocfs2_file_read_iter+0x9a4/0xf80 __io_read+0x8d4/0x20f0 io_read+0x3e/0xf0 io_issue_sqe+0x42b/0x22c0 io_wq_submit_work+0xaf9/0xdc0 io_worker_handle_work+0xd13/0x2110 io_wq_worker+0x447/0x1410 ret_from_fork+0x6f/0x90 ret_from_fork_asm+0x1a/0x30 Uninit was created at: __alloc_pages_noprof+0x9a7/0xe00 alloc_pages_mpol_noprof+0x299/0x990 alloc_pages_noprof+0x1bf/0x1e0 allocate_slab+0x33a/0x1250 ___slab_alloc+0x12ef/0x35e0 kmem_cache_alloc_bulk_noprof+0x486/0x1330 __io_alloc_req_refill+0x84/0x560 io_submit_sqes+0x172f/0x2f30 __se_sys_io_uring_enter+0x406/0x41c0 __x64_sys_io_uring_enter+0x11f/0x1a0 x64_sys_call+0x2b54/0x3ba0 do_syscall_64+0xcd/0x1e0 entry_SYSCALL_64_after_hwframe+0x77/0x7f Since an instance of 'struct kiocb' may be passed from the block layer with 'private' field uninitialized, introduce 'ocfs2_iocb_init_rw_locked()' and use it from where 'ocfs2_dio_end_io()' might take care, i.e. in 'ocfs2_file_read_iter()' and 'ocfs2_file_write_iter()'.",
        "technologies": "Linux\nLinux Kernel 2.6.22 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-015886": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: do not leave a dangling sk pointer in __smc_create() Thanks to commit 4bbd360a5084 (\"socket: Print pf->create() when it does not clear sock->sk on failure.\"), syzbot found an issue with AF_SMC: smc_create must clear sock->sk on failure, family: 43, type: 1, protocol: 0 WARNING: CPU: 0 PID: 5827 at net/socket.c:1565 __sock_create+0x96f/0xa30 net/socket.c:1563 Modules linked in: CPU: 0 UID: 0 PID: 5827 Comm: syz-executor259 Not tainted 6.12.0-rc6-next-20241106-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 RIP: 0010:__sock_create+0x96f/0xa30 net/socket.c:1563 Code: 03 00 74 08 4c 89 e7 e8 4f 3b 85 f8 49 8b 34 24 48 c7 c7 40 89 0c 8d 8b 54 24 04 8b 4c 24 0c 44 8b 44 24 08 e8 32 78 db f7 90 <0f> 0b 90 90 e9 d3 fd ff ff 89 e9 80 e1 07 fe c1 38 c1 0f 8c ee f7 RSP: 0018:ffffc90003e4fda0 EFLAGS: 00010246 RAX: 099c6f938c7f4700 RBX: 1ffffffff1a595fd RCX: ffff888034823c00 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000 RBP: 00000000ffffffe9 R08: ffffffff81567052 R09: 1ffff920007c9f50 R10: dffffc0000000000 R11: fffff520007c9f51 R12: ffffffff8d2cafe8 R13: 1ffffffff1a595fe R14: ffffffff9a789c40 R15: ffff8880764298c0 FS: 000055557b518380(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fa62ff43225 CR3: 0000000031628000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> sock_create net/socket.c:1616 [inline] __sys_socket_create net/socket.c:1653 [inline] __sys_socket+0x150/0x3c0 net/socket.c:1700 __do_sys_socket net/socket.c:1714 [inline] __se_sys_socket net/socket.c:1712 [inline] For reference, see commit 2d859aff775d (\"Merge branch 'do-not-leave-dangling-sk-pointers-in-pf-create-functions'\")",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-015894": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_debug_files_proc_show() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016229": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: EDAC/igen6: Avoid segmentation fault on module unload The segmentation fault happens because: During modprobe: 1. In igen6_probe(), igen6_pvt will be allocated with kzalloc() 2. In igen6_register_mci(), mci->pvt_info will point to &igen6_pvt->imc[mc] During rmmod: 1. In mci_release() in edac_mc.c, it will kfree(mci->pvt_info) 2. In igen6_remove(), it will kfree(igen6_pvt); Fix this issue by setting mci->pvt_info to NULL to avoid the double kfree.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016360": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tipc: Fix use-after-free of kernel socket in cleanup_bearer(). syzkaller reported a use-after-free of UDP kernel socket in cleanup_bearer() without repro. [0][1] When bearer_disable() calls tipc_udp_disable(), cleanup of the UDP kernel socket is deferred by work calling cleanup_bearer(). tipc_exit_net() waits for such works to finish by checking tipc_net(net)->wq_count. However, the work decrements the count too early before releasing the kernel socket, unblocking cleanup_net() and resulting in use-after-free. Let's move the decrement after releasing the socket in cleanup_bearer(). [0]: ref_tracker: net notrefcnt@000000009b3d1faf has 1/1 users at sk_alloc+0x438/0x608 inet_create+0x4c8/0xcb0 __sock_create+0x350/0x6b8 sock_create_kern+0x58/0x78 udp_sock_create4+0x68/0x398 udp_sock_create+0x88/0xc8 tipc_udp_enable+0x5e8/0x848 __tipc_nl_bearer_enable+0x84c/0xed8 tipc_nl_bearer_enable+0x38/0x60 genl_family_rcv_msg_doit+0x170/0x248 genl_rcv_msg+0x400/0x5b0 netlink_rcv_skb+0x1dc/0x398 genl_rcv+0x44/0x68 netlink_unicast+0x678/0x8b0 netlink_sendmsg+0x5e4/0x898 ____sys_sendmsg+0x500/0x830 [1]: BUG: KMSAN: use-after-free in udp_hashslot include/net/udp.h:85 [inline] BUG: KMSAN: use-after-free in udp_lib_unhash+0x3b8/0x930 net/ipv4/udp.c:1979 udp_hashslot include/net/udp.h:85 [inline] udp_lib_unhash+0x3b8/0x930 net/ipv4/udp.c:1979 sk_common_release+0xaf/0x3f0 net/core/sock.c:3820 inet_release+0x1e0/0x260 net/ipv4/af_inet.c:437 inet6_release+0x6f/0xd0 net/ipv6/af_inet6.c:489 __sock_release net/socket.c:658 [inline] sock_release+0xa0/0x210 net/socket.c:686 cleanup_bearer+0x42d/0x4c0 net/tipc/udp_media.c:819 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xcaf/0x1c90 kernel/workqueue.c:3310 worker_thread+0xf6c/0x1510 kernel/workqueue.c:3391 kthread+0x531/0x6b0 kernel/kthread.c:389 ret_from_fork+0x60/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:244 Uninit was created at: slab_free_hook mm/slub.c:2269 [inline] slab_free mm/slub.c:4580 [inline] kmem_cache_free+0x207/0xc40 mm/slub.c:4682 net_free net/core/net_namespace.c:454 [inline] cleanup_net+0x16f2/0x19d0 net/core/net_namespace.c:647 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xcaf/0x1c90 kernel/workqueue.c:3310 worker_thread+0xf6c/0x1510 kernel/workqueue.c:3391 kthread+0x531/0x6b0 kernel/kthread.c:389 ret_from_fork+0x60/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:244 CPU: 0 UID: 0 PID: 54 Comm: kworker/0:2 Not tainted 6.12.0-rc1-00131-gf66ebf37d69c #7 91723d6f74857f70725e1583cba3cf4adc716cfa Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 Workqueue: events cleanup_bearer",
        "technologies": "Linux\nLinux Kernel 4.2 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016248": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btmtk: avoid UAF in btmtk_process_coredump hci_devcd_append may lead to the release of the skb, so it cannot be accessed once it is called. ================================================================== BUG: KASAN: slab-use-after-free in btmtk_process_coredump+0x2a7/0x2d0 [btmtk] Read of size 4 at addr ffff888033cfabb0 by task kworker/0:3/82 CPU: 0 PID: 82 Comm: kworker/0:3 Tainted: G U 6.6.40-lockdep-03464-g1d8b4eb3060e #1 b0b3c1cc0c842735643fb411799d97921d1f688c Hardware name: Google Yaviks_Ufs/Yaviks_Ufs, BIOS Google_Yaviks_Ufs.15217.552.0 05/07/2024 Workqueue: events btusb_rx_work [btusb] Call Trace: <TASK> dump_stack_lvl+0xfd/0x150 print_report+0x131/0x780 kasan_report+0x177/0x1c0 btmtk_process_coredump+0x2a7/0x2d0 [btmtk 03edd567dd71a65958807c95a65db31d433e1d01] btusb_recv_acl_mtk+0x11c/0x1a0 [btusb 675430d1e87c4f24d0c1f80efe600757a0f32bec] btusb_rx_work+0x9e/0xe0 [btusb 675430d1e87c4f24d0c1f80efe600757a0f32bec] worker_thread+0xe44/0x2cc0 kthread+0x2ff/0x3a0 ret_from_fork+0x51/0x80 ret_from_fork_asm+0x1b/0x30 </TASK> Allocated by task 82: stack_trace_save+0xdc/0x190 kasan_set_track+0x4e/0x80 __kasan_slab_alloc+0x4e/0x60 kmem_cache_alloc+0x19f/0x360 skb_clone+0x132/0xf70 btusb_recv_acl_mtk+0x104/0x1a0 [btusb] btusb_rx_work+0x9e/0xe0 [btusb] worker_thread+0xe44/0x2cc0 kthread+0x2ff/0x3a0 ret_from_fork+0x51/0x80 ret_from_fork_asm+0x1b/0x30 Freed by task 1733: stack_trace_save+0xdc/0x190 kasan_set_track+0x4e/0x80 kasan_save_free_info+0x28/0xb0 ____kasan_slab_free+0xfd/0x170 kmem_cache_free+0x183/0x3f0 hci_devcd_rx+0x91a/0x2060 [bluetooth] worker_thread+0xe44/0x2cc0 kthread+0x2ff/0x3a0 ret_from_fork+0x51/0x80 ret_from_fork_asm+0x1b/0x30 The buggy address belongs to the object at ffff888033cfab40 which belongs to the cache skbuff_head_cache of size 232 The buggy address is located 112 bytes inside of freed 232-byte region [ffff888033cfab40, ffff888033cfac28) The buggy address belongs to the physical page: page:00000000a174ba93 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x33cfa head:00000000a174ba93 order:1 entire_mapcount:0 nr_pages_mapped:0 pincount:0 anon flags: 0x4000000000000840(slab|head|zone=1) page_type: 0xffffffff() raw: 4000000000000840 ffff888100848a00 0000000000000000 0000000000000001 raw: 0000000000000000 0000000080190019 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888033cfaa80: fb fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc ffff888033cfab00: fc fc fc fc fc fc fc fc fa fb fb fb fb fb fb fb >ffff888033cfab80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff888033cfac00: fb fb fb fb fb fc fc fc fc fc fc fc fc fc fc fc ffff888033cfac80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ================================================================== Check if we need to call hci_devcd_complete before calling hci_devcd_append. That requires that we check data->cd_info.cnt >= MTK_COREDUMP_NUM instead of data->cd_info.cnt > MTK_COREDUMP_NUM, as we increment data->cd_info.cnt only once the call to hci_devcd_append succeeds.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016353": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix use-after-free in ath12k_dp_cc_cleanup() During ath12k module removal, in ath12k_core_deinit(), ath12k_mac_destroy() un-registers ah->hw from mac80211 and frees the ah->hw as well as all the ar's in it. After this ath12k_core_soc_destroy()-> ath12k_dp_free()-> ath12k_dp_cc_cleanup() tries to access one of the freed ar's from pending skb. This is because during mac destroy, driver failed to flush few data packets, which were accessed later in ath12k_dp_cc_cleanup() and freed, but using ar from the packet led to this use-after-free. BUG: KASAN: use-after-free in ath12k_dp_cc_cleanup.part.0+0x5e2/0xd40 [ath12k] Write of size 4 at addr ffff888150bd3514 by task modprobe/8926 CPU: 0 UID: 0 PID: 8926 Comm: modprobe Not tainted 6.11.0-rc2-wt-ath+ #1746 Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021 Call Trace: <TASK> dump_stack_lvl+0x7d/0xe0 print_address_description.constprop.0+0x33/0x3a0 print_report+0xb5/0x260 ? kasan_addr_to_slab+0x24/0x80 kasan_report+0xd8/0x110 ? ath12k_dp_cc_cleanup.part.0+0x5e2/0xd40 [ath12k] ? ath12k_dp_cc_cleanup.part.0+0x5e2/0xd40 [ath12k] kasan_check_range+0xf3/0x1a0 __kasan_check_write+0x14/0x20 ath12k_dp_cc_cleanup.part.0+0x5e2/0xd40 [ath12k] ath12k_dp_free+0x178/0x420 [ath12k] ath12k_core_stop+0x176/0x200 [ath12k] ath12k_core_deinit+0x13f/0x210 [ath12k] ath12k_pci_remove+0xad/0x1c0 [ath12k] pci_device_remove+0x9b/0x1b0 device_remove+0xbf/0x150 device_release_driver_internal+0x3c3/0x580 ? __kasan_check_read+0x11/0x20 driver_detach+0xc4/0x190 bus_remove_driver+0x130/0x2a0 driver_unregister+0x68/0x90 pci_unregister_driver+0x24/0x240 ? find_module_all+0x13e/0x1e0 ath12k_pci_exit+0x10/0x20 [ath12k] __do_sys_delete_module+0x32c/0x580 ? module_flags+0x2f0/0x2f0 ? kmem_cache_free+0xf0/0x410 ? __fput+0x56f/0xab0 ? __fput+0x56f/0xab0 ? debug_smp_processor_id+0x17/0x20 __x64_sys_delete_module+0x4f/0x70 x64_sys_call+0x522/0x9f0 do_syscall_64+0x64/0x130 entry_SYSCALL_64_after_hwframe+0x4b/0x53 RIP: 0033:0x7f8182c6ac8b Commit 24de1b7b231c (\"wifi: ath12k: fix flush failure in recovery scenarios\") added the change to decrement the pending packets count in case of recovery which make sense as ah->hw as well all ar's in it are intact during recovery, but during core deinit there is no use in decrementing packets count or waking up the empty waitq as the module is going to be removed also ar's from pending skb's can't be used and the packets should just be released back. To fix this, avoid accessing ar from skb->cb when driver is being unregistered. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.1.1-00214-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016222": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: act_mirred: don't override retval if we already lost the skb If we're redirecting the skb, and haven't called tcf_mirred_forward(), yet, we need to tell the core to drop the skb by setting the retcode to SHOT. If we have called tcf_mirred_forward(), however, the skb is out of our hands and returning SHOT will lead to UaF. Move the retval override to the error path which actually need it.",
        "technologies": "Linux\nLinux Kernel 4.19 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016564": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Adding array index check to prevent memory corruption [Why & How] Array indices out of bound caused memory corruption. Adding checks to ensure that array index stays in bound.",
        "technologies": "Linux\nLinux Kernel 6.12.5 未満"
    },
    "JVNDB-2024-016496": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix out-of-bounds access in 'dcn21_link_encoder_create' An issue was identified in the dcn21_link_encoder_create function where an out-of-bounds access could occur when the hpd_source index was used to reference the link_enc_hpd_regs array. This array has a fixed size and the index was not being checked against the array's bounds before accessing it. This fix adds a conditional check to ensure that the hpd_source index is within the valid range of the link_enc_hpd_regs array. If the index is out of bounds, the function now returns NULL to prevent undefined behavior. References: [ 65.920507] ------------[ cut here ]------------ [ 65.920510] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn21/dcn21_resource.c:1312:29 [ 65.920519] index 7 is out of range for type 'dcn10_link_enc_hpd_registers [5]' [ 65.920523] CPU: 3 PID: 1178 Comm: modprobe Tainted: G OE 6.8.0-cleanershaderfeatureresetasdntipmi200nv2132 #13 [ 65.920525] Hardware name: AMD Majolica-RN/Majolica-RN, BIOS WMJ0429N_Weekly_20_04_2 04/29/2020 [ 65.920527] Call Trace: [ 65.920529] <TASK> [ 65.920532] dump_stack_lvl+0x48/0x70 [ 65.920541] dump_stack+0x10/0x20 [ 65.920543] __ubsan_handle_out_of_bounds+0xa2/0xe0 [ 65.920549] dcn21_link_encoder_create+0xd9/0x140 [amdgpu] [ 65.921009] link_create+0x6d3/0xed0 [amdgpu] [ 65.921355] create_links+0x18a/0x4e0 [amdgpu] [ 65.921679] dc_create+0x360/0x720 [amdgpu] [ 65.921999] ? dmi_matches+0xa0/0x220 [ 65.922004] amdgpu_dm_init+0x2b6/0x2c90 [amdgpu] [ 65.922342] ? console_unlock+0x77/0x120 [ 65.922348] ? dev_printk_emit+0x86/0xb0 [ 65.922354] dm_hw_init+0x15/0x40 [amdgpu] [ 65.922686] amdgpu_device_init+0x26a8/0x33a0 [amdgpu] [ 65.922921] amdgpu_driver_load_kms+0x1b/0xa0 [amdgpu] [ 65.923087] amdgpu_pci_probe+0x1b7/0x630 [amdgpu] [ 65.923087] local_pci_probe+0x4b/0xb0 [ 65.923087] pci_device_probe+0xc8/0x280 [ 65.923087] really_probe+0x187/0x300 [ 65.923087] __driver_probe_device+0x85/0x130 [ 65.923087] driver_probe_device+0x24/0x110 [ 65.923087] __driver_attach+0xac/0x1d0 [ 65.923087] ? __pfx___driver_attach+0x10/0x10 [ 65.923087] bus_for_each_dev+0x7d/0xd0 [ 65.923087] driver_attach+0x1e/0x30 [ 65.923087] bus_add_driver+0xf2/0x200 [ 65.923087] driver_register+0x64/0x130 [ 65.923087] ? __pfx_amdgpu_init+0x10/0x10 [amdgpu] [ 65.923087] __pci_register_driver+0x61/0x70 [ 65.923087] amdgpu_init+0x7d/0xff0 [amdgpu] [ 65.923087] do_one_initcall+0x49/0x310 [ 65.923087] ? kmalloc_trace+0x136/0x360 [ 65.923087] do_init_module+0x6a/0x270 [ 65.923087] load_module+0x1fce/0x23a0 [ 65.923087] init_module_from_file+0x9c/0xe0 [ 65.923087] ? init_module_from_file+0x9c/0xe0 [ 65.923087] idempotent_init_module+0x179/0x230 [ 65.923087] __x64_sys_finit_module+0x5d/0xa0 [ 65.923087] do_syscall_64+0x76/0x120 [ 65.923087] entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 65.923087] RIP: 0033:0x7f2d80f1e88d [ 65.923087] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48 [ 65.923087] RSP: 002b:00007ffc7bc1aa78 EFLAGS: 00000246 ORIG_RAX: 0000000000000139 [ 65.923087] RAX: ffffffffffffffda RBX: 0000564c9c1db130 RCX: 00007f2d80f1e88d [ 65.923087] RDX: 0000000000000000 RSI: 0000564c9c1e5480 RDI: 000000000000000f [ 65.923087] RBP: 0000000000040000 R08: 0000000000000000 R09: 0000000000000002 [ 65.923087] R10: 000000000000000f R11: 0000000000000246 R12: 0000564c9c1e5480 [ 65.923087] R13: 0000564c9c1db260 R14: 0000000000000000 R15: 0000564c9c1e54b0 [ 65.923087] </TASK> [ 65.923927] ---[ end trace ]---",
        "technologies": "Linux\nLinux Kernel 6.12.5 未満"
    },
    "JVNDB-2024-016376": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free when COWing tree bock and tracing is enabled When a COWing a tree block, at btrfs_cow_block(), and we have the tracepoint trace_btrfs_cow_block() enabled and preemption is also enabled (CONFIG_PREEMPT=y), we can trigger a use-after-free in the COWed extent buffer while inside the tracepoint code. This is because in some paths that call btrfs_cow_block(), such as btrfs_search_slot(), we are holding the last reference on the extent buffer @buf so btrfs_force_cow_block() drops the last reference on the @buf extent buffer when it calls free_extent_buffer_stale(buf), which schedules the release of the extent buffer with RCU. This means that if we are on a kernel with preemption, the current task may be preempted before calling trace_btrfs_cow_block() and the extent buffer already released by the time trace_btrfs_cow_block() is called, resulting in a use-after-free. Fix this by moving the trace_btrfs_cow_block() from btrfs_cow_block() to btrfs_force_cow_block() before the COWed extent buffer is freed. This also has a side effect of invoking the tracepoint in the tree defrag code, at defrag.c:btrfs_realloc_node(), since btrfs_force_cow_block() is called there, but this is fine and it was actually missing there.",
        "technologies": "Linux\nLinux Kernel 6.12.8 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016563": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: af_packet: avoid erroring out after sock_init_data() in packet_create() After sock_init_data() the allocated sk object is attached to the provided sock object. On error, packet_create() frees the sk object leaving the dangling pointer in the sock object on return. Some other code may try to use this pointer and cause use-after-free.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016380": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: bfa: Fix use-after-free in bfad_im_module_exit() BUG: KASAN: slab-use-after-free in __lock_acquire+0x2aca/0x3a20 Read of size 8 at addr ffff8881082d80c8 by task modprobe/25303 Call Trace: <TASK> dump_stack_lvl+0x95/0xe0 print_report+0xcb/0x620 kasan_report+0xbd/0xf0 __lock_acquire+0x2aca/0x3a20 lock_acquire+0x19b/0x520 _raw_spin_lock+0x2b/0x40 attribute_container_unregister+0x30/0x160 fc_release_transport+0x19/0x90 [scsi_transport_fc] bfad_im_module_exit+0x23/0x60 [bfa] bfad_init+0xdb/0xff0 [bfa] do_one_initcall+0xdc/0x550 do_init_module+0x22d/0x6b0 load_module+0x4e96/0x5ff0 init_module_from_file+0xcd/0x130 idempotent_init_module+0x330/0x620 __x64_sys_finit_module+0xb3/0x110 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f </TASK> Allocated by task 25303: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x7f/0x90 fc_attach_transport+0x4f/0x4740 [scsi_transport_fc] bfad_im_module_init+0x17/0x80 [bfa] bfad_init+0x23/0xff0 [bfa] do_one_initcall+0xdc/0x550 do_init_module+0x22d/0x6b0 load_module+0x4e96/0x5ff0 init_module_from_file+0xcd/0x130 idempotent_init_module+0x330/0x620 __x64_sys_finit_module+0xb3/0x110 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 25303: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x38/0x50 kfree+0x212/0x480 bfad_im_module_init+0x7e/0x80 [bfa] bfad_init+0x23/0xff0 [bfa] do_one_initcall+0xdc/0x550 do_init_module+0x22d/0x6b0 load_module+0x4e96/0x5ff0 init_module_from_file+0xcd/0x130 idempotent_init_module+0x330/0x620 __x64_sys_finit_module+0xb3/0x110 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f Above issue happens as follows: bfad_init error = bfad_im_module_init() fc_release_transport(bfad_im_scsi_transport_template); if (error) goto ext; ext: bfad_im_module_exit(); fc_release_transport(bfad_im_scsi_transport_template); --> Trigger double release Don't call bfad_im_module_exit() if bfad_im_module_init() failed.",
        "technologies": "Linux\nLinux Kernel 2.6.32 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016406": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mtd: rawnand: fix double free in atmel_pmecc_create_user() The \"user\" pointer was converted from being allocated with kzalloc() to being allocated by devm_kzalloc(). Calling kfree(user) will lead to a double free.",
        "technologies": "Linux\nLinux Kernel 4.19.325 以上 4.20 未満\nLinux Kernel 5.4.287 以上 5.5 未満\nLinux Kernel 5.10.231 以上 5.11 未満\nLinux Kernel 5.15.174 以上 5.16 未満\nLinux Kernel 6.1.120 以上 6.1.123 未満\nLinux Kernel 6.6.64 以上 6.6.69 未満\nLinux Kernel 6.11.11 以上 6.12 未満\nLinux Kernel 6.12.2 以上 6.12.8 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016377": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfs/localio: must clear res.replen in nfs_local_read_done Otherwise memory corruption can occur due to NFSv3 LOCALIO reads leaving garbage in res.replen: - nfs3_read_done() copies that into server->read_hdrsize; from there nfs3_proc_read_setup() copies it to args.replen in new requests. - nfs3_xdr_enc_read3args() passes that to rpc_prepare_reply_pages() which includes it in hdrsize for xdr_init_pages, so that rq_rcv_buf contains a ridiculous len. - This is copied to rq_private_buf and xs_read_stream_request() eventually passes the kvec to sock_recvmsg() which receives incoming data into entirely the wrong place. This is easily reproduced with NFSv3 LOCALIO that is servicing reads when it is made to pivot back to using normal RPC. This switch back to using normal NFSv3 with RPC can occur for a few reasons but this issue was exposed with a test that stops and then restarts the NFSv3 server while LOCALIO is performing heavy read IO.",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016492": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/pseries/vas: Add close() callback in vas_vm_ops struct The mapping VMA address is saved in VAS window struct when the paste address is mapped. This VMA address is used during migration to unmap the paste address if the window is active. The paste address mapping will be removed when the window is closed or with the munmap(). But the VMA address in the VAS window is not updated with munmap() which is causing invalid access during migration. The KASAN report shows: [16386.254991] BUG: KASAN: slab-use-after-free in reconfig_close_windows+0x1a0/0x4e8 [16386.255043] Read of size 8 at addr c00000014a819670 by task drmgr/696928 [16386.255096] CPU: 29 UID: 0 PID: 696928 Comm: drmgr Kdump: loaded Tainted: G B 6.11.0-rc5-nxgzip #2 [16386.255128] Tainted: [B]=BAD_PAGE [16386.255148] Hardware name: IBM,9080-HEX Power11 (architected) 0x820200 0xf000007 of:IBM,FW1110.00 (NH1110_016) hv:phyp pSeries [16386.255181] Call Trace: [16386.255202] [c00000016b297660] [c0000000018ad0ac] dump_stack_lvl+0x84/0xe8 (unreliable) [16386.255246] [c00000016b297690] [c0000000006e8a90] print_report+0x19c/0x764 [16386.255285] [c00000016b297760] [c0000000006e9490] kasan_report+0x128/0x1f8 [16386.255309] [c00000016b297880] [c0000000006eb5c8] __asan_load8+0xac/0xe0 [16386.255326] [c00000016b2978a0] [c00000000013f898] reconfig_close_windows+0x1a0/0x4e8 [16386.255343] [c00000016b297990] [c000000000140e58] vas_migration_handler+0x3a4/0x3fc [16386.255368] [c00000016b297a90] [c000000000128848] pseries_migrate_partition+0x4c/0x4c4 ... [16386.256136] Allocated by task 696554 on cpu 31 at 16377.277618s: [16386.256149] kasan_save_stack+0x34/0x68 [16386.256163] kasan_save_track+0x34/0x80 [16386.256175] kasan_save_alloc_info+0x58/0x74 [16386.256196] __kasan_slab_alloc+0xb8/0xdc [16386.256209] kmem_cache_alloc_noprof+0x200/0x3d0 [16386.256225] vm_area_alloc+0x44/0x150 [16386.256245] mmap_region+0x214/0x10c4 [16386.256265] do_mmap+0x5fc/0x750 [16386.256277] vm_mmap_pgoff+0x14c/0x24c [16386.256292] ksys_mmap_pgoff+0x20c/0x348 [16386.256303] sys_mmap+0xd0/0x160 ... [16386.256350] Freed by task 0 on cpu 31 at 16386.204848s: [16386.256363] kasan_save_stack+0x34/0x68 [16386.256374] kasan_save_track+0x34/0x80 [16386.256384] kasan_save_free_info+0x64/0x10c [16386.256396] __kasan_slab_free+0x120/0x204 [16386.256415] kmem_cache_free+0x128/0x450 [16386.256428] vm_area_free_rcu_cb+0xa8/0xd8 [16386.256441] rcu_do_batch+0x2c8/0xcf0 [16386.256458] rcu_core+0x378/0x3c4 [16386.256473] handle_softirqs+0x20c/0x60c [16386.256495] do_softirq_own_stack+0x6c/0x88 [16386.256509] do_softirq_own_stack+0x58/0x88 [16386.256521] __irq_exit_rcu+0x1a4/0x20c [16386.256533] irq_exit+0x20/0x38 [16386.256544] interrupt_async_exit_prepare.constprop.0+0x18/0x2c ... [16386.256717] Last potentially related work creation: [16386.256729] kasan_save_stack+0x34/0x68 [16386.256741] __kasan_record_aux_stack+0xcc/0x12c [16386.256753] __call_rcu_common.constprop.0+0x94/0xd04 [16386.256766] vm_area_free+0x28/0x3c [16386.256778] remove_vma+0xf4/0x114 [16386.256797] do_vmi_align_munmap.constprop.0+0x684/0x870 [16386.256811] __vm_munmap+0xe0/0x1f8 [16386.256821] sys_munmap+0x54/0x6c [16386.256830] system_call_exception+0x1a0/0x4a0 [16386.256841] system_call_vectored_common+0x15c/0x2ec [16386.256868] The buggy address belongs to the object at c00000014a819670 which belongs to the cache vm_area_struct of size 168 [16386.256887] The buggy address is located 0 bytes inside of freed 168-byte region [c00000014a819670, c00000014a819718) [16386.256915] The buggy address belongs to the physical page: [16386.256928] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x14a81 [16386.256950] memcg:c0000000ba430001 [16386.256961] anon flags: 0x43ffff800000000(node=4|zone=0|lastcpupid=0x7ffff) [16386.256975] page_type: 0xfdffffff(slab) [16386 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.123 未満\nLinux Kernel 6.2 以上 6.6.69 未満\nLinux Kernel 6.7 以上 6.12.8 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-012807": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: Fix use-after-free in get_info() ip6table_nat module unload has refcnt warning for UAF. call trace is: WARNING: CPU: 1 PID: 379 at kernel/module/main.c:853 module_put+0x6f/0x80 Modules linked in: ip6table_nat(-) CPU: 1 UID: 0 PID: 379 Comm: ip6tables Not tainted 6.12.0-rc4-00047-gc2ee9f594da8-dirty #205 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:module_put+0x6f/0x80 Call Trace: <TASK> get_info+0x128/0x180 do_ip6t_get_ctl+0x6a/0x430 nf_getsockopt+0x46/0x80 ipv6_getsockopt+0xb9/0x100 rawv6_getsockopt+0x42/0x190 do_sock_getsockopt+0xaa/0x180 __sys_getsockopt+0x70/0xc0 __x64_sys_getsockopt+0x20/0x30 do_syscall_64+0xa2/0x1a0 entry_SYSCALL_64_after_hwframe+0x77/0x7f Concurrent execution of module unload and get_info() trigered the warning. The root cause is as follows: cpu0 cpu1 module_exit //mod->state = MODULE_STATE_GOING ip6table_nat_exit xt_unregister_template kfree(t) //removed from templ_list getinfo() t = xt_find_table_lock list_for_each_entry(tmpl, &xt_templates[af]...) if (strcmp(tmpl->name, name)) continue; //table not found try_module_get list_for_each_entry(t, &xt_net->tables[af]...) return t; //not get refcnt module_put(t->me) //uaf unregister_pernet_subsys //remove table from xt_net list While xt_table module was going away and has been removed from xt_templates list, we couldnt get refcnt of xt_table->me. Check module in xt_net->tables list re-traversal to fix it.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013174": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check num_valid_sets before accessing reader_wm_sets[] [WHY & HOW] num_valid_sets needs to be checked to avoid a negative index when accessing reader_wm_sets[num_valid_sets - 1]. This fixes an OVERRUN issue reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 5.4.284 未満\nLinux Kernel 5.10 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-013000": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/bnxt_re: Add a check for memory allocation __alloc_pbl() can return error when memory allocation fails. Driver is not checking the status on one of the instances.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.229 未満\nLinux Kernel 5.15 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012877": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: udf: fix uninit-value use in udf_get_fileshortad Check for overflow when computing alen in udf_current_aext to mitigate later uninit-value use in udf_get_fileshortad KMSAN bug[1]. After applying the patch reproducer did not trigger any issue[2]. [1] https://syzkaller.appspot.com/bug?extid=8901c4560b7ab5c2f9df [2] https://syzkaller.appspot.com/x/log.txt?x=10242227980000",
        "technologies": "Linux\nLinux Kernel 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012795": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fsdax: dax_unshare_iter needs to copy entire blocks The code that copies data from srcmap to iomap in dax_unshare_iter is very very broken, which bfoster's recent fsx changes have exposed. If the pos and len passed to dax_file_unshare are not aligned to an fsblock boundary, the iter pos and length in the _iter function will reflect this unalignment. dax_iomap_direct_access always returns a pointer to the start of the kmapped fsdax page, even if its pos argument is in the middle of that page. This is catastrophic for data integrity when iter->pos is not aligned to a page, because daddr/saddr do not point to the same byte in the file as iter->pos. Hence we corrupt user data by copying it to the wrong place. If iter->pos + iomap_length() in the _iter function not aligned to a page, then we fail to copy a full block, and only partially populate the destination block. This is catastrophic for data confidentiality because we expose stale pmem contents. Fix both of these issues by aligning copy_pos/copy_len to a page boundary (remember, this is fsdax so 1 fsblock == 1 base page) so that we always copy full blocks. We're not done yet -- there's no call to invalidate_inode_pages2_range, so programs that have the file range mmap'd will continue accessing the old memory mapping after the file metadata updates have completed. Be careful with the return value -- if the unshare succeeds, we still need to return the number of bytes that the iomap iter thinks we're operating on.",
        "technologies": "Linux\nLinux Kernel 6.1.113 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012797": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: macsec: Fix use-after-free while sending the offloading packet KASAN reports the following UAF. The metadata_dst, which is used to store the SCI value for macsec offload, is already freed by metadata_dst_free() in macsec_free_netdev(), while driver still use it for sending the packet. To fix this issue, dst_release() is used instead to release metadata_dst. So it is not freed instantly in macsec_free_netdev() if still referenced by skb. BUG: KASAN: slab-use-after-free in mlx5e_xmit+0x1e8f/0x4190 [mlx5_core] Read of size 2 at addr ffff88813e42e038 by task kworker/7:2/714 [...] Workqueue: mld mld_ifc_work Call Trace: <TASK> dump_stack_lvl+0x51/0x60 print_report+0xc1/0x600 kasan_report+0xab/0xe0 mlx5e_xmit+0x1e8f/0x4190 [mlx5_core] dev_hard_start_xmit+0x120/0x530 sch_direct_xmit+0x149/0x11e0 __qdisc_run+0x3ad/0x1730 __dev_queue_xmit+0x1196/0x2ed0 vlan_dev_hard_start_xmit+0x32e/0x510 [8021q] dev_hard_start_xmit+0x120/0x530 __dev_queue_xmit+0x14a7/0x2ed0 macsec_start_xmit+0x13e9/0x2340 dev_hard_start_xmit+0x120/0x530 __dev_queue_xmit+0x14a7/0x2ed0 ip6_finish_output2+0x923/0x1a70 ip6_finish_output+0x2d7/0x970 ip6_output+0x1ce/0x3a0 NF_HOOK.constprop.0+0x15f/0x190 mld_sendpack+0x59a/0xbd0 mld_ifc_work+0x48a/0xa80 process_one_work+0x5aa/0xe50 worker_thread+0x79c/0x1290 kthread+0x28f/0x350 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x11/0x20 </TASK> Allocated by task 3922: kasan_save_stack+0x20/0x40 kasan_save_track+0x10/0x30 __kasan_kmalloc+0x77/0x90 __kmalloc_noprof+0x188/0x400 metadata_dst_alloc+0x1f/0x4e0 macsec_newlink+0x914/0x1410 __rtnl_newlink+0xe08/0x15b0 rtnl_newlink+0x5f/0x90 rtnetlink_rcv_msg+0x667/0xa80 netlink_rcv_skb+0x12c/0x360 netlink_unicast+0x551/0x770 netlink_sendmsg+0x72d/0xbd0 __sock_sendmsg+0xc5/0x190 ____sys_sendmsg+0x52e/0x6a0 ___sys_sendmsg+0xeb/0x170 __sys_sendmsg+0xb5/0x140 do_syscall_64+0x4c/0x100 entry_SYSCALL_64_after_hwframe+0x4b/0x53 Freed by task 4011: kasan_save_stack+0x20/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x50 poison_slab_object+0x10c/0x190 __kasan_slab_free+0x11/0x30 kfree+0xe0/0x290 macsec_free_netdev+0x3f/0x140 netdev_run_todo+0x450/0xc70 rtnetlink_rcv_msg+0x66f/0xa80 netlink_rcv_skb+0x12c/0x360 netlink_unicast+0x551/0x770 netlink_sendmsg+0x72d/0xbd0 __sock_sendmsg+0xc5/0x190 ____sys_sendmsg+0x52e/0x6a0 ___sys_sendmsg+0xeb/0x170 __sys_sendmsg+0xb5/0x140 do_syscall_64+0x4c/0x100 entry_SYSCALL_64_after_hwframe+0x4b/0x53",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013190": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Skip inactive planes within ModeSupportAndSystemConfiguration [Why] Coverity reports Memory - illegal accesses. [How] Skip inactive planes.",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.109 未満\nLinux Kernel 6.6 以上 6.6.50 未満\nLinux Kernel 6.10 以上 6.10.9 未満"
    },
    "JVNDB-2024-013189": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas() Smatch warns: arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potential spectre issue 'args.args' [r] (local cap) The 'nargs' and 'nret' locals come directly from a user-supplied buffer and are used as indexes into a small stack-based array and as inputs to copy_to_user() after they are subject to bounds checks. Use array_index_nospec() after the bounds checks to clamp these values for speculative execution.",
        "technologies": "Linux\nLinux Kernel 6.10.10 未満"
    },
    "JVNDB-2024-013314": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix OOBs when building SMB2_IOCTL request When using encryption, either enforced by the server or when using 'seal' mount option, the client will squash all compound request buffers down for encryption into a single iov in smb2_set_next_command(). SMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the SMB2_IOCTL request in the first iov, and if the user passes an input buffer that is greater than 328 bytes, smb2_set_next_command() will end up writing off the end of @rqst->iov[0].iov_base as shown below: mount.cifs //srv/share /mnt -o ...,seal ln -s $(perl -e \"print('a')for 1..1024\") /mnt/link BUG: KASAN: slab-out-of-bounds in smb2_set_next_command.cold+0x1d6/0x24c [cifs] Write of size 4116 at addr ffff8881148fcab8 by task ln/859 CPU: 1 UID: 0 PID: 859 Comm: ln Not tainted 6.12.0-rc3 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x5d/0x80 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] print_report+0x156/0x4d9 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] ? __virt_addr_valid+0x145/0x310 ? __phys_addr+0x46/0x90 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] kasan_report+0xda/0x110 ? smb2_set_next_command.cold+0x1d6/0x24c [cifs] kasan_check_range+0x10f/0x1f0 __asan_memcpy+0x3c/0x60 smb2_set_next_command.cold+0x1d6/0x24c [cifs] smb2_compound_op+0x238c/0x3840 [cifs] ? kasan_save_track+0x14/0x30 ? kasan_save_free_info+0x3b/0x70 ? vfs_symlink+0x1a1/0x2c0 ? do_symlinkat+0x108/0x1c0 ? __pfx_smb2_compound_op+0x10/0x10 [cifs] ? kmem_cache_free+0x118/0x3e0 ? cifs_get_writable_path+0xeb/0x1a0 [cifs] smb2_get_reparse_inode+0x423/0x540 [cifs] ? __pfx_smb2_get_reparse_inode+0x10/0x10 [cifs] ? rcu_is_watching+0x20/0x50 ? __kmalloc_noprof+0x37c/0x480 ? smb2_create_reparse_symlink+0x257/0x490 [cifs] ? smb2_create_reparse_symlink+0x38f/0x490 [cifs] smb2_create_reparse_symlink+0x38f/0x490 [cifs] ? __pfx_smb2_create_reparse_symlink+0x10/0x10 [cifs] ? find_held_lock+0x8a/0xa0 ? hlock_class+0x32/0xb0 ? __build_path_from_dentry_optional_prefix+0x19d/0x2e0 [cifs] cifs_symlink+0x24f/0x960 [cifs] ? __pfx_make_vfsuid+0x10/0x10 ? __pfx_cifs_symlink+0x10/0x10 [cifs] ? make_vfsgid+0x6b/0xc0 ? generic_permission+0x96/0x2d0 vfs_symlink+0x1a1/0x2c0 do_symlinkat+0x108/0x1c0 ? __pfx_do_symlinkat+0x10/0x10 ? strncpy_from_user+0xaa/0x160 __x64_sys_symlinkat+0xb9/0xf0 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f08d75c13bb",
        "technologies": "Linux\nLinux Kernel 5.0 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013316": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: USB: serial: io_edgeport: fix use after free in debug printk The \"dev_dbg(&urb->dev->dev, ...\" which happens after usb_free_urb(urb) is a use after free of the \"urb\" pointer. Store the \"dev\" pointer at the start of the function to avoid this issue.",
        "technologies": "Linux\nLinux Kernel 3.7 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013296": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86: Acquire kvm->srcu when handling KVM_SET_VCPU_EVENTS Grab kvm->srcu when processing KVM_SET_VCPU_EVENTS, as KVM will forcibly leave nested VMX/SVM if SMM mode is being toggled, and leaving nested VMX reads guest memory. Note, kvm_vcpu_ioctl_x86_set_vcpu_events() can also be called from KVM_RUN via sync_regs(), which already holds SRCU. I.e. trying to precisely use kvm_vcpu_srcu_read_lock() around the problematic SMM code would cause problems. Acquiring SRCU isn't all that expensive, so for simplicity, grab it unconditionally for KVM_SET_VCPU_EVENTS. ============================= WARNING: suspicious RCU usage 6.10.0-rc7-332d2c1d713e-next-vm #552 Not tainted ----------------------------- include/linux/kvm_host.h:1027 suspicious rcu_dereference_check() usage! other info that might help us debug this: rcu_scheduler_active = 2, debug_locks = 1 1 lock held by repro/1071: #0: ffff88811e424430 (&vcpu->mutex){+.+.}-{3:3}, at: kvm_vcpu_ioctl+0x7d/0x970 [kvm] stack backtrace: CPU: 15 PID: 1071 Comm: repro Not tainted 6.10.0-rc7-332d2c1d713e-next-vm #552 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 Call Trace: <TASK> dump_stack_lvl+0x7f/0x90 lockdep_rcu_suspicious+0x13f/0x1a0 kvm_vcpu_gfn_to_memslot+0x168/0x190 [kvm] kvm_vcpu_read_guest+0x3e/0x90 [kvm] nested_vmx_load_msr+0x6b/0x1d0 [kvm_intel] load_vmcs12_host_state+0x432/0xb40 [kvm_intel] vmx_leave_nested+0x30/0x40 [kvm_intel] kvm_vcpu_ioctl_x86_set_vcpu_events+0x15d/0x2b0 [kvm] kvm_arch_vcpu_ioctl+0x1107/0x1750 [kvm] ? mark_held_locks+0x49/0x70 ? kvm_vcpu_ioctl+0x7d/0x970 [kvm] ? kvm_vcpu_ioctl+0x497/0x970 [kvm] kvm_vcpu_ioctl+0x497/0x970 [kvm] ? lock_acquire+0xba/0x2d0 ? find_held_lock+0x2b/0x80 ? do_user_addr_fault+0x40c/0x6f0 ? lock_release+0xb7/0x270 __x64_sys_ioctl+0x82/0xb0 do_syscall_64+0x6c/0x170 entry_SYSCALL_64_after_hwframe+0x4b/0x53 RIP: 0033:0x7ff11eb1b539 </TASK>",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 5.10.97\nLinux Kernel 5.15.19\nLinux Kernel 5.16.5\nLinux Kernel 6.11"
    },
    "JVNDB-2024-013321": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: add missing size check in amdgpu_debugfs_gprwave_read() Avoid a possible buffer overflow if size is larger than 4K. (cherry picked from commit f5d873f5825b40d886d03bd2aede91d4cf002434)",
        "technologies": "Linux\nLinux Kernel 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013318": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: fix potential out of bounds in ucsi_ccg_update_set_new_cam_cmd() The \"*cmd\" variable can be controlled by the user via debugfs. That means \"new_cam\" can be as high as 255 while the size of the uc->updated[] array is UCSI_MAX_ALTMODES (30). The call tree is: ucsi_cmd() // val comes from simple_attr_write_xsigned() -> ucsi_send_command() -> ucsi_send_command_common() -> ucsi_run_command() // calls ucsi->ops->sync_control() -> ucsi_ccg_sync_control()",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013345": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: Fix increasing MSI-X on VF Increasing MSI-X value on a VF leads to invalid memory operations. This is caused by not reallocating some arrays. Reproducer: modprobe ice echo 0 > /sys/bus/pci/devices/$PF_PCI/sriov_drivers_autoprobe echo 1 > /sys/bus/pci/devices/$PF_PCI/sriov_numvfs echo 17 > /sys/bus/pci/devices/$VF0_PCI/sriov_vf_msix_count Default MSI-X is 16, so 17 and above triggers this issue. KASAN reports: BUG: KASAN: slab-out-of-bounds in ice_vsi_alloc_ring_stats+0x38d/0x4b0 [ice] Read of size 8 at addr ffff8888b937d180 by task bash/28433 (...) Call Trace: (...) ? ice_vsi_alloc_ring_stats+0x38d/0x4b0 [ice] kasan_report+0xed/0x120 ? ice_vsi_alloc_ring_stats+0x38d/0x4b0 [ice] ice_vsi_alloc_ring_stats+0x38d/0x4b0 [ice] ice_vsi_cfg_def+0x3360/0x4770 [ice] ? mutex_unlock+0x83/0xd0 ? __pfx_ice_vsi_cfg_def+0x10/0x10 [ice] ? __pfx_ice_remove_vsi_lkup_fltr+0x10/0x10 [ice] ice_vsi_cfg+0x7f/0x3b0 [ice] ice_vf_reconfig_vsi+0x114/0x210 [ice] ice_sriov_set_msix_vec_count+0x3d0/0x960 [ice] sriov_vf_msix_count_store+0x21c/0x300 (...) Allocated by task 28201: (...) ice_vsi_cfg_def+0x1c8e/0x4770 [ice] ice_vsi_cfg+0x7f/0x3b0 [ice] ice_vsi_setup+0x179/0xa30 [ice] ice_sriov_configure+0xcaa/0x1520 [ice] sriov_numvfs_store+0x212/0x390 (...) To fix it, use ice_vsi_rebuild() instead of ice_vf_reconfig_vsi(). This causes the required arrays to be reallocated taking the new queue count into account (ice_vsi_realloc_stat_arrays()). Set req_txq and req_rxq before ice_vsi_rebuild(), so that realloc uses the newly set queue count. Additionally, ice_vsi_rebuild() does not remove VSI filters (ice_fltr_remove_all()), so ice_vf_init_host_cfg() is no longer necessary.",
        "technologies": "Linux\nLinux Kernel 6.7.10 以上 6.8 未満\nLinux Kernel 6.8 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013192": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu/vcn: remove irq disabling in vcn 5 suspend We do not directly enable/disable VCN IRQ in vcn 5.0.0. And we do not handle the IRQ state as well. So the calls to disable IRQ and set state are removed. This effectively gets rid of the warining of \"WARN_ON(!amdgpu_irq_enabled(adev, src, type))\" in amdgpu_irq_put().",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.9 未満"
    },
    "JVNDB-2024-013033": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, arm64: Fix address emission with tag-based KASAN enabled When BPF_TRAMP_F_CALL_ORIG is enabled, the address of a bpf_tramp_image struct on the stack is passed during the size calculation pass and an address on the heap is passed during code generation. This may cause a heap buffer overflow if the heap address is tagged because emit_a64_mov_i64() will emit longer code than it did during the size calculation pass. The same problem could occur without tag-based KASAN if one of the 16-bit words of the stack address happened to be all-ones during the size calculation pass. Fix the problem by assuming the worst case (4 instructions) when calculating the size of the bpf_tramp_image address emission.",
        "technologies": "Linux\nLinux Kernel 6.10.3 以上 6.11 未満\nLinux Kernel 6.11 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013344": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Prevent tail call between progs attached to different hooks bpf progs can be attached to kernel functions, and the attached functions can take different parameters or return different return values. If prog attached to one kernel function tail calls prog attached to another kernel function, the ctx access or return value verification could be bypassed. For example, if prog1 is attached to func1 which takes only 1 parameter and prog2 is attached to func2 which takes two parameters. Since verifier assumes the bpf ctx passed to prog2 is constructed based on func2's prototype, verifier allows prog2 to access the second parameter from the bpf ctx passed to it. The problem is that verifier does not prevent prog1 from passing its bpf ctx to prog2 via tail call. In this case, the bpf ctx passed to prog2 is constructed from func1 instead of func2, that is, the assumption for ctx access verification is bypassed. Another example, if BPF LSM prog1 is attached to hook file_alloc_security, and BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifier knows the return value rules for these two hooks, e.g. it is legal for bpf_lsm_audit_rule_known to return positive number 1, and it is illegal for file_alloc_security to return positive number. So verifier allows prog2 to return positive number 1, but does not allow prog1 to return positive number. The problem is that verifier does not prevent prog1 from calling prog2 via tail call. In this case, prog2's return value 1 will be used as the return value for prog1's hook file_alloc_security. That is, the return value rule is bypassed. This patch adds restriction for tail call to prevent such bypasses.",
        "technologies": "Linux\nLinux Kernel 5.5 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満"
    },
    "JVNDB-2024-013336": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched: sch_cake: fix bulk flow accounting logic for host fairness In sch_cake, we keep track of the count of active bulk flows per host, when running in dst/src host fairness mode, which is used as the round-robin weight when iterating through flows. The count of active bulk flows is updated whenever a flow changes state. This has a peculiar interaction with the hash collision handling: when a hash collision occurs (after the set-associative hashing), the state of the hash bucket is simply updated to match the new packet that collided, and if host fairness is enabled, that also means assigning new per-host state to the flow. For this reason, the bulk flow counters of the host(s) assigned to the flow are decremented, before new state is assigned (and the counters, which may not belong to the same host anymore, are incremented again). Back when this code was introduced, the host fairness mode was always enabled, so the decrement was unconditional. When the configuration flags were introduced the *increment* was made conditional, but the *decrement* was not. Which of course can lead to a spurious decrement (and associated wrap-around to U16_MAX). AFAICT, when host fairness is disabled, the decrement and wrap-around happens as soon as a hash collision occurs (which is not that common in itself, due to the set-associative hashing). However, in most cases this is harmless, as the value is only used when host fairness mode is enabled. So in order to trigger an array overflow, sch_cake has to first be configured with host fairness disabled, and while running in this mode, a hash collision has to occur to cause the overflow. Then, the qdisc has to be reconfigured to enable host fairness, which leads to the array out-of-bounds because the wrapped-around value is retained and used as an array index. It seems that syzbot managed to trigger this, which is quite impressive in its own right. This patch fixes the issue by introducing the same conditional check on decrement as is used on increment. The original bug predates the upstreaming of cake, but the commit listed in the Fixes tag touched that code, meaning that this patch won't apply before that.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.284 未満\nLinux Kernel 5.10 以上 5.10.226 未満\nLinux Kernel 5.15 以上 5.15.167 未満\nLinux Kernel 6.1 以上 6.1.110 未満\nLinux Kernel 6.6 以上 6.6.51 未満\nLinux Kernel 6.10 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-013339": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: vertexcom: mse102x: Fix possible double free of TX skb The scope of the TX skb is wider than just mse102x_tx_frame_spi(), so in case the TX skb room needs to be expanded, we should free the the temporary skb instead of the original skb. Otherwise the original TX skb pointer would be freed again in mse102x_tx_work(), which leads to crashes: Internal error: Oops: 0000000096000004 [#2] PREEMPT SMP CPU: 0 PID: 712 Comm: kworker/0:1 Tainted: G D 6.6.23 Hardware name: chargebyte Charge SOM DC-ONE (DT) Workqueue: events mse102x_tx_work [mse102x] pstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : skb_release_data+0xb8/0x1d8 lr : skb_release_data+0x1ac/0x1d8 sp : ffff8000819a3cc0 x29: ffff8000819a3cc0 x28: ffff0000046daa60 x27: ffff0000057f2dc0 x26: ffff000005386c00 x25: 0000000000000002 x24: 00000000ffffffff x23: 0000000000000000 x22: 0000000000000001 x21: ffff0000057f2e50 x20: 0000000000000006 x19: 0000000000000000 x18: ffff00003fdacfcc x17: e69ad452d0c49def x16: 84a005feff870102 x15: 0000000000000000 x14: 000000000000024a x13: 0000000000000002 x12: 0000000000000000 x11: 0000000000000400 x10: 0000000000000930 x9 : ffff00003fd913e8 x8 : fffffc00001bc008 x7 : 0000000000000000 x6 : 0000000000000008 x5 : ffff00003fd91340 x4 : 0000000000000000 x3 : 0000000000000009 x2 : 00000000fffffffe x1 : 0000000000000000 x0 : 0000000000000000 Call trace: skb_release_data+0xb8/0x1d8 kfree_skb_reason+0x48/0xb0 mse102x_tx_work+0x164/0x35c [mse102x] process_one_work+0x138/0x260 worker_thread+0x32c/0x438 kthread+0x118/0x11c ret_from_fork+0x10/0x20 Code: aa1303e0 97fffab6 72001c1f 54000141 (f9400660)",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013326": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: s5p-jpeg: prevent buffer overflows The current logic allows word to be less than 2. If this happens, there will be buffer overflows, as reported by smatch. Add extra checks to prevent it. While here, remove an unused word = 0 assignment.",
        "technologies": "Linux\nLinux Kernel 4.4 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013324": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab-use-after-free in ksmbd_smb2_session_create There is a race condition between ksmbd_smb2_session_create and ksmbd_expire_session. This patch add missing sessions_table_lock while adding/deleting session from global session table.",
        "technologies": "Linux\nLinux Kernel 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013356": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/bnxt_re: Fix out of bound check Driver exports pacing stats only on GenP5 and P7 adapters. But while parsing the pacing stats, driver has a check for \"rdev->dbr_pacing\". This caused a trace when KASAN is enabled. BUG: KASAN: slab-out-of-bounds in bnxt_re_get_hw_stats+0x2b6a/0x2e00 [bnxt_re] Write of size 8 at addr ffff8885942a6340 by task modprobe/4809",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013358": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netdevsim: use cond_resched() in nsim_dev_trap_report_work() I am still seeing many syzbot reports hinting that syzbot might fool nsim_dev_trap_report_work() with hundreds of ports [1] Lets use cond_resched(), and system_unbound_wq instead of implicit system_wq. [1] INFO: task syz-executor:20633 blocked for more than 143 seconds. Not tainted 6.12.0-rc2-syzkaller-00205-g1d227fcc7222 #0 \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. task:syz-executor state:D stack:25856 pid:20633 tgid:20633 ppid:1 flags:0x00004006 ... NMI backtrace for cpu 1 CPU: 1 UID: 0 PID: 16760 Comm: kworker/1:0 Not tainted 6.12.0-rc2-syzkaller-00205-g1d227fcc7222 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: events nsim_dev_trap_report_work RIP: 0010:__sanitizer_cov_trace_pc+0x0/0x70 kernel/kcov.c:210 Code: 89 fb e8 23 00 00 00 48 8b 3d 04 fb 9c 0c 48 89 de 5b e9 c3 c7 5d 00 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 <f3> 0f 1e fa 48 8b 04 24 65 48 8b 0c 25 c0 d7 03 00 65 8b 15 60 f0 RSP: 0018:ffffc90000a187e8 EFLAGS: 00000246 RAX: 0000000000000100 RBX: ffffc90000a188e0 RCX: ffff888027d3bc00 RDX: ffff888027d3bc00 RSI: 0000000000000000 RDI: 0000000000000000 RBP: ffff88804a2e6000 R08: ffffffff8a4bc495 R09: ffffffff89da3577 R10: 0000000000000004 R11: ffffffff8a4bc2b0 R12: dffffc0000000000 R13: ffff88806573b503 R14: dffffc0000000000 R15: ffff8880663cca00 FS: 0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fc90a747f98 CR3: 000000000e734000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 000000000000002b DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400 Call Trace: <NMI> </NMI> <TASK> __local_bh_enable_ip+0x1bb/0x200 kernel/softirq.c:382 spin_unlock_bh include/linux/spinlock.h:396 [inline] nsim_dev_trap_report drivers/net/netdevsim/dev.c:820 [inline] nsim_dev_trap_report_work+0x75d/0xaa0 drivers/net/netdevsim/dev.c:850 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK>",
        "technologies": "Linux\nLinux Kernel 6.1.78 以上 6.1.115 未満\nLinux Kernel 6.6.17 以上 6.6.59 未満\nLinux Kernel 6.8 以上 6.11.6 未満\nLinux Kernel 6.7.5\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013328": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: mgb4: protect driver against spectre Frequency range is set from sysfs via frequency_range_store(), being vulnerable to spectre, as reported by smatch: drivers/media/pci/mgb4/mgb4_cmt.c:231 mgb4_cmt_set_vin_freq_range() warn: potential spectre issue 'cmt_vals_in' [r] drivers/media/pci/mgb4/mgb4_cmt.c:238 mgb4_cmt_set_vin_freq_range() warn: possible spectre second half. 'reg_set' Fix it.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013359": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vsock/virtio: Initialization of the dangling pointer occurring in vsk->trans During loopback communication, a dangling pointer can be created in vsk->trans, potentially leading to a Use-After-Free condition. This issue is resolved by initializing vsk->trans to NULL.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013375": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: security/keys: fix slab-out-of-bounds in key_task_permission KASAN reports an out of bounds read: BUG: KASAN: slab-out-of-bounds in __kuid_val include/linux/uidgid.h:36 BUG: KASAN: slab-out-of-bounds in uid_eq include/linux/uidgid.h:63 [inline] BUG: KASAN: slab-out-of-bounds in key_task_permission+0x394/0x410 security/keys/permission.c:54 Read of size 4 at addr ffff88813c3ab618 by task stress-ng/4362 CPU: 2 PID: 4362 Comm: stress-ng Not tainted 5.10.0-14930-gafbffd6c3ede #15 Call Trace: __dump_stack lib/dump_stack.c:82 [inline] dump_stack+0x107/0x167 lib/dump_stack.c:123 print_address_description.constprop.0+0x19/0x170 mm/kasan/report.c:400 __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560 kasan_report+0x3a/0x50 mm/kasan/report.c:585 __kuid_val include/linux/uidgid.h:36 [inline] uid_eq include/linux/uidgid.h:63 [inline] key_task_permission+0x394/0x410 security/keys/permission.c:54 search_nested_keyrings+0x90e/0xe90 security/keys/keyring.c:793 This issue was also reported by syzbot. It can be reproduced by following these steps(more details [1]): 1. Obtain more than 32 inputs that have similar hashes, which ends with the pattern '0xxxxxxxe6'. 2. Reboot and add the keys obtained in step 1. The reproducer demonstrates how this issue happened: 1. In the search_nested_keyrings function, when it iterates through the slots in a node(below tag ascend_to_node), if the slot pointer is meta and node->back_pointer != NULL(it means a root), it will proceed to descend_to_node. However, there is an exception. If node is the root, and one of the slots points to a shortcut, it will be treated as a keyring. 2. Whether the ptr is keyring decided by keyring_ptr_is_keyring function. However, KEYRING_PTR_SUBTYPE is 0x2UL, the same as ASSOC_ARRAY_PTR_SUBTYPE_MASK. 3. When 32 keys with the similar hashes are added to the tree, the ROOT has keys with hashes that are not similar (e.g. slot 0) and it splits NODE A without using a shortcut. When NODE A is filled with keys that all hashes are xxe6, the keys are similar, NODE A will split with a shortcut. Finally, it forms the tree as shown below, where slot 6 points to a shortcut. NODE A +------>+---+ ROOT | | 0 | xxe6 +---+ | +---+ xxxx | 0 | shortcut : : xxe6 +---+ | +---+ xxe6 : : | | | xxe6 +---+ | +---+ | 6 |---+ : : xxe6 +---+ +---+ xxe6 : : | f | xxe6 +---+ +---+ xxe6 | f | +---+ 4. As mentioned above, If a slot(slot 6) of the root points to a shortcut, it may be mistakenly transferred to a key*, leading to a read out-of-bounds read. To fix this issue, one should jump to descend_to_node if the ptr is a shortcut, regardless of whether the node is root or not. [1] https://lore.kernel.org/linux-kernel/1cfa878e-8c7b-4570-8606-21daf5e13ce7@huaweicloud.com/ [jarkko: tweaked the commit message a bit to have an appropriate closes tag.]",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013357": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix overloading of MEM_UNINIT's meaning Lonial reported an issue in the BPF verifier where check_mem_size_reg() has the following code: if (!tnum_is_const(reg->var_off)) /* For unprivileged variable accesses, disable raw * mode so that the program is required to * initialize all the memory that the helper could * just partially fill up. */ meta = NULL; This means that writes are not checked when the register containing the size of the passed buffer has not a fixed size. Through this bug, a BPF program can write to a map which is marked as read-only, for example, .rodata global maps. The problem is that MEM_UNINIT's initial meaning that \"the passed buffer to the BPF helper does not need to be initialized\" which was added back in commit 435faee1aae9 (\"bpf, verifier: add ARG_PTR_TO_RAW_STACK type\") got overloaded over time with \"the passed buffer is being written to\". The problem however is that checks such as the above which were added later via 06c1c049721a (\"bpf: allow helpers access to variable memory\") set meta to NULL in order force the user to always initialize the passed buffer to the helper. Due to the current double meaning of MEM_UNINIT, this bypasses verifier write checks to the memory (not boundary checks though) and only assumes the latter memory is read instead. Fix this by reverting MEM_UNINIT back to its original meaning, and having MEM_WRITE as an annotation to BPF helpers in order to then trigger the BPF verifier checks for writing to memory. Some notes: check_arg_pair_ok() ensures that for ARG_CONST_SIZE{,_OR_ZERO} we can access fn->arg_type[arg - 1] since it must contain a preceding ARG_PTR_TO_MEM. For check_mem_reg() the meta argument can be removed altogether since we do check both BPF_READ and BPF_WRITE. Same for the equivalent check_kfunc_mem_size_reg().",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013376": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab-use-after-free in smb3_preauth_hash_rsp ksmbd_user_session_put should be called under smb3_preauth_hash_rsp(). It will avoid freeing session before calling smb3_preauth_hash_rsp().",
        "technologies": "Linux\nLinux Kernel 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013497": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: virtio_net: Add hash_key_length check Add hash_key_length check in virtnet_probe() to avoid possible out of bound errors when setting/reading the hash key.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013378": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: altmode should keep reference to parent The altmode device release refers to its parent device, but without keeping a reference to it. When registering the altmode, get a reference to the parent and put it in the release function. Before this fix, when using CONFIG_DEBUG_KOBJECT_RELEASE, we see issues like this: [ 43.572860] kobject: 'port0.0' (ffff8880057ba008): kobject_release, parent 0000000000000000 (delayed 3000) [ 43.573532] kobject: 'port0.1' (ffff8880057bd008): kobject_release, parent 0000000000000000 (delayed 1000) [ 43.574407] kobject: 'port0' (ffff8880057b9008): kobject_release, parent 0000000000000000 (delayed 3000) [ 43.575059] kobject: 'port1.0' (ffff8880057ca008): kobject_release, parent 0000000000000000 (delayed 4000) [ 43.575908] kobject: 'port1.1' (ffff8880057c9008): kobject_release, parent 0000000000000000 (delayed 4000) [ 43.576908] kobject: 'typec' (ffff8880062dbc00): kobject_release, parent 0000000000000000 (delayed 4000) [ 43.577769] kobject: 'port1' (ffff8880057bf008): kobject_release, parent 0000000000000000 (delayed 3000) [ 46.612867] ================================================================== [ 46.613402] BUG: KASAN: slab-use-after-free in typec_altmode_release+0x38/0x129 [ 46.614003] Read of size 8 at addr ffff8880057b9118 by task kworker/2:1/48 [ 46.614538] [ 46.614668] CPU: 2 UID: 0 PID: 48 Comm: kworker/2:1 Not tainted 6.12.0-rc1-00138-gedbae730ad31 #535 [ 46.615391] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 [ 46.616042] Workqueue: events kobject_delayed_cleanup [ 46.616446] Call Trace: [ 46.616648] <TASK> [ 46.616820] dump_stack_lvl+0x5b/0x7c [ 46.617112] ? typec_altmode_release+0x38/0x129 [ 46.617470] print_report+0x14c/0x49e [ 46.617769] ? rcu_read_unlock_sched+0x56/0x69 [ 46.618117] ? __virt_addr_valid+0x19a/0x1ab [ 46.618456] ? kmem_cache_debug_flags+0xc/0x1d [ 46.618807] ? typec_altmode_release+0x38/0x129 [ 46.619161] kasan_report+0x8d/0xb4 [ 46.619447] ? typec_altmode_release+0x38/0x129 [ 46.619809] ? process_scheduled_works+0x3cb/0x85f [ 46.620185] typec_altmode_release+0x38/0x129 [ 46.620537] ? process_scheduled_works+0x3cb/0x85f [ 46.620907] device_release+0xaf/0xf2 [ 46.621206] kobject_delayed_cleanup+0x13b/0x17a [ 46.621584] process_scheduled_works+0x4f6/0x85f [ 46.621955] ? __pfx_process_scheduled_works+0x10/0x10 [ 46.622353] ? hlock_class+0x31/0x9a [ 46.622647] ? lock_acquired+0x361/0x3c3 [ 46.622956] ? move_linked_works+0x46/0x7d [ 46.623277] worker_thread+0x1ce/0x291 [ 46.623582] ? __kthread_parkme+0xc8/0xdf [ 46.623900] ? __pfx_worker_thread+0x10/0x10 [ 46.624236] kthread+0x17e/0x190 [ 46.624501] ? kthread+0xfb/0x190 [ 46.624756] ? __pfx_kthread+0x10/0x10 [ 46.625015] ret_from_fork+0x20/0x40 [ 46.625268] ? __pfx_kthread+0x10/0x10 [ 46.625532] ret_from_fork_asm+0x1a/0x30 [ 46.625805] </TASK> [ 46.625953] [ 46.626056] Allocated by task 678: [ 46.626287] kasan_save_stack+0x24/0x44 [ 46.626555] kasan_save_track+0x14/0x2d [ 46.626811] __kasan_kmalloc+0x3f/0x4d [ 46.627049] __kmalloc_noprof+0x1bf/0x1f0 [ 46.627362] typec_register_port+0x23/0x491 [ 46.627698] cros_typec_probe+0x634/0xbb6 [ 46.628026] platform_probe+0x47/0x8c [ 46.628311] really_probe+0x20a/0x47d [ 46.628605] device_driver_attach+0x39/0x72 [ 46.628940] bind_store+0x87/0xd7 [ 46.629213] kernfs_fop_write_iter+0x1aa/0x218 [ 46.629574] vfs_write+0x1d6/0x29b [ 46.629856] ksys_write+0xcd/0x13b [ 46.630128] do_syscall_64+0xd4/0x139 [ 46.630420] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 46.630820] [ 46.630946] Freed by task 48: [ 46.631182] kasan_save_stack+0x24/0x44 [ 46.631493] kasan_save_track+0x14/0x2d [ 46.631799] kasan_save_free_info+0x3f/0x4d [ 46.632144] __kasan_slab_free+0x37/0x45 [ 46.632474] ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013372": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: stop qdisc_tree_reduce_backlog on TC_H_ROOT In qdisc_tree_reduce_backlog, Qdiscs with major handle ffff: are assumed to be either root or ingress. This assumption is bogus since it's valid to create egress qdiscs with major handle ffff: Budimir Markovic found that for qdiscs like DRR that maintain an active class list, it will cause a UAF with a dangling class pointer. In 066a3b5b2346, the concern was to avoid iterating over the ingress qdisc since its parent is itself. The proper fix is to stop when parent TC_H_ROOT is reached because the only way to retrieve ingress is when a hierarchy which does not contain a ffff: major handle call into qdisc_lookup with TC_H_MAJ(TC_H_ROOT). In the scenario where major ffff: is an egress qdisc in any of the tree levels, the updates will also propagate to TC_H_ROOT, which then the iteration must stop. net/sched/sch_api.c | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)",
        "technologies": "Linux\nLinux Kernel 2.6.25 以上 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013673": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm cache: fix out-of-bounds access to the dirty bitset when resizing dm-cache checks the dirty bits of the cache blocks to be dropped when shrinking the fast device, but an index bug in bitset iteration causes out-of-bounds access. Reproduce steps: 1. create a cache device of 1024 cache blocks (128 bytes dirty bitset) dmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\" dmsetup create cdata --table \"0 131072 linear /dev/sdc 8192\" dmsetup create corig --table \"0 524288 linear /dev/sdc 262144\" dd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct dmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\" 2. shrink the fast device to 512 cache blocks, triggering out-of-bounds access to the dirty bitset (offset 0x80) dmsetup suspend cache dmsetup reload cdata --table \"0 65536 linear /dev/sdc 8192\" dmsetup resume cdata dmsetup resume cache KASAN reports: BUG: KASAN: vmalloc-out-of-bounds in cache_preresume+0x269/0x7b0 Read of size 8 at addr ffffc900000f3080 by task dmsetup/131 (...snip...) The buggy address belongs to the virtual mapping at [ffffc900000f3000, ffffc900000f5000) created by: cache_ctr+0x176a/0x35f0 (...snip...) Memory state around the buggy address: ffffc900000f2f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ffffc900000f3000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffffc900000f3080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ^ ffffc900000f3100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ffffc900000f3180: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 Fix by making the index post-incremented.",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013662": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: idpf: avoid vport access in idpf_get_link_ksettings When the device control plane is removed or the platform running device control plane is rebooted, a reset is detected on the driver. On driver reset, it releases the resources and waits for the reset to complete. If the reset fails, it takes the error path and releases the vport lock. At this time if the monitoring tools tries to access link settings, it call traces for accessing released vport pointer. To avoid it, move link_speed_mbps to netdev_priv structure which removes the dependency on vport pointer and the vport lock in idpf_get_link_ksettings. Also use netif_carrier_ok() to check the link status and adjust the offsetof to use link_up instead of link_speed_mbps.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013572": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: musb: sunxi: Fix accessing an released usb phy Commit 6ed05c68cbca (\"usb: musb: sunxi: Explicitly release USB PHY on exit\") will cause that usb phy @glue->xceiv is accessed after released. 1) register platform driver @sunxi_musb_driver // get the usb phy @glue->xceiv sunxi_musb_probe() -> devm_usb_get_phy(). 2) register and unregister platform driver @musb_driver musb_probe() -> sunxi_musb_init() use the phy here //the phy is released here musb_remove() -> sunxi_musb_exit() -> devm_usb_put_phy() 3) register @musb_driver again musb_probe() -> sunxi_musb_init() use the phy here but the phy has been released at 2). ... Fixed by reverting the commit, namely, removing devm_usb_put_phy() from sunxi_musb_exit().",
        "technologies": "Linux\nLinux Kernel 4.4.95 以上 4.5 未満\nLinux Kernel 4.9.59 以上 4.10 未満\nLinux Kernel 4.13.10 以上 4.14 未満\nLinux Kernel 4.14 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013637": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm cache: fix potential out-of-bounds access on the first resume Out-of-bounds access occurs if the fast device is expanded unexpectedly before the first-time resume of the cache table. This happens because expanding the fast device requires reloading the cache table for cache_create to allocate new in-core data structures that fit the new size, and the check in cache_preresume is not performed during the first resume, leading to the issue. Reproduce steps: 1. prepare component devices: dmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\" dmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\" dmsetup create corig --table \"0 524288 linear /dev/sdc 262144\" dd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct 2. load a cache table of 512 cache blocks, and deliberately expand the fast device before resuming the cache, making the in-core data structures inadequate. dmsetup create cache --notable dmsetup reload cache --table \"0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\" dmsetup reload cdata --table \"0 131072 linear /dev/sdc 8192\" dmsetup resume cdata dmsetup resume cache 3. suspend the cache to write out the in-core dirty bitset and hint array, leading to out-of-bounds access to the dirty bitset at offset 0x40: dmsetup suspend cache KASAN reports: BUG: KASAN: vmalloc-out-of-bounds in is_dirty_callback+0x2b/0x80 Read of size 8 at addr ffffc90000085040 by task dmsetup/90 (...snip...) The buggy address belongs to the virtual mapping at [ffffc90000085000, ffffc90000087000) created by: cache_ctr+0x176a/0x35f0 (...snip...) Memory state around the buggy address: ffffc90000084f00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ffffc90000084f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 >ffffc90000085000: 00 00 00 00 00 00 00 00 f8 f8 f8 f8 f8 f8 f8 f8 ^ ffffc90000085080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ffffc90000085100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 Fix by checking the size change on the first resume.",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013623": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arm64/sve: Discard stale CPU state when handling SVE traps The logic for handling SVE traps manipulates saved FPSIMD/SVE state incorrectly, and a race with preemption can result in a task having TIF_SVE set and TIF_FOREIGN_FPSTATE clear even though the live CPU state is stale (e.g. with SVE traps enabled). This has been observed to result in warnings from do_sve_acc() where SVE traps are not expected while TIF_SVE is set: | if (test_and_set_thread_flag(TIF_SVE)) | WARN_ON(1); /* SVE access shouldn't have trapped */ Warnings of this form have been reported intermittently, e.g. https://lore.kernel.org/linux-arm-kernel/CA+G9fYtEGe_DhY2Ms7+L7NKsLYUomGsgqpdBj+QwDLeSg=JhGg@mail.gmail.com/ https://lore.kernel.org/linux-arm-kernel/000000000000511e9a060ce5a45c@google.com/ The race can occur when the SVE trap handler is preempted before and after manipulating the saved FPSIMD/SVE state, starting and ending on the same CPU, e.g. | void do_sve_acc(unsigned long esr, struct pt_regs *regs) | { | // Trap on CPU 0 with TIF_SVE clear, SVE traps enabled | // task->fpsimd_cpu is 0. | // per_cpu_ptr(&fpsimd_last_state, 0) is task. | | ... | | // Preempted; migrated from CPU 0 to CPU 1. | // TIF_FOREIGN_FPSTATE is set. | | get_cpu_fpsimd_context(); | | if (test_and_set_thread_flag(TIF_SVE)) | WARN_ON(1); /* SVE access shouldn't have trapped */ | | sve_init_regs() { | if (!test_thread_flag(TIF_FOREIGN_FPSTATE)) { | ... | } else { | fpsimd_to_sve(current); | current->thread.fp_type = FP_STATE_SVE; | } | } | | put_cpu_fpsimd_context(); | | // Preempted; migrated from CPU 1 to CPU 0. | // task->fpsimd_cpu is still 0 | // If per_cpu_ptr(&fpsimd_last_state, 0) is still task then: | // - Stale HW state is reused (with SVE traps enabled) | // - TIF_FOREIGN_FPSTATE is cleared | // - A return to userspace skips HW state restore | } Fix the case where the state is not live and TIF_FOREIGN_FPSTATE is set by calling fpsimd_flush_task_state() to detach from the saved CPU state. This ensures that a subsequent context switch will not reuse the stale CPU state, and will instead set TIF_FOREIGN_FPSTATE, forcing the new state to be reloaded from memory prior to a return to userspace.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013775": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/entry_32: Clear CPU buffers after register restore in NMI return CPU buffers are currently cleared after call to exc_nmi, but before register state is restored. This may be okay for MDS mitigation but not for RDFS. Because RDFS mitigation requires CPU buffers to be cleared when registers don't have any sensitive data. Move CLEAR_CPU_BUFFERS after RESTORE_ALL_NMI.",
        "technologies": "Linux\nLinux Kernel 5.10.228 未満\nLinux Kernel 5.11 以上 5.15.169 未満\nLinux Kernel 5.16 以上 6.1.114 未満\nLinux Kernel 6.2 以上 6.6.58 未満\nLinux Kernel 6.8 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013749": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fbdev: sisfb: Fix strbuf array overflow The values of the variables xres and yres are placed in strbuf. These variables are obtained from strbuf1. The strbuf1 array contains digit characters and a space if the array contains non-digit characters. Then, when executing sprintf(strbuf, \"%ux%ux8\", xres, yres); more than 16 bytes will be written to strbuf. It is suggested to increase the size of the strbuf array to 24. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満"
    },
    "JVNDB-2024-013500": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier() The scmi_dev->name is released prematurely in __scmi_device_destroy(), which causes slab-use-after-free when accessing scmi_dev->name in scmi_bus_notifier(). So move the release of scmi_dev->name to scmi_device_release() to avoid slab-use-after-free. | BUG: KASAN: slab-use-after-free in strncmp+0xe4/0xec | Read of size 1 at addr ffffff80a482bcc0 by task swapper/0/1 | | CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.6.38-debug #1 | Hardware name: Qualcomm Technologies, Inc. SA8775P Ride (DT) | Call trace: | dump_backtrace+0x94/0x114 | show_stack+0x18/0x24 | dump_stack_lvl+0x48/0x60 | print_report+0xf4/0x5b0 | kasan_report+0xa4/0xec | __asan_report_load1_noabort+0x20/0x2c | strncmp+0xe4/0xec | scmi_bus_notifier+0x5c/0x54c | notifier_call_chain+0xb4/0x31c | blocking_notifier_call_chain+0x68/0x9c | bus_notify+0x54/0x78 | device_del+0x1bc/0x840 | device_unregister+0x20/0xb4 | __scmi_device_destroy+0xac/0x280 | scmi_device_destroy+0x94/0xd0 | scmi_chan_setup+0x524/0x750 | scmi_probe+0x7fc/0x1508 | platform_probe+0xc4/0x19c | really_probe+0x32c/0x99c | __driver_probe_device+0x15c/0x3c4 | driver_probe_device+0x5c/0x170 | __driver_attach+0x1c8/0x440 | bus_for_each_dev+0xf4/0x178 | driver_attach+0x3c/0x58 | bus_add_driver+0x234/0x4d4 | driver_register+0xf4/0x3c0 | __platform_driver_register+0x60/0x88 | scmi_driver_init+0xb0/0x104 | do_one_initcall+0xb4/0x664 | kernel_init_freeable+0x3c8/0x894 | kernel_init+0x24/0x1e8 | ret_from_fork+0x10/0x20 | | Allocated by task 1: | kasan_save_stack+0x2c/0x54 | kasan_set_track+0x2c/0x40 | kasan_save_alloc_info+0x24/0x34 | __kasan_kmalloc+0xa0/0xb8 | __kmalloc_node_track_caller+0x6c/0x104 | kstrdup+0x48/0x84 | kstrdup_const+0x34/0x40 | __scmi_device_create.part.0+0x8c/0x408 | scmi_device_create+0x104/0x370 | scmi_chan_setup+0x2a0/0x750 | scmi_probe+0x7fc/0x1508 | platform_probe+0xc4/0x19c | really_probe+0x32c/0x99c | __driver_probe_device+0x15c/0x3c4 | driver_probe_device+0x5c/0x170 | __driver_attach+0x1c8/0x440 | bus_for_each_dev+0xf4/0x178 | driver_attach+0x3c/0x58 | bus_add_driver+0x234/0x4d4 | driver_register+0xf4/0x3c0 | __platform_driver_register+0x60/0x88 | scmi_driver_init+0xb0/0x104 | do_one_initcall+0xb4/0x664 | kernel_init_freeable+0x3c8/0x894 | kernel_init+0x24/0x1e8 | ret_from_fork+0x10/0x20 | | Freed by task 1: | kasan_save_stack+0x2c/0x54 | kasan_set_track+0x2c/0x40 | kasan_save_free_info+0x38/0x5c | __kasan_slab_free+0xe8/0x164 | __kmem_cache_free+0x11c/0x230 | kfree+0x70/0x130 | kfree_const+0x20/0x40 | __scmi_device_destroy+0x70/0x280 | scmi_device_destroy+0x94/0xd0 | scmi_chan_setup+0x524/0x750 | scmi_probe+0x7fc/0x1508 | platform_probe+0xc4/0x19c | really_probe+0x32c/0x99c | __driver_probe_device+0x15c/0x3c4 | driver_probe_device+0x5c/0x170 | __driver_attach+0x1c8/0x440 | bus_for_each_dev+0xf4/0x178 | driver_attach+0x3c/0x58 | bus_add_driver+0x234/0x4d4 | driver_register+0xf4/0x3c0 | __platform_driver_register+0x60/0x88 | scmi_driver_init+0xb0/0x104 | do_one_initcall+0xb4/0x664 | kernel_init_freeable+0x3c8/0x894 | kernel_init+0x24/0x1e8 | ret_from_fork+0x10/0x20",
        "technologies": "Linux\nLinux Kernel 5.6 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-014377": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: initramfs: avoid filename buffer overrun The initramfs filename field is defined in Documentation/driver-api/early-userspace/buffer-format.rst as: 37 cpio_file := ALGN(4) + cpio_header + filename + \"\\0\" + ALGN(4) + data ... 55 ============= ================== ========================= 56 Field name Field size Meaning 57 ============= ================== ========================= ... 70 c_namesize 8 bytes Length of filename, including final \\0 When extracting an initramfs cpio archive, the kernel's do_name() path handler assumes a zero-terminated path at @collected, passing it directly to filp_open() / init_mkdir() / init_mknod(). If a specially crafted cpio entry carries a non-zero-terminated filename and is followed by uninitialized memory, then a file may be created with trailing characters that represent the uninitialized memory. The ability to create an initramfs entry would imply already having full control of the system, so the buffer overrun shouldn't be considered a security vulnerability. Append the output of the following bash script to an existing initramfs and observe any created /initramfs_test_fname_overrunAA* path. E.g. ./reproducer.sh | gzip >> /myinitramfs It's easiest to observe non-zero uninitialized memory when the output is gzipped, as it'll overflow the heap allocated @out_buf in __gunzip(), rather than the initrd_start+initrd_size block. ---- reproducer.sh ---- nilchar=\"A\" # change to \"\\0\" to properly zero terminate / pad magic=\"070701\" ino=1 mode=$(( 0100777 )) uid=0 gid=0 nlink=1 mtime=1 filesize=0 devmajor=0 devminor=1 rdevmajor=0 rdevminor=0 csum=0 fname=\"initramfs_test_fname_overrun\" namelen=$(( ${#fname} + 1 )) # plus one to account for terminator printf \"%s%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%s\" \\ $magic $ino $mode $uid $gid $nlink $mtime $filesize \\ $devmajor $devminor $rdevmajor $rdevminor $namelen $csum $fname termpadlen=$(( 1 + ((4 - ((110 + $namelen) & 3)) % 4) )) printf \"%.s${nilchar}\" $(seq 1 $termpadlen) ---- reproducer.sh ---- Symlink filename fields handled in do_symlink() won't overrun past the data segment, due to the explicit zero-termination of the symlink target. Fix filename buffer overrun by aborting the initramfs FSM if any cpio entry doesn't carry a zero-terminator at the expected (name_len - 1) offset.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 4.19.325 未満\nLinux Kernel 4.20 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-014518": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tomoyo: fix UAF write bug in tomoyo_write_control() Since tomoyo_write_control() updates head->write_buf when write() of long lines is requested, we need to fetch head->write_buf after head->io_sem is held. Otherwise, concurrent write() requests can cause use-after-free-write and double-free problems.",
        "technologies": "Linux\nLinux Kernel 3.1 以上 5.10.212 未満\nLinux Kernel 5.11 以上 5.15.151 未満\nLinux Kernel 5.16 以上 6.1.81 未満\nLinux Kernel 6.2 以上 6.6.21 未満\nLinux Kernel 6.7 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-014532": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: core_linecards: Fix double memory deallocation in case of invalid INI file In case of invalid INI file mlxsw_linecard_types_init() deallocates memory but doesn't reset pointer to NULL and returns 0. In case of any error occurred after mlxsw_linecard_types_init() call, mlxsw_linecards_init() calls mlxsw_linecard_types_fini() which performs memory deallocation again. Add pointer reset to NULL. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-014376": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: explicitly clear the sk pointer, when pf->create fails We have recently noticed the exact same KASAN splat as in commit 6cd4a78d962b (\"net: do not leave a dangling sk pointer, when socket creation fails\"). The problem is that commit did not fully address the problem, as some pf->create implementations do not use sk_common_release in their error paths. For example, we can use the same reproducer as in the above commit, but changing ping to arping. arping uses AF_PACKET socket and if packet_create fails, it will just sk_free the allocated sk object. While we could chase all the pf->create implementations and make sure they NULL the freed sk object on error from the socket, we can't guarantee future protocols will not make the same mistake. So it is easier to just explicitly NULL the sk pointer upon return from pf->create in __sock_create. We do know that pf->create always releases the allocated sk object on error, so if the pointer is not NULL, it is definitely dangling.",
        "technologies": "Linux\nLinux Kernel 5.15.162 以上 5.15.168 未満\nLinux Kernel 6.1.96 以上 6.1.113 未満\nLinux Kernel 6.6.36 以上 6.6.57 未満\nLinux Kernel 6.9.7 以上 6.10 未満\nLinux Kernel 6.10 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-013938": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: Fix response handling in iwl_mvm_send_recovery_cmd() 1. The size of the response packet is not validated. 2. The response buffer is not freed. Resolve these issues by switching to iwl_mvm_send_cmd_status(), which handles both size validation and frees the buffer.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-014719": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Adjust VSDB parser for replay feature At some point, the IEEE ID identification for the replay check in the AMD EDID was added. However, this check causes the following out-of-bounds issues when using KASAN: [ 27.804016] BUG: KASAN: slab-out-of-bounds in amdgpu_dm_update_freesync_caps+0xefa/0x17a0 [amdgpu] [ 27.804788] Read of size 1 at addr ffff8881647fdb00 by task systemd-udevd/383 ... [ 27.821207] Memory state around the buggy address: [ 27.821215] ffff8881647fda00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 27.821224] ffff8881647fda80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 27.821234] >ffff8881647fdb00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 27.821243] ^ [ 27.821250] ffff8881647fdb80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 27.821259] ffff8881647fdc00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 27.821268] ================================================================== This is caused because the ID extraction happens outside of the range of the edid lenght. This commit addresses this issue by considering the amd_vsdb_block size. (cherry picked from commit b7e381b1ccd5e778e3d9c44c669ad38439a861d8)",
        "technologies": "Linux\nLinux Kernel 6.6.63 未満\nLinux Kernel 6.7 以上 6.11.10 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-014706": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Handle dml allocation failure to avoid crash [Why] In the case where a dml allocation fails for any reason, the current state's dml contexts would no longer be valid. Then subsequent calls dc_state_copy_internal would shallow copy invalid memory and if the new state was released, a double free would occur. [How] Reset dml pointers in new_state to NULL and avoid invalid pointer (cherry picked from commit bcafdc61529a48f6f06355d78eb41b3aeda5296c)",
        "technologies": "Linux\nLinux Kernel 6.11.10 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-014704": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sctp: fix possible UAF in sctp_v6_available() A lockdep report [1] with CONFIG_PROVE_RCU_LIST=y hints that sctp_v6_available() is calling dev_get_by_index_rcu() and ipv6_chk_addr() without holding rcu. [1] ============================= WARNING: suspicious RCU usage 6.12.0-rc5-virtme #1216 Tainted: G W ----------------------------- net/core/dev.c:876 RCU-list traversed in non-reader section!! other info that might help us debug this: rcu_scheduler_active = 2, debug_locks = 1 1 lock held by sctp_hello/31495: #0: ffff9f1ebbdb7418 (sk_lock-AF_INET6){+.+.}-{0:0}, at: sctp_bind (./arch/x86/include/asm/jump_label.h:27 net/sctp/socket.c:315) sctp stack backtrace: CPU: 7 UID: 0 PID: 31495 Comm: sctp_hello Tainted: G W 6.12.0-rc5-virtme #1216 Tainted: [W]=WARN Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:123) lockdep_rcu_suspicious (kernel/locking/lockdep.c:6822) dev_get_by_index_rcu (net/core/dev.c:876 (discriminator 7)) sctp_v6_available (net/sctp/ipv6.c:701) sctp sctp_do_bind (net/sctp/socket.c:400 (discriminator 1)) sctp sctp_bind (net/sctp/socket.c:320) sctp inet6_bind_sk (net/ipv6/af_inet6.c:465) ? security_socket_bind (security/security.c:4581 (discriminator 1)) __sys_bind (net/socket.c:1848 net/socket.c:1869) ? do_user_addr_fault (./include/linux/rcupdate.h:347 ./include/linux/rcupdate.h:880 ./include/linux/mm.h:729 arch/x86/mm/fault.c:1340) ? do_user_addr_fault (./arch/x86/include/asm/preempt.h:84 (discriminator 13) ./include/linux/rcupdate.h:98 (discriminator 13) ./include/linux/rcupdate.h:882 (discriminator 13) ./include/linux/mm.h:729 (discriminator 13) arch/x86/mm/fault.c:1340 (discriminator 13)) __x64_sys_bind (net/socket.c:1877 (discriminator 1) net/socket.c:1875 (discriminator 1) net/socket.c:1875 (discriminator 1)) do_syscall_64 (arch/x86/entry/common.c:52 (discriminator 1) arch/x86/entry/common.c:83 (discriminator 1)) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) RIP: 0033:0x7f59b934a1e7 Code: 44 00 00 48 8b 15 39 8c 0c 00 f7 d8 64 89 02 b8 ff ff ff ff eb bd 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 b8 31 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 09 8c 0c 00 f7 d8 64 89 01 48 All code ======== 0: 44 00 00 add %r8b,(%rax) 3: 48 8b 15 39 8c 0c 00 mov 0xc8c39(%rip),%rdx # 0xc8c43 a: f7 d8 neg %eax c: 64 89 02 mov %eax,%fs:(%rdx) f: b8 ff ff ff ff mov $0xffffffff,%eax 14: eb bd jmp 0xffffffffffffffd3 16: 66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 1d: 00 00 00 20: 0f 1f 00 nopl (%rax) 23: b8 31 00 00 00 mov $0x31,%eax 28: 0f 05 syscall 2a:* 48 3d 01 f0 ff ff cmp $0xfffffffffffff001,%rax <-- trapping instruction 30: 73 01 jae 0x33 32: c3 ret 33: 48 8b 0d 09 8c 0c 00 mov 0xc8c09(%rip),%rcx # 0xc8c43 3a: f7 d8 neg %eax 3c: 64 89 01 mov %eax,%fs:(%rcx) 3f: 48 rex.W Code starting with the faulting instruction =========================================== 0: 48 3d 01 f0 ff ff cmp $0xfffffffffffff001,%rax 6: 73 01 jae 0x9 8: c3 ret 9: 48 8b 0d 09 8c 0c 00 mov 0xc8c09(%rip),%rcx # 0xc8c19 10: f7 d8 neg %eax 12: 64 89 01 mov %eax,%fs:(%rcx) 15: 48 rex.W RSP: 002b:00007ffe2d0ad398 EFLAGS: 00000202 ORIG_RAX: 0000000000000031 RAX: ffffffffffffffda RBX: 00007ffe2d0ad3d0 RCX: 00007f59b934a1e7 RDX: 000000000000001c RSI: 00007ffe2d0ad3d0 RDI: 0000000000000005 RBP: 0000000000000005 R08: 1999999999999999 R09: 0000000000000000 R10: 00007f59b9253298 R11: 000000000000 ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.63 未満\nLinux Kernel 6.7 以上 6.11.10 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-015392": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gtp: fix use-after-free and null-ptr-deref in gtp_newlink() The gtp_link_ops operations structure for the subsystem must be registered after registering the gtp_net_ops pernet operations structure. Syzkaller hit 'general protection fault in gtp_genl_dump_pdp' bug: [ 1010.702740] gtp: GTP module unloaded [ 1010.715877] general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] SMP KASAN NOPTI [ 1010.715888] KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] [ 1010.715895] CPU: 1 PID: 128616 Comm: a.out Not tainted 6.8.0-rc6-std-def-alt1 #1 [ 1010.715899] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-alt1 04/01/2014 [ 1010.715908] RIP: 0010:gtp_newlink+0x4d7/0x9c0 [gtp] [ 1010.715915] Code: 80 3c 02 00 0f 85 41 04 00 00 48 8b bb d8 05 00 00 e8 ed f6 ff ff 48 89 c2 48 89 c5 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 4f 04 00 00 4c 89 e2 4c 8b 6d 00 48 b8 00 00 00 [ 1010.715920] RSP: 0018:ffff888020fbf180 EFLAGS: 00010203 [ 1010.715929] RAX: dffffc0000000000 RBX: ffff88800399c000 RCX: 0000000000000000 [ 1010.715933] RDX: 0000000000000001 RSI: ffffffff84805280 RDI: 0000000000000282 [ 1010.715938] RBP: 000000000000000d R08: 0000000000000001 R09: 0000000000000000 [ 1010.715942] R10: 0000000000000001 R11: 0000000000000001 R12: ffff88800399cc80 [ 1010.715947] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000400 [ 1010.715953] FS: 00007fd1509ab5c0(0000) GS:ffff88805b300000(0000) knlGS:0000000000000000 [ 1010.715958] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 1010.715962] CR2: 0000000000000000 CR3: 000000001c07a000 CR4: 0000000000750ee0 [ 1010.715968] PKRU: 55555554 [ 1010.715972] Call Trace: [ 1010.715985] ? __die_body.cold+0x1a/0x1f [ 1010.715995] ? die_addr+0x43/0x70 [ 1010.716002] ? exc_general_protection+0x199/0x2f0 [ 1010.716016] ? asm_exc_general_protection+0x1e/0x30 [ 1010.716026] ? gtp_newlink+0x4d7/0x9c0 [gtp] [ 1010.716034] ? gtp_net_exit+0x150/0x150 [gtp] [ 1010.716042] __rtnl_newlink+0x1063/0x1700 [ 1010.716051] ? rtnl_setlink+0x3c0/0x3c0 [ 1010.716063] ? is_bpf_text_address+0xc0/0x1f0 [ 1010.716070] ? kernel_text_address.part.0+0xbb/0xd0 [ 1010.716076] ? __kernel_text_address+0x56/0xa0 [ 1010.716084] ? unwind_get_return_address+0x5a/0xa0 [ 1010.716091] ? create_prof_cpu_mask+0x30/0x30 [ 1010.716098] ? arch_stack_walk+0x9e/0xf0 [ 1010.716106] ? stack_trace_save+0x91/0xd0 [ 1010.716113] ? stack_trace_consume_entry+0x170/0x170 [ 1010.716121] ? __lock_acquire+0x15c5/0x5380 [ 1010.716139] ? mark_held_locks+0x9e/0xe0 [ 1010.716148] ? kmem_cache_alloc_trace+0x35f/0x3c0 [ 1010.716155] ? __rtnl_newlink+0x1700/0x1700 [ 1010.716160] rtnl_newlink+0x69/0xa0 [ 1010.716166] rtnetlink_rcv_msg+0x43b/0xc50 [ 1010.716172] ? rtnl_fdb_dump+0x9f0/0x9f0 [ 1010.716179] ? lock_acquire+0x1fe/0x560 [ 1010.716188] ? netlink_deliver_tap+0x12f/0xd50 [ 1010.716196] netlink_rcv_skb+0x14d/0x440 [ 1010.716202] ? rtnl_fdb_dump+0x9f0/0x9f0 [ 1010.716208] ? netlink_ack+0xab0/0xab0 [ 1010.716213] ? netlink_deliver_tap+0x202/0xd50 [ 1010.716220] ? netlink_deliver_tap+0x218/0xd50 [ 1010.716226] ? __virt_addr_valid+0x30b/0x590 [ 1010.716233] netlink_unicast+0x54b/0x800 [ 1010.716240] ? netlink_attachskb+0x870/0x870 [ 1010.716248] ? __check_object_size+0x2de/0x3b0 [ 1010.716254] netlink_sendmsg+0x938/0xe40 [ 1010.716261] ? netlink_unicast+0x800/0x800 [ 1010.716269] ? __import_iovec+0x292/0x510 [ 1010.716276] ? netlink_unicast+0x800/0x800 [ 1010.716284] __sock_sendmsg+0x159/0x190 [ 1010.716290] ____sys_sendmsg+0x712/0x880 [ 1010.716297] ? sock_write_iter+0x3d0/0x3d0 [ 1010.716304] ? __ia32_sys_recvmmsg+0x270/0x270 [ 1010.716309] ? lock_acquire+0x1fe/0x560 [ 1010.716315] ? drain_array_locked+0x90/0x90 [ 1010.716324] ___sys_sendmsg+0xf8/0x170 [ 1010.716331] ? sendmsg_copy_msghdr+0x170/0x170 [ 1010.716337] ? lockdep_init_map ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.19.309 未満\nLinux Kernel 4.20 以上 5.4.271 未満\nLinux Kernel 5.5 以上 5.10.212 未満\nLinux Kernel 5.11 以上 5.15.151 未満\nLinux Kernel 5.16 以上 6.1.81 未満\nLinux Kernel 6.2 以上 6.6.21 未満\nLinux Kernel 6.7 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-012794": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Additional check in ntfs_file_release",
        "technologies": "Linux\nLinux Kernel 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-014720": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/proc/task_mmu: move mmu notification mechanism inside mm lock Move mmu notification mechanism inside mm lock to prevent race condition in other components which depend on it. The notifier will invalidate memory range. Depending upon the number of iterations, different memory ranges would be invalidated. The following warning would be removed by this patch: WARNING: CPU: 0 PID: 5067 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:734 kvm_mmu_notifier_change_pte+0x860/0x960 arch/x86/kvm/../../../virt/kvm/kvm_main.c:734 There is no behavioural and performance change with this patch when there is no component registered with the mmu notifier. [akpm@linux-foundation.org: narrow the scope of `range', per Sean]",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2024-014662": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: scrub: avoid use-after-free when chunk length is not 64K aligned [BUG] There is a bug report that, on a ext4-converted btrfs, scrub leads to various problems, including: - \"unable to find chunk map\" errors BTRFS info (device vdb): scrub: started on devid 1 BTRFS critical (device vdb): unable to find chunk map for logical 2214744064 length 4096 BTRFS critical (device vdb): unable to find chunk map for logical 2214744064 length 45056 This would lead to unrepariable errors. - Use-after-free KASAN reports: ================================================================== BUG: KASAN: slab-use-after-free in __blk_rq_map_sg+0x18f/0x7c0 Read of size 8 at addr ffff8881013c9040 by task btrfs/909 CPU: 0 PID: 909 Comm: btrfs Not tainted 6.7.0-x64v3-dbg #11 c50636e9419a8354555555245df535e380563b2b Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 2023.11-2 12/24/2023 Call Trace: <TASK> dump_stack_lvl+0x43/0x60 print_report+0xcf/0x640 kasan_report+0xa6/0xd0 __blk_rq_map_sg+0x18f/0x7c0 virtblk_prep_rq.isra.0+0x215/0x6a0 [virtio_blk 19a65eeee9ae6fcf02edfad39bb9ddee07dcdaff] virtio_queue_rqs+0xc4/0x310 [virtio_blk 19a65eeee9ae6fcf02edfad39bb9ddee07dcdaff] blk_mq_flush_plug_list.part.0+0x780/0x860 __blk_flush_plug+0x1ba/0x220 blk_finish_plug+0x3b/0x60 submit_initial_group_read+0x10a/0x290 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] flush_scrub_stripes+0x38e/0x430 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] scrub_stripe+0x82a/0xae0 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] scrub_chunk+0x178/0x200 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] scrub_enumerate_chunks+0x4bc/0xa30 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] btrfs_scrub_dev+0x398/0x810 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] btrfs_ioctl+0x4b9/0x3020 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965] __x64_sys_ioctl+0xbd/0x100 do_syscall_64+0x5d/0xe0 entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7f47e5e0952b - Crash, mostly due to above use-after-free [CAUSE] The converted fs has the following data chunk layout: item 2 key (FIRST_CHUNK_TREE CHUNK_ITEM 2214658048) itemoff 16025 itemsize 80 length 86016 owner 2 stripe_len 65536 type DATA|single For above logical bytenr 2214744064, it's at the chunk end (2214658048 + 86016 = 2214744064). This means btrfs_submit_bio() would split the bio, and trigger endio function for both of the two halves. However scrub_submit_initial_read() would only expect the endio function to be called once, not any more. This means the first endio function would already free the bbio::bio, leaving the bvec freed, thus the 2nd endio call would lead to use-after-free. [FIX] - Make sure scrub_read_endio() only updates bits in its range Since we may read less than 64K at the end of the chunk, we should not touch the bits beyond chunk boundary. - Make sure scrub_submit_initial_read() only to read the chunk range This is done by calculating the real number of sectors we need to read, and add sector-by-sector to the bio. Thankfully the scrub read repair path won't need extra fixes: - scrub_stripe_submit_repair_read() With above fixes, we won't update error bit for range beyond chunk, thus scrub_stripe_submit_repair_read() should never submit any read beyond the chunk.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-014350": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: add missing range check in bitmap_ip_uadt When tb[IPSET_ATTR_IP_TO] is not present but tb[IPSET_ATTR_CIDR] exists, the values of ip and ip_to are slightly swapped. Therefore, the range check for ip should be done later, but this part is missing and it seems that the vulnerability occurs. So we should add missing range checks and remove unnecessary range checks.",
        "technologies": "Linux\nLinux Kernel 2.6.39 以上 4.19.325 未満\nLinux Kernel 4.20 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-014700": {
        "title": "Linux の Linux Kernel における無効なポインタや参照の解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bluetooth/hci: disallow setting handle bigger than HCI_CONN_HANDLE_MAX Syzbot hit warning in hci_conn_del() caused by freeing handle that was not allocated using ida allocator. This is caused by handle bigger than HCI_CONN_HANDLE_MAX passed by hci_le_big_sync_established_evt(), which makes code think it's unset connection. Add same check for handle upper bound as in hci_conn_set_handle() to prevent warning.",
        "technologies": "Linux\nLinux Kernel 6.5.12 以上 6.6 未満\nLinux Kernel 6.6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-014660": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv: Fix module loading free order Reverse order of kfree calls to resolve use-after-free error.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2024-014597": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vdpa: solidrun: Fix UB bug with devres In psnet_open_pf_bar() and snet_open_vf_bar() a string later passed to pcim_iomap_regions() is placed on the stack. Neither pcim_iomap_regions() nor the functions it calls copy that string. Should the string later ever be used, this, consequently, causes undefined behavior since the stack frame will by then have disappeared. Fix the bug by allocating the strings on the heap through devm_kasprintf().",
        "technologies": "Linux\nLinux Kernel 6.3 およびそれ以前\nLinux Kernel 6.6.0 以上 6.6.63 未満\nLinux Kernel 6.11.0 以上 6.11.10 未満"
    },
    "JVNDB-2024-014693": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: fix a memory corruption iwl_fw_ini_trigger_tlv::data is a pointer to a __le32, which means that if we copy to iwl_fw_ini_trigger_tlv::data + offset while offset is in bytes, we'll write past the buffer.",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-011143": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: driver core: bus: Fix double free in driver API bus_register() For bus_register(), any error which happens after kset_register() will cause that @priv are freed twice, fixed by setting @priv with NULL after the first free.",
        "technologies": "Linux\nLinux Kernel 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満"
    },
    "JVNDB-2024-011132": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix out-of-bounds in dbNextAG() and diAlloc() In dbNextAG() , there is no check for the case where bmp->db_numag is greater or same than MAXAG due to a polluted image, which causes an out-of-bounds. Therefore, a bounds check should be added in dbMount(). And in dbNextAG(), a check for the case where agpref is greater than bmp->db_numag should be added, so an out-of-bounds exception should be prevented. Additionally, a check for the case where agno is greater or same than MAXAG should be added in diAlloc() to prevent out-of-bounds.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-014612": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: hisilicon/debugfs - Fix debugfs uninit process issue During the zip probe process, the debugfs failure does not stop the probe. When debugfs initialization fails, jumping to the error branch will also release regs, in addition to its own rollback operation. As a result, it may be released repeatedly during the regs uninit process. Therefore, the null check needs to be added to the regs uninit process.",
        "technologies": "Linux\nLinux Kernel 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-011214": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: seeq: Fix use after free vulnerability in ether3 Driver Due to Race Condition In the ether3_probe function, a timer is initialized with a callback function ether3_ledoff, bound to &prev(dev)->timer. Once the timer is started, there is a risk of a race condition if the module or device is removed, triggering the ether3_remove function to perform cleanup. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | ether3_ledoff ether3_remove | free_netdev(dev); | put_devic | kfree(dev); | | ether3_outw(priv(dev)->regs.config2 |= CFG2_CTRLO, REG_CONFIG2); | // use dev Fix it by ensuring that the timer is canceled before proceeding with the cleanup in ether3_remove.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011138": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ppp: fix ppp_async_encode() illegal access syzbot reported an issue in ppp_async_encode() [1] In this case, pppoe_sendmsg() is called with a zero size. Then ppp_async_encode() is called with an empty skb. BUG: KMSAN: uninit-value in ppp_async_encode drivers/net/ppp/ppp_async.c:545 [inline] BUG: KMSAN: uninit-value in ppp_async_push+0xb4f/0x2660 drivers/net/ppp/ppp_async.c:675 ppp_async_encode drivers/net/ppp/ppp_async.c:545 [inline] ppp_async_push+0xb4f/0x2660 drivers/net/ppp/ppp_async.c:675 ppp_async_send+0x130/0x1b0 drivers/net/ppp/ppp_async.c:634 ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2280 [inline] ppp_input+0x1f1/0xe60 drivers/net/ppp/ppp_generic.c:2304 pppoe_rcv_core+0x1d3/0x720 drivers/net/ppp/pppoe.c:379 sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1113 __release_sock+0x1da/0x330 net/core/sock.c:3072 release_sock+0x6b/0x250 net/core/sock.c:3626 pppoe_sendmsg+0x2b8/0xb90 drivers/net/ppp/pppoe.c:903 sock_sendmsg_nosec net/socket.c:729 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:744 ____sys_sendmsg+0x903/0xb60 net/socket.c:2602 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656 __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742 __do_sys_sendmmsg net/socket.c:2771 [inline] __se_sys_sendmmsg net/socket.c:2768 [inline] __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768 x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: slab_post_alloc_hook mm/slub.c:4092 [inline] slab_alloc_node mm/slub.c:4135 [inline] kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4187 kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:587 __alloc_skb+0x363/0x7b0 net/core/skbuff.c:678 alloc_skb include/linux/skbuff.h:1322 [inline] sock_wmalloc+0xfe/0x1a0 net/core/sock.c:2732 pppoe_sendmsg+0x3a7/0xb90 drivers/net/ppp/pppoe.c:867 sock_sendmsg_nosec net/socket.c:729 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:744 ____sys_sendmsg+0x903/0xb60 net/socket.c:2602 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656 __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742 __do_sys_sendmmsg net/socket.c:2771 [inline] __se_sys_sendmmsg net/socket.c:2768 [inline] __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768 x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f CPU: 1 UID: 0 PID: 5411 Comm: syz.1.14 Not tainted 6.12.0-rc1-syzkaller-00165-g360c1f1f24c6 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011221": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: avoid use-after-free in ext4_ext_show_leaf() In ext4_find_extent(), path may be freed by error or be reallocated, so using a previously saved *ppath may have been freed and thus may trigger use-after-free, as follows: ext4_split_extent path = *ppath; ext4_split_extent_at(ppath) path = ext4_find_extent(ppath) ext4_split_extent_at(ppath) // ext4_find_extent fails to free path // but zeroout succeeds ext4_ext_show_leaf(inode, path) eh = path[depth].p_hdr // path use-after-free !!! Similar to ext4_split_extent_at(), we use *ppath directly as an input to ext4_ext_show_leaf(). Fix a spelling error by the way. Same problem in ext4_ext_handle_unwritten_extents(). Since 'path' is only used in ext4_ext_show_leaf(), remove 'path' and use *ppath directly. This issue is triggered only when EXT_DEBUG is defined and therefore does not affect functionality.",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011233": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i3c: master: svc: Fix use after free vulnerability in svc_i3c_master Driver Due to Race Condition In the svc_i3c_master_probe function, &master->hj_work is bound with svc_i3c_master_hj_work, &master->ibi_work is bound with svc_i3c_master_ibi_work. And svc_i3c_master_ibi_work can start the hj_work, svc_i3c_master_irq_handler can start the ibi_work. If we remove the module which will call svc_i3c_master_remove to make cleanup, it will free master->base through i3c_master_unregister while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | svc_i3c_master_hj_work svc_i3c_master_remove | i3c_master_unregister(&master->base)| device_unregister(&master->dev) | device_release | //free master->base | | i3c_master_do_daa(&master->base) | //use master->base Fix it by ensuring that the work is canceled before proceeding with the cleanup in svc_i3c_master_remove.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011225": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i3c: master: cdns: Fix use after free vulnerability in cdns_i3c_master Driver Due to Race Condition In the cdns_i3c_master_probe function, &master->hj_work is bound with cdns_i3c_master_hj. And cdns_i3c_master_interrupt can call cnds_i3c_master_demux_ibis function to start the work. If we remove the module which will call cdns_i3c_master_remove to make cleanup, it will free master->base through i3c_master_unregister while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | cdns_i3c_master_hj cdns_i3c_master_remove | i3c_master_unregister(&master->base) | device_unregister(&master->dev) | device_release | //free master->base | | i3c_master_do_daa(&master->base) | //use master->base Fix it by ensuring that the work is canceled before proceeding with the cleanup in cdns_i3c_master_remove.",
        "technologies": "Linux\nLinux Kernel 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満"
    },
    "JVNDB-2024-011237": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/xen-netback: prevent UAF in xenvif_flush_hash() During the list_for_each_entry_rcu iteration call of xenvif_flush_hash, kfree_rcu does not exist inside the rcu read critical section, so if kfree_rcu is called when the rcu grace period ends during the iteration, UAF occurs when accessing head->next after the entry becomes free. Therefore, to solve this, you need to change it to list_for_each_entry_safe.",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011248": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: aovid use-after-free in ext4_ext_insert_extent() As Ojaswin mentioned in Link, in ext4_ext_insert_extent(), if the path is reallocated in ext4_ext_create_new_leaf(), we'll use the stale path and cause UAF. Below is a sample trace with dummy values: ext4_ext_insert_extent path = *ppath = 2000 ext4_ext_create_new_leaf(ppath) ext4_find_extent(ppath) path = *ppath = 2000 if (depth > path[0].p_maxdepth) kfree(path = 2000); *ppath = path = NULL; path = kcalloc() = 3000 *ppath = 3000; return path; /* here path is still 2000, UAF! */ eh = path[depth].p_hdr ================================================================== BUG: KASAN: slab-use-after-free in ext4_ext_insert_extent+0x26d4/0x3330 Read of size 8 at addr ffff8881027bf7d0 by task kworker/u36:1/179 CPU: 3 UID: 0 PID: 179 Comm: kworker/u6:1 Not tainted 6.11.0-rc2-dirty #866 Call Trace: <TASK> ext4_ext_insert_extent+0x26d4/0x3330 ext4_ext_map_blocks+0xe22/0x2d40 ext4_map_blocks+0x71e/0x1700 ext4_do_writepages+0x1290/0x2800 [...] Allocated by task 179: ext4_find_extent+0x81c/0x1f70 ext4_ext_map_blocks+0x146/0x2d40 ext4_map_blocks+0x71e/0x1700 ext4_do_writepages+0x1290/0x2800 ext4_writepages+0x26d/0x4e0 do_writepages+0x175/0x700 [...] Freed by task 179: kfree+0xcb/0x240 ext4_find_extent+0x7c0/0x1f70 ext4_ext_insert_extent+0xa26/0x3330 ext4_ext_map_blocks+0xe22/0x2d40 ext4_map_blocks+0x71e/0x1700 ext4_do_writepages+0x1290/0x2800 ext4_writepages+0x26d/0x4e0 do_writepages+0x175/0x700 [...] ================================================================== So use *ppath to update the path to avoid the above problem.",
        "technologies": "Linux\nLinux Kernel 3.18 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011229": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: slip: make slhc_remember() more robust against malicious packets syzbot found that slhc_remember() was missing checks against malicious packets [1]. slhc_remember() only checked the size of the packet was at least 20, which is not good enough. We need to make sure the packet includes the IPv4 and TCP header that are supposed to be carried. Add iph and th pointers to make the code more readable. [1] BUG: KMSAN: uninit-value in slhc_remember+0x2e8/0x7b0 drivers/net/slip/slhc.c:666 slhc_remember+0x2e8/0x7b0 drivers/net/slip/slhc.c:666 ppp_receive_nonmp_frame+0xe45/0x35e0 drivers/net/ppp/ppp_generic.c:2455 ppp_receive_frame drivers/net/ppp/ppp_generic.c:2372 [inline] ppp_do_recv+0x65f/0x40d0 drivers/net/ppp/ppp_generic.c:2212 ppp_input+0x7dc/0xe60 drivers/net/ppp/ppp_generic.c:2327 pppoe_rcv_core+0x1d3/0x720 drivers/net/ppp/pppoe.c:379 sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1113 __release_sock+0x1da/0x330 net/core/sock.c:3072 release_sock+0x6b/0x250 net/core/sock.c:3626 pppoe_sendmsg+0x2b8/0xb90 drivers/net/ppp/pppoe.c:903 sock_sendmsg_nosec net/socket.c:729 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:744 ____sys_sendmsg+0x903/0xb60 net/socket.c:2602 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656 __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742 __do_sys_sendmmsg net/socket.c:2771 [inline] __se_sys_sendmmsg net/socket.c:2768 [inline] __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768 x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: slab_post_alloc_hook mm/slub.c:4091 [inline] slab_alloc_node mm/slub.c:4134 [inline] kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4186 kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:587 __alloc_skb+0x363/0x7b0 net/core/skbuff.c:678 alloc_skb include/linux/skbuff.h:1322 [inline] sock_wmalloc+0xfe/0x1a0 net/core/sock.c:2732 pppoe_sendmsg+0x3a7/0xb90 drivers/net/ppp/pppoe.c:867 sock_sendmsg_nosec net/socket.c:729 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:744 ____sys_sendmsg+0x903/0xb60 net/socket.c:2602 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656 __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742 __do_sys_sendmmsg net/socket.c:2771 [inline] __se_sys_sendmmsg net/socket.c:2768 [inline] __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768 x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f CPU: 0 UID: 0 PID: 5460 Comm: syz.2.33 Not tainted 6.12.0-rc2-syzkaller-00006-g87d6aab2389e #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024",
        "technologies": "Linux\nLinux Kernel 3.2 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011226": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ntb: ntb_hw_switchtec: Fix use after free vulnerability in switchtec_ntb_remove due to race condition In the switchtec_ntb_add function, it can call switchtec_ntb_init_sndev function, then &sndev->check_link_status_work is bound with check_link_status_work. switchtec_ntb_link_notification may be called to start the work. If we remove the module which will call switchtec_ntb_remove to make cleanup, it will free sndev through kfree(sndev), while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | check_link_status_work switchtec_ntb_remove | kfree(sndev); | | if (sndev->link_force_down) | // use sndev Fix it by ensuring that the work is canceled before proceeding with the cleanup in switchtec_ntb_remove.",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満"
    },
    "JVNDB-2024-011227": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix UAF in async decryption Doing an async decryption (large read) crashes with a slab-use-after-free way down in the crypto API. Reproducer: # mount.cifs -o ...,seal,esize=1 //srv/share /mnt # dd if=/mnt/largefile of=/dev/null ... [ 194.196391] ================================================================== [ 194.196844] BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xc1/0x110 [ 194.197269] Read of size 8 at addr ffff888112bd0448 by task kworker/u77:2/899 [ 194.197707] [ 194.197818] CPU: 12 UID: 0 PID: 899 Comm: kworker/u77:2 Not tainted 6.11.0-lku-00028-gfca3ca14a17a-dirty #43 [ 194.198400] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014 [ 194.199046] Workqueue: smb3decryptd smb2_decrypt_offload [cifs] [ 194.200032] Call Trace: [ 194.200191] <TASK> [ 194.200327] dump_stack_lvl+0x4e/0x70 [ 194.200558] ? gf128mul_4k_lle+0xc1/0x110 [ 194.200809] print_report+0x174/0x505 [ 194.201040] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 194.201352] ? srso_return_thunk+0x5/0x5f [ 194.201604] ? __virt_addr_valid+0xdf/0x1c0 [ 194.201868] ? gf128mul_4k_lle+0xc1/0x110 [ 194.202128] kasan_report+0xc8/0x150 [ 194.202361] ? gf128mul_4k_lle+0xc1/0x110 [ 194.202616] gf128mul_4k_lle+0xc1/0x110 [ 194.202863] ghash_update+0x184/0x210 [ 194.203103] shash_ahash_update+0x184/0x2a0 [ 194.203377] ? __pfx_shash_ahash_update+0x10/0x10 [ 194.203651] ? srso_return_thunk+0x5/0x5f [ 194.203877] ? crypto_gcm_init_common+0x1ba/0x340 [ 194.204142] gcm_hash_assoc_remain_continue+0x10a/0x140 [ 194.204434] crypt_message+0xec1/0x10a0 [cifs] [ 194.206489] ? __pfx_crypt_message+0x10/0x10 [cifs] [ 194.208507] ? srso_return_thunk+0x5/0x5f [ 194.209205] ? srso_return_thunk+0x5/0x5f [ 194.209925] ? srso_return_thunk+0x5/0x5f [ 194.210443] ? srso_return_thunk+0x5/0x5f [ 194.211037] decrypt_raw_data+0x15f/0x250 [cifs] [ 194.212906] ? __pfx_decrypt_raw_data+0x10/0x10 [cifs] [ 194.214670] ? srso_return_thunk+0x5/0x5f [ 194.215193] smb2_decrypt_offload+0x12a/0x6c0 [cifs] This is because TFM is being used in parallel. Fix this by allocating a new AEAD TFM for async decryption, but keep the existing one for synchronous READ cases (similar to what is done in smb3_calc_signature()). Also remove the calls to aead_request_set_callback() and crypto_wait_req() since it's always going to be a synchronous operation.",
        "technologies": "Linux\nLinux Kernel 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満"
    },
    "JVNDB-2024-011219": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix off by one issue in alloc_flex_gd() Wesley reported an issue: ================================================================== EXT4-fs (dm-5): resizing filesystem from 7168 to 786432 blocks ------------[ cut here ]------------ kernel BUG at fs/ext4/resize.c:324! CPU: 9 UID: 0 PID: 3576 Comm: resize2fs Not tainted 6.11.0+ #27 RIP: 0010:ext4_resize_fs+0x1212/0x12d0 Call Trace: __ext4_ioctl+0x4e0/0x1800 ext4_ioctl+0x12/0x20 __x64_sys_ioctl+0x99/0xd0 x64_sys_call+0x1206/0x20d0 do_syscall_64+0x72/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e ================================================================== While reviewing the patch, Honza found that when adjusting resize_bg in alloc_flex_gd(), it was possible for flex_gd->resize_bg to be bigger than flexbg_size. The reproduction of the problem requires the following: o_group = flexbg_size * 2 * n; o_size = (o_group + 1) * group_size; n_group: [o_group + flexbg_size, o_group + flexbg_size * 2) o_size = (n_group + 1) * group_size; Take n=0,flexbg_size=16 as an example: last:15 |o---------------|--------------n-| o_group:0 resize to n_group:30 The corresponding reproducer is: img=test.img rm -f $img truncate -s 600M $img mkfs.ext4 -F $img -b 1024 -G 16 8M dev=`losetup -f --show $img` mkdir -p /tmp/test mount $dev /tmp/test resize2fs $dev 248M Delete the problematic plus 1 to fix the issue, and add a WARN_ON_ONCE() to prevent the issue from happening again. [ Note: another reproucer which this commit fixes is: img=test.img rm -f $img truncate -s 25MiB $img mkfs.ext4 -b 4096 -E nodiscard,lazy_itable_init=0,lazy_journal_init=0 $img truncate -s 3GiB $img dev=`losetup -f --show $img` mkdir -p /tmp/test mount $dev /tmp/test resize2fs $dev 3G umount $dev losetup -d $dev -- TYT ]",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011257": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: x86-android-tablets: Fix use after free on platform_device_register() errors x86_android_tablet_remove() frees the pdevs[] array, so it should not be used after calling x86_android_tablet_remove(). When platform_device_register() fails, store the pdevs[x] PTR_ERR() value into the local ret variable before calling x86_android_tablet_remove() to avoid using pdevs[] after it has been freed.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011250": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: avoid reading out of bounds when loading TX power FW elements Because the loop-expression will do one more time before getting false from cond-expression, the original code copied one more entry size beyond valid region. Fix it by moving the entry copy to loop-body.",
        "technologies": "Linux\nLinux Kernel 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011255": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nbd: fix race between timeout and normal completion If request timetout is handled by nbd_requeue_cmd(), normal completion has to be stopped for avoiding to complete this requeued request, other use-after-free can be triggered. Fix the race by clearing NBD_CMD_INFLIGHT in nbd_requeue_cmd(), meantime make sure that cmd->lock is grabbed for clearing the flag and the requeue.",
        "technologies": "Linux\nLinux Kernel 5.18.4 以上 5.19 未満\nLinux Kernel 5.19 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満\nLinux Kernel 5.17.15"
    },
    "JVNDB-2024-011217": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix invalid memory access while processing fragmented packets The monitor ring and the reo reinject ring share the same ring mask index. When the driver receives an interrupt for the reo reinject ring, the monitor ring is also processed, leading to invalid memory access. Since monitor support is not yet enabled in ath12k, the ring mask for the monitor ring should be removed. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.1.1-00209-QCAHKSWPL_SILICONZ-1",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-011261": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/ct: prevent UAF in send_recv() Ensure we serialize with completion side to prevent UAF with fence going out of scope on the stack, since we have no clue if it will fire after the timeout before we can erase from the xa. Also we have some dependent loads and stores for which we need the correct ordering, and we lack the needed barriers. Fix this by grabbing the ct->lock after the wait, which is also held by the completion side. v2 (Badal): - Also print done after acquiring the lock and seeing timeout. (cherry picked from commit 52789ce35c55ccd30c4b67b9cc5b2af55e0122ea)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011251": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: fix array out-of-bound access in SoC stats Currently, the ath11k_soc_dp_stats::hal_reo_error array is defined with a maximum size of DP_REO_DST_RING_MAX. However, the ath11k_dp_process_rx() function access ath11k_soc_dp_stats::hal_reo_error using the REO destination SRNG ring ID, which is incorrect. SRNG ring ID differ from normal ring ID, and this usage leads to out-of-bounds array access. To fix this issue, modify ath11k_dp_process_rx() to use the normal ring ID directly instead of the SRNG ring ID to avoid out-of-bounds array access. Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011280": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix slab-use-after-free in ext4_split_extent_at() We hit the following use-after-free: ================================================================== BUG: KASAN: slab-use-after-free in ext4_split_extent_at+0xba8/0xcc0 Read of size 2 at addr ffff88810548ed08 by task kworker/u20:0/40 CPU: 0 PID: 40 Comm: kworker/u20:0 Not tainted 6.9.0-dirty #724 Call Trace: <TASK> kasan_report+0x93/0xc0 ext4_split_extent_at+0xba8/0xcc0 ext4_split_extent.isra.0+0x18f/0x500 ext4_split_convert_extents+0x275/0x750 ext4_ext_handle_unwritten_extents+0x73e/0x1580 ext4_ext_map_blocks+0xe20/0x2dc0 ext4_map_blocks+0x724/0x1700 ext4_do_writepages+0x12d6/0x2a70 [...] Allocated by task 40: __kmalloc_noprof+0x1ac/0x480 ext4_find_extent+0xf3b/0x1e70 ext4_ext_map_blocks+0x188/0x2dc0 ext4_map_blocks+0x724/0x1700 ext4_do_writepages+0x12d6/0x2a70 [...] Freed by task 40: kfree+0xf1/0x2b0 ext4_find_extent+0xa71/0x1e70 ext4_ext_insert_extent+0xa22/0x3260 ext4_split_extent_at+0x3ef/0xcc0 ext4_split_extent.isra.0+0x18f/0x500 ext4_split_convert_extents+0x275/0x750 ext4_ext_handle_unwritten_extents+0x73e/0x1580 ext4_ext_map_blocks+0xe20/0x2dc0 ext4_map_blocks+0x724/0x1700 ext4_do_writepages+0x12d6/0x2a70 [...] ================================================================== The flow of issue triggering is as follows: ext4_split_extent_at path = *ppath ext4_ext_insert_extent(ppath) ext4_ext_create_new_leaf(ppath) ext4_find_extent(orig_path) path = *orig_path read_extent_tree_block // return -ENOMEM or -EIO ext4_free_ext_path(path) kfree(path) *orig_path = NULL a. If err is -ENOMEM: ext4_ext_dirty(path + path->p_depth) // path use-after-free !!! b. If err is -EIO and we have EXT_DEBUG defined: ext4_ext_show_leaf(path) eh = path[depth].p_hdr // path also use-after-free !!! So when trying to zeroout or fix the extent length, call ext4_find_extent() to update the path. In addition we use *ppath directly as an ext4_ext_show_leaf() input to avoid possible use-after-free when EXT_DEBUG is defined, and to avoid unnecessary path updates.",
        "technologies": "Linux\nLinux Kernel 3.18 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011291": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix index out of bounds in degamma hardware format translation Fixes index out of bounds issue in `cm_helper_translate_curve_to_degamma_hw_format` function. The issue could occur when the index 'i' exceeds the number of transfer function points (TRANSFER_FUNC_POINTS). The fix adds a check to ensure 'i' is within bounds before accessing the transfer function points. If 'i' is out of bounds the function returns false to indicate an error. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:594 cm_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:595 cm_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:596 cm_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011309": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/stm: Avoid use-after-free issues with crtc and plane ltdc_load() calls functions drm_crtc_init_with_planes(), drm_universal_plane_init() and drm_encoder_init(). These functions should not be called with parameters allocated with devm_kzalloc() to avoid use-after-free issues [1]. Use allocations managed by the DRM framework. Found by Linux Verification Center (linuxtesting.org). [1] https://lore.kernel.org/lkml/u366i76e3qhh3ra5oxrtngjtm2u5lterkekcz6y2jkndhuxzli@diujon4h7qwb/",
        "technologies": "Linux\nLinux Kernel 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011312": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: send: fix buffer overflow detection when copying path to cache entry Starting with commit c0247d289e73 (\"btrfs: send: annotate struct name_cache_entry with __counted_by()\") we annotated the variable length array \"name\" from the name_cache_entry structure with __counted_by() to improve overflow detection. However that alone was not correct, because the length of that array does not match the \"name_len\" field - it matches that plus 1 to include the NUL string terminator, so that makes a fortified kernel think there's an overflow and report a splat like this: strcpy: detected buffer overflow: 20 byte write of buffer size 19 WARNING: CPU: 3 PID: 3310 at __fortify_report+0x45/0x50 CPU: 3 UID: 0 PID: 3310 Comm: btrfs Not tainted 6.11.0-prnet #1 Hardware name: CompuLab Ltd. sbc-ihsw/Intense-PC2 (IPC2), BIOS IPC2_3.330.7 X64 03/15/2018 RIP: 0010:__fortify_report+0x45/0x50 Code: 48 8b 34 (...) RSP: 0018:ffff97ebc0d6f650 EFLAGS: 00010246 RAX: 7749924ef60fa600 RBX: ffff8bf5446a521a RCX: 0000000000000027 RDX: 00000000ffffdfff RSI: ffff97ebc0d6f548 RDI: ffff8bf84e7a1cc8 RBP: ffff8bf548574080 R08: ffffffffa8c40e10 R09: 0000000000005ffd R10: 0000000000000004 R11: ffffffffa8c70e10 R12: ffff8bf551eef400 R13: 0000000000000000 R14: 0000000000000013 R15: 00000000000003a8 FS: 00007fae144de8c0(0000) GS:ffff8bf84e780000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fae14691690 CR3: 00000001027a2003 CR4: 00000000001706f0 Call Trace: <TASK> ? __warn+0x12a/0x1d0 ? __fortify_report+0x45/0x50 ? report_bug+0x154/0x1c0 ? handle_bug+0x42/0x70 ? exc_invalid_op+0x1a/0x50 ? asm_exc_invalid_op+0x1a/0x20 ? __fortify_report+0x45/0x50 __fortify_panic+0x9/0x10 __get_cur_name_and_parent+0x3bc/0x3c0 get_cur_path+0x207/0x3b0 send_extent_data+0x709/0x10d0 ? find_parent_nodes+0x22df/0x25d0 ? mas_nomem+0x13/0x90 ? mtree_insert_range+0xa5/0x110 ? btrfs_lru_cache_store+0x5f/0x1e0 ? iterate_extent_inodes+0x52d/0x5a0 process_extent+0xa96/0x11a0 ? __pfx_lookup_backref_cache+0x10/0x10 ? __pfx_store_backref_cache+0x10/0x10 ? __pfx_iterate_backrefs+0x10/0x10 ? __pfx_check_extent_item+0x10/0x10 changed_cb+0x6fa/0x930 ? tree_advance+0x362/0x390 ? memcmp_extent_buffer+0xd7/0x160 send_subvol+0xf0a/0x1520 btrfs_ioctl_send+0x106b/0x11d0 ? __pfx___clone_root_cmp_sort+0x10/0x10 _btrfs_ioctl_send+0x1ac/0x240 btrfs_ioctl+0x75b/0x850 __se_sys_ioctl+0xca/0x150 do_syscall_64+0x85/0x160 ? __count_memcg_events+0x69/0x100 ? handle_mm_fault+0x1327/0x15c0 ? __se_sys_rt_sigprocmask+0xf1/0x180 ? syscall_exit_to_user_mode+0x75/0xa0 ? do_syscall_64+0x91/0x160 ? do_user_addr_fault+0x21d/0x630 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7fae145eeb4f Code: 00 48 89 (...) RSP: 002b:00007ffdf1cb09b0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007fae145eeb4f RDX: 00007ffdf1cb0ad0 RSI: 0000000040489426 RDI: 0000000000000004 RBP: 00000000000078fe R08: 00007fae144006c0 R09: 00007ffdf1cb0927 R10: 0000000000000008 R11: 0000000000000246 R12: 00007ffdf1cb1ce8 R13: 0000000000000003 R14: 000055c499fab2e0 R15: 0000000000000004 </TASK> Fix this by not storing the NUL string terminator since we don't actually need it for name cache entries, this way \"name_len\" corresponds to the actual size of the \"name\" array. This requires marking the \"name\" array field with __nonstring and using memcpy() instead of strcpy() as recommended by the guidelines at: https://github.com/KSPP/linux/issues/90",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011336": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Correct the defined value for AMDGPU_DMUB_NOTIFICATION_MAX [Why & How] It actually exposes '6' types in enum dmub_notification_type. Not 5. Using smaller number to create array dmub_callback & dmub_thread_offload has potential to access item out of array bound. Fix it.",
        "technologies": "Linux\nLinux Kernel 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-011350": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vhost_vdpa: assign irq bypass producer token correctly We used to call irq_bypass_unregister_producer() in vhost_vdpa_setup_vq_irq() which is problematic as we don't know if the token pointer is still valid or not. Actually, we use the eventfd_ctx as the token so the life cycle of the token should be bound to the VHOST_SET_VRING_CALL instead of vhost_vdpa_setup_vq_irq() which could be called by set_status(). Fixing this by setting up irq bypass producer's token when handling VHOST_SET_VRING_CALL and un-registering the producer before calling vhost_vring_ioctl() to prevent a possible use after free as eventfd could have been released in vhost_vring_ioctl(). And such registering and unregistering will only be done if DRIVER_OK is set.",
        "technologies": "Linux\nLinux Kernel 5.9 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011365": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: do not delay dst_entries_add() in dst_release() dst_entries_add() uses per-cpu data that might be freed at netns dismantle from ip6_route_net_exit() calling dst_entries_destroy() Before ip6_route_net_exit() can be called, we release all the dsts associated with this netns, via calls to dst_release(), which waits an rcu grace period before calling dst_destroy() dst_entries_add() use in dst_destroy() is racy, because dst_entries_destroy() could have been called already. Decrementing the number of dsts must happen sooner. Notes: 1) in CONFIG_XFRM case, dst_destroy() can call dst_release_immediate(child), this might also cause UAF if the child does not have DST_NOCOUNT set. IPSEC maintainers might take a look and see how to address this. 2) There is also discussion about removing this count of dst, which might happen in future kernels.",
        "technologies": "Linux\nLinux Kernel 3.10.50 以上 3.11 未満\nLinux Kernel 3.12.26 以上 3.13 未満\nLinux Kernel 3.14.14 以上 3.15 未満\nLinux Kernel 3.15.7 以上 3.16 未満\nLinux Kernel 3.16 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011356": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block, bfq: fix uaf for accessing waker_bfqq after splitting After commit 42c306ed7233 (\"block, bfq: don't break merge chain in bfq_split_bfqq()\"), if the current procress is the last holder of bfqq, the bfqq can be freed after bfq_split_bfqq(). Hence recored the bfqq and then access bfqq->waker_bfqq may trigger UAF. What's more, the waker_bfqq may in the merge chain of bfqq, hence just recored waker_bfqq is still not safe. Fix the problem by adding a helper bfq_waker_bfqq() to check if bfqq->waker_bfqq is in the merge chain, and current procress is the only holder.",
        "technologies": "Linux\nLinux Kernel 5.10.227 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011348": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: iaa - Fix potential use after free bug The free_device_compression_mode(iaa_device, device_mode) function frees \"device_mode\" but it iss passed to iaa_compression_modes[i]->free() a few lines later resulting in a use after free. The good news is that, so far as I can tell, nothing implements the ->free() function and the use after free happens in dead code. But, with this fix, when something does implement it, we'll be ready. :)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011343": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: aoe: fix the potential use-after-free problem in more places For fixing CVE-2023-6270, f98364e92662 (\"aoe: fix the potential use-after-free problem in aoecmd_cfg_pkts\") makes tx() calling dev_put() instead of doing in aoecmd_cfg_pkts(). It avoids that the tx() runs into use-after-free. Then Nicolai Stange found more places in aoe have potential use-after-free problem with tx(). e.g. revalidate(), aoecmd_ata_rw(), resend(), probe() and aoecmd_cfg_rsp(). Those functions also use aoenet_xmit() to push packet to tx queue. So they should also use dev_hold() to increase the refcnt of skb->dev. On the other hand, moving dev_put() to tx() causes that the refcnt of skb->dev be reduced to a negative value, because corresponding dev_hold() are not called in revalidate(), aoecmd_ata_rw(), resend(), probe(), and aoecmd_cfg_rsp(). This patch fixed this issue.",
        "technologies": "Linux\nLinux Kernel 5.10.214 以上 5.10.227 未満\nLinux Kernel 5.15.153 以上 5.15.168 未満\nLinux Kernel 6.1.83 以上 6.1.113 未満\nLinux Kernel 6.6.23 以上 6.6.55 未満\nLinux Kernel 6.7.11 以上 6.8.2 未満\nLinux Kernel 6.9 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満\nLinux Kernel 4.19.311\nLinux Kernel 5.4.273\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011294": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: Fix uninit-value access of new_ea in ea_buffer syzbot reports that lzo1x_1_do_compress is using uninit-value: ===================================================== BUG: KMSAN: uninit-value in lzo1x_1_do_compress+0x19f9/0x2510 lib/lzo/lzo1x_compress.c:178 ... Uninit was stored to memory at: ea_put fs/jfs/xattr.c:639 [inline] ... Local variable ea_buf created at: __jfs_setxattr+0x5d/0x1ae0 fs/jfs/xattr.c:662 __jfs_xattr_set+0xe6/0x1f0 fs/jfs/xattr.c:934 ===================================================== The reason is ea_buf->new_ea is not initialized properly. Fix this by using memset to empty its content at the beginning in ea_get().",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011366": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_conn: Fix UAF in hci_enhanced_setup_sync This checks if the ACL connection remains valid as it could be destroyed while hci_enhanced_setup_sync is pending on cmd_sync leading to the following trace: BUG: KASAN: slab-use-after-free in hci_enhanced_setup_sync+0x91b/0xa60 Read of size 1 at addr ffff888002328ffd by task kworker/u5:2/37 CPU: 0 UID: 0 PID: 37 Comm: kworker/u5:2 Not tainted 6.11.0-rc6-01300-g810be445d8d6 #7099 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> dump_stack_lvl+0x5d/0x80 ? hci_enhanced_setup_sync+0x91b/0xa60 print_report+0x152/0x4c0 ? hci_enhanced_setup_sync+0x91b/0xa60 ? __virt_addr_valid+0x1fa/0x420 ? hci_enhanced_setup_sync+0x91b/0xa60 kasan_report+0xda/0x1b0 ? hci_enhanced_setup_sync+0x91b/0xa60 hci_enhanced_setup_sync+0x91b/0xa60 ? __pfx_hci_enhanced_setup_sync+0x10/0x10 ? __pfx___mutex_lock+0x10/0x10 hci_cmd_sync_work+0x1c2/0x330 process_one_work+0x7d9/0x1360 ? __pfx_lock_acquire+0x10/0x10 ? __pfx_process_one_work+0x10/0x10 ? assign_work+0x167/0x240 worker_thread+0x5b7/0xf60 ? __kthread_parkme+0xac/0x1c0 ? __pfx_worker_thread+0x10/0x10 ? __pfx_worker_thread+0x10/0x10 kthread+0x293/0x360 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2f/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 34: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 __hci_conn_add+0x187/0x17d0 hci_connect_sco+0x2e1/0xb90 sco_sock_connect+0x2a2/0xb80 __sys_connect+0x227/0x2a0 __x64_sys_connect+0x6d/0xb0 do_syscall_64+0x71/0x140 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 37: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x101/0x160 kfree+0xd0/0x250 device_release+0x9a/0x210 kobject_put+0x151/0x280 hci_conn_del+0x448/0xbf0 hci_abort_conn_sync+0x46f/0x980 hci_cmd_sync_work+0x1c2/0x330 process_one_work+0x7d9/0x1360 worker_thread+0x5b7/0xf60 kthread+0x293/0x360 ret_from_fork+0x2f/0x70 ret_from_fork_asm+0x1a/0x30",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.6.57 未満\nLinux Kernel 6.7 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011371": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: sd: Fix off-by-one error in sd_read_block_characteristics() Ff the device returns page 0xb1 with length 8 (happens with qemu v2.x, for example), sd_read_block_characteristics() may attempt an out-of-bounds memory access when accessing the zoned field at offset 8.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011368": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put() syzbot reported that nf_reject_ip6_tcphdr_put() was possibly sending garbage on the four reserved tcp bits (th->res1) Use skb_put_zero() to clear the whole TCP header, as done in nf_reject_ip_tcphdr_put() BUG: KMSAN: uninit-value in nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255 nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255 nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344 nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48 expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline] nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288 nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] NF_HOOK include/linux/netfilter.h:312 [inline] ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310 __netif_receive_skb_one_core net/core/dev.c:5661 [inline] __netif_receive_skb+0x1da/0xa00 net/core/dev.c:5775 process_backlog+0x4ad/0xa50 net/core/dev.c:6108 __napi_poll+0xe7/0x980 net/core/dev.c:6772 napi_poll net/core/dev.c:6841 [inline] net_rx_action+0xa5a/0x19b0 net/core/dev.c:6963 handle_softirqs+0x1ce/0x800 kernel/softirq.c:554 __do_softirq+0x14/0x1a kernel/softirq.c:588 do_softirq+0x9a/0x100 kernel/softirq.c:455 __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:382 local_bh_enable include/linux/bottom_half.h:33 [inline] rcu_read_unlock_bh include/linux/rcupdate.h:908 [inline] __dev_queue_xmit+0x2692/0x5610 net/core/dev.c:4450 dev_queue_xmit include/linux/netdevice.h:3105 [inline] neigh_resolve_output+0x9ca/0xae0 net/core/neighbour.c:1565 neigh_output include/net/neighbour.h:542 [inline] ip6_finish_output2+0x2347/0x2ba0 net/ipv6/ip6_output.c:141 __ip6_finish_output net/ipv6/ip6_output.c:215 [inline] ip6_finish_output+0xbb8/0x14b0 net/ipv6/ip6_output.c:226 NF_HOOK_COND include/linux/netfilter.h:303 [inline] ip6_output+0x356/0x620 net/ipv6/ip6_output.c:247 dst_output include/net/dst.h:450 [inline] NF_HOOK include/linux/netfilter.h:314 [inline] ip6_xmit+0x1ba6/0x25d0 net/ipv6/ip6_output.c:366 inet6_csk_xmit+0x442/0x530 net/ipv6/inet6_connection_sock.c:135 __tcp_transmit_skb+0x3b07/0x4880 net/ipv4/tcp_output.c:1466 tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline] tcp_connect+0x35b6/0x7130 net/ipv4/tcp_output.c:4143 tcp_v6_connect+0x1bcc/0x1e40 net/ipv6/tcp_ipv6.c:333 __inet_stream_connect+0x2ef/0x1730 net/ipv4/af_inet.c:679 inet_stream_connect+0x6a/0xd0 net/ipv4/af_inet.c:750 __sys_connect_file net/socket.c:2061 [inline] __sys_connect+0x606/0x690 net/socket.c:2078 __do_sys_connect net/socket.c:2088 [inline] __se_sys_connect net/socket.c:2085 [inline] __x64_sys_connect+0x91/0xe0 net/socket.c:2085 x64_sys_call+0x27a5/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:43 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was stored to memory at: nf_reject_ip6_tcphdr_put+0x60c/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:249 nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344 nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48 expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline] nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288 nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] NF_HOOK include/linux/netfilter.h:312 [inline] ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310 __netif_receive_skb_one_core ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.18 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011373": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: add bounds checking to ocfs2_xattr_find_entry() Add a paranoia check to make sure it doesn't stray beyond valid memory region containing ocfs2 xattr entries when scanning for a match. It will prevent out-of-bound access in case of crafted images.",
        "technologies": "Linux\nLinux Kernel 6.1.112 未満\nLinux Kernel 6.2 以上 6.6.53 未満\nLinux Kernel 6.7 以上 6.10.12 未満"
    },
    "JVNDB-2024-011381": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix timer use-after-free on failed mount Syzbot has found an ODEBUG bug in ext4_fill_super The del_timer_sync function cancels the s_err_report timer, which reminds about filesystem errors daily. We should guarantee the timer is no longer active before kfree(sbi). When filesystem mounting fails, the flow goes to failed_mount3, where an error occurs when ext4_stop_mmpd is called, causing a read I/O failure. This triggers the ext4_handle_error function that ultimately re-arms the timer, leaving the s_err_report timer active before kfree(sbi) is called. Fix the issue by canceling the s_err_report timer after calling ext4_stop_mmpd.",
        "technologies": "Linux\nLinux Kernel 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011376": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smack: tcp: ipv4, fix incorrect labeling Currently, Smack mirrors the label of incoming tcp/ipv4 connections: when a label 'foo' connects to a label 'bar' with tcp/ipv4, 'foo' always gets 'foo' in returned ipv4 packets. So, 1) returned packets are incorrectly labeled ('foo' instead of 'bar') 2) 'bar' can write to 'foo' without being authorized to write. Here is a scenario how to see this: * Take two machines, let's call them C and S, with active Smack in the default state (no settings, no rules, no labeled hosts, only builtin labels) * At S, add Smack rule 'foo bar w' (labels 'foo' and 'bar' are instantiated at S at this moment) * At S, at label 'bar', launch a program that listens for incoming tcp/ipv4 connections * From C, at label 'foo', connect to the listener at S. (label 'foo' is instantiated at C at this moment) Connection succeedes and works. * Send some data in both directions. * Collect network traffic of this connection. All packets in both directions are labeled with the CIPSO of the label 'foo'. Hence, label 'bar' writes to 'foo' without being authorized, and even without ever being known at C. If anybody cares: exactly the same happens with DCCP. This behavior 1st manifested in release 2.6.29.4 (see Fixes below) and it looks unintentional. At least, no explanation was provided. I changed returned packes label into the 'bar', to bring it into line with the Smack documentation claims.",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-007694": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: stm class: Fix a double free in stm_register_device() The put_device(&stm->dev) call will trigger stm_device_release() which frees \"stm\" so the vfree(stm) on the next line is a double free.",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-007768": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe: Free job before xe_exec_queue_put Free job depends on job->vm being valid, the last xe_exec_queue_put can destroy the VM. Prevent UAF by freeing job before xe_exec_queue_put. (cherry picked from commit 32a42c93b74c8ca6d0915ea3eba21bceff53042f)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007748": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hfsplus: fix uninit-value in copy_name [syzbot reported] BUG: KMSAN: uninit-value in sized_strscpy+0xc4/0x160 sized_strscpy+0xc4/0x160 copy_name+0x2af/0x320 fs/hfsplus/xattr.c:411 hfsplus_listxattr+0x11e9/0x1a50 fs/hfsplus/xattr.c:750 vfs_listxattr fs/xattr.c:493 [inline] listxattr+0x1f3/0x6b0 fs/xattr.c:840 path_listxattr fs/xattr.c:864 [inline] __do_sys_listxattr fs/xattr.c:876 [inline] __se_sys_listxattr fs/xattr.c:873 [inline] __x64_sys_listxattr+0x16b/0x2f0 fs/xattr.c:873 x64_sys_call+0x2ba0/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:195 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: slab_post_alloc_hook mm/slub.c:3877 [inline] slab_alloc_node mm/slub.c:3918 [inline] kmalloc_trace+0x57b/0xbe0 mm/slub.c:4065 kmalloc include/linux/slab.h:628 [inline] hfsplus_listxattr+0x4cc/0x1a50 fs/hfsplus/xattr.c:699 vfs_listxattr fs/xattr.c:493 [inline] listxattr+0x1f3/0x6b0 fs/xattr.c:840 path_listxattr fs/xattr.c:864 [inline] __do_sys_listxattr fs/xattr.c:876 [inline] __se_sys_listxattr fs/xattr.c:873 [inline] __x64_sys_listxattr+0x16b/0x2f0 fs/xattr.c:873 x64_sys_call+0x2ba0/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:195 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f [Fix] When allocating memory to strbuf, initialize memory to 0.",
        "technologies": "Linux\nLinux Kernel 4.19.319 未満\nLinux Kernel 4.20 以上 5.4.281 未満\nLinux Kernel 5.5 以上 5.10.223 未満\nLinux Kernel 5.11 以上 5.15.164 未満\nLinux Kernel 5.16 以上 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満"
    },
    "JVNDB-2024-008307": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/dasd: fix error recovery leading to data corruption on ESE devices Extent Space Efficient (ESE) or thin provisioned volumes need to be formatted on demand during usual IO processing. The dasd_ese_needs_format function checks for error codes that signal the non existence of a proper track format. The check for incorrect length is to imprecise since other error cases leading to transport of insufficient data also have this flag set. This might lead to data corruption in certain error cases for example during a storage server warmstart. Fix by removing the check for incorrect length and replacing by explicitly checking for invalid track format in transport mode. Also remove the check for file protected since this is not a valid ESE handling case.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007771": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mISDN: Fix a use after free in hfcmulti_tx() Don't dereference *sp after calling dev_kfree_skb(*sp).",
        "technologies": "Linux\nLinux Kernel 2.6.27 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-007747": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: Fix UAF when resolving a clash KASAN reports the following UAF: BUG: KASAN: slab-use-after-free in tcf_ct_flow_table_process_conn+0x12b/0x380 [act_ct] Read of size 1 at addr ffff888c07603600 by task handler130/6469 Call Trace: <IRQ> dump_stack_lvl+0x48/0x70 print_address_description.constprop.0+0x33/0x3d0 print_report+0xc0/0x2b0 kasan_report+0xd0/0x120 __asan_load1+0x6c/0x80 tcf_ct_flow_table_process_conn+0x12b/0x380 [act_ct] tcf_ct_act+0x886/0x1350 [act_ct] tcf_action_exec+0xf8/0x1f0 fl_classify+0x355/0x360 [cls_flower] __tcf_classify+0x1fd/0x330 tcf_classify+0x21c/0x3c0 sch_handle_ingress.constprop.0+0x2c5/0x500 __netif_receive_skb_core.constprop.0+0xb25/0x1510 __netif_receive_skb_list_core+0x220/0x4c0 netif_receive_skb_list_internal+0x446/0x620 napi_complete_done+0x157/0x3d0 gro_cell_poll+0xcf/0x100 __napi_poll+0x65/0x310 net_rx_action+0x30c/0x5c0 __do_softirq+0x14f/0x491 __irq_exit_rcu+0x82/0xc0 irq_exit_rcu+0xe/0x20 common_interrupt+0xa1/0xb0 </IRQ> <TASK> asm_common_interrupt+0x27/0x40 Allocated by task 6469: kasan_save_stack+0x38/0x70 kasan_set_track+0x25/0x40 kasan_save_alloc_info+0x1e/0x40 __kasan_krealloc+0x133/0x190 krealloc+0xaa/0x130 nf_ct_ext_add+0xed/0x230 [nf_conntrack] tcf_ct_act+0x1095/0x1350 [act_ct] tcf_action_exec+0xf8/0x1f0 fl_classify+0x355/0x360 [cls_flower] __tcf_classify+0x1fd/0x330 tcf_classify+0x21c/0x3c0 sch_handle_ingress.constprop.0+0x2c5/0x500 __netif_receive_skb_core.constprop.0+0xb25/0x1510 __netif_receive_skb_list_core+0x220/0x4c0 netif_receive_skb_list_internal+0x446/0x620 napi_complete_done+0x157/0x3d0 gro_cell_poll+0xcf/0x100 __napi_poll+0x65/0x310 net_rx_action+0x30c/0x5c0 __do_softirq+0x14f/0x491 Freed by task 6469: kasan_save_stack+0x38/0x70 kasan_set_track+0x25/0x40 kasan_save_free_info+0x2b/0x60 ____kasan_slab_free+0x180/0x1f0 __kasan_slab_free+0x12/0x30 slab_free_freelist_hook+0xd2/0x1a0 __kmem_cache_free+0x1a2/0x2f0 kfree+0x78/0x120 nf_conntrack_free+0x74/0x130 [nf_conntrack] nf_ct_destroy+0xb2/0x140 [nf_conntrack] __nf_ct_resolve_clash+0x529/0x5d0 [nf_conntrack] nf_ct_resolve_clash+0xf6/0x490 [nf_conntrack] __nf_conntrack_confirm+0x2c6/0x770 [nf_conntrack] tcf_ct_act+0x12ad/0x1350 [act_ct] tcf_action_exec+0xf8/0x1f0 fl_classify+0x355/0x360 [cls_flower] __tcf_classify+0x1fd/0x330 tcf_classify+0x21c/0x3c0 sch_handle_ingress.constprop.0+0x2c5/0x500 __netif_receive_skb_core.constprop.0+0xb25/0x1510 __netif_receive_skb_list_core+0x220/0x4c0 netif_receive_skb_list_internal+0x446/0x620 napi_complete_done+0x157/0x3d0 gro_cell_poll+0xcf/0x100 __napi_poll+0x65/0x310 net_rx_action+0x30c/0x5c0 __do_softirq+0x14f/0x491 The ct may be dropped if a clash has been resolved but is still passed to the tcf_ct_flow_table_process_conn function for further usage. This issue can be fixed by retrieving ct from skb again after confirming conntrack.",
        "technologies": "Linux\nLinux Kernel 5.10.43 以上 5.10.222 未満\nLinux Kernel 5.12.10 以上 5.13 未満\nLinux Kernel 5.13 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.100 未満\nLinux Kernel 6.2 以上 6.6.41 未満\nLinux Kernel 6.7 以上 6.9.10 未満"
    },
    "JVNDB-2024-007696": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: PAC1934: fix accessing out of bounds array index Fix accessing out of bounds array index for average current and voltage measurements. The device itself has only 4 channels, but in sysfs there are \"fake\" channels for the average voltages and currents too.",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.9.4 未満"
    },
    "JVNDB-2024-007936": {
        "title": "インテルの Linux 用 ethernet 800 series controllers driver における境界外書き込みに関する脆弱性",
        "description": "Out-of-bounds write in Linux kernel mode driver for some Intel(R) Ethernet Network Controllers and Adapters before version 28.3 may allow an authenticated user to potentially enable escalation of privilege via local access.",
        "technologies": "インテル\nethernet 800 series controllers driver 28.3 未満\n日立\n日立アドバンストサーバ HA8000V シリーズ"
    },
    "JVNDB-2024-008283": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: dwc3: st: fix probed platform device ref count on probe error path The probe function never performs any paltform device allocation, thus error path \"undo_platform_dev_alloc\" is entirely bogus. It drops the reference count from the platform device being probed. If error path is triggered, this will lead to unbalanced device reference counts and premature release of device resources, thus possible use-after-free when releasing remaining devm-managed resources.",
        "technologies": "Linux\nLinux Kernel 3.18 以上 4.19.321 未満\nLinux Kernel 4.20 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.108 未満\nLinux Kernel 6.2 以上 6.6.49 未満\nLinux Kernel 6.7 以上 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007766": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix overflow checking of wmfw header Fix the checking that firmware file buffer is large enough for the wmfw header, to prevent overrunning the buffer. The original code tested that the firmware data buffer contained enough bytes for the sums of the size of the structs wmfw_header + wmfw_adsp1_sizes + wmfw_footer But wmfw_adsp1_sizes is only used on ADSP1 firmware. For ADSP2 and Halo Core the equivalent struct is wmfw_adsp2_sizes, which is 4 bytes longer. So the length check didn't guarantee that there are enough bytes in the firmware buffer for a header with wmfw_adsp2_sizes. This patch splits the length check into three separate parts. Each of the wmfw_header, wmfw_adsp?_sizes and wmfw_footer are checked separately before they are used.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.100 未満\nLinux Kernel 6.2 以上 6.6.41 未満\nLinux Kernel 6.7 以上 6.9.10 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-008189": {
        "title": "NVIDIA の Jetson Linux における例外的な状態の処理に関する脆弱性",
        "description": "NVIDIA Jetson Linux contains a vulnerability in NvGPU where error handling paths in GPU MMU mapping code fail to clean up a failed mapping attempt. A successful exploit of this vulnerability may lead to denial of service, code execution, and escalation of privileges.",
        "technologies": "NVIDIA\nJetson Linux 32.7.5 未満"
    },
    "JVNDB-2024-008272": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: fix potential UAF in nfsd4_cb_getattr_release Once we drop the delegation reference, the fields embedded in it are no longer safe to access. Do that last.",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007775": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: flowtable: validate vlan header Ensure there is sufficient room to access the protocol field of the VLAN header, validate it once before the flowtable lookup. ===================================================== BUG: KMSAN: uninit-value in nf_flow_offload_inet_hook+0x45a/0x5f0 net/netfilter/nf_flow_table_inet.c:32 nf_flow_offload_inet_hook+0x45a/0x5f0 net/netfilter/nf_flow_table_inet.c:32 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626 nf_hook_ingress include/linux/netfilter_netdev.h:34 [inline] nf_ingress net/core/dev.c:5440 [inline]",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007975": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fou: remove warn in gue_gro_receive on unsupported protocol Drop the WARN_ON_ONCE inn gue_gro_receive if the encapsulated type is not known or does not have a GRO handler. Such a packet is easily constructed. Syzbot generates them and sets off this warning. Remove the warning as it is expected and not actionable. The warning was previously reduced from WARN_ON to WARN_ON_ONCE in commit 270136613bf7 (\"fou: Do WARN_ON_ONCE in gue_gro_receive for bad proto callbacks\").",
        "technologies": "Linux\nLinux Kernel 6.6.47 未満\nLinux Kernel 6.7 以上 6.10.6 未満"
    },
    "JVNDB-2024-008308": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix a use-after-free when hitting errors inside btrfs_submit_chunk() [BUG] There is an internal report that KASAN is reporting use-after-free, with the following backtrace: BUG: KASAN: slab-use-after-free in btrfs_check_read_bio+0xa68/0xb70 [btrfs] Read of size 4 at addr ffff8881117cec28 by task kworker/u16:2/45 CPU: 1 UID: 0 PID: 45 Comm: kworker/u16:2 Not tainted 6.11.0-rc2-next-20240805-default+ #76 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 Workqueue: btrfs-endio btrfs_end_bio_work [btrfs] Call Trace: dump_stack_lvl+0x61/0x80 print_address_description.constprop.0+0x5e/0x2f0 print_report+0x118/0x216 kasan_report+0x11d/0x1f0 btrfs_check_read_bio+0xa68/0xb70 [btrfs] process_one_work+0xce0/0x12a0 worker_thread+0x717/0x1250 kthread+0x2e3/0x3c0 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x11/0x20 Allocated by task 20917: kasan_save_stack+0x37/0x60 kasan_save_track+0x10/0x30 __kasan_slab_alloc+0x7d/0x80 kmem_cache_alloc_noprof+0x16e/0x3e0 mempool_alloc_noprof+0x12e/0x310 bio_alloc_bioset+0x3f0/0x7a0 btrfs_bio_alloc+0x2e/0x50 [btrfs] submit_extent_page+0x4d1/0xdb0 [btrfs] btrfs_do_readpage+0x8b4/0x12a0 [btrfs] btrfs_readahead+0x29a/0x430 [btrfs] read_pages+0x1a7/0xc60 page_cache_ra_unbounded+0x2ad/0x560 filemap_get_pages+0x629/0xa20 filemap_read+0x335/0xbf0 vfs_read+0x790/0xcb0 ksys_read+0xfd/0x1d0 do_syscall_64+0x6d/0x140 entry_SYSCALL_64_after_hwframe+0x4b/0x53 Freed by task 20917: kasan_save_stack+0x37/0x60 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x50 __kasan_slab_free+0x4b/0x60 kmem_cache_free+0x214/0x5d0 bio_free+0xed/0x180 end_bbio_data_read+0x1cc/0x580 [btrfs] btrfs_submit_chunk+0x98d/0x1880 [btrfs] btrfs_submit_bio+0x33/0x70 [btrfs] submit_one_bio+0xd4/0x130 [btrfs] submit_extent_page+0x3ea/0xdb0 [btrfs] btrfs_do_readpage+0x8b4/0x12a0 [btrfs] btrfs_readahead+0x29a/0x430 [btrfs] read_pages+0x1a7/0xc60 page_cache_ra_unbounded+0x2ad/0x560 filemap_get_pages+0x629/0xa20 filemap_read+0x335/0xbf0 vfs_read+0x790/0xcb0 ksys_read+0xfd/0x1d0 do_syscall_64+0x6d/0x140 entry_SYSCALL_64_after_hwframe+0x4b/0x53 [CAUSE] Although I cannot reproduce the error, the report itself is good enough to pin down the cause. The call trace is the regular endio workqueue context, but the free-by-task trace is showing that during btrfs_submit_chunk() we already hit a critical error, and is calling btrfs_bio_end_io() to error out. And the original endio function called bio_put() to free the whole bio. This means a double freeing thus causing use-after-free, e.g.: 1. Enter btrfs_submit_bio() with a read bio The read bio length is 128K, crossing two 64K stripes. 2. The first run of btrfs_submit_chunk() 2.1 Call btrfs_map_block(), which returns 64K 2.2 Call btrfs_split_bio() Now there are two bios, one referring to the first 64K, the other referring to the second 64K. 2.3 The first half is submitted. 3. The second run of btrfs_submit_chunk() 3.1 Call btrfs_map_block(), which by somehow failed Now we call btrfs_bio_end_io() to handle the error 3.2 btrfs_bio_end_io() calls the original endio function Which is end_bbio_data_read(), and it calls bio_put() for the original bio. Now the original bio is freed. 4. The submitted first 64K bio finished Now we call into btrfs_check_read_bio() and tries to advance the bio iter. But since the original bio (thus its iter) is already freed, we trigger the above use-after free. And even if the memory is not poisoned/corrupted, we will later call the original endio function, causing a double freeing. [FIX] Instead of calling btrfs_bio_end_io(), call btrfs_orig_bbio_end_io(), which has the extra check on split bios and do the pr ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.49 未満\nLinux Kernel 6.7 以上 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008310": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Disable preemption while updating GPU stats We forgot to disable preemption around the write_seqcount_begin/end() pair while updating GPU stats: [ ] WARNING: CPU: 2 PID: 12 at include/linux/seqlock.h:221 __seqprop_assert.isra.0+0x128/0x150 [v3d] [ ] Workqueue: v3d_bin drm_sched_run_job_work [gpu_sched] <...snip...> [ ] Call trace: [ ] __seqprop_assert.isra.0+0x128/0x150 [v3d] [ ] v3d_job_start_stats.isra.0+0x90/0x218 [v3d] [ ] v3d_bin_job_run+0x23c/0x388 [v3d] [ ] drm_sched_run_job_work+0x520/0x6d0 [gpu_sched] [ ] process_one_work+0x62c/0xb48 [ ] worker_thread+0x468/0x5b0 [ ] kthread+0x1c4/0x1e0 [ ] ret_from_fork+0x10/0x20 Fix it.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008312": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cdrom: rearrange last_media_change check to avoid unintentional overflow When running syzkaller with the newly reintroduced signed integer wrap sanitizer we encounter this splat: [ 366.015950] UBSAN: signed-integer-overflow in ../drivers/cdrom/cdrom.c:2361:33 [ 366.021089] -9223372036854775808 - 346321 cannot be represented in type '__s64' (aka 'long long') [ 366.025894] program syz-executor.4 is using a deprecated SCSI ioctl, please convert it to SG_IO [ 366.027502] CPU: 5 PID: 28472 Comm: syz-executor.7 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1 [ 366.027512] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 366.027518] Call Trace: [ 366.027523] <TASK> [ 366.027533] dump_stack_lvl+0x93/0xd0 [ 366.027899] handle_overflow+0x171/0x1b0 [ 366.038787] ata1.00: invalid multi_count 32 ignored [ 366.043924] cdrom_ioctl+0x2c3f/0x2d10 [ 366.063932] ? __pm_runtime_resume+0xe6/0x130 [ 366.071923] sr_block_ioctl+0x15d/0x1d0 [ 366.074624] ? __pfx_sr_block_ioctl+0x10/0x10 [ 366.077642] blkdev_ioctl+0x419/0x500 [ 366.080231] ? __pfx_blkdev_ioctl+0x10/0x10 ... Historically, the signed integer overflow sanitizer did not work in the kernel due to its interaction with `-fwrapv` but this has since been changed [1] in the newest version of Clang. It was re-enabled in the kernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow sanitizer\"). Let's rearrange the check to not perform any arithmetic, thus not tripping the sanitizer.",
        "technologies": "Linux\nLinux Kernel 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-008387": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe: prevent UAF around preempt fence The fence lock is part of the queue, therefore in the current design anything locking the fence should then also hold a ref to the queue to prevent the queue from being freed. However, currently it looks like we signal the fence and then drop the queue ref, but if something is waiting on the fence, the waiter is kicked to wake up at some later point, where upon waking up it first grabs the lock before checking the fence state. But if we have already dropped the queue ref, then the lock might already be freed as part of the queue, leading to uaf. To prevent this, move the fence lock into the fence itself so we don't run into lifetime issues. Alternative might be to have device level lock, or only release the queue in the fence release callback, however that might require pushing to another worker to avoid locking issues. References: https://gitlab.freedesktop.org/drm/xe/kernel/-/issues/2454 References: https://gitlab.freedesktop.org/drm/xe/kernel/-/issues/2342 References: https://gitlab.freedesktop.org/drm/xe/kernel/-/issues/2020 (cherry picked from commit 7116c35aacedc38be6d15bd21b2fc936eed0008b)",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008389": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: aacraid: Fix double-free on probe failure aac_probe_one() calls hardware-specific init functions through the aac_driver_ident::init pointer, all of which eventually call down to aac_init_adapter(). If aac_init_adapter() fails after allocating memory for aac_dev::queues, it frees the memory but does not clear that member. After the hardware-specific init function returns an error, aac_probe_one() goes down an error path that frees the memory pointed to by aac_dev::queues, resulting.in a double-free.",
        "technologies": "Linux\nLinux Kernel 2.6.15 以上 4.19.321 未満\nLinux Kernel 4.20 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.108 未満\nLinux Kernel 6.2 以上 6.6.49 未満\nLinux Kernel 6.7 以上 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008386": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to cover read extent cache access with lock syzbot reports a f2fs bug as below: BUG: KASAN: slab-use-after-free in sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46 Read of size 4 at addr ffff8880739ab220 by task syz-executor200/5097 CPU: 0 PID: 5097 Comm: syz-executor200 Not tainted 6.9.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46 do_read_inode fs/f2fs/inode.c:509 [inline] f2fs_iget+0x33e1/0x46e0 fs/f2fs/inode.c:560 f2fs_nfs_get_inode+0x74/0x100 fs/f2fs/super.c:3237 generic_fh_to_dentry+0x9f/0xf0 fs/libfs.c:1413 exportfs_decode_fh_raw+0x152/0x5f0 fs/exportfs/expfs.c:444 exportfs_decode_fh+0x3c/0x80 fs/exportfs/expfs.c:584 do_handle_to_path fs/fhandle.c:155 [inline] handle_to_path fs/fhandle.c:210 [inline] do_handle_open+0x495/0x650 fs/fhandle.c:226 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f We missed to cover sanity_check_extent_cache() w/ extent cache lock, so, below race case may happen, result in use after free issue. - f2fs_iget - do_read_inode - f2fs_init_read_extent_tree : add largest extent entry in to cache - shrink - f2fs_shrink_read_extent_tree - __shrink_extent_tree - __detach_extent_node : drop largest extent entry - sanity_check_extent_cache : access et->largest w/o lock let's refactor sanity_check_extent_cache() to avoid extent cache access and call it before f2fs_init_read_extent_tree() to fix this issue.",
        "technologies": "Linux\nLinux Kernel 6.6.47 未満\nLinux Kernel 6.7 以上 6.10.6 未満"
    },
    "JVNDB-2024-008342": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nfnetlink: Initialise extack before use in ACKs Add missing extack initialisation when ACKing BATCH_BEGIN and BATCH_END.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008384": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: md/raid1: Fix data corruption for degraded array with slow disk read_balance() will avoid reading from slow disks as much as possible, however, if valid data only lands in slow disks, and a new normal disk is still in recovery, unrecovered data can be read: raid1_read_request read_balance raid1_should_read_first -> return false choose_best_rdev -> normal disk is not recovered, return -1 choose_bb_rdev -> missing the checking of recovery, return the normal disk -> read unrecovered data Root cause is that the checking of recovery is missing in choose_bb_rdev(). Hence add such checking to fix the problem. Also fix similar problem in choose_slow_rdev().",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-004078": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kdb: Fix buffer overflow during tab-complete Currently, when the user attempts symbol completion with the Tab key, kdb will use strncpy() to insert the completed symbol into the command buffer. Unfortunately it passes the size of the source buffer rather than the destination to strncpy() with predictably horrible results. Most obviously if the command buffer is already full but cp, the cursor position, is in the middle of the buffer, then we will write past the end of the supplied buffer. Fix this by replacing the dubious strncpy() calls with memmove()/memcpy() calls plus explicit boundary checks to make sure we have enough space before we start moving characters around.",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.316 未満\nLinux Kernel 5.4 以上 5.4.278 未満\nLinux Kernel 5.10 以上 5.10.219 未満\nLinux Kernel 5.15 以上 5.15.161 未満\nLinux Kernel 6.1 以上 6.1.94 未満\nLinux Kernel 6.6 以上 6.6.34 未満\nLinux Kernel 6.9 以上 6.9.5 未満"
    },
    "JVNDB-2024-004050": {
        "title": "OpenBSD の OpenSSH 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A security regression (CVE-2006-5051) was discovered in OpenSSH's server (sshd). There is a race condition which can lead sshd to handle some signals in an unsafe manner. An unauthenticated, remote attacker may be able to trigger it by failing to authenticate within a set time period.",
        "technologies": "Amazon.com, Inc.\nlinux 2023\nCanonical\nUbuntu 22.04\nUbuntu 22.10\nUbuntu 23.04\nDebian\nDebian GNU/Linux 12.0\nFreeBSD\nFreeBSD 13.2\nFreeBSD 13.3\nFreeBSD 14.0\nNetApp\nE-Series SANtricity OS Controller Software 11.0.0 から 11.70.2\nONTAP Select Deploy administration utility\nontap tools 9\nNetBSD\nNetBSD 10.0.0 およびそれ以前\nOpenBSD\nOpenSSH 4.4 未満\nOpenSSH 8.6 以上 9.8 未満\nOpenSSH 4.4\nOpenSSH 8.5\nOpenSSH 9.8\nSUSE\nlinux enterprise micro 6.0\nレッドハット\nRed Hat OpenShift Container Platform 4.0\nenterprise linux for arm 64 9.0 aarch64\nenterprise linux for arm 64 eus 9.4 aarch64\nRed Hat Enterprise Linux 9.0\nRed Hat Enterprise Linux EUS 9.4\nRed Hat Enterprise Linux for IBM z Systems 9.0 s390x\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 9.4 s390x\nRed Hat Enterprise Linux for Power, little endian 9.0 ppc64le\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 9.4 ppc64le\nRed Hat Enterprise Linux Server AUS 9.4\n日立\n日立高信頼サーバ RV3000"
    },
    "JVNDB-2024-003800": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv: prevent pt_regs corruption for secondary idle threads Top of the kernel thread stack should be reserved for pt_regs. However this is not the case for the idle threads of the secondary boot harts. Their stacks overlap with their pt_regs, so both may get corrupted. Similar issue has been fixed for the primary hart, see c7cdd96eca28 (\"riscv: prevent stack corruption by reserving task_pt_regs(p) early\"). However that fix was not propagated to the secondary harts. The problem has been noticed in some CPU hotplug tests with V enabled. The function smp_callin stored several registers on stack, corrupting top of pt_regs structure including status field. As a result, kernel attempted to save or restore inexistent V context.",
        "technologies": "Linux\nLinux Kernel 5.7 未満\nLinux Kernel 6.1 以上 6.1.93 未満\nLinux Kernel 6.6 以上 6.6.33 未満\nLinux Kernel 6.9 以上 6.9.4 未満\nLinux Kernel 6.10.0"
    },
    "JVNDB-2024-003799": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm: zynqmp_dpsub: Always register bridge We must always register the DRM bridge, since zynqmp_dp_hpd_work_func calls drm_bridge_hpd_notify, which in turn expects hpd_mutex to be initialized. We do this before zynqmp_dpsub_drm_init since that calls drm_bridge_attach. This fixes the following lockdep warning: [ 19.217084] ------------[ cut here ]------------ [ 19.227530] DEBUG_LOCKS_WARN_ON(lock->magic != lock) [ 19.227768] WARNING: CPU: 0 PID: 140 at kernel/locking/mutex.c:582 __mutex_lock+0x4bc/0x550 [ 19.241696] Modules linked in: [ 19.244937] CPU: 0 PID: 140 Comm: kworker/0:4 Not tainted 6.6.20+ #96 [ 19.252046] Hardware name: xlnx,zynqmp (DT) [ 19.256421] Workqueue: events zynqmp_dp_hpd_work_func [ 19.261795] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 19.269104] pc : __mutex_lock+0x4bc/0x550 [ 19.273364] lr : __mutex_lock+0x4bc/0x550 [ 19.277592] sp : ffffffc085c5bbe0 [ 19.281066] x29: ffffffc085c5bbe0 x28: 0000000000000000 x27: ffffff88009417f8 [ 19.288624] x26: ffffff8800941788 x25: ffffff8800020008 x24: ffffffc082aa3000 [ 19.296227] x23: ffffffc080d90e3c x22: 0000000000000002 x21: 0000000000000000 [ 19.303744] x20: 0000000000000000 x19: ffffff88002f5210 x18: 0000000000000000 [ 19.311295] x17: 6c707369642e3030 x16: 3030613464662072 x15: 0720072007200720 [ 19.318922] x14: 0000000000000000 x13: 284e4f5f4e524157 x12: 0000000000000001 [ 19.326442] x11: 0001ffc085c5b940 x10: 0001ff88003f388b x9 : 0001ff88003f3888 [ 19.334003] x8 : 0001ff88003f3888 x7 : 0000000000000000 x6 : 0000000000000000 [ 19.341537] x5 : 0000000000000000 x4 : 0000000000001668 x3 : 0000000000000000 [ 19.349054] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffffff88003f3880 [ 19.356581] Call trace: [ 19.359160] __mutex_lock+0x4bc/0x550 [ 19.363032] mutex_lock_nested+0x24/0x30 [ 19.367187] drm_bridge_hpd_notify+0x2c/0x6c [ 19.371698] zynqmp_dp_hpd_work_func+0x44/0x54 [ 19.376364] process_one_work+0x3ac/0x988 [ 19.380660] worker_thread+0x398/0x694 [ 19.384736] kthread+0x1bc/0x1c0 [ 19.388241] ret_from_fork+0x10/0x20 [ 19.392031] irq event stamp: 183 [ 19.395450] hardirqs last enabled at (183): [<ffffffc0800b9278>] finish_task_switch.isra.0+0xa8/0x2d4 [ 19.405140] hardirqs last disabled at (182): [<ffffffc081ad3754>] __schedule+0x714/0xd04 [ 19.413612] softirqs last enabled at (114): [<ffffffc080133de8>] srcu_invoke_callbacks+0x158/0x23c [ 19.423128] softirqs last disabled at (110): [<ffffffc080133de8>] srcu_invoke_callbacks+0x158/0x23c [ 19.432614] ---[ end trace 0000000000000000 ]--- (cherry picked from commit 61ba791c4a7a09a370c45b70a81b8c7d4cf6b2ae)",
        "technologies": "Linux\nLinux Kernel 6.2 未満\nLinux Kernel 6.6 以上 6.6.33 未満\nLinux Kernel 6.9 以上 6.9.4 未満\nLinux Kernel 6.10.0"
    },
    "JVNDB-2024-004079": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/hwmon: Get rid of devm When both hwmon and hwmon drvdata (on which hwmon depends) are device managed resources, the expectation, on device unbind, is that hwmon will be released before drvdata. However, in i915 there are two separate code paths, which both release either drvdata or hwmon and either can be released before the other. These code paths (for device unbind) are as follows (see also the bug referenced below): Call Trace: release_nodes+0x11/0x70 devres_release_group+0xb2/0x110 component_unbind_all+0x8d/0xa0 component_del+0xa5/0x140 intel_pxp_tee_component_fini+0x29/0x40 [i915] intel_pxp_fini+0x33/0x80 [i915] i915_driver_remove+0x4c/0x120 [i915] i915_pci_remove+0x19/0x30 [i915] pci_device_remove+0x32/0xa0 device_release_driver_internal+0x19c/0x200 unbind_store+0x9c/0xb0 and Call Trace: release_nodes+0x11/0x70 devres_release_all+0x8a/0xc0 device_unbind_cleanup+0x9/0x70 device_release_driver_internal+0x1c1/0x200 unbind_store+0x9c/0xb0 This means that in i915, if use devm, we cannot gurantee that hwmon will always be released before drvdata. Which means that we have a uaf if hwmon sysfs is accessed when drvdata has been released but hwmon hasn't. The only way out of this seems to be do get rid of devm_ and release/free everything explicitly during device unbind. v2: Change commit message and other minor code changes v3: Cleanup from i915_hwmon_register on error (Armin Wolf) v4: Eliminate potential static analyzer warning (Rodrigo) Eliminate fetch_and_zero (Jani) v5: Restore previous logic for ddat_gt->hwmon_dev error return (Andi)",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.34 未満\nLinux Kernel 6.9 以上 6.9.5 未満"
    },
    "JVNDB-2024-004646": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: zoned: fix use-after-free due to race with dev replace While loading a zone's info during creation of a block group, we can race with a device replace operation and then trigger a use-after-free on the device that was just replaced (source device of the replace operation). This happens because at btrfs_load_zone_info() we extract a device from the chunk map into a local variable and then use the device while not under the protection of the device replace rwsem. So if there's a device replace operation happening when we extract the device and that device is the source of the replace operation, we will trigger a use-after-free if before we finish using the device the replace operation finishes and frees the device. Fix this by enlarging the critical section under the protection of the device replace rwsem so that all uses of the device are done inside the critical section.",
        "technologies": "Linux\nLinux Kernel 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満"
    },
    "JVNDB-2024-004916": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rcu-tasks: Fix show_rcu_tasks_trace_gp_kthread buffer overflow There is a possibility of buffer overflow in show_rcu_tasks_trace_gp_kthread() if counters, passed to sprintf() are huge. Counter numbers, needed for this are unrealistically high, but buffer overflow is still possible. Use snprintf() with buffer size instead of sprintf(). Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-004647": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: xattr: fix buffer overflow for invalid xattr When an xattr size is not what is expected, it is printed out to the kernel log in hex format as a form of debugging. But when that xattr size is bigger than the expected size, printing it out can cause an access off the end of the buffer. Fix this all up by properly restricting the size of the debug hex dump in the kernel log.",
        "technologies": "Linux\nLinux Kernel 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-004849": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix may_goto with negative offset. Zac's syzbot crafted a bpf prog that exposed two bugs in may_goto. The 1st bug is the way may_goto is patched. When offset is negative it should be patched differently. The 2nd bug is in the verifier: when current state may_goto_depth is equal to visited state may_goto_depth it means there is an actual infinite loop. It's not correct to prune exploration of the program at this point. Note, that this check doesn't limit the program to only one may_goto insn, since 2nd and any further may_goto will increment may_goto_depth only in the queued state pushed for future exploration. The current state will have may_goto_depth == 0 regardless of number of may_goto insns and the verifier has to explore the program until bpf_exit.",
        "technologies": "Linux\nLinux Kernel 6.9 未満\nLinux Kernel 6.9.1 以上 6.9.8 未満"
    },
    "JVNDB-2024-004653": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ima: Fix use-after-free on a dentry's dname.name ->d_name.name can change on rename and the earlier value can be freed; there are conditions sufficient to stabilize it (->d_lock on dentry, ->d_lock on its parent, ->i_rwsem exclusive on the parent's inode, rename_lock), but none of those are met at any of the sites. Take a stable snapshot of the name instead.",
        "technologies": "Linux\nLinux Kernel 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満"
    },
    "JVNDB-2024-004655": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: fix use-after-free case in tcpm_register_source_caps There could be a potential use-after-free case in tcpm_register_source_caps(). This could happen when: * new (say invalid) source caps are advertised * the existing source caps are unregistered * tcpm_register_source_caps() returns with an error as usb_power_delivery_register_capabilities() fails This causes port->partner_source_caps to hold on to the now freed source caps. Reset port->partner_source_caps value to NULL after unregistering existing source caps.",
        "technologies": "Linux\nLinux Kernel 6.1.61 以上 6.1.95 未満\nLinux Kernel 6.6.31 以上 6.6.35 未満\nLinux Kernel 6.9 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-004853": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Using uninitialized value *size when calling amdgpu_vce_cs_reloc Initialize the size before calling amdgpu_vce_cs_reloc, such as case 0x03000001. V2: To really improve the handling we would actually need to have a separate value of 0xffffffff.(Christian)",
        "technologies": "Linux\nLinux Kernel 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-004654": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: greybus: Fix use-after-free bug in gb_interface_release due to race condition. In gb_interface_create, &intf->mode_switch_completion is bound with gb_interface_mode_switch_work. Then it will be started by gb_interface_request_mode_switch. Here is the relevant code. if (!queue_work(system_long_wq, &intf->mode_switch_work)) { ... } If we call gb_interface_release to make cleanup, there may be an unfinished work. This function will call kfree to free the object \"intf\". However, if gb_interface_mode_switch_work is scheduled to run after kfree, it may cause use-after-free error as gb_interface_mode_switch_work will use the object \"intf\". The possible execution flow that may lead to the issue is as follows: CPU0 CPU1 | gb_interface_create | gb_interface_request_mode_switch gb_interface_release | kfree(intf) (free) | | gb_interface_mode_switch_work | mutex_lock(&intf->mutex) (use) Fix it by canceling the work before kfree.",
        "technologies": "Linux\nLinux Kernel 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満"
    },
    "JVNDB-2024-004925": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: check validation of fault attrs in f2fs_build_fault_attr() - It missed to check validation of fault attrs in parse_options(), let's fix to add check condition in f2fs_build_fault_attr(). - Use f2fs_build_fault_attr() in __sbi_store() to clean up code.",
        "technologies": "Linux\nLinux Kernel 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-004934": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu/mes: fix use-after-free issue Delete fence fallback timer to fix the ramdom use-after-free issue. v2: move to amdgpu_mes.c",
        "technologies": "Linux\nLinux Kernel 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満"
    },
    "JVNDB-2024-004837": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: replace skb_put with skb_put_zero Avoid potentially reusing uninitialized data",
        "technologies": "Linux\nLinux Kernel 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-004931": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gfs2: Fix potential glock use-after-free on unmount When a DLM lockspace is released and there ares still locks in that lockspace, DLM will unlock those locks automatically. Commit fb6791d100d1b started exploiting this behavior to speed up filesystem unmount: gfs2 would simply free glocks it didn't want to unlock and then release the lockspace. This didn't take the bast callbacks for asynchronous lock contention notifications into account, which remain active until until a lock is unlocked or its lockspace is released. To prevent those callbacks from accessing deallocated objects, put the glocks that should not be unlocked on the sd_dead_glocks list, release the lockspace, and only then free those glocks. As an additional measure, ignore unexpected ast and bast callbacks if the receiving glock is dead.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-004933": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix use-after-free of timer for log writer thread Patch series \"nilfs2: fix log writer related issues\". This bug fix series covers three nilfs2 log writer-related issues, including a timer use-after-free issue and potential deadlock issue on unmount, and a potential freeze issue in event synchronization found during their analysis. Details are described in each commit log. This patch (of 3): A use-after-free issue has been reported regarding the timer sc_timer on the nilfs_sc_info structure. The problem is that even though it is used to wake up a sleeping log writer thread, sc_timer is not shut down until the nilfs_sc_info structure is about to be freed, and is used regardless of the thread's lifetime. Fix this issue by limiting the use of sc_timer only while the log writer thread is alive.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.94 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2023-028503": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における認証の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: rc: bpf attach/detach requires write permission Note that bpf attach/detach also requires CAP_NET_ADMIN.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.79 未満\nLinux Kernel 6.2 以上 6.6.18 未満\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2023-028521": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: iscsi_tcp: Fix UAF during logout when accessing the shost ipaddress Bug report and analysis from Ding Hui. During iSCSI session logout, if another task accesses the shost ipaddress attr, we can get a KASAN UAF report like this: [ 276.942144] BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x78/0xe0 [ 276.942535] Write of size 4 at addr ffff8881053b45b8 by task cat/4088 [ 276.943511] CPU: 2 PID: 4088 Comm: cat Tainted: G E 6.1.0-rc8+ #3 [ 276.943997] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 [ 276.944470] Call Trace: [ 276.944943] <TASK> [ 276.945397] dump_stack_lvl+0x34/0x48 [ 276.945887] print_address_description.constprop.0+0x86/0x1e7 [ 276.946421] print_report+0x36/0x4f [ 276.947358] kasan_report+0xad/0x130 [ 276.948234] kasan_check_range+0x35/0x1c0 [ 276.948674] _raw_spin_lock_bh+0x78/0xe0 [ 276.949989] iscsi_sw_tcp_host_get_param+0xad/0x2e0 [iscsi_tcp] [ 276.951765] show_host_param_ISCSI_HOST_PARAM_IPADDRESS+0xe9/0x130 [scsi_transport_iscsi] [ 276.952185] dev_attr_show+0x3f/0x80 [ 276.953005] sysfs_kf_seq_show+0x1fb/0x3e0 [ 276.953401] seq_read_iter+0x402/0x1020 [ 276.954260] vfs_read+0x532/0x7b0 [ 276.955113] ksys_read+0xed/0x1c0 [ 276.955952] do_syscall_64+0x38/0x90 [ 276.956347] entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 276.956769] RIP: 0033:0x7f5d3a679222 [ 276.957161] Code: c0 e9 b2 fe ff ff 50 48 8d 3d 32 c0 0b 00 e8 a5 fe 01 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24 [ 276.958009] RSP: 002b:00007ffc864d16a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000 [ 276.958431] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5d3a679222 [ 276.958857] RDX: 0000000000020000 RSI: 00007f5d3a4fe000 RDI: 0000000000000003 [ 276.959281] RBP: 00007f5d3a4fe000 R08: 00000000ffffffff R09: 0000000000000000 [ 276.959682] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000020000 [ 276.960126] R13: 0000000000000003 R14: 0000000000000000 R15: 0000557a26dada58 [ 276.960536] </TASK> [ 276.961357] Allocated by task 2209: [ 276.961756] kasan_save_stack+0x1e/0x40 [ 276.962170] kasan_set_track+0x21/0x30 [ 276.962557] __kasan_kmalloc+0x7e/0x90 [ 276.962923] __kmalloc+0x5b/0x140 [ 276.963308] iscsi_alloc_session+0x28/0x840 [scsi_transport_iscsi] [ 276.963712] iscsi_session_setup+0xda/0xba0 [libiscsi] [ 276.964078] iscsi_sw_tcp_session_create+0x1fd/0x330 [iscsi_tcp] [ 276.964431] iscsi_if_create_session.isra.0+0x50/0x260 [scsi_transport_iscsi] [ 276.964793] iscsi_if_recv_msg+0xc5a/0x2660 [scsi_transport_iscsi] [ 276.965153] iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi] [ 276.965546] netlink_unicast+0x4d5/0x7b0 [ 276.965905] netlink_sendmsg+0x78d/0xc30 [ 276.966236] sock_sendmsg+0xe5/0x120 [ 276.966576] ____sys_sendmsg+0x5fe/0x860 [ 276.966923] ___sys_sendmsg+0xe0/0x170 [ 276.967300] __sys_sendmsg+0xc8/0x170 [ 276.967666] do_syscall_64+0x38/0x90 [ 276.968028] entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 276.968773] Freed by task 2209: [ 276.969111] kasan_save_stack+0x1e/0x40 [ 276.969449] kasan_set_track+0x21/0x30 [ 276.969789] kasan_save_free_info+0x2a/0x50 [ 276.970146] __kasan_slab_free+0x106/0x190 [ 276.970470] __kmem_cache_free+0x133/0x270 [ 276.970816] device_release+0x98/0x210 [ 276.971145] kobject_cleanup+0x101/0x360 [ 276.971462] iscsi_session_teardown+0x3fb/0x530 [libiscsi] [ 276.971775] iscsi_sw_tcp_session_destroy+0xd8/0x130 [iscsi_tcp] [ 276.972143] iscsi_if_recv_msg+0x1bf1/0x2660 [scsi_transport_iscsi] [ 276.972485] iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi] [ 276.972808] netlink_unicast+0x4d5/0x7b0 [ 276.973201] netlink_sendmsg+0x78d/0xc30 [ 276.973544] sock_sendmsg+0xe5/0x120 [ 276.973864] ____sys_sendmsg+0x5fe/0x860 [ 276.974248] ___sys_ ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028527": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vc_screen: move load of struct vc_data pointer in vcs_read() to avoid UAF After a call to console_unlock() in vcs_read() the vc_data struct can be freed by vc_deallocate(). Because of that, the struct vc_data pointer load must be done at the top of while loop in vcs_read() to avoid a UAF when vcs_size() is called. Syzkaller reported a UAF in vcs_size(). BUG: KASAN: use-after-free in vcs_size (drivers/tty/vt/vc_screen.c:215) Read of size 4 at addr ffff8881137479a8 by task 4a005ed81e27e65/1537 CPU: 0 PID: 1537 Comm: 4a005ed81e27e65 Not tainted 6.2.0-rc5 #1 Hardware name: Red Hat KVM, BIOS 1.15.0-2.module Call Trace: <TASK> __asan_report_load4_noabort (mm/kasan/report_generic.c:350) vcs_size (drivers/tty/vt/vc_screen.c:215) vcs_read (drivers/tty/vt/vc_screen.c:415) vfs_read (fs/read_write.c:468 fs/read_write.c:450) ... </TASK> Allocated by task 1191: ... kmalloc_trace (mm/slab_common.c:1069) vc_allocate (./include/linux/slab.h:580 ./include/linux/slab.h:720 drivers/tty/vt/vt.c:1128 drivers/tty/vt/vt.c:1108) con_install (drivers/tty/vt/vt.c:3383) tty_init_dev (drivers/tty/tty_io.c:1301 drivers/tty/tty_io.c:1413 drivers/tty/tty_io.c:1390) tty_open (drivers/tty/tty_io.c:2080 drivers/tty/tty_io.c:2126) chrdev_open (fs/char_dev.c:415) do_dentry_open (fs/open.c:883) vfs_open (fs/open.c:1014) ... Freed by task 1548: ... kfree (mm/slab_common.c:1021) vc_port_destruct (drivers/tty/vt/vt.c:1094) tty_port_destructor (drivers/tty/tty_port.c:296) tty_port_put (drivers/tty/tty_port.c:312) vt_disallocate_all (drivers/tty/vt/vt_ioctl.c:662 (discriminator 2)) vt_ioctl (drivers/tty/vt/vt_ioctl.c:903) tty_ioctl (drivers/tty/tty_io.c:2776) ... The buggy address belongs to the object at ffff888113747800 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 424 bytes inside of 1024-byte region [ffff888113747800, ffff888113747c00) The buggy address belongs to the physical page: page:00000000b3fe6c7c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x113740 head:00000000b3fe6c7c order:3 compound_mapcount:0 subpages_mapcount:0 compound_pincount:0 anon flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff) raw: 0017ffffc0010200 ffff888100042dc0 0000000000000000 dead000000000001 raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888113747880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888113747900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb > ffff888113747980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff888113747a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888113747a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ================================================================== Disabling lock debugging due to kernel taint",
        "technologies": "Linux\nLinux Kernel 2.6.38 以上 4.14.329 未満\nLinux Kernel 4.15 以上 4.19.273 未満\nLinux Kernel 4.20 以上 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2024-004923": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Sanitise num_phys Information is stored in mr_sas_port->phy_mask, values larger then size of this field shouldn't be allowed.",
        "technologies": "Linux\nLinux Kernel 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2023-028523": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: fix UaF in netns ops registration error path If net_assign_generic() fails, the current error path in ops_init() tries to clear the gen pointer slot. Anyway, in such error path, the gen pointer itself has not been modified yet, and the existing and accessed one is smaller than the accessed index, causing an out-of-bounds error: BUG: KASAN: slab-out-of-bounds in ops_init+0x2de/0x320 Write of size 8 at addr ffff888109124978 by task modprobe/1018 CPU: 2 PID: 1018 Comm: modprobe Not tainted 6.2.0-rc2.mptcp_ae5ac65fbed5+ #1641 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x6a/0x9f print_address_description.constprop.0+0x86/0x2b5 print_report+0x11b/0x1fb kasan_report+0x87/0xc0 ops_init+0x2de/0x320 register_pernet_operations+0x2e4/0x750 register_pernet_subsys+0x24/0x40 tcf_register_action+0x9f/0x560 do_one_initcall+0xf9/0x570 do_init_module+0x190/0x650 load_module+0x1fa5/0x23c0 __do_sys_finit_module+0x10d/0x1b0 do_syscall_64+0x58/0x80 entry_SYSCALL_64_after_hwframe+0x72/0xdc RIP: 0033:0x7f42518f778d Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d cb 56 2c 00 f7 d8 64 89 01 48 RSP: 002b:00007fff96869688 EFLAGS: 00000246 ORIG_RAX: 0000000000000139 RAX: ffffffffffffffda RBX: 00005568ef7f7c90 RCX: 00007f42518f778d RDX: 0000000000000000 RSI: 00005568ef41d796 RDI: 0000000000000003 RBP: 00005568ef41d796 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000003 R11: 0000000000000246 R12: 0000000000000000 R13: 00005568ef7f7d30 R14: 0000000000040000 R15: 0000000000000000 </TASK> This change addresses the issue by skipping the gen pointer de-reference in the mentioned error-path. Found by code inspection and verified with explicit error injection on a kasan-enabled kernel.",
        "technologies": "Linux\nLinux Kernel 4.19.264 以上 4.19.272 未満\nLinux Kernel 5.4.223 以上 5.4.231 未満\nLinux Kernel 5.10.153 以上 5.10.166 未満\nLinux Kernel 5.15.77 以上 5.15.91 未満\nLinux Kernel 6.1 以上 6.1.9 未満\nLinux Kernel 6.1 以上 6.2 未満\nLinux Kernel 6.0.7\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028522": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block, bfq: fix uaf for bfqq in bic_set_bfqq() After commit 64dc8c732f5c (\"block, bfq: fix possible uaf for 'bfqq->bic'\"), bic->bfqq will be accessed in bic_set_bfqq(), however, in some context bic->bfqq will be freed, and bic_set_bfqq() is called with the freed bic->bfqq. Fix the problem by always freeing bfqq after bic_set_bfqq().",
        "technologies": "Linux\nLinux Kernel 5.15.86 以上 5.15.93 未満\nLinux Kernel 6.1.2 以上 6.1.11 未満\nLinux Kernel 6.0.16"
    },
    "JVNDB-2023-028528": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: sch_taprio: fix possible use-after-free syzbot reported a nasty crash [1] in net_tx_action() which made little sense until we got a repro. This repro installs a taprio qdisc, but providing an invalid TCA_RATE attribute. qdisc_create() has to destroy the just initialized taprio qdisc, and taprio_destroy() is called. However, the hrtimer used by taprio had already fired, therefore advance_sched() called __netif_schedule(). Then net_tx_action was trying to use a destroyed qdisc. We can not undo the __netif_schedule(), so we must wait until one cpu serviced the qdisc before we can proceed. Many thanks to Alexander Potapenko for his help. [1] BUG: KMSAN: uninit-value in queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline] BUG: KMSAN: uninit-value in do_raw_spin_trylock include/linux/spinlock.h:191 [inline] BUG: KMSAN: uninit-value in __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline] BUG: KMSAN: uninit-value in _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138 queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline] do_raw_spin_trylock include/linux/spinlock.h:191 [inline] __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline] _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138 spin_trylock include/linux/spinlock.h:359 [inline] qdisc_run_begin include/net/sch_generic.h:187 [inline] qdisc_run+0xee/0x540 include/net/pkt_sched.h:125 net_tx_action+0x77c/0x9a0 net/core/dev.c:5086 __do_softirq+0x1cc/0x7fb kernel/softirq.c:571 run_ksoftirqd+0x2c/0x50 kernel/softirq.c:934 smpboot_thread_fn+0x554/0x9f0 kernel/smpboot.c:164 kthread+0x31b/0x430 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 Uninit was created at: slab_post_alloc_hook mm/slab.h:732 [inline] slab_alloc_node mm/slub.c:3258 [inline] __kmalloc_node_track_caller+0x814/0x1250 mm/slub.c:4970 kmalloc_reserve net/core/skbuff.c:358 [inline] __alloc_skb+0x346/0xcf0 net/core/skbuff.c:430 alloc_skb include/linux/skbuff.h:1257 [inline] nlmsg_new include/net/netlink.h:953 [inline] netlink_ack+0x5f3/0x12b0 net/netlink/af_netlink.c:2436 netlink_rcv_skb+0x55d/0x6c0 net/netlink/af_netlink.c:2507 rtnetlink_rcv+0x30/0x40 net/core/rtnetlink.c:6108 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0xf3b/0x1270 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x1288/0x1440 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] ____sys_sendmsg+0xabc/0xe90 net/socket.c:2482 ___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2536 __sys_sendmsg net/socket.c:2565 [inline] __do_sys_sendmsg net/socket.c:2574 [inline] __se_sys_sendmsg net/socket.c:2572 [inline] __x64_sys_sendmsg+0x367/0x540 net/socket.c:2572 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd CPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 6.0.0-rc2-syzkaller-47461-gac3859c02d7f #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/22/2022",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.231 未満\nLinux Kernel 5.5 以上 5.10.166 未満\nLinux Kernel 5.11 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028530": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: iscsi_tcp: Fix UAF during login when accessing the shost ipaddress If during iscsi_sw_tcp_session_create() iscsi_tcp_r2tpool_alloc() fails, userspace could be accessing the host's ipaddress attr. If we then free the session via iscsi_session_teardown() while userspace is still accessing the session we will hit a use after free bug. Set the tcp_sw_host->session after we have completed session creation and can no longer fail.",
        "technologies": "Linux\nLinux Kernel 4.14.306 未満\nLinux Kernel 4.15 以上 4.19.273 未満\nLinux Kernel 4.20 以上 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028535": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Don't let sock_map_{close,destroy,unhash} call itself sock_map proto callbacks should never call themselves by design. Protect against bugs like [1] and break out of the recursive loop to avoid a stack overflow in favor of a resource leak. [1] https://lore.kernel.org/all/00000000000073b14905ef2e7401@google.com/",
        "technologies": "Linux\nLinux Kernel 5.15.95 未満\nLinux Kernel 5.16 以上 6.1.13 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028529": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: nfc: Fix use-after-free in local_cleanup() Fix a use-after-free that occurs in kfree_skb() called from local_cleanup(). This could happen when killing nfc daemon (e.g. neard) after detaching an nfc device. When detaching an nfc device, local_cleanup() called from nfc_llcp_unregister_device() frees local->rx_pending and decreases local->ref by kref_put() in nfc_llcp_local_put(). In the terminating process, nfc daemon releases all sockets and it leads to decreasing local->ref. After the last release of local->ref, local_cleanup() called from local_release() frees local->rx_pending again, which leads to the bug. Setting local->rx_pending to NULL in local_cleanup() could prevent use-after-free when local_cleanup() is called twice. Found by a modified version of syzkaller. BUG: KASAN: use-after-free in kfree_skb() Call Trace: dump_stack_lvl (lib/dump_stack.c:106) print_address_description.constprop.0.cold (mm/kasan/report.c:306) kasan_check_range (mm/kasan/generic.c:189) kfree_skb (net/core/skbuff.c:955) local_cleanup (net/nfc/llcp_core.c:159) nfc_llcp_local_put.part.0 (net/nfc/llcp_core.c:172) nfc_llcp_local_put (net/nfc/llcp_core.c:181) llcp_sock_destruct (net/nfc/llcp_sock.c:959) __sk_destruct (net/core/sock.c:2133) sk_destruct (net/core/sock.c:2181) __sk_free (net/core/sock.c:2192) sk_free (net/core/sock.c:2203) llcp_sock_release (net/nfc/llcp_sock.c:646) __sock_release (net/socket.c:650) sock_close (net/socket.c:1365) __fput (fs/file_table.c:306) task_work_run (kernel/task_work.c:179) ptrace_notify (kernel/signal.c:2354) syscall_exit_to_user_mode_prepare (kernel/entry/common.c:278) syscall_exit_to_user_mode (kernel/entry/common.c:296) do_syscall_64 (arch/x86/entry/common.c:86) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:106) Allocated by task 4719: kasan_save_stack (mm/kasan/common.c:45) __kasan_slab_alloc (mm/kasan/common.c:325) slab_post_alloc_hook (mm/slab.h:766) kmem_cache_alloc_node (mm/slub.c:3497) __alloc_skb (net/core/skbuff.c:552) pn533_recv_response (drivers/nfc/pn533/usb.c:65) __usb_hcd_giveback_urb (drivers/usb/core/hcd.c:1671) usb_giveback_urb_bh (drivers/usb/core/hcd.c:1704) tasklet_action_common.isra.0 (kernel/softirq.c:797) __do_softirq (kernel/softirq.c:571) Freed by task 1901: kasan_save_stack (mm/kasan/common.c:45) kasan_set_track (mm/kasan/common.c:52) kasan_save_free_info (mm/kasan/genericdd.c:518) __kasan_slab_free (mm/kasan/common.c:236) kmem_cache_free (mm/slub.c:3809) kfree_skbmem (net/core/skbuff.c:874) kfree_skb (net/core/skbuff.c:931) local_cleanup (net/nfc/llcp_core.c:159) nfc_llcp_unregister_device (net/nfc/llcp_core.c:1617) nfc_unregister_device (net/nfc/core.c:1179) pn53x_unregister_nfc (drivers/nfc/pn533/pn533.c:2846) pn533_usb_disconnect (drivers/nfc/pn533/usb.c:579) usb_unbind_interface (drivers/usb/core/driver.c:458) device_release_driver_internal (drivers/base/dd.c:1279) bus_remove_device (drivers/base/bus.c:529) device_del (drivers/base/core.c:3665) usb_disable_device (drivers/usb/core/message.c:1420) usb_disconnect (drivers/usb/core.c:2261) hub_event (drivers/usb/core/hub.c:5833) process_one_work (arch/x86/include/asm/jump_label.h:27 include/linux/jump_label.h:212 include/trace/events/workqueue.h:108 kernel/workqueue.c:2281) worker_thread (include/linux/list.h:282 kernel/workqueue.c:2423) kthread (kernel/kthread.c:319) ret_from_fork (arch/x86/entry/entry_64.S:301)",
        "technologies": "Linux\nLinux Kernel 3.9 以上 4.14.305 未満\nLinux Kernel 4.15 以上 4.19.272 未満\nLinux Kernel 4.20 以上 5.4.231 未満\nLinux Kernel 5.5 以上 5.10.166 未満\nLinux Kernel 5.11 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028539": {
        "title": "Linux の Linux Kernel におけるアクセス制御に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommufd: Fix missing update of domains_itree after splitting iopt_area In iopt_area_split(), if the original iopt_area has filled a domain and is linked to domains_itree, pages_nodes have to be properly reinserted. Otherwise the domains_itree becomes corrupted and we will UAF.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028588": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: power: supply: rk817: Fix node refcount leak Dan Carpenter reports that the Smatch static checker warning has found that there is another refcount leak in the probe function. While of_node_put() was added in one of the return paths, it should in fact be added for ALL return paths that return an error and at driver removal time.",
        "technologies": "Linux\nLinux Kernel 6.1.2 以上 6.1.56 未満\nLinux Kernel 6.2 以上 6.5.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-028587": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sh: push-switch: Reorder cleanup operations to avoid use-after-free bug The original code puts flush_work() before timer_shutdown_sync() in switch_drv_remove(). Although we use flush_work() to stop the worker, it could be rescheduled in switch_timer(). As a result, a use-after-free bug can occur. The details are shown below: (cpu 0) | (cpu 1) switch_drv_remove() | flush_work() | ... | switch_timer // timer | schedule_work(&psw->work) timer_shutdown_sync() | ... | switch_work_handler // worker kfree(psw) // free | | psw->state = 0 // use This patch puts timer_shutdown_sync() before flush_work() to mitigate the bugs. As a result, the worker and timer will be stopped safely before the deallocate operations.",
        "technologies": "Linux\nLinux Kernel 2.6.20 以上 6.5.4 未満"
    },
    "JVNDB-2023-028652": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/khugepaged: fix ->anon_vma race If an ->anon_vma is attached to the VMA, collapse_and_free_pmd() requires it to be locked. Page table traversal is allowed under any one of the mmap lock, the anon_vma lock (if the VMA is associated with an anon_vma), and the mapping lock (if the VMA is associated with a mapping); and so to be able to remove page tables, we must hold all three of them. retract_page_tables() bails out if an ->anon_vma is attached, but does this check before holding the mmap lock (as the comment above the check explains). If we racily merged an existing ->anon_vma (shared with a child process) from a neighboring VMA, subsequent rmap traversals on pages belonging to the child will be able to see the page tables that we are concurrently removing while assuming that nothing else can access them. Repeat the ->anon_vma check once we hold the mmap lock to ensure that there really is no concurrent page table access. Hitting this bug causes a lockdep warning in collapse_and_free_pmd(), in the line \"lockdep_assert_held_write(&vma->anon_vma->root->rwsem)\". It can also lead to use-after-free access.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028538": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: fix dfs radar event locking The ath11k active pdevs are protected by RCU but the DFS radar event handling code calling ath11k_mac_get_ar_by_pdev_id() was not marked as a read-side critical section. Mark the code in question as an RCU read-side critical section to avoid any potential use-after-free issues. Compile tested only.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028540": {
        "title": "Linux の Linux Kernel における整数への不適切なビットシフトに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/jfs: Add check for negative db_l2nbperpage l2nbperpage is log2(number of blks per page), and the minimum legal value should be 0, not negative. In the case of l2nbperpage being negative, an error will occur when subsequently used as shift exponent. Syzbot reported this bug: UBSAN: shift-out-of-bounds in fs/jfs/jfs_dmap.c:799:12 shift exponent -16777216 is negative",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028648": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab out of bounds write in smb_inherit_dacl() slab out-of-bounds write is caused by that offsets is bigger than pntsd allocation size. This patch add the check to validate 3 offsets using allocation size.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-026090": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix out of bounds in init_smb2_rsp_hdr() If client send smb2 negotiate request and then send smb1 negotiate request, init_smb2_rsp_hdr is called for smb1 negotiate request since need_neg is set to false. This patch ignore smb1 packets after ->need_neg is set to false.",
        "technologies": "Linux\nLinux Kernel 5.15.0 以上 5.15.145 未満\nLinux Kernel 5.16.0 以上 6.1.53 未満\nLinux Kernel 6.2.0 以上 6.4.16 未満"
    },
    "JVNDB-2023-028627": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915: Fix potential bit_17 double-free A userspace with multiple threads racing I915_GEM_SET_TILING to set the tiling to I915_TILING_NONE could trigger a double free of the bit_17 bitmask. (Or conversely leak memory on the transition to tiled.) Move allocation/free'ing of the bitmask within the section protected by the obj lock. [tursulin: Correct fixes tag and added cc stable.] (cherry picked from commit 10e0cbaaf1104f449d695c80bcacf930dcd3c42e)",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-026096": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid dirent corruption As Al reported in link[1]: f2fs_rename() ... if (old_dir != new_dir && !whiteout) f2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir); else f2fs_put_page(old_dir_page, 0); You want correct inumber in the \"..\" link. And cross-directory rename does move the source to new parent, even if you'd been asked to leave a whiteout in the old place. [1] https://lore.kernel.org/all/20231017055040.GN800259@ZenIV/ With below testcase, it may cause dirent corruption, due to it missed to call f2fs_set_link() to update \"..\" link to new directory. - mkdir -p dir/foo - renameat2 -w dir/foo bar [ASSERT] (__chk_dots_dentries:1421) --> Bad inode number[0x4] for '..', parent parent ino is [0x3] [FSCK] other corrupted bugs [Fail]",
        "technologies": "Linux\nLinux Kernel 4.2.0 以上 4.19.306 未満\nLinux Kernel 4.20 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-028573": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/powernv: Add a null pointer check in opal_powercap_init() kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.20 以上 5.4.268 未満\nLinux Kernel 5.5 以上 5.10.209 未満\nLinux Kernel 5.11 以上 5.15.148 未満\nLinux Kernel 5.16 以上 6.1.75 未満\nLinux Kernel 6.2 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-026097": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: binder: fix use-after-free in shinker's callback The mmap read lock is used during the shrinker's callback, which means that using alloc->vma pointer isn't safe as it can race with munmap(). As of commit dd2283f2605e (\"mm: mmap: zap pages with read mmap_sem in munmap\") the mmap lock is downgraded after the vma has been isolated. I was able to reproduce this issue by manually adding some delays and triggering page reclaiming through the shrinker's debug sysfs. The following KASAN report confirms the UAF: ================================================================== BUG: KASAN: slab-use-after-free in zap_page_range_single+0x470/0x4b8 Read of size 8 at addr ffff356ed50e50f0 by task bash/478 CPU: 1 PID: 478 Comm: bash Not tainted 6.6.0-rc5-00055-g1c8b86a3799f-dirty #70 Hardware name: linux,dummy-virt (DT) Call trace: zap_page_range_single+0x470/0x4b8 binder_alloc_free_page+0x608/0xadc __list_lru_walk_one+0x130/0x3b0 list_lru_walk_node+0xc4/0x22c binder_shrink_scan+0x108/0x1dc shrinker_debugfs_scan_write+0x2b4/0x500 full_proxy_write+0xd4/0x140 vfs_write+0x1ac/0x758 ksys_write+0xf0/0x1dc __arm64_sys_write+0x6c/0x9c Allocated by task 492: kmem_cache_alloc+0x130/0x368 vm_area_alloc+0x2c/0x190 mmap_region+0x258/0x18bc do_mmap+0x694/0xa60 vm_mmap_pgoff+0x170/0x29c ksys_mmap_pgoff+0x290/0x3a0 __arm64_sys_mmap+0xcc/0x144 Freed by task 491: kmem_cache_free+0x17c/0x3c8 vm_area_free_rcu_cb+0x74/0x98 rcu_core+0xa38/0x26d4 rcu_core_si+0x10/0x1c __do_softirq+0x2fc/0xd24 Last potentially related work creation: __call_rcu_common.constprop.0+0x6c/0xba0 call_rcu+0x10/0x1c vm_area_free+0x18/0x24 remove_vma+0xe4/0x118 do_vmi_align_munmap.isra.0+0x718/0xb5c do_vmi_munmap+0xdc/0x1fc __vm_munmap+0x10c/0x278 __arm64_sys_munmap+0x58/0x7c Fix this issue by performing instead a vma_lookup() which will fail to find the vma that was isolated before the mmap lock downgrade. Note that this option has better performance than upgrading to a mmap write lock which would increase contention. Plus, mmap_write_trylock() has been recently removed anyway.",
        "technologies": "Linux\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.74 未満\nLinux Kernel 6.2.0 以上 6.6.13 未満\nLinux Kernel 6.7.0 以上 6.7.1 未満"
    },
    "JVNDB-2023-026103": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/pseries/memhp: Fix access beyond end of drmem array dlpar_memory_remove_by_index() may access beyond the bounds of the drmem lmb array when the LMB lookup fails to match an entry with the given DRC index. When the search fails, the cursor is left pointing to &drmem_info->lmbs[drmem_info->n_lmbs], which is one element past the last valid entry in the array. The debug message at the end of the function then dereferences this pointer: pr_debug(\"Failed to hot-remove memory at %llx\\n\", lmb->base_addr); This was found by inspection and confirmed with KASAN: pseries-hotplug-mem: Attempting to hot-remove LMB, drc index 1234 ================================================================== BUG: KASAN: slab-out-of-bounds in dlpar_memory+0x298/0x1658 Read of size 8 at addr c000000364e97fd0 by task bash/949 dump_stack_lvl+0xa4/0xfc (unreliable) print_report+0x214/0x63c kasan_report+0x140/0x2e0 __asan_load8+0xa8/0xe0 dlpar_memory+0x298/0x1658 handle_dlpar_errorlog+0x130/0x1d0 dlpar_store+0x18c/0x3e0 kobj_attr_store+0x68/0xa0 sysfs_kf_write+0xc4/0x110 kernfs_fop_write_iter+0x26c/0x390 vfs_write+0x2d4/0x4e0 ksys_write+0xac/0x1a0 system_call_exception+0x268/0x530 system_call_vectored_common+0x15c/0x2ec Allocated by task 1: kasan_save_stack+0x48/0x80 kasan_set_track+0x34/0x50 kasan_save_alloc_info+0x34/0x50 __kasan_kmalloc+0xd0/0x120 __kmalloc+0x8c/0x320 kmalloc_array.constprop.0+0x48/0x5c drmem_init+0x2a0/0x41c do_one_initcall+0xe0/0x5c0 kernel_init_freeable+0x4ec/0x5a0 kernel_init+0x30/0x1e0 ret_from_kernel_user_thread+0x14/0x1c The buggy address belongs to the object at c000000364e80000 which belongs to the cache kmalloc-128k of size 131072 The buggy address is located 0 bytes to the right of allocated 98256-byte region [c000000364e80000, c000000364e97fd0) ================================================================== pseries-hotplug-mem: Failed to hot-remove memory at 0 Log failed lookups with a separate message and dereference the cursor only when it points to a valid entry.",
        "technologies": "Linux\nLinux Kernel 4.1.0 以上 4.19.306 未満\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026109": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential OOBs in smb2_parse_contexts() Validate offsets and lengths before dereferencing create contexts in smb2_parse_contexts(). This fixes following oops when accessing invalid create contexts from server: BUG: unable to handle page fault for address: ffff8881178d8cc3 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 4a01067 P4D 4a01067 PUD 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 3 PID: 1736 Comm: mount.cifs Not tainted 6.7.0-rc4 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 RIP: 0010:smb2_parse_contexts+0xa0/0x3a0 [cifs] Code: f8 10 75 13 48 b8 93 ad 25 50 9c b4 11 e7 49 39 06 0f 84 d2 00 00 00 8b 45 00 85 c0 74 61 41 29 c5 48 01 c5 41 83 fd 0f 76 55 <0f> b7 7d 04 0f b7 45 06 4c 8d 74 3d 00 66 83 f8 04 75 bc ba 04 00 RSP: 0018:ffffc900007939e0 EFLAGS: 00010216 RAX: ffffc90000793c78 RBX: ffff8880180cc000 RCX: ffffc90000793c90 RDX: ffffc90000793cc0 RSI: ffff8880178d8cc0 RDI: ffff8880180cc000 RBP: ffff8881178d8cbf R08: ffffc90000793c22 R09: 0000000000000000 R10: ffff8880180cc000 R11: 0000000000000024 R12: 0000000000000000 R13: 0000000000000020 R14: 0000000000000000 R15: ffffc90000793c22 FS: 00007f873753cbc0(0000) GS:ffff88806bc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffff8881178d8cc3 CR3: 00000000181ca000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x181/0x480 ? search_module_extables+0x19/0x60 ? srso_alias_return_thunk+0x5/0xfbef5 ? exc_page_fault+0x1b6/0x1c0 ? asm_exc_page_fault+0x26/0x30 ? smb2_parse_contexts+0xa0/0x3a0 [cifs] SMB2_open+0x38d/0x5f0 [cifs] ? smb2_is_path_accessible+0x138/0x260 [cifs] smb2_is_path_accessible+0x138/0x260 [cifs] cifs_is_path_remote+0x8d/0x230 [cifs] cifs_mount+0x7e/0x350 [cifs] cifs_smb3_do_mount+0x128/0x780 [cifs] smb3_get_tree+0xd9/0x290 [cifs] vfs_get_tree+0x2c/0x100 ? capable+0x37/0x70 path_mount+0x2d7/0xb80 ? srso_alias_return_thunk+0x5/0xfbef5 ? _raw_spin_unlock_irqrestore+0x44/0x60 __x64_sys_mount+0x11a/0x150 do_syscall_64+0x47/0xf0 entry_SYSCALL_64_after_hwframe+0x6f/0x77 RIP: 0033:0x7f8737657b1e",
        "technologies": "Linux\nLinux Kernel 5.10.211 未満\nLinux Kernel 5.11.0 以上 5.15.150 未満\nLinux Kernel 5.16.0 から 6.1.79\nLinux Kernel 6.2.0 以上 6.6.8 未満"
    },
    "JVNDB-2023-026138": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: IB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests hfi1 user SDMA request processing has two bugs that can cause data corruption for user SDMA requests that have multiple payload iovecs where an iovec other than the tail iovec does not run up to the page boundary for the buffer pointed to by that iovec.a Here are the specific bugs: 1. user_sdma_txadd() does not use struct user_sdma_iovec->iov.iov_len. Rather, user_sdma_txadd() will add up to PAGE_SIZE bytes from iovec to the packet, even if some of those bytes are past iovec->iov.iov_len and are thus not intended to be in the packet. 2. user_sdma_txadd() and user_sdma_send_pkts() fail to advance to the next iovec in user_sdma_request->iovs when the current iovec is not PAGE_SIZE and does not contain enough data to complete the packet. The transmitted packet will contain the wrong data from the iovec pages. This has not been an issue with SDMA packets from hfi1 Verbs or PSM2 because they only produce iovecs that end short of PAGE_SIZE as the tail iovec of an SDMA request. Fixing these bugs exposes other bugs with the SDMA pin cache (struct mmu_rb_handler) that get in way of supporting user SDMA requests with multiple payload iovecs whose buffers do not end at PAGE_SIZE. So this commit fixes those issues as well. Here are the mmu_rb_handler bugs that non-PAGE_SIZE-end multi-iovec payload user SDMA requests can hit: 1. Overlapping memory ranges in mmu_rb_handler will result in duplicate pinnings. 2. When extending an existing mmu_rb_handler entry (struct mmu_rb_node), the mmu_rb code (1) removes the existing entry under a lock, (2) releases that lock, pins the new pages, (3) then reacquires the lock to insert the extended mmu_rb_node. If someone else comes in and inserts an overlapping entry between (2) and (3), insert in (3) will fail. The failure path code in this case unpins _all_ pages in either the original mmu_rb_node or the new mmu_rb_node that was inserted between (2) and (3). 3. In hfi1_mmu_rb_remove_unless_exact(), mmu_rb_node->refcount is incremented outside of mmu_rb_handler->lock. As a result, mmu_rb_node could be evicted by another thread that gets mmu_rb_handler->lock and checks mmu_rb_node->refcount before mmu_rb_node->refcount is incremented. 4. Related to #2 above, SDMA request submission failure path does not check mmu_rb_node->refcount before freeing mmu_rb_node object. If there are other SDMA requests in progress whose iovecs have pointers to the now-freed mmu_rb_node(s), those pointers to the now-freed mmu_rb nodes will be dereferenced when those SDMA requests complete.",
        "technologies": "Linux\nLinux Kernel 4.3.0 以上 5.10.180 未満\nLinux Kernel 5.11.0 以上 5.15.111 未満\nLinux Kernel 5.16.0 以上 6.1.28 未満\nLinux Kernel 6.2.0 以上 6.2.15 未満\nLinux Kernel 6.3.0 以上 6.3.2 未満"
    },
    "JVNDB-2023-026140": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drivers/amd/pm: fix a use-after-free in kv_parse_power_table When ps allocated by kzalloc equals to NULL, kv_parse_power_table frees adev->pm.dpm.ps that allocated before. However, after the control flow goes through the following call chains: kv_parse_power_table |-> kv_dpm_init |-> kv_dpm_sw_init |-> kv_dpm_fini The adev->pm.dpm.ps is used in the for loop of kv_dpm_fini after its first free in kv_parse_power_table and causes a use-after-free bug.",
        "technologies": "Linux\nLinux Kernel 4.2.0 以上 4.19.306 未満\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026139": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: EDAC/thunderx: Fix possible out-of-bounds string access Enabling -Wstringop-overflow globally exposes a warning for a common bug in the usage of strncat(): drivers/edac/thunderx_edac.c: In function 'thunderx_ocx_com_threaded_isr': drivers/edac/thunderx_edac.c:1136:17: error: 'strncat' specified bound 1024 equals destination size [-Werror=stringop-overflow=] 1136 | strncat(msg, other, OCX_MESSAGE_SIZE); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ... 1145 | strncat(msg, other, OCX_MESSAGE_SIZE); ... 1150 | strncat(msg, other, OCX_MESSAGE_SIZE); ... Apparently the author of this driver expected strncat() to behave the way that strlcat() does, which uses the size of the destination buffer as its third argument rather than the length of the source buffer. The result is that there is no check on the size of the allocated buffer. Change it to strlcat(). [ bp: Trim compiler output, fixup commit message. ]",
        "technologies": "Linux\nLinux Kernel 4.12.0 以上 4.19.306 未満\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026094": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slub overflow in ksmbd_decode_ntlmssp_auth_blob() If authblob->SessionKey.Length is bigger than session key size(CIFS_KEY_SIZE), slub overflow can happen in key exchange codes. cifs_arc4_crypt copy to session key array from SessionKey from client.",
        "technologies": "Linux\nLinux Kernel 5.17.0 以上 6.1.52 未満\nLinux Kernel 6.2.0 以上 6.4.15 未満\nLinux Kernel 6.5.0 以上 6.5.2 未満"
    },
    "JVNDB-2023-026135": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: class: fix use-after-free in class_register() The lock_class_key is still registered and can be found in lock_keys_hash hlist after subsys_private is freed in error handler path.A task who iterate over the lock_keys_hash later may cause use-after-free.So fix that up and unregister the lock_class_key before kfree(cp). On our platform, a driver fails to kset_register because of creating duplicate filename '/class/xxx'.With Kasan enabled, it prints a invalid-access bug report. KASAN bug report: BUG: KASAN: invalid-access in lockdep_register_key+0x19c/0x1bc Write of size 8 at addr 15ffff808b8c0368 by task modprobe/252 Pointer tag: [15], memory tag: [fe] CPU: 7 PID: 252 Comm: modprobe Tainted: G W 6.6.0-mainline-maybe-dirty #1 Call trace: dump_backtrace+0x1b0/0x1e4 show_stack+0x2c/0x40 dump_stack_lvl+0xac/0xe0 print_report+0x18c/0x4d8 kasan_report+0xe8/0x148 __hwasan_store8_noabort+0x88/0x98 lockdep_register_key+0x19c/0x1bc class_register+0x94/0x1ec init_module+0xbc/0xf48 [rfkill] do_one_initcall+0x17c/0x72c do_init_module+0x19c/0x3f8 ... Memory state around the buggy address: ffffff808b8c0100: 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a ffffff808b8c0200: 8a 8a 8a 8a 8a 8a 8a 8a fe fe fe fe fe fe fe fe >ffffff808b8c0300: fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe ^ ffffff808b8c0400: 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 As CONFIG_KASAN_GENERIC is not set, Kasan reports invalid-access not use-after-free here.In this case, modprobe is manipulating the corrupted lock_keys_hash hlish where lock_class_key is already freed before. It's worth noting that this only can happen if lockdep is enabled, which is not true for normal system.",
        "technologies": "Linux\nLinux Kernel 6.4.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026100": {
        "title": "Linux の Linux Kernel における初期化に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix accesses to uninit stack slots Privileged programs are supposed to be able to read uninitialized stack memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons. This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it. Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead. This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue. A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026148": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: explicitly null-terminate the xattr list When setting an xattr, explicitly null-terminate the xattr list. This eliminates the fragile assumption that the unused xattr space is always zeroed.",
        "technologies": "Linux\nLinux Kernel 4.19.306 未満\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.74 未満\nLinux Kernel 6.2.0 以上 6.6.13 未満\nLinux Kernel 6.7.0 以上 6.7.1 未満"
    },
    "JVNDB-2023-026158": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommu: Don't reserve 0-length IOVA region When the bootloader/firmware doesn't setup the framebuffers, their address and size are 0 in \"iommu-addresses\" property. If IOVA region is reserved with 0 length, then it ends up corrupting the IOVA rbtree with an entry which has pfn_hi < pfn_lo. If we intend to use display driver in kernel without framebuffer then it's causing the display IOMMU mappings to fail as entire valid IOVA space is reserved when address and length are passed as 0. An ideal solution would be firmware removing the \"iommu-addresses\" property and corresponding \"memory-region\" if display is not present. But the kernel should be able to handle this by checking for size of IOVA region and skipping the IOVA reservation if size is 0. Also, add a warning if firmware is requesting 0-length IOVA region reservation.",
        "technologies": "Linux\nLinux Kernel 6.3.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026156": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: serial: 8250: omap: Don't skip resource freeing if pm_runtime_resume_and_get() failed Returning an error code from .remove() makes the driver core emit the little helpful error message: remove callback returned a non-zero value. This will be ignored. and then remove the device anyhow. So all resources that were not freed are leaked in this case. Skipping serial8250_unregister_port() has the potential to keep enough of the UART around to trigger a use-after-free. So replace the error return (and with it the little helpful error message) by a more useful error message and continue to cleanup.",
        "technologies": "Linux\nLinux Kernel 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-026185": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix htt mlo-offset event locking The ath12k active pdevs are protected by RCU but the htt mlo-offset event handling code calling ath12k_mac_get_ar_by_pdev_id() was not marked as a read-side critical section. Mark the code in question as an RCU read-side critical section to avoid any potential use-after-free issues. Compile tested only.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-026179": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix possible out-of-bound read in ath12k_htt_pull_ppdu_stats() len is extracted from HTT message and could be an unexpected value in case errors happen, so add validation before using to avoid possible out-of-bound read in the following message iteration and parsing. The same issue also applies to ppdu_info->ppdu_stats.common.num_users, so validate it before using too. These are found during code review. Compile test only.",
        "technologies": "Linux\nLinux Kernel 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027287": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: act_mpls: Fix warning during failed attribute validation The 'TCA_MPLS_LABEL' attribute is of 'NLA_U32' type, but has a validation type of 'NLA_VALIDATE_FUNCTION'. This is an invalid combination according to the comment above 'struct nla_policy': \" Meaning of `validate' field, use via NLA_POLICY_VALIDATE_FN: NLA_BINARY Validation function called for the attribute. All other Unused - but note that it's a union \" This can trigger the warning [1] in nla_get_range_unsigned() when validation of the attribute fails. Despite being of 'NLA_U32' type, the associated 'min'/'max' fields in the policy are negative as they are aliased by the 'validate' field. Fix by changing the attribute type to 'NLA_BINARY' which is consistent with the above comment and all other users of NLA_POLICY_VALIDATE_FN(). As a result, move the length validation to the validation function. No regressions in MPLS tests: # ./tdc.py -f tc-tests/actions/mpls.json [...] # echo $? 0 [1] WARNING: CPU: 0 PID: 17743 at lib/nlattr.c:118 nla_get_range_unsigned+0x1d8/0x1e0 lib/nlattr.c:117 Modules linked in: CPU: 0 PID: 17743 Comm: syz-executor.0 Not tainted 6.1.0-rc8 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014 RIP: 0010:nla_get_range_unsigned+0x1d8/0x1e0 lib/nlattr.c:117 [...] Call Trace: <TASK> __netlink_policy_dump_write_attr+0x23d/0x990 net/netlink/policy.c:310 netlink_policy_dump_write_attr+0x22/0x30 net/netlink/policy.c:411 netlink_ack_tlv_fill net/netlink/af_netlink.c:2454 [inline] netlink_ack+0x546/0x760 net/netlink/af_netlink.c:2506 netlink_rcv_skb+0x1b7/0x240 net/netlink/af_netlink.c:2546 rtnetlink_rcv+0x18/0x20 net/core/rtnetlink.c:6109 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0x5e9/0x6b0 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x739/0x860 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] ____sys_sendmsg+0x38f/0x500 net/socket.c:2482 ___sys_sendmsg net/socket.c:2536 [inline] __sys_sendmsg+0x197/0x230 net/socket.c:2565 __do_sys_sendmsg net/socket.c:2574 [inline] __se_sys_sendmsg net/socket.c:2572 [inline] __x64_sys_sendmsg+0x42/0x50 net/socket.c:2572 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.229 未満\nLinux Kernel 5.5 以上 5.10.164 未満\nLinux Kernel 5.11 以上 5.15.89 未満\nLinux Kernel 5.16 以上 6.1.7 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-026184": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gfs2: Fix slab-use-after-free in gfs2_qd_dealloc In gfs2_put_super(), whether withdrawn or not, the quota should be cleaned up by gfs2_quota_cleanup(). Otherwise, struct gfs2_sbd will be freed before gfs2_qd_dealloc (rcu callback) has run for all gfs2_quota_data objects, resulting in use-after-free. Also, gfs2_destroy_threads() and gfs2_quota_cleanup() is already called by gfs2_make_fs_ro(), so in gfs2_put_super(), after calling gfs2_make_fs_ro(), there is no need to call them again.",
        "technologies": "Linux\nLinux Kernel 6.6.3 未満"
    },
    "JVNDB-2023-026181": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free bug in cifs_debug_data_proc_show() Skip SMB sessions that are being teared down (e.g. @ses->ses_status == SES_EXITING) in cifs_debug_data_proc_show() to avoid use-after-free in @ses. This fixes the following GPF when reading from /proc/fs/cifs/DebugData while mounting and umounting [ 816.251274] general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6d81: 0000 [#1] PREEMPT SMP NOPTI ... [ 816.260138] Call Trace: [ 816.260329] <TASK> [ 816.260499] ? die_addr+0x36/0x90 [ 816.260762] ? exc_general_protection+0x1b3/0x410 [ 816.261126] ? asm_exc_general_protection+0x26/0x30 [ 816.261502] ? cifs_debug_tcon+0xbd/0x240 [cifs] [ 816.261878] ? cifs_debug_tcon+0xab/0x240 [cifs] [ 816.262249] cifs_debug_data_proc_show+0x516/0xdb0 [cifs] [ 816.262689] ? seq_read_iter+0x379/0x470 [ 816.262995] seq_read_iter+0x118/0x470 [ 816.263291] proc_reg_read_iter+0x53/0x90 [ 816.263596] ? srso_alias_return_thunk+0x5/0x7f [ 816.263945] vfs_read+0x201/0x350 [ 816.264211] ksys_read+0x75/0x100 [ 816.264472] do_syscall_64+0x3f/0x90 [ 816.264750] entry_SYSCALL_64_after_hwframe+0x6e/0xd8 [ 816.265135] RIP: 0033:0x7fd5e669d381",
        "technologies": "Linux\nLinux Kernel 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-026187": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: af_unix: fix use-after-free in unix_stream_read_actor() syzbot reported the following crash [1] After releasing unix socket lock, u->oob_skb can be changed by another thread. We must temporarily increase skb refcount to make sure this other thread will not free the skb under us. [1] BUG: KASAN: slab-use-after-free in unix_stream_read_actor+0xa7/0xc0 net/unix/af_unix.c:2866 Read of size 4 at addr ffff88801f3b9cc4 by task syz-executor107/5297 CPU: 1 PID: 5297 Comm: syz-executor107 Not tainted 6.6.0-syzkaller-15910-gb8e3a87a627b #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/09/2023 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:364 [inline] print_report+0xc4/0x620 mm/kasan/report.c:475 kasan_report+0xda/0x110 mm/kasan/report.c:588 unix_stream_read_actor+0xa7/0xc0 net/unix/af_unix.c:2866 unix_stream_recv_urg net/unix/af_unix.c:2587 [inline] unix_stream_read_generic+0x19a5/0x2480 net/unix/af_unix.c:2666 unix_stream_recvmsg+0x189/0x1b0 net/unix/af_unix.c:2903 sock_recvmsg_nosec net/socket.c:1044 [inline] sock_recvmsg+0xe2/0x170 net/socket.c:1066 ____sys_recvmsg+0x21f/0x5c0 net/socket.c:2803 ___sys_recvmsg+0x115/0x1a0 net/socket.c:2845 __sys_recvmsg+0x114/0x1e0 net/socket.c:2875 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7fc67492c559 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fc6748ab228 EFLAGS: 00000246 ORIG_RAX: 000000000000002f RAX: ffffffffffffffda RBX: 000000000000001c RCX: 00007fc67492c559 RDX: 0000000040010083 RSI: 0000000020000140 RDI: 0000000000000004 RBP: 00007fc6749b6348 R08: 00007fc6748ab6c0 R09: 00007fc6748ab6c0 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fc6749b6340 R13: 00007fc6749b634c R14: 00007ffe9fac52a0 R15: 00007ffe9fac5388 </TASK> Allocated by task 5295: kasan_save_stack+0x33/0x50 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:328 kasan_slab_alloc include/linux/kasan.h:188 [inline] slab_post_alloc_hook mm/slab.h:763 [inline] slab_alloc_node mm/slub.c:3478 [inline] kmem_cache_alloc_node+0x180/0x3c0 mm/slub.c:3523 __alloc_skb+0x287/0x330 net/core/skbuff.c:641 alloc_skb include/linux/skbuff.h:1286 [inline] alloc_skb_with_frags+0xe4/0x710 net/core/skbuff.c:6331 sock_alloc_send_pskb+0x7e4/0x970 net/core/sock.c:2780 sock_alloc_send_skb include/net/sock.h:1884 [inline] queue_oob net/unix/af_unix.c:2147 [inline] unix_stream_sendmsg+0xb5f/0x10a0 net/unix/af_unix.c:2301 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0xd5/0x180 net/socket.c:745 ____sys_sendmsg+0x6ac/0x940 net/socket.c:2584 ___sys_sendmsg+0x135/0x1d0 net/socket.c:2638 __sys_sendmsg+0x117/0x1e0 net/socket.c:2667 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x63/0x6b Freed by task 5295: kasan_save_stack+0x33/0x50 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 kasan_save_free_info+0x2b/0x40 mm/kasan/generic.c:522 ____kasan_slab_free mm/kasan/common.c:236 [inline] ____kasan_slab_free+0x15b/0x1b0 mm/kasan/common.c:200 kasan_slab_free include/linux/kasan.h:164 [inline] slab_free_hook mm/slub.c:1800 [inline] slab_free_freelist_hook+0x114/0x1e0 mm/slub.c:1826 slab_free mm/slub.c:3809 [inline] kmem_cache_free+0xf8/0x340 mm/slub.c:3831 kfree_skbmem+0xef/0x1b0 net/core/skbuff.c:1015 __kfree_skb net/core/skbuff.c:1073 [inline] consume_skb net/core/skbuff.c:1288 [inline] consume_skb+0xdf/0x170 net/core/skbuff.c:1282 queue_oob net/unix/af_unix.c:2178 [inline] u ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027204": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: SUNRPC: Fix UAF in svc_tcp_listen_data_ready() After the listener svc_sock is freed, and before invoking svc_tcp_accept() for the established child sock, there is a window that the newsock retaining a freed listener svc_sock in sk_user_data which cloning from parent. In the race window, if data is received on the newsock, we will observe use-after-free report in svc_tcp_listen_data_ready(). Reproduce by two tasks: 1. while :; do rpc.nfsd 0 ; rpc.nfsd; done 2. while :; do echo \"\" | ncat -4 127.0.0.1 2049 ; done KASAN report: ================================================================== BUG: KASAN: slab-use-after-free in svc_tcp_listen_data_ready+0x1cf/0x1f0 [sunrpc] Read of size 8 at addr ffff888139d96228 by task nc/102553 CPU: 7 PID: 102553 Comm: nc Not tainted 6.3.0+ #18 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Call Trace: <IRQ> dump_stack_lvl+0x33/0x50 print_address_description.constprop.0+0x27/0x310 print_report+0x3e/0x70 kasan_report+0xae/0xe0 svc_tcp_listen_data_ready+0x1cf/0x1f0 [sunrpc] tcp_data_queue+0x9f4/0x20e0 tcp_rcv_established+0x666/0x1f60 tcp_v4_do_rcv+0x51c/0x850 tcp_v4_rcv+0x23fc/0x2e80 ip_protocol_deliver_rcu+0x62/0x300 ip_local_deliver_finish+0x267/0x350 ip_local_deliver+0x18b/0x2d0 ip_rcv+0x2fb/0x370 __netif_receive_skb_one_core+0x166/0x1b0 process_backlog+0x24c/0x5e0 __napi_poll+0xa2/0x500 net_rx_action+0x854/0xc90 __do_softirq+0x1bb/0x5de do_softirq+0xcb/0x100 </IRQ> <TASK> ... </TASK> Allocated by task 102371: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 __kasan_kmalloc+0x7b/0x90 svc_setup_socket+0x52/0x4f0 [sunrpc] svc_addsock+0x20d/0x400 [sunrpc] __write_ports_addfd+0x209/0x390 [nfsd] write_ports+0x239/0x2c0 [nfsd] nfsctl_transaction_write+0xac/0x110 [nfsd] vfs_write+0x1c3/0xae0 ksys_write+0xed/0x1c0 do_syscall_64+0x38/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc Freed by task 102551: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_save_free_info+0x2a/0x50 __kasan_slab_free+0x106/0x190 __kmem_cache_free+0x133/0x270 svc_xprt_free+0x1e2/0x350 [sunrpc] svc_xprt_destroy_all+0x25a/0x440 [sunrpc] nfsd_put+0x125/0x240 [nfsd] nfsd_svc+0x2cb/0x3c0 [nfsd] write_threads+0x1ac/0x2a0 [nfsd] nfsctl_transaction_write+0xac/0x110 [nfsd] vfs_write+0x1c3/0xae0 ksys_write+0xed/0x1c0 do_syscall_64+0x38/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc Fix the UAF by simply doing nothing in svc_tcp_listen_data_ready() if state != TCP_LISTEN, that will avoid dereferencing svsk for all child socket.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.14.322 未満\nLinux Kernel 4.15 以上 4.19.291 未満\nLinux Kernel 4.20 以上 5.4.251 未満\nLinux Kernel 5.5 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.15.121 未満\nLinux Kernel 5.16 以上 6.1.39 未満\nLinux Kernel 6.2 以上 6.4.4 未満"
    },
    "JVNDB-2023-027231": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched/core: Fix use-after-free bug in dup_user_cpus_ptr() Since commit 07ec77a1d4e8 (\"sched: Allow task CPU affinity to be restricted on asymmetric systems\"), the setting and clearing of user_cpus_ptr are done under pi_lock for arm64 architecture. However, dup_user_cpus_ptr() accesses user_cpus_ptr without any lock protection. Since sched_setaffinity() can be invoked from another process, the process being modified may be undergoing fork() at the same time. When racing with the clearing of user_cpus_ptr in __set_cpus_allowed_ptr_locked(), it can lead to user-after-free and possibly double-free in arm64 kernel. Commit 8f9ea86fdf99 (\"sched: Always preserve the user requested cpumask\") fixes this problem as user_cpus_ptr, once set, will never be cleared in a task's lifetime. However, this bug was re-introduced in commit 851a723e45d1 (\"sched: Always clear user_cpus_ptr in do_set_cpus_allowed()\") which allows the clearing of user_cpus_ptr in do_set_cpus_allowed(). This time, it will affect all arches. Fix this bug by always clearing the user_cpus_ptr of the newly cloned/forked task before the copying process starts and check the user_cpus_ptr state of the source task under pi_lock. Note to stable, this patch won't be applicable to stable releases. Just copy the new dup_user_cpus_ptr() function over.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.89 未満\nLinux Kernel 5.16 以上 6.1.7 未満"
    },
    "JVNDB-2023-026207": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "The IPv6 implementation in the Linux kernel before 6.3 has a net/ipv6/route.c max_size threshold that can be consumed easily, e.g., leading to a denial of service (network is unreachable errors) when IPv6 packets are sent in a loop via a raw socket.",
        "technologies": "Linux\nLinux Kernel 6.3 未満"
    },
    "JVNDB-2023-027506": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix possible UAF in amdgpu_cs_pass1() Since the gang_size check is outside of chunk parsing loop, we need to reset i before we free the chunk data. Suggested by Ye Zhang (@VAR10CK) of Baidu Security.",
        "technologies": "Linux\nLinux Kernel 6.1.46 未満\nLinux Kernel 6.2 以上 6.4.11 未満\nLinux Kernel 6.5"
    },
    "JVNDB-2024-008123": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 6.10.8 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2023-027565": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Input: powermate - fix use-after-free in powermate_config_complete syzbot has found a use-after-free bug [1] in the powermate driver. This happens when the device is disconnected, which leads to a memory free from the powermate_device struct. When an asynchronous control message completes after the kfree and its callback is invoked, the lock does not exist anymore and hence the bug. Use usb_kill_urb() on pm->config to cancel any in-progress requests upon device disconnection. [1] https://syzkaller.appspot.com/bug?extid=0434ac83f907a1dbdd1e",
        "technologies": "Linux\nLinux Kernel 4.14.328 未満\nLinux Kernel 4.15 以上 4.19.297 未満\nLinux Kernel 4.20 以上 5.4.259 未満\nLinux Kernel 5.5 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027592": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix potential key use-after-free When ieee80211_key_link() is called by ieee80211_gtk_rekey_add() but returns 0 due to KRACK protection (identical key reinstall), ieee80211_gtk_rekey_add() will still return a pointer into the key, in a potential use-after-free. This normally doesn't happen since it's only called by iwlwifi in case of WoWLAN rekey offload which has its own KRACK protection, but still better to fix, do that by returning an error code and converting that to success on the cfg80211 boundary only, leaving the error for bad callers of ieee80211_gtk_rekey_add().",
        "technologies": "Linux\nLinux Kernel 4.14 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.288 未満\nLinux Kernel 5.11 以上 5.15.169 未満\nLinux Kernel 5.16 以上 6.1.57 未満\nLinux Kernel 6.2 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-026086": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix a race condition between btf_put() and map_free() When running `./test_progs -j` in my local vm with latest kernel, I once hit a kasan error like below: [ 1887.184724] BUG: KASAN: slab-use-after-free in bpf_rb_root_free+0x1f8/0x2b0 [ 1887.185599] Read of size 4 at addr ffff888106806910 by task kworker/u12:2/2830 [ 1887.186498] [ 1887.186712] CPU: 3 PID: 2830 Comm: kworker/u12:2 Tainted: G OEL 6.7.0-rc3-00699-g90679706d486-dirty #494 [ 1887.188034] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [ 1887.189618] Workqueue: events_unbound bpf_map_free_deferred [ 1887.190341] Call Trace: [ 1887.190666] <TASK> [ 1887.190949] dump_stack_lvl+0xac/0xe0 [ 1887.191423] ? nf_tcp_handle_invalid+0x1b0/0x1b0 [ 1887.192019] ? panic+0x3c0/0x3c0 [ 1887.192449] print_report+0x14f/0x720 [ 1887.192930] ? preempt_count_sub+0x1c/0xd0 [ 1887.193459] ? __virt_addr_valid+0xac/0x120 [ 1887.194004] ? bpf_rb_root_free+0x1f8/0x2b0 [ 1887.194572] kasan_report+0xc3/0x100 [ 1887.195085] ? bpf_rb_root_free+0x1f8/0x2b0 [ 1887.195668] bpf_rb_root_free+0x1f8/0x2b0 [ 1887.196183] ? __bpf_obj_drop_impl+0xb0/0xb0 [ 1887.196736] ? preempt_count_sub+0x1c/0xd0 [ 1887.197270] ? preempt_count_sub+0x1c/0xd0 [ 1887.197802] ? _raw_spin_unlock+0x1f/0x40 [ 1887.198319] bpf_obj_free_fields+0x1d4/0x260 [ 1887.198883] array_map_free+0x1a3/0x260 [ 1887.199380] bpf_map_free_deferred+0x7b/0xe0 [ 1887.199943] process_scheduled_works+0x3a2/0x6c0 [ 1887.200549] worker_thread+0x633/0x890 [ 1887.201047] ? __kthread_parkme+0xd7/0xf0 [ 1887.201574] ? kthread+0x102/0x1d0 [ 1887.202020] kthread+0x1ab/0x1d0 [ 1887.202447] ? pr_cont_work+0x270/0x270 [ 1887.202954] ? kthread_blkcg+0x50/0x50 [ 1887.203444] ret_from_fork+0x34/0x50 [ 1887.203914] ? kthread_blkcg+0x50/0x50 [ 1887.204397] ret_from_fork_asm+0x11/0x20 [ 1887.204913] </TASK> [ 1887.204913] </TASK> [ 1887.205209] [ 1887.205416] Allocated by task 2197: [ 1887.205881] kasan_set_track+0x3f/0x60 [ 1887.206366] __kasan_kmalloc+0x6e/0x80 [ 1887.206856] __kmalloc+0xac/0x1a0 [ 1887.207293] btf_parse_fields+0xa15/0x1480 [ 1887.207836] btf_parse_struct_metas+0x566/0x670 [ 1887.208387] btf_new_fd+0x294/0x4d0 [ 1887.208851] __sys_bpf+0x4ba/0x600 [ 1887.209292] __x64_sys_bpf+0x41/0x50 [ 1887.209762] do_syscall_64+0x4c/0xf0 [ 1887.210222] entry_SYSCALL_64_after_hwframe+0x63/0x6b [ 1887.210868] [ 1887.211074] Freed by task 36: [ 1887.211460] kasan_set_track+0x3f/0x60 [ 1887.211951] kasan_save_free_info+0x28/0x40 [ 1887.212485] ____kasan_slab_free+0x101/0x180 [ 1887.213027] __kmem_cache_free+0xe4/0x210 [ 1887.213514] btf_free+0x5b/0x130 [ 1887.213918] rcu_core+0x638/0xcc0 [ 1887.214347] __do_softirq+0x114/0x37e The error happens at bpf_rb_root_free+0x1f8/0x2b0: 00000000000034c0 <bpf_rb_root_free>: ; { 34c0: f3 0f 1e fa endbr64 34c4: e8 00 00 00 00 callq 0x34c9 <bpf_rb_root_free+0x9> 34c9: 55 pushq %rbp 34ca: 48 89 e5 movq %rsp, %rbp ... ; if (rec && rec->refcount_off >= 0 && 36aa: 4d 85 ed testq %r13, %r13 36ad: 74 a9 je 0x3658 <bpf_rb_root_free+0x198> 36af: 49 8d 7d 10 leaq 0x10(%r13), %rdi 36b3: e8 00 00 00 00 callq 0x36b8 <bpf_rb_root_free+0x1f8> <==== kasan function 36b8: 45 8b 7d 10 movl 0x10(%r13), %r15d <==== use-after-free load 36bc: 45 85 ff testl %r15d, %r15d 36bf: 78 8c js 0x364d <bpf_rb_root_free+0x18d> So the problem ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-027611": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath9k: Fix potential array-index-out-of-bounds read in ath9k_htc_txstatus() Fix an array-index-out-of-bounds read in ath9k_htc_txstatus(). The bug occurs when txs->cnt, data from a URB provided by a USB device, is bigger than the size of the array txs->txstatus, which is HTC_MAX_TX_STATUS. WARN_ON() already checks it, but there is no bug handling code after the check. Make the function return if that is the case. Found by a modified version of syzkaller. UBSAN: array-index-out-of-bounds in htc_drv_txrx.c index 13 is out of range for type '__wmi_event_txstatus [12]' Call Trace: ath9k_htc_txstatus ath9k_wmi_event_tasklet tasklet_action_common __do_softirq irq_exit_rxu sysvec_apic_timer_interrupt",
        "technologies": "Linux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-027604": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/srp: Do not call scsi_done() from srp_abort() After scmd_eh_abort_handler() has called the SCSI LLD eh_abort_handler callback, it performs one of the following actions: * Call scsi_queue_insert(). * Call scsi_finish_command(). * Call scsi_eh_scmd_add(). Hence, SCSI abort handlers must not call scsi_done(). Otherwise all the above actions would trigger a use-after-free. Hence remove the scsi_done() call from srp_abort(). Keep the srp_free_req() call before returning SUCCESS because we may not see the command again if SUCCESS is returned.",
        "technologies": "Linux\nLinux Kernel 3.7 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.57 未満\nLinux Kernel 6.2 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027619": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: FS:JFS:UBSAN:array-index-out-of-bounds in dbAdjTree Syzkaller reported the following issue: UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:2867:6 index 196694 is out of range for type 's8[1365]' (aka 'signed char[1365]') CPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106 ubsan_epilogue lib/ubsan.c:217 [inline] __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348 dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867 dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834 dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331 dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline] dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402 txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534 txUpdateMap+0x342/0x9e0 txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline] jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732 kthread+0x2d3/0x370 kernel/kthread.c:388 ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 </TASK> ================================================================================ Kernel panic - not syncing: UBSAN: panic_on_warn set ... CPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106 panic+0x30f/0x770 kernel/panic.c:340 check_panic_on_warn+0x82/0xa0 kernel/panic.c:236 ubsan_epilogue lib/ubsan.c:223 [inline] __ubsan_handle_out_of_bounds+0x13c/0x150 lib/ubsan.c:348 dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867 dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834 dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331 dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline] dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402 txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534 txUpdateMap+0x342/0x9e0 txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline] jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732 kthread+0x2d3/0x370 kernel/kthread.c:388 ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 </TASK> Kernel Offset: disabled Rebooting in 86400 seconds.. The issue is caused when the value of lp becomes greater than CTLTREESIZE which is the max size of stree. Adding a simple check solves this issue. Dave: As the function returns a void, good error handling would require a more intrusive code reorganization, so I modified Osama's patch at use WARN_ON_ONCE for lack of a cleaner option. The patch is tested via syzbot.",
        "technologies": "Linux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-027590": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ravb: Fix use-after-free issue in ravb_tx_timeout_work() The ravb_stop() should call cancel_work_sync(). Otherwise, ravb_tx_timeout_work() is possible to use the freed priv after ravb_remove() was called like below: CPU0 CPU1 ravb_tx_timeout() ravb_remove() unregister_netdev() free_netdev(ndev) // free priv ravb_tx_timeout_work() // use priv unregister_netdev() will call .ndo_stop() so that ravb_stop() is called. And, after phy_stop() is called, netif_carrier_off() is also called. So that .ndo_tx_timeout() will not be called after phy_stop().",
        "technologies": "Linux\nLinux Kernel 4.2 以上 5.4.259 未満\nLinux Kernel 5.5 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027605": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/alternatives: Disable KASAN in apply_alternatives() Fei has reported that KASAN triggers during apply_alternatives() on a 5-level paging machine: BUG: KASAN: out-of-bounds in rcu_is_watching() Read of size 4 at addr ff110003ee6419a0 by task swapper/0/0 ... __asan_load4() rcu_is_watching() trace_hardirqs_on() text_poke_early() apply_alternatives() ... On machines with 5-level paging, cpu_feature_enabled(X86_FEATURE_LA57) gets patched. It includes KASAN code, where KASAN_SHADOW_START depends on __VIRTUAL_MASK_SHIFT, which is defined with cpu_feature_enabled(). KASAN gets confused when apply_alternatives() patches the KASAN_SHADOW_START users. A test patch that makes KASAN_SHADOW_START static, by replacing __VIRTUAL_MASK_SHIFT with 56, works around the issue. Fix it for real by disabling KASAN while the kernel is patching alternatives. [ mingo: updated the changelog ]",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.297 未満\nLinux Kernel 4.20 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027622": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix array-index-out-of-bounds in diNewExt [Syz report] UBSAN: array-index-out-of-bounds in fs/jfs/jfs_imap.c:2360:2 index -878706688 is out of range for type 'struct iagctl[128]' CPU: 1 PID: 5065 Comm: syz-executor282 Not tainted 6.7.0-rc4-syzkaller-00009-gbee0e7762ad2 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/10/2023 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106 ubsan_epilogue lib/ubsan.c:217 [inline] __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348 diNewExt+0x3cf3/0x4000 fs/jfs/jfs_imap.c:2360 diAllocExt fs/jfs/jfs_imap.c:1949 [inline] diAllocAG+0xbe8/0x1e50 fs/jfs/jfs_imap.c:1666 diAlloc+0x1d3/0x1760 fs/jfs/jfs_imap.c:1587 ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56 jfs_mkdir+0x1c5/0xb90 fs/jfs/namei.c:225 vfs_mkdir+0x2f1/0x4b0 fs/namei.c:4106 do_mkdirat+0x264/0x3a0 fs/namei.c:4129 __do_sys_mkdir fs/namei.c:4149 [inline] __se_sys_mkdir fs/namei.c:4147 [inline] __x64_sys_mkdir+0x6e/0x80 fs/namei.c:4147 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x45/0x110 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x63/0x6b RIP: 0033:0x7fcb7e6a0b57 Code: ff ff 77 07 31 c0 c3 0f 1f 40 00 48 c7 c2 b8 ff ff ff f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 b8 53 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffd83023038 EFLAGS: 00000286 ORIG_RAX: 0000000000000053 RAX: ffffffffffffffda RBX: 00000000ffffffff RCX: 00007fcb7e6a0b57 RDX: 00000000000a1020 RSI: 00000000000001ff RDI: 0000000020000140 RBP: 0000000020000140 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000286 R12: 00007ffd830230d0 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [Analysis] When the agstart is too large, it can cause agno overflow. [Fix] After obtaining agno, if the value is invalid, exit the subsequent process. Modified the test from agno > MAXAG to agno >= MAXAG based on linux-next report by kernel test robot (Dan Carpenter).",
        "technologies": "Linux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-027591": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ieee802154: ca8210: Fix a potential UAF in ca8210_probe If of_clk_add_provider() fails in ca8210_register_ext_clock(), it calls clk_unregister() to release priv->clk and returns an error. However, the caller ca8210_probe() then calls ca8210_remove(), where priv->clk is freed again in ca8210_unregister_ext_clock(). In this case, a use-after-free may happen in the second time we call clk_unregister(). Fix this by removing the first clk_unregister(). Also, priv->clk could be an error code on failure of clk_register_fixed_rate(). Use IS_ERR_OR_NULL to catch this case in ca8210_unregister_ext_clock().",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.328 未満\nLinux Kernel 4.15 以上 4.19.297 未満\nLinux Kernel 4.20 以上 5.4.259 未満\nLinux Kernel 5.5 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027588": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix UAF in cifs_demultiplex_thread() There is a UAF when xfstests on cifs: BUG: KASAN: use-after-free in smb2_is_network_name_deleted+0x27/0x160 Read of size 4 at addr ffff88810103fc08 by task cifsd/923 CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45 ... Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_report+0x171/0x472 kasan_report+0xad/0x130 kasan_check_range+0x145/0x1a0 smb2_is_network_name_deleted+0x27/0x160 cifs_demultiplex_thread.cold+0x172/0x5a4 kthread+0x165/0x1a0 ret_from_fork+0x1f/0x30 </TASK> Allocated by task 923: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 __kasan_slab_alloc+0x54/0x60 kmem_cache_alloc+0x147/0x320 mempool_alloc+0xe1/0x260 cifs_small_buf_get+0x24/0x60 allocate_buffers+0xa1/0x1c0 cifs_demultiplex_thread+0x199/0x10d0 kthread+0x165/0x1a0 ret_from_fork+0x1f/0x30 Freed by task 921: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_save_free_info+0x2a/0x40 ____kasan_slab_free+0x143/0x1b0 kmem_cache_free+0xe3/0x4d0 cifs_small_buf_release+0x29/0x90 SMB2_negotiate+0x8b7/0x1c60 smb2_negotiate+0x51/0x70 cifs_negotiate_protocol+0xf0/0x160 cifs_get_smb_ses+0x5fa/0x13c0 mount_get_conns+0x7a/0x750 cifs_mount+0x103/0xd00 cifs_smb3_do_mount+0x1dd/0xcb0 smb3_get_tree+0x1d5/0x300 vfs_get_tree+0x41/0xf0 path_mount+0x9b3/0xdd0 __x64_sys_mount+0x190/0x1d0 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 The UAF is because: mount(pid: 921) | cifsd(pid: 923) -------------------------------|------------------------------- | cifs_demultiplex_thread SMB2_negotiate | cifs_send_recv | compound_send_recv | smb_send_rqst | wait_for_response | wait_event_state [1] | | standard_receive3 | cifs_handle_standard | handle_mid | mid->resp_buf = buf; [2] | dequeue_mid [3] KILL the process [4] | resp_iov[i].iov_base = buf | free_rsp_buf [5] | | is_network_name_deleted [6] | callback 1. After send request to server, wait the response until mid->mid_state != SUBMITTED; 2. Receive response from server, and set it to mid; 3. Set the mid state to RECEIVED; 4. Kill the process, the mid state already RECEIVED, get 0; 5. Handle and release the negotiate response; 6. UAF. It can be easily reproduce with add some delay in [3] - [6]. Only sync call has the problem since async call's callback is executed in cifsd process. Add an extra state to mark the mid state to READY before wakeup the waitter, then it can get the resp safely.",
        "technologies": "Linux\nLinux Kernel 2.6.16 以上 6.1.56 未満\nLinux Kernel 6.2 以上 6.5.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027589": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: use DEV_STATS_INC() syzbot/KCSAN reported data-races in br_handle_frame_finish() [1] This function can run from multiple cpus without mutual exclusion. Adopt SMP safe DEV_STATS_INC() to update dev->stats fields. Handles updates to dev->stats.tx_dropped while we are at it. [1] BUG: KCSAN: data-race in br_handle_frame_finish / br_handle_frame_finish read-write to 0xffff8881374b2178 of 8 bytes by interrupt on cpu 1: br_handle_frame_finish+0xd4f/0xef0 net/bridge/br_input.c:189 br_nf_hook_thresh+0x1ed/0x220 br_nf_pre_routing_finish_ipv6+0x50f/0x540 NF_HOOK include/linux/netfilter.h:304 [inline] br_nf_pre_routing_ipv6+0x1e3/0x2a0 net/bridge/br_netfilter_ipv6.c:178 br_nf_pre_routing+0x526/0xba0 net/bridge/br_netfilter_hooks.c:508 nf_hook_entry_hookfn include/linux/netfilter.h:144 [inline] nf_hook_bridge_pre net/bridge/br_input.c:272 [inline] br_handle_frame+0x4c9/0x940 net/bridge/br_input.c:417 __netif_receive_skb_core+0xa8a/0x21e0 net/core/dev.c:5417 __netif_receive_skb_one_core net/core/dev.c:5521 [inline] __netif_receive_skb+0x57/0x1b0 net/core/dev.c:5637 process_backlog+0x21f/0x380 net/core/dev.c:5965 __napi_poll+0x60/0x3b0 net/core/dev.c:6527 napi_poll net/core/dev.c:6594 [inline] net_rx_action+0x32b/0x750 net/core/dev.c:6727 __do_softirq+0xc1/0x265 kernel/softirq.c:553 run_ksoftirqd+0x17/0x20 kernel/softirq.c:921 smpboot_thread_fn+0x30a/0x4a0 kernel/smpboot.c:164 kthread+0x1d7/0x210 kernel/kthread.c:388 ret_from_fork+0x48/0x60 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 read-write to 0xffff8881374b2178 of 8 bytes by interrupt on cpu 0: br_handle_frame_finish+0xd4f/0xef0 net/bridge/br_input.c:189 br_nf_hook_thresh+0x1ed/0x220 br_nf_pre_routing_finish_ipv6+0x50f/0x540 NF_HOOK include/linux/netfilter.h:304 [inline] br_nf_pre_routing_ipv6+0x1e3/0x2a0 net/bridge/br_netfilter_ipv6.c:178 br_nf_pre_routing+0x526/0xba0 net/bridge/br_netfilter_hooks.c:508 nf_hook_entry_hookfn include/linux/netfilter.h:144 [inline] nf_hook_bridge_pre net/bridge/br_input.c:272 [inline] br_handle_frame+0x4c9/0x940 net/bridge/br_input.c:417 __netif_receive_skb_core+0xa8a/0x21e0 net/core/dev.c:5417 __netif_receive_skb_one_core net/core/dev.c:5521 [inline] __netif_receive_skb+0x57/0x1b0 net/core/dev.c:5637 process_backlog+0x21f/0x380 net/core/dev.c:5965 __napi_poll+0x60/0x3b0 net/core/dev.c:6527 napi_poll net/core/dev.c:6594 [inline] net_rx_action+0x32b/0x750 net/core/dev.c:6727 __do_softirq+0xc1/0x265 kernel/softirq.c:553 do_softirq+0x5e/0x90 kernel/softirq.c:454 __local_bh_enable_ip+0x64/0x70 kernel/softirq.c:381 __raw_spin_unlock_bh include/linux/spinlock_api_smp.h:167 [inline] _raw_spin_unlock_bh+0x36/0x40 kernel/locking/spinlock.c:210 spin_unlock_bh include/linux/spinlock.h:396 [inline] batadv_tt_local_purge+0x1a8/0x1f0 net/batman-adv/translation-table.c:1356 batadv_tt_purge+0x2b/0x630 net/batman-adv/translation-table.c:3560 process_one_work kernel/workqueue.c:2630 [inline] process_scheduled_works+0x5b8/0xa30 kernel/workqueue.c:2703 worker_thread+0x525/0x730 kernel/workqueue.c:2784 kthread+0x1d7/0x210 kernel/kthread.c:388 ret_from_fork+0x48/0x60 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 value changed: 0x00000000000d7190 -> 0x00000000000d7191 Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 14848 Comm: kworker/u4:11 Not tainted 6.6.0-rc1-syzkaller-00236-gad8a69f361b9 #0",
        "technologies": "Linux\nLinux Kernel 2.6.17 以上 4.19.296 未満\nLinux Kernel 4.20 以上 5.4.258 未満\nLinux Kernel 5.5 以上 5.10.198 未満\nLinux Kernel 5.11 以上 5.15.134 未満\nLinux Kernel 5.16 以上 6.1.56 未満\nLinux Kernel 6.2 以上 6.5.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027567": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tee: amdtee: fix use-after-free vulnerability in amdtee_close_session There is a potential race condition in amdtee_close_session that may cause use-after-free in amdtee_open_session. For instance, if a session has refcount == 1, and one thread tries to free this session via: kref_put(&sess->refcount, destroy_session); the reference count will get decremented, and the next step would be to call destroy_session(). However, if in another thread, amdtee_open_session() is called before destroy_session() has completed execution, alloc_session() may return 'sess' that will be freed up later in destroy_session() leading to use-after-free in amdtee_open_session. To fix this issue, treat decrement of sess->refcount and removal of 'sess' from session list in destroy_session() as a critical section, so that it is executed atomically.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027586": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: Fix a memory corruption issue A few lines above, space is kzalloc()'ed for: sizeof(struct iwl_nvm_data) + sizeof(struct ieee80211_channel) + sizeof(struct ieee80211_rate) 'mvm->nvm_data' is a 'struct iwl_nvm_data', so it is fine. At the end of this structure, there is the 'channels' flex array. Each element is of type 'struct ieee80211_channel'. So only 1 element is allocated in this array. When doing: mvm->nvm_data->bands[0].channels = mvm->nvm_data->channels; We point at the first element of the 'channels' flex array. So this is fine. However, when doing: mvm->nvm_data->bands[0].bitrates = (void *)((u8 *)mvm->nvm_data->channels + 1); because of the \"(u8 *)\" cast, we add only 1 to the address of the beginning of the flex array. It is likely that we want point at the 'struct ieee80211_rate' allocated just after. Remove the spurious casting so that the pointer arithmetic works as expected.",
        "technologies": "Linux\nLinux Kernel 3.9 以上 5.15.135 未満\nLinux Kernel 5.16 以上 6.1.57 未満\nLinux Kernel 6.2 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027587": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Fix OOB read If the index provided by the user is bigger than the mask size, we might do an out of bound read.",
        "technologies": "Linux\nLinux Kernel 6.1.16 以上 6.1.56 未満\nLinux Kernel 6.3 以上 6.5.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-015420": {
        "title": "Debian の Debian GNU/Linux 等複数ベンダの製品における不適切な比較に関する脆弱性",
        "description": "Babel is a compiler for writingJavaScript. In `@babel/traverse` prior to versions 7.23.2 and 8.0.0-alpha.4 and all versions of `babel-traverse`, using Babel to compile code that was specifically crafted by an attacker can lead to arbitrary code execution during compilation, when using plugins that rely on the `path.evaluate()`or `path.evaluateTruthy()` internal Babel methods. Known affected plugins are `@babel/plugin-transform-runtime`; `@babel/preset-env` when using its `useBuiltIns` option; and any \"polyfill provider\" plugin that depends on `@babel/helper-define-polyfill-provider`, such as `babel-plugin-polyfill-corejs3`, `babel-plugin-polyfill-corejs2`, `babel-plugin-polyfill-es-shims`, `babel-plugin-polyfill-regenerator`. No other plugins under the `@babel/` namespace are impacted, but third-party plugins might be. Users that only compile trusted code are not impacted. The vulnerability has been fixed in `@babel/traverse@7.23.2` and `@babel/traverse@8.0.0-alpha.4`. Those who cannot upgrade `@babel/traverse` and are using one of the affected packages mentioned above should upgrade them to their latest version to avoid triggering the vulnerable code path in affected `@babel/traverse` versions: `@babel/plugin-transform-runtime` v7.23.2, `@babel/preset-env` v7.23.2, `@babel/helper-define-polyfill-provider` v0.4.3, `babel-plugin-polyfill-corejs2` v0.4.6, `babel-plugin-polyfill-corejs3` v0.8.5, `babel-plugin-polyfill-es-shims` v0.10.0, `babel-plugin-polyfill-regenerator` v0.5.3.",
        "technologies": "babeljs\nbabel 7.23.2 未満\nbabel 8.0.0\nbabel-helper-define-polyfill-provider 0.4.3 未満\nbabel-plugin-polyfill-corejs2 0.4.6 未満\nbabel-plugin-polyfill-corejs3 0.8.5 未満\nbabel-plugin-polyfill-es-shims 0.10.0 未満\nbabel-plugin-polyfill-regenerator 0.5.3 未満\nbabel-plugin-transform-runtime 7.23.2 未満\nbabel-preset-env 7.23.2 未満\nDebian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0"
    },
    "JVNDB-2023-014360": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "In wlan firmware, there is possible system crash due to an integer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07664741; Issue ID: ALPS07664741.",
        "technologies": "Google\nAndroid 11.0\nLinux Foundation\nYocto 4.0"
    },
    "JVNDB-2023-015199": {
        "title": "Zscaler Inc. の Linux 用 Zscaler Client Connector におけるデジタル署名の検証に関する脆弱性",
        "description": "Improper Verification of Cryptographic Signature vulnerability in Zscaler Client Connector on Linux allows Code Injection. This issue affects Zscaler Client Connector for Linux: before 1.3.1.6.",
        "technologies": "Zscaler Inc.\nZscaler Client Connector 1.3.1.6 未満"
    },
    "JVNDB-2023-015202": {
        "title": "Zscaler Inc. の Linux 用 Zscaler Client Connector における同一生成元ポリシー違反に関する脆弱性",
        "description": "Origin Validation Error vulnerability in Zscaler Client Connector on Linux allows Inclusion of Code in Existing Process. This issue affects Zscaler Client Connector for Linux: before 1.3.1.6.",
        "technologies": "Zscaler Inc.\nZscaler Client Connector 1.3.1.6 未満"
    },
    "JVNDB-2023-014359": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "In wlan firmware, there is possible system crash due to an integer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07664735; Issue ID: ALPS07664735.",
        "technologies": "Google\nAndroid 11.0\nAndroid 12.0\nLinux Foundation\nYocto 4.0"
    },
    "JVNDB-2023-015203": {
        "title": "Zscaler Inc. の Linux 用 Zscaler Client Connector における境界外書き込みに関する脆弱性",
        "description": "Buffer overflow vulnerability in the signelf library used by Zscaler Client Connector on Linux allows Code Injection. This issue affects Zscaler Client Connector for Linux: before 1.3.1.6.",
        "technologies": "Zscaler Inc.\nZscaler Client Connector 1.3.1.6 未満"
    },
    "JVNDB-2023-015051": {
        "title": "South River Technologies の Linux 用 titan mfp server におけるパストラバーサルの脆弱性",
        "description": "Insufficient path validation when writing a file via WebDAV in South River Technologies' Titan MFT and Titan SFTP servers on Linux allows an authenticated attacker to write a file to any location on the filesystem via path traversal",
        "technologies": "South River Technologies\ntitan mfp server 2.0.18 未満"
    },
    "JVNDB-2023-015188": {
        "title": "Zscaler Inc. の Linux 用 Zscaler Client Connector における脆弱性",
        "description": "An Improper Input Validation vulnerability in Zscaler Client Connector on Linux allows Privilege Escalation. This issue affects Client Connector: before 1.4.0.105",
        "technologies": "Zscaler Inc.\nZscaler Client Connector 1.4.0.105 未満"
    },
    "JVNDB-2023-015425": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "The Linux kernel before 6.5.4 has an es1 use-after-free in fs/ext4/extents_status.c, related to ext4_es_insert_extent.",
        "technologies": "Linux\nLinux Kernel 6.5.4 未満"
    },
    "JVNDB-2023-015455": {
        "title": "Linux の Linux Kernel におけるバッファサイズの計算の誤りに関する脆弱性",
        "description": "An issue was discovered in drivers/net/ethernet/intel/igb/igb_main.c in the IGB driver in the Linux kernel before 6.5.3. A buffer size may not be adequate for frames larger than the MTU.",
        "technologies": "Linux\nLinux Kernel 6.5.3 未満\n日立\nEP8000 E1050\nEP8000 S1014\nEP8000 S1024"
    },
    "JVNDB-2023-016153": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation. If perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer. We recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.",
        "technologies": "Linux\nLinux Kernel 4.4 以上 6.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-017043": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds (OOB) memory read flaw was found in parse_lease_state in the KSMBD implementation of the in-kernel samba server and CIFS in the Linux kernel. When an attacker sends the CREATE command with a malformed payload to KSMBD, due to a missing check of `NameOffset` in the `parse_lease_state()` function, the `create_context` object can access invalid memory.",
        "technologies": "Fedora Project\nFedora 37\nLinux\nLinux Kernel 6.4 未満\nLinux Kernel 6.4"
    },
    "JVNDB-2023-017213": {
        "title": "NVIDIA の Linux 用 gpu display driver における整数オーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer, where an unprivileged user can cause an integer overflow, which may lead to information disclosure and denial of service.",
        "technologies": "NVIDIA\ngpu display driver 11.12 およびそれ以前\ngpu display driver 13.0 から 13.7\ngpu display driver 15.0 から 15.2"
    },
    "JVNDB-2023-016229": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.5.9, exploitable by local users with userspace access to MMIO registers. Incorrect access checking in the #VC handler and instruction emulation of the SEV-ES emulation of MMIO accesses could lead to arbitrary write access to kernel memory (and thus privilege escalation). This depends on a race condition through which userspace can replace an instruction before the #VC handler reads it.",
        "technologies": "Linux\nLinux Kernel 6.5.9 未満"
    },
    "JVNDB-2023-017040": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s mm/mremap memory address space accounting source code. This issue occurs due to a race condition between rmap walk and mremap, allowing a local user to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.14 未満\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux EUS 8.8\nRed Hat Enterprise Linux for Power, little endian 8.0 ppc64le\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 8.8 ppc64le\nRed Hat Enterprise Linux Server TUS 8.8"
    },
    "JVNDB-2023-016221": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "The reference count changes made as part of the CVE-2023-33951 and CVE-2023-33952 fixes exposed a use-after-free flaw in the way memory objects were handled when they were being used to store a surface. When running inside a VMware guest with 3D acceleration enabled, a local, unprivileged user could potentially use this flaw to escalate their privileges.",
        "technologies": "Linux\nLinux Kernel 6.6 未満\nLinux Kernel 6.6\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-016654": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability was found in drivers/nvme/target/tcp.c` in `nvmet_tcp_free_crypto` due to a logical bug in the NVMe/TCP subsystem in the Linux kernel. This issue may allow a malicious user to cause a use-after-free and double-free problem, which may permit remote code execution or lead to local privilege escalation.",
        "technologies": "Linux\nLinux Kernel 6.6 未満\nLinux Kernel 6.6\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-026526": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/panfrost: Fix shrinker list corruption by madvise IOCTL Calling madvise IOCTL twice on BO causes memory shrinker list corruption and crashes kernel because BO is already on the list and it's added to the list again, while BO should be removed from the list before it's re-added. Fix it.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.207 未満\nLinux Kernel 5.5 以上 5.10.132 未満\nLinux Kernel 5.11 以上 5.15.56 未満\nLinux Kernel 5.16 以上 5.18.13 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-026530": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: power: supply: core: Fix boundary conditions in interpolation The functions power_supply_temp2resist_simple and power_supply_ocv2cap_simple handle boundary conditions incorrectly. The change was introduced in a4585ba2050f460f749bbaf2b67bd56c41e30283 (\"power: supply: core: Use library interpolation\"). There are two issues: First, the lines \"high = i - 1\" and \"high = i\" in ocv2cap have the wrong order compared to temp2resist. As a consequence, ocv2cap sets high=-1 if ocv>table[0].ocv, which causes an out-of-bounds read. Second, the logic of temp2resist is also not correct. Consider the case table[] = {{20, 100}, {10, 80}, {0, 60}}. For temp=5, we expect a resistance of 70% by interpolation. However, temp2resist sets high=low=2 and returns 60.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.18.13 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2023-003615": {
        "title": "Windows、Linux、MacOS、iOS 上で稼働する YugaByte, Inc. Yugabyte DB における脆弱性",
        "description": "External Control of Critical State Data, Improper Control of Generation of Code ('Code Injection') vulnerability in YugaByte, Inc. Yugabyte DB on Windows, Linux, MacOS, iOS (DevopsBase.Java:execCommand, TableManager.Java:runCommand modules) allows API Manipulation, Privilege Abuse. This vulnerability is associated with program files backup.Py. This issue affects Yugabyte DB: Lesser then 2.2.0.0",
        "technologies": "YugaByte\nYugabyteDB 2.2 未満"
    },
    "JVNDB-2023-002027": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A NULL pointer dereference vulnerability in the Linux kernel NVMe functionality, in nvmet_setup_auth(), allows an attacker to perform a Pre-Auth Denial of Service (DoS) attack on a remote machine. Affected versions v6.0-rc1 to v6.0-rc3, fixed in v6.0-rc4.",
        "technologies": "Linux\nLinux Kernel v6.0-rc1 から v6.0-rc3"
    },
    "JVNDB-2023-003747": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.10. fs/smb/server/smb2misc.c in ksmbd does not validate the relationship between the command payload size and the RFC1002 length specification, leading to an out-of-bounds read.",
        "technologies": "Linux\nLinux Kernel 6.3.10 未満"
    },
    "JVNDB-2023-004068": {
        "title": "Linux Foundation の containerd における不正な認証に関する脆弱性",
        "description": "containerd is an open source container runtime. A bug was found in containerd prior to versions 1.6.18 and 1.5.18 where supplementary groups are not set up properly inside a container. If an attacker has direct access to a container and manipulates their supplementary group access, they may be able to use supplementary group access to bypass primary group restrictions in some cases, potentially gaining access to sensitive information or gaining the ability to execute code in that container. Downstream applications that use the containerd client library may be affected as well. This bug has been fixed in containerd v1.6.18 and v.1.5.18. Users should update to these versions and recreate containers to resolve this issue. Users who rely on a downstream application that uses containerd's client library should check that application for a separate advisory and instructions. As a workaround, ensure that the `\"USER $USERNAME\"` Dockerfile instruction is not used. Instead, set the container entrypoint to a value similar to `ENTRYPOINT [\"su\", \"-\", \"user\"]` to allow `su` to properly set up supplementary groups.",
        "technologies": "Linux Foundation\ncontainerd 1.5.18 未満\ncontainerd 1.6.0 以上 1.6.18 未満"
    },
    "JVNDB-2023-003830": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.0 未満"
    },
    "JVNDB-2023-002661": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation. In the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
        "technologies": "Linux\nLinux Kernel 5.10.161 未満"
    },
    "JVNDB-2023-002664": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel. SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit 56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2023-002052": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In rndis_query_oid in drivers/net/wireless/rndis_wlan.c in the Linux kernel through 6.1.5, there is an integer overflow in an addition.",
        "technologies": "Linux\nLinux Kernel 6.1.5 まで"
    },
    "JVNDB-2022-026517": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: stmmac: fix dma queue left shift overflow issue When queue number is > 4, left shift overflows due to 32 bits integer variable. Mask calculation is wrong for MTL_RXQ_DMA_MAP1. If CONFIG_UBSAN is enabled, kernel dumps below warning: [ 10.363842] ================================================================== [ 10.363882] UBSAN: shift-out-of-bounds in /build/linux-intel-iotg-5.15-8e6Tf4/ linux-intel-iotg-5.15-5.15.0/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c:224:12 [ 10.363929] shift exponent 40 is too large for 32-bit type 'unsigned int' [ 10.363953] CPU: 1 PID: 599 Comm: NetworkManager Not tainted 5.15.0-1003-intel-iotg [ 10.363956] Hardware name: ADLINK Technology Inc. LEC-EL/LEC-EL, BIOS 0.15.11 12/22/2021 [ 10.363958] Call Trace: [ 10.363960] <TASK> [ 10.363963] dump_stack_lvl+0x4a/0x5f [ 10.363971] dump_stack+0x10/0x12 [ 10.363974] ubsan_epilogue+0x9/0x45 [ 10.363976] __ubsan_handle_shift_out_of_bounds.cold+0x61/0x10e [ 10.363979] ? wake_up_klogd+0x4a/0x50 [ 10.363983] ? vprintk_emit+0x8f/0x240 [ 10.363986] dwmac4_map_mtl_dma.cold+0x42/0x91 [stmmac] [ 10.364001] stmmac_mtl_configuration+0x1ce/0x7a0 [stmmac] [ 10.364009] ? dwmac410_dma_init_channel+0x70/0x70 [stmmac] [ 10.364020] stmmac_hw_setup.cold+0xf/0xb14 [stmmac] [ 10.364030] ? page_pool_alloc_pages+0x4d/0x70 [ 10.364034] ? stmmac_clear_tx_descriptors+0x6e/0xe0 [stmmac] [ 10.364042] stmmac_open+0x39e/0x920 [stmmac] [ 10.364050] __dev_open+0xf0/0x1a0 [ 10.364054] __dev_change_flags+0x188/0x1f0 [ 10.364057] dev_change_flags+0x26/0x60 [ 10.364059] do_setlink+0x908/0xc40 [ 10.364062] ? do_setlink+0xb10/0xc40 [ 10.364064] ? __nla_validate_parse+0x4c/0x1a0 [ 10.364068] __rtnl_newlink+0x597/0xa10 [ 10.364072] ? __nla_reserve+0x41/0x50 [ 10.364074] ? __kmalloc_node_track_caller+0x1d0/0x4d0 [ 10.364079] ? pskb_expand_head+0x75/0x310 [ 10.364082] ? nla_reserve_64bit+0x21/0x40 [ 10.364086] ? skb_free_head+0x65/0x80 [ 10.364089] ? security_sock_rcv_skb+0x2c/0x50 [ 10.364094] ? __cond_resched+0x19/0x30 [ 10.364097] ? kmem_cache_alloc_trace+0x15a/0x420 [ 10.364100] rtnl_newlink+0x49/0x70 This change fixes MTL_RXQ_DMA_MAP1 mask issue and channel/queue mapping warning. BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=216195",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.290 未満\nLinux Kernel 4.15 以上 4.19.254 未満\nLinux Kernel 4.20 以上 5.4.208 未満\nLinux Kernel 5.5 以上 5.10.134 未満\nLinux Kernel 5.11 以上 5.15.58 未満\nLinux Kernel 5.16 以上 5.18.15 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-026470": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: cs35l41: Fix an out-of-bounds access in otp_packed_element_t The CS35L41_NUM_OTP_ELEM is 100, but only 99 entries are defined in the array otp_map_1/2[CS35L41_NUM_OTP_ELEM], this will trigger UBSAN to report a shift-out-of-bounds warning in the cs35l41_otp_unpack() since the last entry in the array will result in GENMASK(-1, 0). UBSAN reports this problem: UBSAN: shift-out-of-bounds in /home/hwang4/build/jammy/jammy/sound/soc/codecs/cs35l41-lib.c:836:8 shift exponent 64 is too large for 64-bit type 'long unsigned int' CPU: 10 PID: 595 Comm: systemd-udevd Not tainted 5.15.0-23-generic #23 Hardware name: LENOVO \\x02MFG_IN_GO/\\x02MFG_IN_GO, BIOS N3GET19W (1.00 ) 03/11/2022 Call Trace: <TASK> show_stack+0x52/0x58 dump_stack_lvl+0x4a/0x5f dump_stack+0x10/0x12 ubsan_epilogue+0x9/0x45 __ubsan_handle_shift_out_of_bounds.cold+0x61/0xef ? regmap_unlock_mutex+0xe/0x10 cs35l41_otp_unpack.cold+0x1c6/0x2b2 [snd_soc_cs35l41_lib] cs35l41_hda_probe+0x24f/0x33a [snd_hda_scodec_cs35l41] cs35l41_hda_i2c_probe+0x65/0x90 [snd_hda_scodec_cs35l41_i2c] ? cs35l41_hda_i2c_remove+0x20/0x20 [snd_hda_scodec_cs35l41_i2c] i2c_device_probe+0x252/0x2b0",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2023-000055": {
        "title": "ESS REC Agent Server Edition for Linux 等におけるディレクトリトラバーサルの脆弱性",
        "description": "Directory traversal vulnerability in ESS REC Agent Server Edition series allows an authenticated attacker to view or alter an arbitrary file on the server. Affected products and versions are as follows: ESS REC Agent Server Edition for Linux V1.0.0 to V1.4.3, ESS REC Agent Server Edition for Solaris V1.1.0 to V1.4.0, ESS REC Agent Server Edition for HP-UX V1.1.0 to V1.4.0, and ESS REC Agent Server Edition for AIX V1.2.0 to V1.4.1",
        "technologies": "エンカレッジ・テクノロジ株式会社\nESS REC Agent Server Edition for AIX V1.2.0 から V1.4.1\nESS REC Agent Server Edition for HP-UX V1.1.0 から V1.4.0\nESS REC Agent Server Edition for Linux V1.0.0 から V1.4.3\nESS REC Agent Server Edition for Solaris V1.1.0 から V1.4.0"
    },
    "JVNDB-2023-004246": {
        "title": "Linux Foundation の argocd における不正な認証に関する脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All Argo CD versions starting with 2.3.0-rc1 and prior to 2.3.17, 2.4.23 2.5.11, and 2.6.2 are vulnerable to an improper authorization bug which allows users who have the ability to update at least one cluster secret to update any cluster secret. The attacker could use this access to escalate privileges (potentially controlling Kubernetes resources) or to break Argo CD functionality (by preventing connections to external clusters). A patch for this vulnerability has been released in Argo CD versions 2.6.2, 2.5.11, 2.4.23, and 2.3.17. Two workarounds are available. Either modify the RBAC configuration to completely revoke all `clusters, update` access, or use the `destinations` and `clusterResourceWhitelist` fields to apply similar restrictions as the `namespaces` and `clusterResources` fields.",
        "technologies": "Linux Foundation\nargocd 2.3.0 以上 2.3.17 未満\nargocd 2.4.0 以上 2.4.23 未満\nargocd 2.5.0 以上 2.5.11 未満\nargocd 2.6.0 以上 2.6.2 未満"
    },
    "JVNDB-2023-004705": {
        "title": "Linux Foundation の zowe における脆弱性",
        "description": "A vulnerability in Imperative framework which allows already-privileged local actors to execute arbitrary shell commands via plugin install/update commands, or maliciously formed environment variables. Impacts Zowe CLI.",
        "technologies": "Linux Foundation\nzowe 1.16.0 以上 1.28.2 未満\nzowe 2.0.0 以上 2.5.0 未満"
    },
    "JVNDB-2023-004438": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
        "technologies": "Linux\nLinux Kernel 6.1.12 およびそれ以前"
    },
    "JVNDB-2023-004592": {
        "title": "Gentoo Linux の soko における SQL インジェクションの脆弱性",
        "description": "Gentoo soko is the code that powers packages.gentoo.org. Versions prior to 1.0.1 are vulnerable to SQL Injection, leading to a Denial of Service. If the user selects (in user preferences) the \"Recently Visited Packages\" view for the index page, the value of the `search_history` cookie is used as a base64 encoded comma separated list of atoms. These are string loaded directly into the SQL query with `atom = '%s'` format string. As a result, any user can modify the browser's cookie value and inject most SQL queries. A proof of concept malformed cookie was generated that wiped the database or changed it's content. On the database, only public data is stored, so there is no confidentiality issues to site users. If it is known that the database was modified, a full restoration of data is possible by performing a full database wipe and performing full update of all components. This issue is patched with commit id 5ae9ca83b73. Version 1.0.1 contains the patch. If users are unable to upgrade immediately, the following workarounds may be applied: (1.) Use a proxy to always drop the `search_history` cookie until upgraded. The impact on user experience is low. (2.) Sanitize to the value of `search_history` cookie after base64 decoding it.",
        "technologies": "Gentoo Linux\nsoko 1.0.1 未満"
    },
    "JVNDB-2023-004641": {
        "title": "Linux Foundation の automotive grade linux における到達可能なアサーションに関する脆弱性",
        "description": "In MPD before 0.23.8, as used on Automotive Grade Linux and other platforms, the PipeWire output plugin mishandles a Drain call in certain situations involving truncated files. Eventually there is an assertion failure in libmpdclient because libqtappfw passes in a NULL pointer.",
        "technologies": "Linux Foundation\nautomotive grade linux 0.23.8 未満"
    },
    "JVNDB-2023-004640": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel 6.0.8, there is a use-after-free in inode_cgwb_move_to_attached in fs/fs-writeback.c, related to __list_del_entry_valid.",
        "technologies": "Linux\nLinux Kernel 5.15.75 以上 5.15.81 未満\nLinux Kernel 5.19.17 以上 6.0.0 未満\nLinux Kernel 6.0.3 以上 6.0.11 未満"
    },
    "JVNDB-2023-004637": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel 6.0.8, there is a use-after-free in ntfs_trim_fs in fs/ntfs3/bitmap.c.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.86 未満\nLinux Kernel 5.16 以上 6.0.16 未満\nLinux Kernel 6.1 以上 6.1.2 未満"
    },
    "JVNDB-2023-004636": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel 6.0.8, there is an out-of-bounds read in ntfs_attr_find in fs/ntfs/attrib.c.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 4.9.334 未満\nLinux Kernel 4.10 以上 4.14.300 未満\nLinux Kernel 4.15 以上 4.19.267 未満\nLinux Kernel 4.20 以上 5.4.225 未満\nLinux Kernel 5.5.0 以上 5.10.156 未満\nLinux Kernel 5.11 以上 5.15.80 未満\nLinux Kernel 5.16 以上 6.0.10 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2023-004757": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",
        "technologies": "Linux\nLinux Kernel 5.17 未満"
    },
    "JVNDB-2023-004823": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 2.6.36 以上 4.14.308 未満\nLinux Kernel 4.15 以上 4.19.276 未満\nLinux Kernel 4.20 以上 5.4.235 未満\nLinux Kernel 5.5 以上 5.10.173 未満\nLinux Kernel 5.11 以上 5.15.99 未満\nLinux Kernel 5.16 以上 6.1.16 未満\nLinux Kernel 6.2 以上 6.2.3 未満"
    },
    "JVNDB-2023-005129": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel 6.0.8, there is a use-after-free in run_unpack in fs/ntfs3/run.c, related to a difference between NTFS sector size and media sector size.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.87 未満\nLinux Kernel 5.16 以上 6.0.17 未満\nLinux Kernel 6.1 以上 6.1.3 未満"
    },
    "JVNDB-2023-004934": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "There is a use-after-free vulnerability in the Linux Kernel which can be exploited to achieve local privilege escalation. To reach the vulnerability kernel configuration flag CONFIG_TLS or CONFIG_XFRM_ESPINTCP has to be configured, but the operation does not require any privilege. There is a use-after-free bug of icsk_ulp_data of a struct inet_connection_sock. When CONFIG_TLS is enabled, user can install a tls context (struct tls_context) on a connected tcp socket. The context is not cleared if this socket is disconnected and reused as a listener. If a new socket is created from the listener, the context is inherited and vulnerable. The setsockopt TCP_ULP operation does not require any privilege. We recommend upgrading past commit 2c02d41d71f90a5168391b6a5f2954112ba2307c",
        "technologies": "Linux\nLinux Kernel 4.13.0 以上 4.14.303 未満\nLinux Kernel 4.19 以上 4.19.270 未満\nLinux Kernel 5.4 以上 5.4.229 未満\nLinux Kernel 5.10 以上 5.10.163 未満\nLinux Kernel 5.15 以上 5.15.88 未満\nLinux Kernel 6.0 以上 6.0.19 未満\nLinux Kernel 6.1 以上 6.1.5 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-005484": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.13 から 5.4.240\nLinux Kernel 5.5 以上 5.10.177 未満\nLinux Kernel 5.11 以上 5.15.105 未満\nLinux Kernel 5.16 以上 6.1.20 未満\nLinux Kernel 6.2 以上 6.2.7 未満\nNetApp\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア"
    },
    "JVNDB-2023-005674": {
        "title": "Gentoo Linux の soko における SQL インジェクションの脆弱性",
        "description": "Soko if the code that powers packages.gentoo.org. Prior to version 1.0.2, the two package search handlers, `Search` and `SearchFeed`, implemented in `pkg/app/handler/packages/search.go`, are affected by a SQL injection via the `q` parameter. As a result, unauthenticated attackers can execute arbitrary SQL queries on `https://packages.gentoo.org/`. It was also demonstrated that primitive was enough to gain code execution in the context of the PostgreSQL container. The issue was addressed in commit `4fa6e4b619c0362728955b6ec56eab0e0cbf1e23y` of version 1.0.2 using prepared statements to interpolate user-controlled data in SQL queries.",
        "technologies": "Gentoo Linux\nsoko 1.0.2 未満"
    },
    "JVNDB-2023-004859": {
        "title": "Linux Foundation の runc 他複数ベンダの製品における誤って解決された名前や参照の使用に関する脆弱性",
        "description": "runc through 1.1.4 has Incorrect Access Control leading to Escalation of Privileges, related to libcontainer/rootfs_linux.go. To exploit this, an attacker must be able to spawn two containers with custom volume-mount configurations, and be able to run custom images. NOTE: this issue exists because of a CVE-2019-19921 regression.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux Foundation\nrunc 1.1.5 未満\nレッドハット\nRed Hat OpenShift Container Platform 4.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-005726": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "Use After Free vulnerability in Linux kernel traffic control index filter (tcindex) allows Privilege Escalation. The imperfect hash area can be updated while packets are traversing, which will cause a use-after-free when 'tcf_exts_exec()' is called with the destroyed tcf_ext. A local attacker user can use this vulnerability to elevate its privileges to root. This issue affects Linux Kernel: from 4.14 before git commit ee059170b1f7e94e55fa6cadee544e176a6e59c2.",
        "technologies": "Linux\nLinux Kernel 4.14 以上 5.10.169 未満\nLinux Kernel 5.11 以上 5.15.95 未満\nLinux Kernel 5.16 以上 6.1.13 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-005696": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "A remote denial of service vulnerability was found in the Linux kernel’s TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state while attempting to parse SKBs, which are not in the queue. Sending two small UDP packets to a system with a UDP bearer results in the CPU utilization for the system to instantly spike to 100%, causing a denial of service condition.",
        "technologies": "Linux\nLinux Kernel 4.3 以上 4.9.253 未満\nLinux Kernel 4.10 以上 4.14.217 未満\nLinux Kernel 4.15 以上 4.19.170 未満\nLinux Kernel 4.20 以上 5.4.92 未満\nLinux Kernel 5.5 以上 5.10.10 未満\nLinux Kernel 5.11"
    },
    "JVNDB-2023-005937": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s Ext4 File System in how a user triggers several file operations simultaneously with the overlay FS usage. This flaw allows a local user to crash or potentially escalate their privileges on the system. Only if patch 9a2544037600 (\"ovl: fix use after free in struct ovl_aio_req\") not applied yet, the kernel could be affected.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.80 未満\nLinux Kernel 5.11 以上 5.14.19 未満\nLinux Kernel 5.15 以上 5.15.3 未満"
    },
    "JVNDB-2023-005951": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "A flaw was found in the Linux kernel, where unauthorized access to the execution of the setuid file with capabilities was found in the Linux kernel’s OverlayFS subsystem in how a user copies a capable file from a nosuid mount into another mount. This uid mapping bug allows a local user to escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-006344": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "A buffer overflow vulnerability was found in the Netfilter subsystem in the Linux Kernel. This issue could allow the leakage of both stack and heap addresses, and potentially allow Local Privilege Escalation to the root user via arbitrary code execution.",
        "technologies": "Canonical\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nFedora Project\nFedora 36\nFedora 37\nLinux\nLinux Kernel 5.5.0 以上 5.10.164 未満\nLinux Kernel 5.11 以上 5.15.89 未満\nLinux Kernel 5.16 以上 6.1.7 未満\nレッドハット\ncodeready linux builder\nRed Hat Enterprise Linux 9.0\nRed Hat Enterprise Linux EUS 9.0\nRed Hat Enterprise Linux for IBM z Systems 9.0\nRed Hat Enterprise Linux for Power Little Endian Update Services for SAP Solutions 9.0\nRed Hat Enterprise Linux for Power, little endian 9.0\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 9.0\nRed Hat Enterprise Linux for Real Time 9.0\nRed Hat Enterprise Linux for Real Time for NFV 9.0\nRed Hat Enterprise Linux Server 9.0"
    },
    "JVNDB-2023-006343": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A bug affects the Linux kernel’s ksmbd NTLMv2 authentication and is known to crash the OS immediately in Linux-based systems.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.87 未満\nLinux Kernel 5.16 以上 6.0.19 未満\nLinux Kernel 6.1 以上 6.1.5 未満"
    },
    "JVNDB-2023-006351": {
        "title": "Linux の Linux Kernel における型の取り違えに関する脆弱性",
        "description": "A flaw was found in the Linux Kernel in RDS (Reliable Datagram Sockets) protocol. The rds_rm_zerocopy_callback() uses list_entry() on the head of a list causing a type confusion. Local user can trigger this with rds_message_put(). Type confusion leads to `struct rds_msg_zcopy_info *info` actually points to something else that is potentially controlled by local user. It is known how to trigger this, which causes an out of bounds access, and a lock corruption.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.273 未満\nLinux Kernel 4.20 以上 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.94 未満\nLinux Kernel 5.16 以上 6.1.12 未満"
    },
    "JVNDB-2023-006401": {
        "title": "Linux Foundation の runc におけるリンク解釈に関する脆弱性",
        "description": "runc is a CLI tool for spawning and running containers according to the OCI specification. It was found that AppArmor can be bypassed when `/proc` inside the container is symlinked with a specific mount configuration. This issue has been fixed in runc version 1.1.5, by prohibiting symlinked `/proc`. See PR #3785 for details. users are advised to upgrade. Users unable to upgrade should avoid using an untrusted container image.",
        "technologies": "Linux Foundation\nrunc 1.1.5 未満"
    },
    "JVNDB-2023-006348": {
        "title": "レッドハットの Red Hat Enterprise Linux 他複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info->req_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",
        "technologies": "Linux\nLinux Kernel 3.2.1 以上 4.14.315 未満\nLinux Kernel 4.19 以上 4.19.283 未満\nLinux Kernel 5.4 以上 5.4.243 未満\nLinux Kernel 5.10 以上 5.10.180 未満\nLinux Kernel 5.15 以上 5.15.110 未満\nLinux Kernel 6.1 以上 6.1.27 未満\nLinux Kernel 6.2 以上 6.2.14 未満\nLinux Kernel 6.3\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-008505": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "A flaw was found in the Linux kernel's udmabuf device driver. The specific flaw exists within a fault handler. The issue results from the lack of proper validation of user-supplied data, which can result in a memory access past the end of an array. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 5.19 未満\nLinux Kernel 4.20 以上 5.4.202 未満\nLinux Kernel 5.5 以上 5.10.127 未満\nLinux Kernel 5.11 以上 5.15.51 未満\nLinux Kernel 5.16 以上 5.18.8 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2023-008502": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in btsdio_remove in drivers\\bluetooth\\btsdio.c in the Linux Kernel. In this flaw, a call to btsdio_remove with an unfinished job, may cause a race problem leading to a UAF on hdev devices.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.24 以上 4.14.312 未満\nLinux Kernel 4.15 以上 4.19.280 未満\nLinux Kernel 4.20 以上 5.4.240 未満\nLinux Kernel 5.5 以上 5.10.177 未満\nLinux Kernel 5.11 以上 5.15.105 未満\nLinux Kernel 5.16 以上 6.1.22 未満\nLinux Kernel 6.2 以上 6.2.9 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-006355": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における型の取り違えに関する脆弱性",
        "description": "In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel\nNetApp\n8300 ファームウェア\n8700 ファームウェア\nA400 ファームウェア\nA700S ファームウェア\nC400 ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-025957": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: fix tx status related use-after-free race on station removal There is a small race window where ongoing tx activity can lead to a skb getting added to the status tracking idr after that idr has already been cleaned up, which will keep the wcid linked in the status poll list. Fix this by only adding status skbs if the wcid pointer is still assigned in dev->wcid, which gets cleared early by mt76_sta_pre_rcu_remove",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2023-006587": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in nfsd4_ssc_setup_dul in fs/nfsd/nfs4proc.c in the NFS filesystem in the Linux Kernel. This issue could allow a local attacker to crash the system or it may lead to a kernel information leak problem.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-008497": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux Kernel traffic control index filter (tcindex) can be exploited to achieve local privilege escalation. The tcindex_delete function which does not properly deactivate filters in case of a perfect hashes while deleting the underlying structure which can later lead to double freeing the structure. A local attacker user can use this vulnerability to elevate its privileges to root. We recommend upgrading past commit 8c710f75256bb3cf05ac7b1672c82b92c43f3d28.",
        "technologies": "Linux\nLinux Kernel 4.14.308 未満\nLinux Kernel 4.15 以上 4.19.276 未満\nLinux Kernel 4.20 以上 5.4.235 未満\nLinux Kernel 5.5 以上 5.10.173 未満\nLinux Kernel 5.11 以上 5.15.100 未満\nLinux Kernel 5.16 以上 6.1.18 未満\nLinux Kernel 6.2 以上 6.2.5 未満"
    },
    "JVNDB-2023-008483": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux Kernel io_uring system can be exploited to achieve local privilege escalation. The io_file_get_fixed function lacks the presence of ctx->uring_lock which can lead to a Use-After-Free vulnerability due a race condition with fixed files getting unregistered. We recommend upgrading past commit da24142b1ef9fd5d36b76e36bab328a5b27523e8.",
        "technologies": "Linux\nLinux Kernel 5.17 未満"
    },
    "JVNDB-2023-007363": {
        "title": "Linux Mint の warpinator におけるパストラバーサルの脆弱性",
        "description": "Warpinator before 1.6.0 allows remote file deletion via directory traversal in top_dir_basenames.",
        "technologies": "Linux Mint\nwarpinator 1.0.7 以上 1.6.0 未満"
    },
    "JVNDB-2023-007126": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in vhost_net_set_backend in drivers/vhost/net.c in virtio network subcomponent in the Linux kernel due to a double fget. This flaw could allow a local attacker to crash the system, and could even lead to a kernel information leak problem.",
        "technologies": "Linux\nLinux Kernel 5.18 25 未満"
    },
    "JVNDB-2022-025963": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: vlan: fix memory leak in __allowed_ingress When using per-vlan state, if vlan snooping and stats are disabled, untagged or priority-tagged ingress frame will go to check pvid state. If the port state is forwarding and the pvid state is not learning/forwarding, untagged or priority-tagged frame will be dropped but skb memory is not freed. Should free skb when __allowed_ingress returns false.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.96 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025961": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block: disable the elevator int del_gendisk The elevator is only used for file system requests, which are stopped in del_gendisk. Move disabling the elevator and freeing the scheduler tags to the end of del_gendisk instead of doing that work in disk_release and blk_cleanup_queue to avoid a use after free on q->tag_set from disk_release as the tag_set might not be alive at that point. Move the blk_qos_exit call as well, as it just depends on the elevator exit and would be the only reason to keep the not exactly cheap queue freeze in disk_release.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.18.8 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025960": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: trigger: sysfs: fix use-after-free on remove Ensure that the irq_work has completed before the trigger is freed. ================================================================== BUG: KASAN: use-after-free in irq_work_run_list Read of size 8 at addr 0000000064702248 by task python3/25 Call Trace: irq_work_run_list irq_work_tick update_process_times tick_sched_handle tick_sched_timer __hrtimer_run_queues hrtimer_interrupt Allocated by task 25: kmem_cache_alloc_trace iio_sysfs_trig_add dev_attr_store sysfs_kf_write kernfs_fop_write_iter new_sync_write vfs_write ksys_write sys_write Freed by task 25: kfree iio_sysfs_trig_remove dev_attr_store sysfs_kf_write kernfs_fop_write_iter new_sync_write vfs_write ksys_write sys_write ==================================================================",
        "technologies": "Linux\nLinux Kernel 3.7 以上 4.9.321 未満\nLinux Kernel 4.10 以上 4.14.286 未満\nLinux Kernel 4.15 以上 4.19.250 未満\nLinux Kernel 4.20 以上 5.4.202 未満\nLinux Kernel 5.5 以上 5.10.127 未満\nLinux Kernel 5.11 以上 5.15.51 未満\nLinux Kernel 5.16 以上 5.18.8 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025958": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3 Call trace: dpu_vbif_init_memtypes+0x40/0xb8 dpu_runtime_resume+0xcc/0x1c0 pm_generic_runtime_resume+0x30/0x44 __genpd_runtime_resume+0x68/0x7c genpd_runtime_resume+0x134/0x258 __rpm_callback+0x98/0x138 rpm_callback+0x30/0x88 rpm_resume+0x36c/0x49c __pm_runtime_resume+0x80/0xb0 dpu_core_irq_uninstall+0x30/0xb0 dpu_irq_uninstall+0x18/0x24 msm_drm_uninit+0xd8/0x16c Patchwork: https://patchwork.freedesktop.org/patch/483255/ [DB: fixed Fixes tag]",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025964": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: video: fbdev: vesafb: Fix a use-after-free due early fb_info cleanup Commit b3c9a924aab6 (\"fbdev: vesafb: Cleanup fb_info in .fb_destroy rather than .remove\") fixed a use-after-free error due the vesafb driver freeing the fb_info in the .remove handler instead of doing it in .fb_destroy. This can happen if the .fb_destroy callback is executed after the .remove callback, since the former tries to access a pointer freed by the latter. But that change didn't take into account that another possible scenario is that .fb_destroy is called before the .remove callback. For example, if no process has the fbdev chardev opened by the time the driver is removed. If that's the case, fb_info will be freed when unregister_framebuffer() is called, making the fb_info pointer accessed in vesafb_remove() after that to no longer be valid. To prevent that, move the expression containing the info->par to happen before the unregister_framebuffer() function call.",
        "technologies": "Linux\nLinux Kernel 5.15.41 以上 5.15.46 未満\nLinux Kernel 5.17.9 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025965": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btmtksdio: fix use-after-free at btmtksdio_recv_event We should not access skb buffer data anymore after hci_recv_frame was called. [ 39.634809] BUG: KASAN: use-after-free in btmtksdio_recv_event+0x1b0 [ 39.634855] Read of size 1 at addr ffffff80cf28a60d by task kworker [ 39.634962] Call trace: [ 39.634974] dump_backtrace+0x0/0x3b8 [ 39.634999] show_stack+0x20/0x2c [ 39.635016] dump_stack_lvl+0x60/0x78 [ 39.635040] print_address_description+0x70/0x2f0 [ 39.635062] kasan_report+0x154/0x194 [ 39.635079] __asan_report_load1_noabort+0x44/0x50 [ 39.635099] btmtksdio_recv_event+0x1b0/0x1c4 [ 39.635129] btmtksdio_txrx_work+0x6cc/0xac4 [ 39.635157] process_one_work+0x560/0xc5c [ 39.635177] worker_thread+0x7ec/0xcc0 [ 39.635195] kthread+0x2d0/0x3d0 [ 39.635215] ret_from_fork+0x10/0x20 [ 39.635247] Allocated by task 0: [ 39.635260] (stack is not available) [ 39.635281] Freed by task 2392: [ 39.635295] kasan_save_stack+0x38/0x68 [ 39.635319] kasan_set_track+0x28/0x3c [ 39.635338] kasan_set_free_info+0x28/0x4c [ 39.635357] ____kasan_slab_free+0x104/0x150 [ 39.635374] __kasan_slab_free+0x18/0x28 [ 39.635391] slab_free_freelist_hook+0x114/0x248 [ 39.635410] kfree+0xf8/0x2b4 [ 39.635427] skb_free_head+0x58/0x98 [ 39.635447] skb_release_data+0x2f4/0x410 [ 39.635464] skb_release_all+0x50/0x60 [ 39.635481] kfree_skb+0xc8/0x25c [ 39.635498] hci_event_packet+0x894/0xca4 [bluetooth] [ 39.635721] hci_rx_work+0x1c8/0x68c [bluetooth] [ 39.635925] process_one_work+0x560/0xc5c [ 39.635951] worker_thread+0x7ec/0xcc0 [ 39.635970] kthread+0x2d0/0x3d0 [ 39.635990] ret_from_fork+0x10/0x20 [ 39.636021] The buggy address belongs to the object at ffffff80cf28a600 which belongs to the cache kmalloc-512 of size 512 [ 39.636039] The buggy address is located 13 bytes inside of 512-byte region [ffffff80cf28a600, ffffff80cf28a800)",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.15.54 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025974": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: fix dangling sco_conn and use-after-free in sco_sock_timeout Connecting the same socket twice consecutively in sco_sock_connect() could lead to a race condition where two sco_conn objects are created but only one is associated with the socket. If the socket is closed before the SCO connection is established, the timer associated with the dangling sco_conn object won't be canceled. As the sock object is being freed, the use-after-free problem happens when the timer callback function sco_sock_timeout() accesses the socket. Here's the call trace: dump_stack+0x107/0x163 ? refcount_inc+0x1c/ print_address_description.constprop.0+0x1c/0x47e ? refcount_inc+0x1c/0x7b kasan_report+0x13a/0x173 ? refcount_inc+0x1c/0x7b check_memory_region+0x132/0x139 refcount_inc+0x1c/0x7b sco_sock_timeout+0xb2/0x1ba process_one_work+0x739/0xbd1 ? cancel_delayed_work+0x13f/0x13f ? __raw_spin_lock_init+0xf0/0xf0 ? to_kthread+0x59/0x85 worker_thread+0x593/0x70e kthread+0x346/0x35a ? drain_workqueue+0x31a/0x31a ? kthread_bind+0x4b/0x4b ret_from_fork+0x1f/0x30",
        "technologies": "Linux\nLinux Kernel 4.4.284 以上 4.5 未満\nLinux Kernel 4.9.238 以上 4.9.318 未満\nLinux Kernel 4.14.247 以上 4.14.283 未満\nLinux Kernel 4.19.207 以上 4.19.247 未満\nLinux Kernel 5.4.146 以上 5.4.198 未満\nLinux Kernel 5.10.65 以上 5.10.121 未満\nLinux Kernel 5.13.17 以上 5.14 未満\nLinux Kernel 5.14.4 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025959": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: avoid skb access on nf_stolen When verdict is NF_STOLEN, the skb might have been freed. When tracing is enabled, this can result in a use-after-free: 1. access to skb->nf_trace 2. access to skb->mark 3. computation of trace id 4. dump of packet payload To avoid 1, keep a cached copy of skb->nf_trace in the trace state struct. Refresh this copy whenever verdict is != STOLEN. Avoid 2 by skipping skb->mark access if verdict is STOLEN. 3 is avoided by precomputing the trace id. Only dump the packet when verdict is not \"STOLEN\".",
        "technologies": "Linux\nLinux Kernel 5.18.13 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025973": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: arfs: fix use-after-free when freeing @rx_cpu_rmap The CI testing bots triggered the following splat: [ 718.203054] BUG: KASAN: use-after-free in free_irq_cpu_rmap+0x53/0x80 [ 718.206349] Read of size 4 at addr ffff8881bd127e00 by task sh/20834 [ 718.212852] CPU: 28 PID: 20834 Comm: sh Kdump: loaded Tainted: G S W IOE 5.17.0-rc8_nextqueue-devqueue-02643-g23f3121aca93 #1 [ 718.219695] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0012.070720200218 07/07/2020 [ 718.223418] Call Trace: [ 718.227139] [ 718.230783] dump_stack_lvl+0x33/0x42 [ 718.234431] print_address_description.constprop.9+0x21/0x170 [ 718.238177] ? free_irq_cpu_rmap+0x53/0x80 [ 718.241885] ? free_irq_cpu_rmap+0x53/0x80 [ 718.245539] kasan_report.cold.18+0x7f/0x11b [ 718.249197] ? free_irq_cpu_rmap+0x53/0x80 [ 718.252852] free_irq_cpu_rmap+0x53/0x80 [ 718.256471] ice_free_cpu_rx_rmap.part.11+0x37/0x50 [ice] [ 718.260174] ice_remove_arfs+0x5f/0x70 [ice] [ 718.263810] ice_rebuild_arfs+0x3b/0x70 [ice] [ 718.267419] ice_rebuild+0x39c/0xb60 [ice] [ 718.270974] ? asm_sysvec_apic_timer_interrupt+0x12/0x20 [ 718.274472] ? ice_init_phy_user_cfg+0x360/0x360 [ice] [ 718.278033] ? delay_tsc+0x4a/0xb0 [ 718.281513] ? preempt_count_sub+0x14/0xc0 [ 718.284984] ? delay_tsc+0x8f/0xb0 [ 718.288463] ice_do_reset+0x92/0xf0 [ice] [ 718.292014] ice_pci_err_resume+0x91/0xf0 [ice] [ 718.295561] pci_reset_function+0x53/0x80 <...> [ 718.393035] Allocated by task 690: [ 718.433497] Freed by task 20834: [ 718.495688] Last potentially related work creation: [ 718.568966] The buggy address belongs to the object at ffff8881bd127e00 which belongs to the cache kmalloc-96 of size 96 [ 718.574085] The buggy address is located 0 bytes inside of 96-byte region [ffff8881bd127e00, ffff8881bd127e60) [ 718.579265] The buggy address belongs to the page: [ 718.598905] Memory state around the buggy address: [ 718.601809] ffff8881bd127d00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc [ 718.604796] ffff8881bd127d80: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc [ 718.607794] >ffff8881bd127e00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc [ 718.610811] ^ [ 718.613819] ffff8881bd127e80: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc [ 718.617107] ffff8881bd127f00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc This is due to that free_irq_cpu_rmap() is always being called *after* (devm_)free_irq() and thus it tries to work with IRQ descs already freed. For example, on device reset the driver frees the rmap right before allocating a new one (the splat above). Make rmap creation and freeing function symmetrical with {request,free}_irq() calls i.e. do that on ifup/ifdown instead of device probe/remove/resume. These operations can be performed independently from the actual device aRFS configuration. Also, make sure ice_vsi_free_irq() clears IRQ affinity notifiers only when aRFS is disabled -- otherwise, CPU rmap sets and clears its own and they must not be touched manually.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025975": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: rt5645: Fix errorenous cleanup order There is a logic error when removing rt5645 device as the function rt5645_i2c_remove() first cancel the &rt5645->jack_detect_work and delete the &rt5645->btn_check_timer latter. However, since the timer handler rt5645_btn_check_callback() will re-queue the jack_detect_work, this cleanup order is buggy. That is, once the del_timer_sync in rt5645_i2c_remove is concurrently run with the rt5645_btn_check_callback, the canceled jack_detect_work will be rescheduled again, leading to possible use-after-free. This patch fix the issue by placing the del_timer_sync function before the cancel_delayed_work_sync.",
        "technologies": "Linux\nLinux Kernel 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025977": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Fix null pointer dereference after failing to issue FLOGI and PLOGI If lpfc_issue_els_flogi() fails and returns non-zero status, the node reference count is decremented to trigger the release of the nodelist structure. However, if there is a prior registration or dev-loss-evt work pending, the node may be released prematurely. When dev-loss-evt completes, the released node is referenced causing a use-after-free null pointer dereference. Similarly, when processing non-zero ELS PLOGI completion status in lpfc_cmpl_els_plogi(), the ndlp flags are checked for a transport registration before triggering node removal. If dev-loss-evt work is pending, the node may be released prematurely and a subsequent call to lpfc_dev_loss_tmo_handler() results in a use after free ndlp dereference. Add test for pending dev-loss before decrementing the node reference count for FLOGI, PLOGI, PRLI, and ADISC handling.",
        "technologies": "Linux\nLinux Kernel 5.18.3 未満"
    },
    "JVNDB-2022-025976": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFC: NULL out the dev->rfkill to prevent UAF Commit 3e3b5dfcd16a (\"NFC: reorder the logic in nfc_{un,}register_device\") assumes the device_is_registered() in function nfc_dev_up() will help to check when the rfkill is unregistered. However, this check only take effect when device_del(&dev->dev) is done in nfc_unregister_device(). Hence, the rfkill object is still possible be dereferenced. The crash trace in latest kernel (5.18-rc2): [ 68.760105] ================================================================== [ 68.760330] BUG: KASAN: use-after-free in __lock_acquire+0x3ec1/0x6750 [ 68.760756] Read of size 8 at addr ffff888009c93018 by task fuzz/313 [ 68.760756] [ 68.760756] CPU: 0 PID: 313 Comm: fuzz Not tainted 5.18.0-rc2 #4 [ 68.760756] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [ 68.760756] Call Trace: [ 68.760756] <TASK> [ 68.760756] dump_stack_lvl+0x57/0x7d [ 68.760756] print_report.cold+0x5e/0x5db [ 68.760756] ? __lock_acquire+0x3ec1/0x6750 [ 68.760756] kasan_report+0xbe/0x1c0 [ 68.760756] ? __lock_acquire+0x3ec1/0x6750 [ 68.760756] __lock_acquire+0x3ec1/0x6750 [ 68.760756] ? lockdep_hardirqs_on_prepare+0x410/0x410 [ 68.760756] ? register_lock_class+0x18d0/0x18d0 [ 68.760756] lock_acquire+0x1ac/0x4f0 [ 68.760756] ? rfkill_blocked+0xe/0x60 [ 68.760756] ? lockdep_hardirqs_on_prepare+0x410/0x410 [ 68.760756] ? mutex_lock_io_nested+0x12c0/0x12c0 [ 68.760756] ? nla_get_range_signed+0x540/0x540 [ 68.760756] ? _raw_spin_lock_irqsave+0x4e/0x50 [ 68.760756] _raw_spin_lock_irqsave+0x39/0x50 [ 68.760756] ? rfkill_blocked+0xe/0x60 [ 68.760756] rfkill_blocked+0xe/0x60 [ 68.760756] nfc_dev_up+0x84/0x260 [ 68.760756] nfc_genl_dev_up+0x90/0xe0 [ 68.760756] genl_family_rcv_msg_doit+0x1f4/0x2f0 [ 68.760756] ? genl_family_rcv_msg_attrs_parse.constprop.0+0x230/0x230 [ 68.760756] ? security_capable+0x51/0x90 [ 68.760756] genl_rcv_msg+0x280/0x500 [ 68.760756] ? genl_get_cmd+0x3c0/0x3c0 [ 68.760756] ? lock_acquire+0x1ac/0x4f0 [ 68.760756] ? nfc_genl_dev_down+0xe0/0xe0 [ 68.760756] ? lockdep_hardirqs_on_prepare+0x410/0x410 [ 68.760756] netlink_rcv_skb+0x11b/0x340 [ 68.760756] ? genl_get_cmd+0x3c0/0x3c0 [ 68.760756] ? netlink_ack+0x9c0/0x9c0 [ 68.760756] ? netlink_deliver_tap+0x136/0xb00 [ 68.760756] genl_rcv+0x1f/0x30 [ 68.760756] netlink_unicast+0x430/0x710 [ 68.760756] ? memset+0x20/0x40 [ 68.760756] ? netlink_attachskb+0x740/0x740 [ 68.760756] ? __build_skb_around+0x1f4/0x2a0 [ 68.760756] netlink_sendmsg+0x75d/0xc00 [ 68.760756] ? netlink_unicast+0x710/0x710 [ 68.760756] ? netlink_unicast+0x710/0x710 [ 68.760756] sock_sendmsg+0xdf/0x110 [ 68.760756] __sys_sendto+0x19e/0x270 [ 68.760756] ? __ia32_sys_getpeername+0xa0/0xa0 [ 68.760756] ? fd_install+0x178/0x4c0 [ 68.760756] ? fd_install+0x195/0x4c0 [ 68.760756] ? kernel_fpu_begin_mask+0x1c0/0x1c0 [ 68.760756] __x64_sys_sendto+0xd8/0x1b0 [ 68.760756] ? lockdep_hardirqs_on+0xbf/0x130 [ 68.760756] ? syscall_enter_from_user_mode+0x1d/0x50 [ 68.760756] do_syscall_64+0x3b/0x90 [ 68.760756] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 68.760756] RIP: 0033:0x7f67fb50e6b3 ... [ 68.760756] RSP: 002b:00007f67fa91fe90 EFLAGS: 00000293 ORIG_RAX: 000000000000002c [ 68.760756] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f67fb50e6b3 [ 68.760756] RDX: 000000000000001c RSI: 0000559354603090 RDI: 0000000000000003 [ 68.760756] RBP: 00007f67fa91ff00 R08: 00007f67fa91fedc R09: 000000000000000c [ 68.760756] R10: 0000000000000000 R11: 0000000000000293 R12: 00007ffe824d496e [ 68.760756] R13: 00007ffe824d496f R14: 00007f67fa120000 R15: 0000000000000003 [ 68.760756] </TASK> [ 68.760756] [ 68.760756] Allocated by task 279: [ 68.760756] kasan_save_stack+0x1e/0x40 [ ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.4.293 以上 4.5 未満\nLinux Kernel 4.9.291 以上 4.9.318 未満\nLinux Kernel 4.14.256 以上 4.14.283 未満\nLinux Kernel 4.19.218 以上 4.19.247 未満\nLinux Kernel 5.4.162 以上 5.4.198 未満\nLinux Kernel 5.10.82 以上 5.10.121 未満\nLinux Kernel 5.15.5 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025972": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfc: nci: add flush_workqueue to prevent uaf Our detector found a concurrent use-after-free bug when detaching an NCI device. The main reason for this bug is the unexpected scheduling between the used delayed mechanism (timer and workqueue). The race can be demonstrated below: Thread-1 Thread-2 | nci_dev_up() | nci_open_device() | __nci_request(nci_reset_req) | nci_send_cmd | queue_work(cmd_work) nci_unregister_device() | nci_close_device() | ... del_timer_sync(cmd_timer)[1] | ... | Worker nci_free_device() | nci_cmd_work() kfree(ndev)[3] | mod_timer(cmd_timer)[2] In short, the cleanup routine thought that the cmd_timer has already been detached by [1] but the mod_timer can re-attach the timer [2], even it is already released [3], resulting in UAF. This UAF is easy to trigger, crash trace by POC is like below [ 66.703713] ================================================================== [ 66.703974] BUG: KASAN: use-after-free in enqueue_timer+0x448/0x490 [ 66.703974] Write of size 8 at addr ffff888009fb7058 by task kworker/u4:1/33 [ 66.703974] [ 66.703974] CPU: 1 PID: 33 Comm: kworker/u4:1 Not tainted 5.18.0-rc2 #5 [ 66.703974] Workqueue: nfc2_nci_cmd_wq nci_cmd_work [ 66.703974] Call Trace: [ 66.703974] <TASK> [ 66.703974] dump_stack_lvl+0x57/0x7d [ 66.703974] print_report.cold+0x5e/0x5db [ 66.703974] ? enqueue_timer+0x448/0x490 [ 66.703974] kasan_report+0xbe/0x1c0 [ 66.703974] ? enqueue_timer+0x448/0x490 [ 66.703974] enqueue_timer+0x448/0x490 [ 66.703974] __mod_timer+0x5e6/0xb80 [ 66.703974] ? mark_held_locks+0x9e/0xe0 [ 66.703974] ? try_to_del_timer_sync+0xf0/0xf0 [ 66.703974] ? lockdep_hardirqs_on_prepare+0x17b/0x410 [ 66.703974] ? queue_work_on+0x61/0x80 [ 66.703974] ? lockdep_hardirqs_on+0xbf/0x130 [ 66.703974] process_one_work+0x8bb/0x1510 [ 66.703974] ? lockdep_hardirqs_on_prepare+0x410/0x410 [ 66.703974] ? pwq_dec_nr_in_flight+0x230/0x230 [ 66.703974] ? rwlock_bug.part.0+0x90/0x90 [ 66.703974] ? _raw_spin_lock_irq+0x41/0x50 [ 66.703974] worker_thread+0x575/0x1190 [ 66.703974] ? process_one_work+0x1510/0x1510 [ 66.703974] kthread+0x2a0/0x340 [ 66.703974] ? kthread_complete_and_exit+0x20/0x20 [ 66.703974] ret_from_fork+0x22/0x30 [ 66.703974] </TASK> [ 66.703974] [ 66.703974] Allocated by task 267: [ 66.703974] kasan_save_stack+0x1e/0x40 [ 66.703974] __kasan_kmalloc+0x81/0xa0 [ 66.703974] nci_allocate_device+0xd3/0x390 [ 66.703974] nfcmrvl_nci_register_dev+0x183/0x2c0 [ 66.703974] nfcmrvl_nci_uart_open+0xf2/0x1dd [ 66.703974] nci_uart_tty_ioctl+0x2c3/0x4a0 [ 66.703974] tty_ioctl+0x764/0x1310 [ 66.703974] __x64_sys_ioctl+0x122/0x190 [ 66.703974] do_syscall_64+0x3b/0x90 [ 66.703974] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 66.703974] [ 66.703974] Freed by task 406: [ 66.703974] kasan_save_stack+0x1e/0x40 [ 66.703974] kasan_set_track+0x21/0x30 [ 66.703974] kasan_set_free_info+0x20/0x30 [ 66.703974] __kasan_slab_free+0x108/0x170 [ 66.703974] kfree+0xb0/0x330 [ 66.703974] nfcmrvl_nci_unregister_dev+0x90/0xd0 [ 66.703974] nci_uart_tty_close+0xdf/0x180 [ 66.703974] tty_ldisc_kill+0x73/0x110 [ 66.703974] tty_ldisc_hangup+0x281/0x5b0 [ 66.703974] __tty_hangup.part.0+0x431/0x890 [ 66.703974] tty_release+0x3a8/0xc80 [ 66.703974] __fput+0x1f0/0x8c0 [ 66.703974] task_work_run+0xc9/0x170 [ 66.703974] exit_to_user_mode_prepare+0x194/0x1a0 [ 66.703974] syscall_exit_to_user_mode+0x19/0x50 [ 66.703974] do_syscall_64+0x48/0x90 [ 66.703974] entry_SYSCALL_64_after_hwframe+0x44/0x ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.2 以上 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.239 未満\nLinux Kernel 4.20 以上 5.4.190 未満\nLinux Kernel 5.5 以上 5.10.112 未満\nLinux Kernel 5.11 以上 5.15.35 未満\nLinux Kernel 5.16 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025971": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block: Fix wrong offset in bio_truncate() bio_truncate() clears the buffer outside of last block of bdev, however current bio_truncate() is using the wrong offset of page. So it can return the uninitialized data. This happened when both of truncated/corrupted FS and userspace (via bdev) are trying to read the last of bdev.",
        "technologies": "Linux\nLinux Kernel 5.4.176 未満\nLinux Kernel 5.5 以上 5.10.96 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満"
    },
    "JVNDB-2022-025969": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Resolve NULL ptr dereference after an ELS LOGO is aborted A use-after-free crash can occur after an ELS LOGO is aborted. Specifically, a nodelist structure is freed and then ndlp->vport->cfg_log_verbose is dereferenced in lpfc_nlp_get() when the discovery state machine is mistakenly called a second time with NLP_EVT_DEVICE_RM argument. Rework lpfc_cmpl_els_logo() to prevent the duplicate calls to release a nodelist structure.",
        "technologies": "Linux\nLinux Kernel 5.15.49 未満\nLinux Kernel 5.16 以上 5.18.6 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025968": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bus: fsl-mc-bus: fix KASAN use-after-free in fsl_mc_bus_remove() In fsl_mc_bus_remove(), mc->root_mc_bus_dev->mc_io is passed to fsl_destroy_mc_io(). However, mc->root_mc_bus_dev is already freed in fsl_mc_device_remove(). Then reference to mc->root_mc_bus_dev->mc_io triggers KASAN use-after-free. To avoid the use-after-free, keep the reference to mc->root_mc_bus_dev->mc_io in a local variable and pass to fsl_destroy_mc_io(). This patch needs rework to apply to kernels older than v5.15.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 5.15.49 未満\nLinux Kernel 5.16 以上 5.18.6 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025352": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: tsc2046: fix memory corruption by preventing array overflow On one side we have indio_dev->num_channels includes all physical channels + timestamp channel. On other side we have an array allocated only for physical channels. So, fix memory corruption by ARRAY_SIZE() instead of num_channels variable. Note the first case is a cleanup rather than a fix as the software timestamp channel bit in active_scanmask is never set by the IIO core.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.26 未満\nLinux Kernel 5.16 以上 5.16.12 未満"
    },
    "JVNDB-2022-025365": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/cma: Do not change route.addr.src_addr outside state checks If the state is not idle then resolve_prepare_src() should immediately fail and no change to global state should happen. However, it unconditionally overwrites the src_addr trying to build a temporary any address. For instance if the state is already RDMA_CM_LISTEN then this will corrupt the src_addr and would cause the test in cma_cancel_operation(): if (cma_any_addr(cma_src_addr(id_priv)) && !id_priv->cma_dev) Which would manifest as this trace from syzkaller: BUG: KASAN: use-after-free in __list_add_valid+0x93/0xa0 lib/list_debug.c:26 Read of size 8 at addr ffff8881546491e0 by task syz-executor.1/32204 CPU: 1 PID: 32204 Comm: syz-executor.1 Not tainted 5.12.0-rc8-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: __dump_stack lib/dump_stack.c:79 [inline] dump_stack+0x141/0x1d7 lib/dump_stack.c:120 print_address_description.constprop.0.cold+0x5b/0x2f8 mm/kasan/report.c:232 __kasan_report mm/kasan/report.c:399 [inline] kasan_report.cold+0x7c/0xd8 mm/kasan/report.c:416 __list_add_valid+0x93/0xa0 lib/list_debug.c:26 __list_add include/linux/list.h:67 [inline] list_add_tail include/linux/list.h:100 [inline] cma_listen_on_all drivers/infiniband/core/cma.c:2557 [inline] rdma_listen+0x787/0xe00 drivers/infiniband/core/cma.c:3751 ucma_listen+0x16a/0x210 drivers/infiniband/core/ucma.c:1102 ucma_write+0x259/0x350 drivers/infiniband/core/ucma.c:1732 vfs_write+0x28e/0xa30 fs/read_write.c:603 ksys_write+0x1ee/0x250 fs/read_write.c:658 do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x44/0xae This is indicating that an rdma_id_private was destroyed without doing cma_cancel_listens(). Instead of trying to re-use the src_addr memory to indirectly create an any address derived from the dst build one explicitly on the stack and bind to that as any other normal flow would do. rdma_bind_addr() will copy it over the src_addr once it knows the state is valid. This is similar to commit bc0bdc5afaa7 (\"RDMA/cma: Do not change route.addr.src_addr.ss_family\")",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.103 未満\nLinux Kernel 5.11 以上 5.15.26 未満\nLinux Kernel 5.16 以上 5.16.12 未満"
    },
    "JVNDB-2022-025361": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86/mmu: make apf token non-zero to fix bug In current async pagefault logic, when a page is ready, KVM relies on kvm_arch_can_dequeue_async_page_present() to determine whether to deliver a READY event to the Guest. This function test token value of struct kvm_vcpu_pv_apf_data, which must be reset to zero by Guest kernel when a READY event is finished by Guest. If value is zero meaning that a READY event is done, so the KVM can deliver another. But the kvm_arch_setup_async_pf() may produce a valid token with zero value, which is confused with previous mention and may lead the loss of this READY event. This bug may cause task blocked forever in Guest: INFO: task stress:7532 blocked for more than 1254 seconds. Not tainted 5.10.0 #16 \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. task:stress state:D stack: 0 pid: 7532 ppid: 1409 flags:0x00000080 Call Trace: __schedule+0x1e7/0x650 schedule+0x46/0xb0 kvm_async_pf_task_wait_schedule+0xad/0xe0 ? exit_to_user_mode_prepare+0x60/0x70 __kvm_handle_async_pf+0x4f/0xb0 ? asm_exc_page_fault+0x8/0x30 exc_page_fault+0x6f/0x110 ? asm_exc_page_fault+0x8/0x30 asm_exc_page_fault+0x1e/0x30 RIP: 0033:0x402d00 RSP: 002b:00007ffd31912500 EFLAGS: 00010206 RAX: 0000000000071000 RBX: ffffffffffffffff RCX: 00000000021a32b0 RDX: 000000000007d011 RSI: 000000000007d000 RDI: 00000000021262b0 RBP: 00000000021262b0 R08: 0000000000000003 R09: 0000000000000086 R10: 00000000000000eb R11: 00007fefbdf2baa0 R12: 0000000000000000 R13: 0000000000000002 R14: 000000000007d000 R15: 0000000000001000",
        "technologies": "Linux\nLinux Kernel 5.10.103 未満\nLinux Kernel 5.11 以上 5.15.26 未満\nLinux Kernel 5.16 以上 5.16.12 未満"
    },
    "JVNDB-2022-025358": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: rndis: add spinlock for rndis response list There's no lock for rndis response list. It could cause list corruption if there're two different list_add at the same time like below. It's better to add in rndis_add_response / rndis_free_response / rndis_get_next_response to prevent any race condition on response list. [ 361.894299] [1: irq/191-dwc3:16979] list_add corruption. next->prev should be prev (ffffff80651764d0), but was ffffff883dc36f80. (next=ffffff80651764d0). [ 361.904380] [1: irq/191-dwc3:16979] Call trace: [ 361.904391] [1: irq/191-dwc3:16979] __list_add_valid+0x74/0x90 [ 361.904401] [1: irq/191-dwc3:16979] rndis_msg_parser+0x168/0x8c0 [ 361.904409] [1: irq/191-dwc3:16979] rndis_command_complete+0x24/0x84 [ 361.904417] [1: irq/191-dwc3:16979] usb_gadget_giveback_request+0x20/0xe4 [ 361.904426] [1: irq/191-dwc3:16979] dwc3_gadget_giveback+0x44/0x60 [ 361.904434] [1: irq/191-dwc3:16979] dwc3_ep0_complete_data+0x1e8/0x3a0 [ 361.904442] [1: irq/191-dwc3:16979] dwc3_ep0_interrupt+0x29c/0x3dc [ 361.904450] [1: irq/191-dwc3:16979] dwc3_process_event_entry+0x78/0x6cc [ 361.904457] [1: irq/191-dwc3:16979] dwc3_process_event_buf+0xa0/0x1ec [ 361.904465] [1: irq/191-dwc3:16979] dwc3_thread_interrupt+0x34/0x5c",
        "technologies": "Linux\nLinux Kernel 4.6 以上 4.9.304 未満\nLinux Kernel 4.10 以上 4.14.269 未満\nLinux Kernel 4.15 以上 4.19.232 未満\nLinux Kernel 4.20 以上 5.4.182 未満\nLinux Kernel 5.5 以上 5.10.103 未満\nLinux Kernel 5.11 以上 5.15.26 未満\nLinux Kernel 5.16 以上 5.16.12 未満"
    },
    "JVNDB-2022-025374": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: fastrpc: Fix use-after-free and race in fastrpc_map_find Currently, there is a race window between the point when the mutex is unlocked in fastrpc_map_lookup and the reference count increasing (fastrpc_map_get) in fastrpc_map_find, which can also lead to use-after-free. So lets merge fastrpc_map_find into fastrpc_map_lookup which allows us to both protect the maps list by also taking the &fl->lock spinlock and the reference count, since the spinlock will be released only after. Add take_ref argument to make this suitable for all callers.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.8 未満"
    },
    "JVNDB-2022-025369": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: blktrace: fix use after free for struct blk_trace When tracing the whole disk, 'dropped' and 'msg' will be created under 'q->debugfs_dir' and 'bt->dir' is NULL, thus blk_trace_free() won't remove those files. What's worse, the following UAF can be triggered because of accessing stale 'dropped' and 'msg': ================================================================== BUG: KASAN: use-after-free in blk_dropped_read+0x89/0x100 Read of size 4 at addr ffff88816912f3d8 by task blktrace/1188 CPU: 27 PID: 1188 Comm: blktrace Not tainted 5.17.0-rc4-next-20220217+ #469 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-4 Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_address_description.constprop.0.cold+0xab/0x381 ? blk_dropped_read+0x89/0x100 ? blk_dropped_read+0x89/0x100 kasan_report.cold+0x83/0xdf ? blk_dropped_read+0x89/0x100 kasan_check_range+0x140/0x1b0 blk_dropped_read+0x89/0x100 ? blk_create_buf_file_callback+0x20/0x20 ? kmem_cache_free+0xa1/0x500 ? do_sys_openat2+0x258/0x460 full_proxy_read+0x8f/0xc0 vfs_read+0xc6/0x260 ksys_read+0xb9/0x150 ? vfs_write+0x3d0/0x3d0 ? fpregs_assert_state_consistent+0x55/0x60 ? exit_to_user_mode_prepare+0x39/0x1e0 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7fbc080d92fd Code: ce 20 00 00 75 10 b8 00 00 00 00 0f 05 48 3d 01 f0 ff ff 73 31 c3 48 83 1 RSP: 002b:00007fbb95ff9cb0 EFLAGS: 00000293 ORIG_RAX: 0000000000000000 RAX: ffffffffffffffda RBX: 00007fbb95ff9dc0 RCX: 00007fbc080d92fd RDX: 0000000000000100 RSI: 00007fbb95ff9cc0 RDI: 0000000000000045 RBP: 0000000000000045 R08: 0000000000406299 R09: 00000000fffffffd R10: 000000000153afa0 R11: 0000000000000293 R12: 00007fbb780008c0 R13: 00007fbb78000938 R14: 0000000000608b30 R15: 00007fbb780029c8 </TASK> Allocated by task 1050: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0x81/0xa0 do_blk_trace_setup+0xcb/0x410 __blk_trace_setup+0xac/0x130 blk_trace_ioctl+0xe9/0x1c0 blkdev_ioctl+0xf1/0x390 __x64_sys_ioctl+0xa5/0xe0 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae Freed by task 1050: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_set_free_info+0x20/0x30 __kasan_slab_free+0x103/0x180 kfree+0x9a/0x4c0 __blk_trace_remove+0x53/0x70 blk_trace_ioctl+0x199/0x1c0 blkdev_common_ioctl+0x5e9/0xb30 blkdev_ioctl+0x1a5/0x390 __x64_sys_ioctl+0xa5/0xe0 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae The buggy address belongs to the object at ffff88816912f380 which belongs to the cache kmalloc-96 of size 96 The buggy address is located 88 bytes inside of 96-byte region [ffff88816912f380, ffff88816912f3e0) The buggy address belongs to the page: page:000000009a1b4e7c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0f flags: 0x17ffffc0000200(slab|node=0|zone=2|lastcpupid=0x1fffff) raw: 0017ffffc0000200 ffffea00044f1100 dead000000000002 ffff88810004c780 raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff88816912f280: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ffff88816912f300: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc >ffff88816912f380: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ^ ffff88816912f400: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ffff88816912f480: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ==================================================================",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.27 未満\nLinux Kernel 5.16 以上 5.16.13 未満"
    },
    "JVNDB-2022-025368": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: fix use-after-free in __nf_register_net_hook() We must not dereference @new_hooks after nf_hook_mutex has been released, because other threads might have freed our allocated hooks already. BUG: KASAN: use-after-free in nf_hook_entries_get_hook_ops include/linux/netfilter.h:130 [inline] BUG: KASAN: use-after-free in hooks_validate net/netfilter/core.c:171 [inline] BUG: KASAN: use-after-free in __nf_register_net_hook+0x77a/0x820 net/netfilter/core.c:438 Read of size 2 at addr ffff88801c1a8000 by task syz-executor237/4430 CPU: 1 PID: 4430 Comm: syz-executor237 Not tainted 5.17.0-rc5-syzkaller-00306-g2293be58d6a1 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0x8d/0x336 mm/kasan/report.c:255 __kasan_report mm/kasan/report.c:442 [inline] kasan_report.cold+0x83/0xdf mm/kasan/report.c:459 nf_hook_entries_get_hook_ops include/linux/netfilter.h:130 [inline] hooks_validate net/netfilter/core.c:171 [inline] __nf_register_net_hook+0x77a/0x820 net/netfilter/core.c:438 nf_register_net_hook+0x114/0x170 net/netfilter/core.c:571 nf_register_net_hooks+0x59/0xc0 net/netfilter/core.c:587 nf_synproxy_ipv6_init+0x85/0xe0 net/netfilter/nf_synproxy_core.c:1218 synproxy_tg6_check+0x30d/0x560 net/ipv6/netfilter/ip6t_SYNPROXY.c:81 xt_check_target+0x26c/0x9e0 net/netfilter/x_tables.c:1038 check_target net/ipv6/netfilter/ip6_tables.c:530 [inline] find_check_entry.constprop.0+0x7f1/0x9e0 net/ipv6/netfilter/ip6_tables.c:573 translate_table+0xc8b/0x1750 net/ipv6/netfilter/ip6_tables.c:735 do_replace net/ipv6/netfilter/ip6_tables.c:1153 [inline] do_ip6t_set_ctl+0x56e/0xb90 net/ipv6/netfilter/ip6_tables.c:1639 nf_setsockopt+0x83/0xe0 net/netfilter/nf_sockopt.c:101 ipv6_setsockopt+0x122/0x180 net/ipv6/ipv6_sockglue.c:1024 rawv6_setsockopt+0xd3/0x6a0 net/ipv6/raw.c:1084 __sys_setsockopt+0x2db/0x610 net/socket.c:2180 __do_sys_setsockopt net/socket.c:2191 [inline] __se_sys_setsockopt net/socket.c:2188 [inline] __x64_sys_setsockopt+0xba/0x150 net/socket.c:2188 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f65a1ace7d9 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 71 15 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f65a1a7f308 EFLAGS: 00000246 ORIG_RAX: 0000000000000036 RAX: ffffffffffffffda RBX: 0000000000000006 RCX: 00007f65a1ace7d9 RDX: 0000000000000040 RSI: 0000000000000029 RDI: 0000000000000003 RBP: 00007f65a1b574c8 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000020000000 R11: 0000000000000246 R12: 00007f65a1b55130 R13: 00007f65a1b574c0 R14: 00007f65a1b24090 R15: 0000000000022000 </TASK> The buggy address belongs to the page: page:ffffea0000706a00 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1c1a8 flags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff) raw: 00fff00000000000 ffffea0001c1b108 ffffea000046dd08 0000000000000000 raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: kasan: bad access detected page_owner tracks the page as freed page last allocated via order 2, migratetype Unmovable, gfp_mask 0x52dc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_ZERO), pid 4430, ts 1061781545818, free_ts 1061791488993 prep_new_page mm/page_alloc.c:2434 [inline] get_page_from_freelist+0xa72/0x2f50 mm/page_alloc.c:4165 __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5389 __alloc_pages_node include/linux/gfp.h:572 [inline] alloc_pages_node include/linux/gfp.h:595 [inline] kmalloc_large_node+0x62/0x130 mm/slub.c:4438 __kmalloc_node+0x35a/0x4a0 mm/slub. ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.14 以上 4.14.270 未満\nLinux Kernel 4.15 以上 4.19.233 未満\nLinux Kernel 4.20 以上 5.4.183 未満\nLinux Kernel 5.5 以上 5.10.104 未満\nLinux Kernel 5.11 以上 5.15.27 未満\nLinux Kernel 5.16 以上 5.16.13 未満"
    },
    "JVNDB-2022-025375": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_qca: Fix driver shutdown on closed serdev The driver shutdown callback (which sends EDL_SOC_RESET to the device over serdev) should not be invoked when HCI device is not open (e.g. if hci_dev_open_sync() failed), because the serdev and its TTY are not open either. Also skip this step if device is powered off (qca_power_shutdown()). The shutdown callback causes use-after-free during system reboot with Qualcomm Atheros Bluetooth: Unable to handle kernel paging request at virtual address 0072662f67726fd7 ... CPU: 6 PID: 1 Comm: systemd-shutdow Tainted: G W 6.1.0-rt5-00325-g8a5f56bcfcca #8 Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT) Call trace: tty_driver_flush_buffer+0x4/0x30 serdev_device_write_flush+0x24/0x34 qca_serdev_shutdown+0x80/0x130 [hci_uart] device_shutdown+0x15c/0x260 kernel_restart+0x48/0xac KASAN report: BUG: KASAN: use-after-free in tty_driver_flush_buffer+0x1c/0x50 Read of size 8 at addr ffff16270c2e0018 by task systemd-shutdow/1 CPU: 7 PID: 1 Comm: systemd-shutdow Not tainted 6.1.0-next-20221220-00014-gb85aaf97fb01-dirty #28 Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT) Call trace: dump_backtrace.part.0+0xdc/0xf0 show_stack+0x18/0x30 dump_stack_lvl+0x68/0x84 print_report+0x188/0x488 kasan_report+0xa4/0xf0 __asan_load8+0x80/0xac tty_driver_flush_buffer+0x1c/0x50 ttyport_write_flush+0x34/0x44 serdev_device_write_flush+0x48/0x60 qca_serdev_shutdown+0x124/0x274 device_shutdown+0x1e8/0x350 kernel_restart+0x48/0xb0 __do_sys_reboot+0x244/0x2d0 __arm64_sys_reboot+0x54/0x70 invoke_syscall+0x60/0x190 el0_svc_common.constprop.0+0x7c/0x160 do_el0_svc+0x44/0xf0 el0_svc+0x2c/0x6c el0t_64_sync_handler+0xbc/0x140 el0t_64_sync+0x190/0x194",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.165 未満\nLinux Kernel 5.11 以上 5.15.90 未満\nLinux Kernel 5.16 以上 6.1.8 未満"
    },
    "JVNDB-2022-025380": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86/amd: Fix refcount leak in amd_pmc_probe pci_get_domain_bus_and_slot() takes reference, the caller should release the reference by calling pci_dev_put() after use. Call pci_dev_put() in the error path to fix this.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.7 未満"
    },
    "JVNDB-2022-025342": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dsa: lantiq_gswip: fix use after free in gswip_remove() of_node_put(priv->ds->slave_mii_bus->dev.of_node) should be done before mdiobus_free(priv->ds->slave_mii_bus).",
        "technologies": "Linux\nLinux Kernel 5.10.101\nLinux Kernel 5.15.24\nLinux Kernel 5.16.10"
    },
    "JVNDB-2022-025393": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: fastrpc: Fix use-after-free race condition for maps It is possible that in between calling fastrpc_map_get() until map->fl->lock is taken in fastrpc_free_map(), another thread can call fastrpc_map_lookup() and get a reference to a map that is about to be deleted. Rewrite fastrpc_map_get() to only increase the reference count of a map if it's non-zero. Propagate this to callers so they can know if a map is about to be deleted. Fixes this warning: refcount_t: addition on 0; use-after-free. WARNING: CPU: 5 PID: 10100 at lib/refcount.c:25 refcount_warn_saturate ... Call trace: refcount_warn_saturate [fastrpc_map_get inlined] [fastrpc_map_lookup inlined] fastrpc_map_create fastrpc_internal_invoke fastrpc_device_ioctl __arm64_sys_ioctl invoke_syscall",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.230 未満\nLinux Kernel 5.5 以上 5.10.165 未満\nLinux Kernel 5.11 以上 5.15.90 未満\nLinux Kernel 5.16 以上 6.2 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-025371": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: fix double free race when mount fails in cifs_get_root() When cifs_get_root() fails during cifs_smb3_do_mount() we call deactivate_locked_super() which eventually will call delayed_free() which will free the context. In this situation we should not proceed to enter the out: section in cifs_smb3_do_mount() and free the same resources a second time. [Thu Feb 10 12:59:06 2022] BUG: KASAN: use-after-free in rcu_cblist_dequeue+0x32/0x60 [Thu Feb 10 12:59:06 2022] Read of size 8 at addr ffff888364f4d110 by task swapper/1/0 [Thu Feb 10 12:59:06 2022] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G OE 5.17.0-rc3+ #4 [Thu Feb 10 12:59:06 2022] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.0 12/17/2019 [Thu Feb 10 12:59:06 2022] Call Trace: [Thu Feb 10 12:59:06 2022] <IRQ> [Thu Feb 10 12:59:06 2022] dump_stack_lvl+0x5d/0x78 [Thu Feb 10 12:59:06 2022] print_address_description.constprop.0+0x24/0x150 [Thu Feb 10 12:59:06 2022] ? rcu_cblist_dequeue+0x32/0x60 [Thu Feb 10 12:59:06 2022] kasan_report.cold+0x7d/0x117 [Thu Feb 10 12:59:06 2022] ? rcu_cblist_dequeue+0x32/0x60 [Thu Feb 10 12:59:06 2022] __asan_load8+0x86/0xa0 [Thu Feb 10 12:59:06 2022] rcu_cblist_dequeue+0x32/0x60 [Thu Feb 10 12:59:06 2022] rcu_core+0x547/0xca0 [Thu Feb 10 12:59:06 2022] ? call_rcu+0x3c0/0x3c0 [Thu Feb 10 12:59:06 2022] ? __this_cpu_preempt_check+0x13/0x20 [Thu Feb 10 12:59:06 2022] ? lock_is_held_type+0xea/0x140 [Thu Feb 10 12:59:06 2022] rcu_core_si+0xe/0x10 [Thu Feb 10 12:59:06 2022] __do_softirq+0x1d4/0x67b [Thu Feb 10 12:59:06 2022] __irq_exit_rcu+0x100/0x150 [Thu Feb 10 12:59:06 2022] irq_exit_rcu+0xe/0x30 [Thu Feb 10 12:59:06 2022] sysvec_hyperv_stimer0+0x9d/0xc0 ... [Thu Feb 10 12:59:07 2022] Freed by task 58179: [Thu Feb 10 12:59:07 2022] kasan_save_stack+0x26/0x50 [Thu Feb 10 12:59:07 2022] kasan_set_track+0x25/0x30 [Thu Feb 10 12:59:07 2022] kasan_set_free_info+0x24/0x40 [Thu Feb 10 12:59:07 2022] ____kasan_slab_free+0x137/0x170 [Thu Feb 10 12:59:07 2022] __kasan_slab_free+0x12/0x20 [Thu Feb 10 12:59:07 2022] slab_free_freelist_hook+0xb3/0x1d0 [Thu Feb 10 12:59:07 2022] kfree+0xcd/0x520 [Thu Feb 10 12:59:07 2022] cifs_smb3_do_mount+0x149/0xbe0 [cifs] [Thu Feb 10 12:59:07 2022] smb3_get_tree+0x1a0/0x2e0 [cifs] [Thu Feb 10 12:59:07 2022] vfs_get_tree+0x52/0x140 [Thu Feb 10 12:59:07 2022] path_mount+0x635/0x10c0 [Thu Feb 10 12:59:07 2022] __x64_sys_mount+0x1bf/0x210 [Thu Feb 10 12:59:07 2022] do_syscall_64+0x5c/0xc0 [Thu Feb 10 12:59:07 2022] entry_SYSCALL_64_after_hwframe+0x44/0xae [Thu Feb 10 12:59:07 2022] Last potentially related work creation: [Thu Feb 10 12:59:07 2022] kasan_save_stack+0x26/0x50 [Thu Feb 10 12:59:07 2022] __kasan_record_aux_stack+0xb6/0xc0 [Thu Feb 10 12:59:07 2022] kasan_record_aux_stack_noalloc+0xb/0x10 [Thu Feb 10 12:59:07 2022] call_rcu+0x76/0x3c0 [Thu Feb 10 12:59:07 2022] cifs_umount+0xce/0xe0 [cifs] [Thu Feb 10 12:59:07 2022] cifs_kill_sb+0xc8/0xe0 [cifs] [Thu Feb 10 12:59:07 2022] deactivate_locked_super+0x5d/0xd0 [Thu Feb 10 12:59:07 2022] cifs_smb3_do_mount+0xab9/0xbe0 [cifs] [Thu Feb 10 12:59:07 2022] smb3_get_tree+0x1a0/0x2e0 [cifs] [Thu Feb 10 12:59:07 2022] vfs_get_tree+0x52/0x140 [Thu Feb 10 12:59:07 2022] path_mount+0x635/0x10c0 [Thu Feb 10 12:59:07 2022] __x64_sys_mount+0x1bf/0x210 [Thu Feb 10 12:59:07 2022] do_syscall_64+0x5c/0xc0 [Thu Feb 10 12:59:07 2022] entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 4.9.305 未満\nLinux Kernel 4.10 以上 4.14.270 未満\nLinux Kernel 4.15 以上 4.19.233 未満\nLinux Kernel 4.20 以上 5.4.183 未満\nLinux Kernel 5.5 以上 5.10.104 未満\nLinux Kernel 5.11 以上 5.15.27 未満\nLinux Kernel 5.16 以上 5.16.13 未満"
    },
    "JVNDB-2022-025396": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dmaengine: idxd: Prevent use after free on completion memory On driver unload any pending descriptors are flushed at the time the interrupt is freed: idxd_dmaengine_drv_remove() -> drv_disable_wq() -> idxd_wq_free_irq() -> idxd_flush_pending_descs(). If there are any descriptors present that need to be flushed this flow triggers a \"not present\" page fault as below: BUG: unable to handle page fault for address: ff391c97c70c9040 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page The address that triggers the fault is the address of the descriptor that was freed moments earlier via: drv_disable_wq()->idxd_wq_free_resources() Fix the use after free by freeing the descriptors after any possible usage. This is done after idxd_wq_reset() to ensure that the memory remains accessible during possible completion writes by the device.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.8 未満"
    },
    "JVNDB-2022-025402": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: phy: stm32: fix a refcount leak in stm32_usbphyc_pll_enable() This error path needs to decrement \"usbphyc->n_pll_cons.counter\" before returning.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025467": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hsr: Fix potential use-after-free The skb is delivered to netif_rx() which may free it, after calling this, dereferencing skb may trigger use-after-free.",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.9.335 未満\nLinux Kernel 4.10 以上 4.14.301 未満\nLinux Kernel 4.15 以上 4.19.268 未満\nLinux Kernel 4.20 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025465": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac8021: fix possible oob access in ieee80211_get_rate_duration Fix possible out-of-bound access in ieee80211_get_rate_duration routine as reported by the following UBSAN report: UBSAN: array-index-out-of-bounds in net/mac80211/airtime.c:455:47 index 15 is out of range for type 'u16 [12]' CPU: 2 PID: 217 Comm: kworker/u32:10 Not tainted 6.1.0-060100rc3-generic Hardware name: Acer Aspire TC-281/Aspire TC-281, BIOS R01-A2 07/18/2017 Workqueue: mt76 mt76u_tx_status_data [mt76_usb] Call Trace: <TASK> show_stack+0x4e/0x61 dump_stack_lvl+0x4a/0x6f dump_stack+0x10/0x18 ubsan_epilogue+0x9/0x43 __ubsan_handle_out_of_bounds.cold+0x42/0x47 ieee80211_get_rate_duration.constprop.0+0x22f/0x2a0 [mac80211] ? ieee80211_tx_status_ext+0x32e/0x640 [mac80211] ieee80211_calc_rx_airtime+0xda/0x120 [mac80211] ieee80211_calc_tx_airtime+0xb4/0x100 [mac80211] mt76x02_send_tx_status+0x266/0x480 [mt76x02_lib] mt76x02_tx_status_data+0x52/0x80 [mt76x02_lib] mt76u_tx_status_data+0x67/0xd0 [mt76_usb] process_one_work+0x225/0x400 worker_thread+0x50/0x3e0 ? process_one_work+0x400/0x400 kthread+0xe9/0x110 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x22/0x30",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-018869": {
        "title": "Linux Foundation の yocto 他複数ベンダの製品におけるリソースの不適切なシャットダウンおよびリリースに関する脆弱性",
        "description": "In Wi-Fi driver, there is a possible way to disconnect Wi-Fi due to an improper resource release. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07030600; Issue ID: ALPS07030600.",
        "technologies": "Google\nAndroid 11.0\nAndroid 12.0\nLinux Foundation\nyocto 3.1\nyocto 3.3"
    },
    "JVNDB-2022-018945": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における脆弱性",
        "description": "An issue was discovered the x86 KVM subsystem in the Linux kernel before 5.18.17. Unprivileged guest users can compromise the guest kernel because TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.",
        "technologies": "Linux\nLinux Kernel 4.16 以上 5.4.244 未満\nLinux Kernel 5.5.0 以上 5.10.180 未満\nLinux Kernel 5.11 以上 5.15.60 未満\nLinux Kernel 5.16 以上 5.18.17 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2022-025470": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: fix buffer overflow in elem comparison For vendor elements, the code here assumes that 5 octets are present without checking. Since the element itself is already checked to fit, we only need to check the length.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025461": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: avoid use-after-free in ip6_fragment() Blamed commit claimed rcu_read_lock() was held by ip6_fragment() callers. It seems to not be always true, at least for UDP stack. syzbot reported: BUG: KASAN: use-after-free in ip6_dst_idev include/net/ip6_fib.h:245 [inline] BUG: KASAN: use-after-free in ip6_fragment+0x2724/0x2770 net/ipv6/ip6_output.c:951 Read of size 8 at addr ffff88801d403e80 by task syz-executor.3/7618 CPU: 1 PID: 7618 Comm: syz-executor.3 Not tainted 6.1.0-rc6-syzkaller-00012-g4312098baf37 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:284 [inline] print_report+0x15e/0x45d mm/kasan/report.c:395 kasan_report+0xbf/0x1f0 mm/kasan/report.c:495 ip6_dst_idev include/net/ip6_fib.h:245 [inline] ip6_fragment+0x2724/0x2770 net/ipv6/ip6_output.c:951 __ip6_finish_output net/ipv6/ip6_output.c:193 [inline] ip6_finish_output+0x9a3/0x1170 net/ipv6/ip6_output.c:206 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip6_output+0x1f1/0x540 net/ipv6/ip6_output.c:227 dst_output include/net/dst.h:445 [inline] ip6_local_out+0xb3/0x1a0 net/ipv6/output_core.c:161 ip6_send_skb+0xbb/0x340 net/ipv6/ip6_output.c:1966 udp_v6_send_skb+0x82a/0x18a0 net/ipv6/udp.c:1286 udp_v6_push_pending_frames+0x140/0x200 net/ipv6/udp.c:1313 udpv6_sendmsg+0x18da/0x2c80 net/ipv6/udp.c:1606 inet6_sendmsg+0x9d/0xe0 net/ipv6/af_inet6.c:665 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg+0xd3/0x120 net/socket.c:734 sock_write_iter+0x295/0x3d0 net/socket.c:1108 call_write_iter include/linux/fs.h:2191 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x9ed/0xdd0 fs/read_write.c:584 ksys_write+0x1ec/0x250 fs/read_write.c:637 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fde3588c0d9 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fde365b6168 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 RAX: ffffffffffffffda RBX: 00007fde359ac050 RCX: 00007fde3588c0d9 RDX: 000000000000ffdc RSI: 00000000200000c0 RDI: 000000000000000a RBP: 00007fde358e7ae9 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007fde35acfb1f R14: 00007fde365b6300 R15: 0000000000022000 </TASK> Allocated by task 7618: kasan_save_stack+0x22/0x40 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 __kasan_slab_alloc+0x82/0x90 mm/kasan/common.c:325 kasan_slab_alloc include/linux/kasan.h:201 [inline] slab_post_alloc_hook mm/slab.h:737 [inline] slab_alloc_node mm/slub.c:3398 [inline] slab_alloc mm/slub.c:3406 [inline] __kmem_cache_alloc_lru mm/slub.c:3413 [inline] kmem_cache_alloc+0x2b4/0x3d0 mm/slub.c:3422 dst_alloc+0x14a/0x1f0 net/core/dst.c:92 ip6_dst_alloc+0x32/0xa0 net/ipv6/route.c:344 ip6_rt_pcpu_alloc net/ipv6/route.c:1369 [inline] rt6_make_pcpu_route net/ipv6/route.c:1417 [inline] ip6_pol_route+0x901/0x1190 net/ipv6/route.c:2254 pol_lookup_func include/net/ip6_fib.h:582 [inline] fib6_rule_lookup+0x52e/0x6f0 net/ipv6/fib6_rules.c:121 ip6_route_output_flags_noref+0x2e6/0x380 net/ipv6/route.c:2625 ip6_route_output_flags+0x76/0x320 net/ipv6/route.c:2638 ip6_route_output include/net/ip6_route.h:98 [inline] ip6_dst_lookup_tail+0x5ab/0x1620 net/ipv6/ip6_output.c:1092 ip6_dst_lookup_flow+0x90/0x1d0 net/ipv6/ip6_output.c:1222 ip6_sk_dst_lookup_flow+0x553/0x980 net/ipv6/ip6_output.c:1260 udpv6_sendmsg+0x151d/0x2c80 net/ipv6/udp.c:1554 inet6_sendmsg+0x9d/0xe0 net/ipv6/af_inet6.c:665 sock_sendmsg_nosec n ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.13 以上 4.14.302 未満\nLinux Kernel 4.15 以上 4.19.269 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-018949": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "A race condition was found in the way the Linux kernel's memory subsystem handled the copy-on-write (COW) breakage of private read-only shared memory mappings. This flaw allows an unprivileged, local user to gain write access to read-only memory mappings, increasing their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.19.6 未満"
    },
    "JVNDB-2022-019010": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free in the mac80211 stack when parsing a multi-BSSID element in the Linux kernel 5.2 through 5.19.x before 5.19.16 could be used by attackers (able to inject WLAN frames) to crash the kernel and potentially execute code.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nFedora Project\nFedora 35\nFedora 36\nFedora 37\nLinux\nLinux Kernel 5.2 以上 5.4.219 未満\nLinux Kernel 5.5 以上 5.10.149 未満\nLinux Kernel 5.11 以上 5.15.74 未満\nLinux Kernel 5.16 以上 5.19.16 未満\nLinux Kernel 6.0 以上 6.0.2 未満"
    },
    "JVNDB-2022-019001": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 5.19.16. Attackers able to inject WLAN frames could cause a buffer overflow in the ieee80211_bss_info_update function in net/mac80211/scan.c.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nFedora Project\nFedora 35\nFedora 36\nFedora 37\nLinux\nLinux Kernel 5.1 以上 5.4.218 未満\nLinux Kernel 5.5 以上 5.10.148 未満\nLinux Kernel 5.11 以上 5.15.74 未満\nLinux Kernel 5.16 以上 5.19.16 未満\nLinux Kernel 6.0 以上 6.0.2 未満"
    },
    "JVNDB-2022-019229": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "mm/mremap.c in the Linux kernel before 5.13.3 has a use-after-free via a stale TLB because an rmap lock is not held during a PUD move.",
        "technologies": "Canonical\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nDebian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.0 以上 5.4.211 未満\nLinux Kernel 5.5 以上 5.10.137 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2022-019244": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "A vulnerability classified as critical has been found in Linux Kernel. This affects the function spl2sw_nvmem_get_mac_address of the file drivers/net/ethernet/sunplus/spl2sw_driver.c of the component BPF. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211041 was assigned to this vulnerability.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 5.19.17 未満\nLinux Kernel 6.0 以上 6.0.3 未満"
    },
    "JVNDB-2022-020470": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における脆弱性",
        "description": "nfqnl_mangle in net/netfilter/nfnetlink_queue.c in the Linux kernel through 5.18.14 allows remote attackers to cause a denial of service (panic) because, in the case of an nf_queue verdict with a one-byte nfta_payload attribute, an skb_pull can encounter a negative skb->len.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 2.6.14 以上 4.9.326 未満\nLinux Kernel 4.10 以上 4.14.291 未満\nLinux Kernel 4.15 以上 4.19.255 未満\nLinux Kernel 4.20 以上 5.4.209 未満\nLinux Kernel 5.5 以上 5.10.135 未満\nLinux Kernel 5.11 以上 5.15.59 未満\nLinux Kernel 5.16 以上 5.18.16 未満\nNetApp\nActive IQ Unified Manager\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire & HCI Storage Node\nNetApp SolidFire Enterprise SDS\nNetApp HCI Compute Node"
    },
    "JVNDB-2022-019245": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A vulnerability classified as critical has been found in Linux Kernel. Affected is the function btf_dump_name_dups of the file tools/lib/bpf/btf_dump.c of the component libbpf. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211032.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-019257": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-019014": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 4.11 以上 4.14.303 未満\nLinux Kernel 4.15 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.228 未満\nLinux Kernel 5.5 以上 5.10.160 未満\nLinux Kernel 5.11 以上 5.15.84 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-020491": {
        "title": "ヒューレット・パッカード・エンタープライズの HPE Serviceguard for Linux における信頼できないデータのデシリアライゼーションに関する脆弱性",
        "description": "Unauthenticated Java deserialization vulnerability in Serviceguard Manager",
        "technologies": "ヒューレット・パッカード・エンタープライズ\nHPE Serviceguard for Linux a.12.80.05 未満"
    },
    "JVNDB-2022-019569": {
        "title": "SUSE の linux enterprise module for sap applications 他複数ベンダの製品における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "An Incorrect Default Permissions vulnerability in saphanabootstrap-formula of SUSE Linux Enterprise Module for SAP Applications 15-SP1, SUSE Linux Enterprise Server for SAP 12-SP5; openSUSE Leap 15.4 allows local attackers to escalate to root by manipulating the sudo configuration that is created. This issue affects: SUSE Linux Enterprise Module for SAP Applications 15-SP1 saphanabootstrap-formula versions prior to 0.13.1+git.1667812208.4db963e. SUSE Linux Enterprise Server for SAP 12-SP5 saphanabootstrap-formula versions prior to 0.13.1+git.1667812208.4db963e. openSUSE Leap 15.4 saphanabootstrap-formula versions prior to 0.13.1+git.1667812208.4db963e.",
        "technologies": "openSUSE project\nopenSUSE Leap 15.4\nSUSE\nlinux enterprise module for sap applications 15\nSUSE Linux Enterprise Server 12"
    },
    "JVNDB-2022-021236": {
        "title": "Linux の Linux Kernel における無効なポインタや参照の解放に関する脆弱性",
        "description": "In the Linux kernel through 6.2.7, fs/ntfs3/inode.c has an invalid kfree because it does not validate MFT flags before replaying logs.",
        "technologies": "Linux\nLinux Kernel 6.2.7 およびそれ以前"
    },
    "JVNDB-2022-021467": {
        "title": "Linux Foundation の knative func における情報漏えいに関する脆弱性",
        "description": "knative.dev/func is is a client library and CLI enabling the development and deployment of Kubernetes functions. Developers using a malicious or compromised third-party buildpack could expose their registry credentials or local docker socket to a malicious `lifecycle` container. This issues has been patched in PR #1442, and is part of release 1.8.1. This issue only affects users who are using function buildpacks from third-parties; pinning the builder image to a specific content-hash with a valid `lifecycle` image will also mitigate the attack.",
        "technologies": "Linux Foundation\nknative func 1.8.1 未満"
    },
    "JVNDB-2022-020493": {
        "title": "ヒューレット・パッカード・エンタープライズの HPE Serviceguard for Linux におけるサーバサイドのリクエストフォージェリの脆弱性",
        "description": "Unauthenticated server side request forgery in HPE Serviceguard Manager",
        "technologies": "ヒューレット・パッカード・エンタープライズ\nHPE Serviceguard for Linux a.12.80.05 未満"
    },
    "JVNDB-2022-020492": {
        "title": "ヒューレット・パッカード・エンタープライズの HPE Serviceguard for Linux における境界外書き込みに関する脆弱性",
        "description": "Pre-auth memory corruption in HPE Serviceguard",
        "technologies": "ヒューレット・パッカード・エンタープライズ\nHPE Serviceguard for Linux a.12.80.05 未満"
    },
    "JVNDB-2022-021244": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in Linux kernel before 5.19.2. This issue occurs in cmd_hdl_filter in drivers/staging/rtl8712/rtl8712_cmd.c, allowing an attacker to launch a local denial of service attack and gain escalation of privileges.",
        "technologies": "Linux\nLinux Kernel 2.6.37 以上 4.9.328 未満\nLinux Kernel 4.10 以上 4.14.293 未満\nLinux Kernel 4.15 以上 4.19.258 未満\nLinux Kernel 4.20 以上 5.4.213 未満\nLinux Kernel 5.5 以上 5.10.142 未満\nLinux Kernel 5.11 以上 5.15.66 未満\nLinux Kernel 5.16 以上 5.19.8 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-021238": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel before 6.1.3, fs/ntfs3/record.c does not validate resident attribute names. An out-of-bounds write may occur.",
        "technologies": "Linux\nLinux Kernel 6.1.3 未満"
    },
    "JVNDB-2022-021417": {
        "title": "Linux Foundation の Python 用 pytorch におけるコードインジェクションの脆弱性",
        "description": "In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can cause arbitrary code execution because eval is used unsafely.",
        "technologies": "Linux Foundation\npytorch 1.13.1 未満"
    },
    "JVNDB-2022-021575": {
        "title": "Linux Foundation の opendaylight における SQL インジェクションの脆弱性",
        "description": "A SQL injection issue was discovered in AAA in OpenDaylight (ODL) before 0.16.5. The aaa-idm-store-h2/src/main/java/org/opendaylight/aaa/datastore/h2/RoleStore.java deleteRole function is affected when the API interface /auth/v1/roles/ is used.",
        "technologies": "Linux Foundation\nopendaylight 0.15.0\nopendaylight 0.15.6\nopendaylight 0.16.0\nopendaylight 0.16.4"
    },
    "JVNDB-2022-021576": {
        "title": "Linux Foundation の opendaylight における SQL インジェクションの脆弱性",
        "description": "A SQL injection issue was discovered in AAA in OpenDaylight (ODL) before 0.16.5. The aaa-idm-store-h2/src/main/java/org/opendaylight/aaa/datastore/h2/UserStore.java deleteUser function is affected when the API interface /auth/v1/users/ is used.",
        "technologies": "Linux Foundation\nopendaylight 0.15.0\nopendaylight 0.15.6\nopendaylight 0.16.0\nopendaylight 0.16.4"
    },
    "JVNDB-2022-021022": {
        "title": "Linux Foundation の software for open networking in the cloud における古典的バッファオーバーフローの脆弱性",
        "description": "There is a vulnerability in DHCPv6 packet parsing code that could be explored by remote attacker to craft a packet that could cause buffer overflow in a memcpy call, leading to out-of-bounds memory write that would cause dhcp6relay to crash. Dhcp6relay is a critical process and could cause dhcp relay docker to shutdown. Discovered by Eugene Lim of GovTech Singapore.",
        "technologies": "Linux Foundation\nsoftware for open networking in the cloud 202111"
    },
    "JVNDB-2022-021237": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel before 6.1.3, fs/ntfs3/inode.c does not validate the attribute name offset. An unhandled page fault may occur.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.87 未満\nLinux Kernel 5.16 以上 6.0.17 未満\nLinux Kernel 6.1 以上 6.1.3 未満"
    },
    "JVNDB-2022-022099": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "A double-free flaw was found in the Linux kernel’s TUN/TAP device driver functionality in how a user registers the device when the register_netdevice function fails (NETDEV_REGISTER notifier). This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.136 未満\nLinux Kernel 5.11 以上 5.15.12 未満"
    },
    "JVNDB-2022-022007": {
        "title": "レッドハットの device-mapper-multipath および Red Hat Enterprise Linux における脆弱性",
        "description": "A vulnerability was found in the device-mapper-multipath. The device-mapper-multipath allows local users to obtain root access, exploited alone or in conjunction with CVE-2022-41973. Local users that are able to write to UNIX domain sockets can bypass access controls and manipulate the multipath setup. This issue occurs because an attacker can repeat a keyword, which is mishandled when arithmetic ADD is used instead of bitwise OR. This could lead to local privilege escalation to root.",
        "technologies": "レッドハット\ndevice-mapper-multipath\nRed Hat Enterprise Linux 8.7\nRed Hat Enterprise Linux 9.1"
    },
    "JVNDB-2022-021698": {
        "title": "NVIDIA の Linux 用 gpu display driver におけるパーミッションの不適切な保持に関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in an optional D-Bus configuration file, where a local user with basic capabilities can impact protected D-Bus endpoints, which may lead to code execution, denial of service, escalation of privileges, information disclosure, and data tampering.",
        "technologies": "NVIDIA\ngpu display driver 390 以上 390.154 未満\ngpu display driver 470 以上 470.141.03 未満\ngpu display driver 510 以上 510.85.02 未満\ngpu display driver 515 以上 515.65.01 未満\ngpu display driver 390 以上 390.154 未満\ngpu display driver 470 以上 470.141.03 未満\ngpu display driver 510 以上 510.85.02 未満\ngpu display driver 515 以上 515.65.01 未満\ngpu display driver 450 以上 450.203.03 未満\ngpu display driver 470 以上 470.141.03 未満\ngpu display driver 510 以上 510.85.02 未満\ngpu display driver 515 以上 515.65.01 未満"
    },
    "JVNDB-2022-021577": {
        "title": "Linux Foundation の opendaylight における SQL インジェクションの脆弱性",
        "description": "A SQL injection issue was discovered in AAA in OpenDaylight (ODL) before 0.16.5. The aaa-idm-store-h2/src/main/java/org/opendaylight/aaa/datastore/h2/DomainStore.java deleteDomain function is affected for the /auth/v1/domains/ API interface.",
        "technologies": "Linux Foundation\nopendaylight 0.15.0\nopendaylight 0.15.6\nopendaylight 0.16.0\nopendaylight 0.16.4"
    },
    "JVNDB-2022-018517": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw use after free in the Linux kernel NILFS file system was found in the way user triggers function security_inode_alloc to fail with following call to function nilfs_mdt_destroy. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 以上 4.9.331 未満\nLinux Kernel 4.10 以上 4.14.296 未満\nLinux Kernel 4.15 以上 4.19.262 未満\nLinux Kernel 4.20 以上 5.4.218 未満\nLinux Kernel 5.5 以上 5.10.148 未満\nLinux Kernel 5.11 以上 5.15.73 未満\nLinux Kernel 5.16 以上 5.19.15 未満\nLinux Kernel 6.0 以上 6.0.1 未満"
    },
    "JVNDB-2022-008024": {
        "title": "Linux Kernel における認証の欠如に関する脆弱性",
        "description": "A vulnerability was found in the Linux kernel’s cgroup_release_agent_write in the kernel/cgroup/cgroup-v1.c function. This flaw, under certain circumstances, allows the use of the cgroups v1 release_agent feature to escalate privileges and bypass the namespace isolation unexpectedly.",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nNetApp SolidFire Enterprise SDS & HCI Storage Node\nレッドハット\ncodeready linux builder\ncodeready linux builder for power little endian\nRed Hat Virtualization Host\nRed Hat Enterprise Linux\nRed Hat Enterprise Linux EUS"
    },
    "JVNDB-2022-022611": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "Various refcounting bugs in the multi-BSS handling in the mac80211 stack in the Linux kernel 5.1 through 5.19.x before 5.19.16 could be used by local attackers (able to inject WLAN frames) to trigger use-after-free conditions to potentially execute code.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nFedora Project\nFedora 36\nFedora 37\nLinux\nLinux Kernel 5.1 以上 5.4.218 未満\nLinux Kernel 5.5 以上 5.10.148 未満\nLinux Kernel 5.11 以上 5.15.74 未満\nLinux Kernel 5.16 以上 5.19.16 未満\nLinux Kernel 6.0 以上 6.0.2 未満"
    },
    "JVNDB-2022-022614": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "A vulnerability classified as problematic was found in Linux Kernel. This vulnerability affects the function macvlan_handle_frame of the file drivers/net/macvlan.c of the component skb. The manipulation leads to memory leak. The attack can be initiated remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211024.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.35 未満\nLinux Kernel 5.16 以上 5.17.4 未満"
    },
    "JVNDB-2022-007538": {
        "title": "Linux Foundation の imgcrypt 他複数ベンダの製品における不正な認証に関する脆弱性",
        "description": "The imgcrypt library provides API exensions for containerd to support encrypted container images and implements the ctd-decoder command line tool for use by containerd to decrypt encrypted container images. The imgcrypt function `CheckAuthorization` is supposed to check whether the current used is authorized to access an encrypted image and prevent the user from running an image that another user previously decrypted on the same system. In versions prior to 1.1.4, a failure occurs when an image with a ManifestList is used and the architecture of the local host is not the first one in the ManifestList. Only the first architecture in the list was tested, which may not have its layers available locally since it could not be run on the host architecture. Therefore, the verdict on unavailable layers was that the image could be run anticipating that image run failure would occur later due to the layers not being available. However, this verdict to allow the image to run enabled other architectures in the ManifestList to run an image without providing keys if that image had previously been decrypted. A patch has been applied to imgcrypt 1.1.4. Workarounds may include usage of different namespaces for each remote user.",
        "technologies": "Fedora Project\nFedora 34\nFedora 35\nFedora 36\nLinux Foundation\nimgcrypt 1.1.4 未満"
    },
    "JVNDB-2022-007999": {
        "title": "Linux Kernel における脆弱性",
        "description": "A vulnerability was found in kvm_s390_guest_sida_op in the arch/s390/kvm/kvm-s390.c function in KVM for s390 in the Linux kernel. This flaw allows a local attacker with a normal user privilege to obtain unauthorized memory write access. This flaw affects Linux kernel versions prior to 5.17-rc4.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.17-rc4 未満\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア\nレッドハット\nRed Hat Virtualization Host\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-008736": {
        "title": "Linux Kernel の FUSE ファイルシステムにおける解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s FUSE filesystem in the way a user triggers write(). This flaw allows a local user to gain unauthorized access to data from the FUSE filesystem, resulting in privilege escalation.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function\nレッドハット\nbuild of Quarkus\nRed Hat Developer Tools\nRed Hat Enterprise Linux\nRed Hat Enterprise Linux EUS\nRed Hat Enterprise Linux for IBM z Systems"
    },
    "JVNDB-2022-009003": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "Memory leak in icmp6 implementation in Linux Kernel 5.13+ allows a remote attacker to DoS a host by making it go out-of-memory via icmp6 packets of type 130 or 131. We recommend upgrading past commit 2d3916f3189172d5c69d33065c3c21119fe539fc.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nA400 ファームウェア\nAFF 8300 ファームウェア\nAFF 8700 ファームウェア\nFAS 8300 ファームウェア\nFAS 8700 ファームウェア\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア"
    },
    "JVNDB-2022-007993": {
        "title": "Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.16.12 未満\nNetApp\nActive IQ Unified Manager\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-010069": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "The SUNRPC subsystem in the Linux kernel through 5.17.2 can call xs_xprt_free before ensuring that sockets are in the intended state.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.17.2 まで\nNetApp\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire Enterprise SDS & HCI Storage Node\nH300E ファームウェア\nH300S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nNetApp HCI Compute Node ファームウェア"
    },
    "JVNDB-2022-009119": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds (OOB) memory write flaw was found in the Linux kernel’s watch_queue event notification subsystem. This flaw can overwrite parts of the kernel state, potentially allowing a local user to gain privileged access or cause a denial of service on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H610C ファームウェア\nHCI Baseboard Management Controller (BMC) H610S ファームウェア"
    },
    "JVNDB-2022-010072": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.17.1 未満\nNetApp\nActive IQ Unified Manager\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire Enterprise SDS & HCI Storage Node\nH300S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nNetApp HCI Compute Node ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-009892": {
        "title": "Linux Kernel におけるリソースの初期化の不備に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in fs/io_uring.c lacks initialization of kiocb->private.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.17.5 まで\nNetApp\nNetApp SolidFire & HCI Management Node\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-009900": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free due to a race condition in io_uring timeouts. This can be triggered by a local user who has no access to any user namespace; however, the race condition perhaps can only be exploited infrequently.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.17.3 未満"
    },
    "JVNDB-2022-009376": {
        "title": "Linux Kernel における二重解放に関する脆弱性",
        "description": "drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.",
        "technologies": "Linux\nLinux Kernel 5.16.12 未満\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-009540": {
        "title": "Linux 用 VMware Horizon Agent におけるリンク解釈に関する脆弱性",
        "description": "VMware Horizon Agent for Linux (prior to 22.x) contains a local privilege escalation as a user is able to change the default shared folder location due to a vulnerable symbolic link. Successful exploitation can result in linking to a root owned file.",
        "technologies": "VMware\nVMware Horizon"
    },
    "JVNDB-2022-010162": {
        "title": "Linux Foundation の runc 他複数ベンダの製品における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. A bug was found in runc prior to version 1.1.2 where `runc exec --cap` created processes with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during execve(2). This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container's bounding set. This bug has been fixed in runc 1.1.2. This fix changes `runc exec --cap` behavior such that the additional capabilities granted to the process being executed (as specified via `--cap` arguments) do not include inheritable capabilities. In addition, `runc spec` is changed to not set any inheritable capabilities in the created example OCI spec (`config.json`) file.",
        "technologies": "Fedora Project\nFedora 34\nFedora 35\nFedora 36\nLinux Foundation\nrunc 1.1.2 未満"
    },
    "JVNDB-2022-010160": {
        "title": "Linux Foundation の argocd におけるスプーフィングによる認証回避に関する脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. A critical vulnerability has been discovered in Argo CD starting with version 1.4.0 and prior to versions 2.1.15, 2.2.9, and 2.3.4 which would allow unauthenticated users to impersonate as any Argo CD user or role, including the `admin` user, by sending a specifically crafted JSON Web Token (JWT) along with the request. In order for this vulnerability to be exploited, anonymous access to the Argo CD instance must have been enabled. In a default Argo CD installation, anonymous access is disabled. The vulnerability can be exploited to impersonate as any user or role, including the built-in `admin` account regardless of whether it is enabled or disabled. Also, the attacker does not need an account on the Argo CD instance in order to exploit this. If anonymous access to the instance is enabled, an attacker can escalate their privileges, effectively allowing them to gain the same privileges on the cluster as the Argo CD instance, which is cluster admin in a default installation. This will allow the attacker to create, manipulate and delete any resource on the cluster. They may also exfiltrate data by deploying malicious workloads with elevated privileges, thus bypassing any redaction of sensitive data otherwise enforced by the Argo CD API. A patch for this vulnerability has been released in Argo CD versions 2.3.4, 2.2.9, and 2.1.15. As a workaround, one may disable anonymous access, but upgrading to a patched version is preferable.",
        "technologies": "Linux Foundation\nargocd 1.4.0 以上 2.1.15 未満\nargocd 2.2.0 以上 2.2.9 未満\nargocd 2.3.0 以上 2.3.4 未満"
    },
    "JVNDB-2022-010257": {
        "title": "Linux Kernel における脆弱性",
        "description": "A vulnerability was found in the pfkey_register function in net/key/af_key.c in the Linux kernel. This flaw allows a local, unprivileged user to gain access to kernel memory, leading to a system crash or a leak of internal kernel information.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-009167": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nレッドハット\nRed Hat Virtualization\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-009341": {
        "title": "Linux Kernel における二重解放に関する脆弱性",
        "description": "ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.17.1 まで\nNetApp\nNetApp HCI Baseboard Management Controller"
    },
    "JVNDB-2021-021770": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFS: Fix use-after-free in nfs4_init_client() KASAN reports a use-after-free when attempting to mount two different exports through two different NICs that belong to the same server. Olga was able to hit this with kernels starting somewhere between 5.7 and 5.10, but I traced the patch that introduced the clear_bit() call to 4.13. So something must have changed in the refcounting of the clp pointer to make this call to nfs_put_client() the very last one.",
        "technologies": "Linux\nLinux Kernel 4.13 以上 4.14.237 未満\nLinux Kernel 4.15 以上 4.19.195 未満\nLinux Kernel 4.20 以上 5.4.126 未満\nLinux Kernel 5.5 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021776": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/sched: Avoid data corruptions Wait for all dependencies of a job to complete before killing it to avoid data corruptions.",
        "technologies": "Linux\nLinux Kernel 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021775": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86/mmu: Don't advance iterator after restart due to yielding After dropping mmu_lock in the TDP MMU, restart the iterator during tdp_iter_next() and do not advance the iterator. Advancing the iterator results in skipping the top-level SPTE and all its children, which is fatal if any of the skipped SPTEs were not visited before yielding. When zapping all SPTEs, i.e. when min_level == root_level, restarting the iter and then invoking tdp_iter_next() is always fatal if the current gfn has as a valid SPTE, as advancing the iterator results in try_step_side() skipping the current gfn, which wasn't visited before yielding. Sprinkle WARNs on iter->yielded being true in various helpers that are often used in conjunction with yielding, and tag the helper with __must_check to reduce the probabily of improper usage. Failing to zap a top-level SPTE manifests in one of two ways. If a valid SPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(), the shadow page will be leaked and KVM will WARN accordingly. WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm] RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm] Call Trace: <TASK> kvm_arch_destroy_vm+0x130/0x1b0 [kvm] kvm_destroy_vm+0x162/0x2a0 [kvm] kvm_vcpu_release+0x34/0x60 [kvm] __fput+0x82/0x240 task_work_run+0x5c/0x90 do_exit+0x364/0xa10 ? futex_unqueue+0x38/0x60 do_group_exit+0x33/0xa0 get_signal+0x155/0x850 arch_do_signal_or_restart+0xed/0x750 exit_to_user_mode_prepare+0xc5/0x120 syscall_exit_to_user_mode+0x1d/0x40 do_syscall_64+0x48/0xc0 entry_SYSCALL_64_after_hwframe+0x44/0xae If kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped by kvm_tdp_mmu_put_root(), KVM triggers a use-after-free in the form of marking a struct page as dirty/accessed after it has been put back on the free list. This directly triggers a WARN due to encountering a page with page_count() == 0, but it can also lead to data corruption and additional errors in the kernel. WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171 RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm] Call Trace: <TASK> kvm_set_pfn_dirty+0x120/0x1d0 [kvm] __handle_changed_spte+0x92e/0xca0 [kvm] __handle_changed_spte+0x63c/0xca0 [kvm] __handle_changed_spte+0x63c/0xca0 [kvm] __handle_changed_spte+0x63c/0xca0 [kvm] zap_gfn_range+0x549/0x620 [kvm] kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm] mmu_free_root_page+0x219/0x2c0 [kvm] kvm_mmu_free_roots+0x1b4/0x4e0 [kvm] kvm_mmu_unload+0x1c/0xa0 [kvm] kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm] kvm_put_kvm+0x3b1/0x8b0 [kvm] kvm_vcpu_release+0x4e/0x70 [kvm] __fput+0x1f7/0x8c0 task_work_run+0xf8/0x1a0 do_exit+0x97b/0x2230 do_group_exit+0xda/0x2a0 get_signal+0x3be/0x1e50 arch_do_signal_or_restart+0x244/0x17f0 exit_to_user_mode_prepare+0xcb/0x120 syscall_exit_to_user_mode+0x1d/0x40 do_syscall_64+0x4d/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae Note, the underlying bug existed even before commit 1af4a96025b3 (\"KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed\") moved calls to tdp_mmu_iter_cond_resched() to the beginning of loops, as KVM could still incorrectly advance past a top-level entry when yielding on a lower-level entry. But with respect to leaking shadow pages, the bug was introduced by yielding before processing the current gfn. Alternatively, tdp_mmu_iter_cond_resched() could simply fall through, or callers could jump to their \"retry\" label. The downside of that approach is that tdp_mmu_iter_cond_resched() _must_ be called before anything else in the loop, and there's no easy way to enfornce that requirement. Ideally, KVM would handling the cond_resched() fully within the iterator macro (the code is actually quite clean) and avoid this entire class of bugs, but that is extremely difficult do wh ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021777": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wl1251: Fix possible buffer overflow in wl1251_cmd_scan Function wl1251_cmd_scan calls memcpy without checking the length. Harden by checking the length is within the maximum allowed size.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021779": {
        "title": "Linux の Linux Kernel における参照カウントの更新に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommu/arm-smmu: Fix arm_smmu_device refcount leak when arm_smmu_rpm_get fails arm_smmu_rpm_get() invokes pm_runtime_get_sync(), which increases the refcount of the \"smmu\" even though the return value is less than 0. The reference counting issue happens in some error handling paths of arm_smmu_rpm_get() in its caller functions. When arm_smmu_rpm_get() fails, the caller functions forget to decrease the refcount of \"smmu\" increased by arm_smmu_rpm_get(), causing a refcount leak. Fix this issue by calling pm_runtime_resume_and_get() instead of pm_runtime_get_sync() in arm_smmu_rpm_get(), which can keep the refcount balanced in case of failure.",
        "technologies": "Linux\nLinux Kernel 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021781": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (w83791d) Fix NULL pointer dereference by removing unnecessary structure field If driver read val value sufficient for (val & 0x08) && (!(val & 0x80)) && ((val & 0x7) == ((val >> 4) & 0x7)) from device then Null pointer dereference occurs. (It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers) Also lm75[] does not serve a purpose anymore after switching to devm_i2c_new_dummy_device() in w83791d_detect_subclients(). The patch fixes possible NULL pointer dereference by removing lm75[]. Found by Linux Driver Verification project (linuxtesting.org). [groeck: Dropped unnecessary continuation lines, fixed multi-line alignment]",
        "technologies": "Linux\nLinux Kernel 5.4.151 未満\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021772": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: j1939: fix Use-after-Free, hold skb ref while in use This patch fixes a Use-after-Free found by the syzbot. The problem is that a skb is taken from the per-session skb queue, without incrementing the ref count. This leads to a Use-after-Free if the skb is taken concurrently from the session queue due to a CTS.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021782": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-rdma: destroy cm id before destroy qp to avoid use after free We should always destroy cm_id before destroy qp to avoid to get cma event after qp was destroyed, which may lead to use after free. In RDMA connection establishment error flow, don't destroy qp in cm event handler.Just report cm_error to upper level, qp will be destroy in nvme_rdma_alloc_queue() after destroy cm id.",
        "technologies": "Linux\nLinux Kernel 5.10.70 未満\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021791": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv, bpf: Fix potential NULL dereference The bpf_jit_binary_free() function requires a non-NULL argument. When the RISC-V BPF JIT fails to converge in NR_JIT_ITERATIONS steps, jit_data->header will be NULL, which triggers a NULL dereference. Avoid this by checking the argument, prior calling the function.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.77 未満\nLinux Kernel 5.11 以上 5.14.16 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021825": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86: Ensure liveliness of nested VM-Enter fail tracepoint message Use the __string() machinery provided by the tracing subystem to make a copy of the string literals consumed by the \"nested VM-Enter failed\" tracepoint. A complete copy is necessary to ensure that the tracepoint can't outlive the data/memory it consumes and deference stale memory. Because the tracepoint itself is defined by kvm, if kvm-intel and/or kvm-amd are built as modules, the memory holding the string literals defined by the vendor modules will be freed when the module is unloaded, whereas the tracepoint and its data in the ring buffer will live until kvm is unloaded (or \"indefinitely\" if kvm is built-in). This bug has existed since the tracepoint was added, but was recently exposed by a new check in tracing to detect exactly this type of bug. fmt: '%s%s ' current_buffer: ' vmx_dirty_log_t-140127 [003] .... kvm_nested_vmenter_failed: ' WARNING: CPU: 3 PID: 140134 at kernel/trace/trace.c:3759 trace_check_vprintf+0x3be/0x3e0 CPU: 3 PID: 140134 Comm: less Not tainted 5.13.0-rc1-ce2e73ce600a-req #184 Hardware name: ASUS Q87M-E/Q87M-E, BIOS 1102 03/03/2014 RIP: 0010:trace_check_vprintf+0x3be/0x3e0 Code: <0f> 0b 44 8b 4c 24 1c e9 a9 fe ff ff c6 44 02 ff 00 49 8b 97 b0 20 RSP: 0018:ffffa895cc37bcb0 EFLAGS: 00010282 RAX: 0000000000000000 RBX: ffffa895cc37bd08 RCX: 0000000000000027 RDX: 0000000000000027 RSI: 00000000ffffdfff RDI: ffff9766cfad74f8 RBP: ffffffffc0a041d4 R08: ffff9766cfad74f0 R09: ffffa895cc37bad8 R10: 0000000000000001 R11: 0000000000000001 R12: ffffffffc0a041d4 R13: ffffffffc0f4dba8 R14: 0000000000000000 R15: ffff976409f2c000 FS: 00007f92fa200740(0000) GS:ffff9766cfac0000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000559bd11b0000 CR3: 000000019fbaa002 CR4: 00000000001726e0 Call Trace: trace_event_printf+0x5e/0x80 trace_raw_output_kvm_nested_vmenter_failed+0x3a/0x60 [kvm] print_trace_line+0x1dd/0x4e0 s_show+0x45/0x150 seq_read_iter+0x2d5/0x4c0 seq_read+0x106/0x150 vfs_read+0x98/0x180 ksys_read+0x5f/0xe0 do_syscall_64+0x40/0xb0 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.126 未満\nLinux Kernel 5.5 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021823": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: vxcan: vxcan_xmit: fix use after free bug After calling netif_rx_ni(skb), dereferencing skb is unsafe. Especially, the canfd_frame cfd which aliases skb memory is accessed after the netif_rx_ni().",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.218 未満\nLinux Kernel 4.15 以上 4.19.171 未満\nLinux Kernel 4.20 以上 5.4.93 未満\nLinux Kernel 5.5 以上 5.10.11 未満\nLinux Kernel 5.11"
    },
    "JVNDB-2021-021796": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ethernet: hisilicon: hns: hns_dsaf_misc: fix a possible array overflow in hns_dsaf_ge_srst_by_port() The if statement: if (port >= DSAF_GE_NUM) return; limits the value of port less than DSAF_GE_NUM (i.e., 8). However, if the value of port is 6 or 7, an array overflow could occur: port_rst_off = dsaf_dev->mac_cb[port]->port_rst_off; because the length of dsaf_dev->mac_cb is DSAF_MAX_PORT_NUM (i.e., 6). To fix this possible array overflow, we first check port and if it is greater than or equal to DSAF_MAX_PORT_NUM, the function returns.",
        "technologies": "Linux\nLinux Kernel 4.9.292 未満\nLinux Kernel 4.10 以上 4.14.257 未満\nLinux Kernel 4.15 以上 4.19.220 未満\nLinux Kernel 4.20 以上 5.4.164 未満\nLinux Kernel 5.5 以上 5.10.84 未満\nLinux Kernel 5.11 以上 5.15.7 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021822": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: fix vlan tunnel dst refcnt when egressing The egress tunnel code uses dst_clone() and directly sets the result which is wrong because the entry might have 0 refcnt or be already deleted, causing number of problems. It also triggers the WARN_ON() in dst_hold()[1] when a refcnt couldn't be taken. Fix it by using dst_hold_safe() and checking if a reference was actually taken before setting the dst. [1] dmesg WARN_ON log and following refcnt errors WARNING: CPU: 5 PID: 38 at include/net/dst.h:230 br_handle_egress_vlan_tunnel+0x10b/0x134 [bridge] Modules linked in: 8021q garp mrp bridge stp llc bonding ipv6 virtio_net CPU: 5 PID: 38 Comm: ksoftirqd/5 Kdump: loaded Tainted: G W 5.13.0-rc3+ #360 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 04/01/2014 RIP: 0010:br_handle_egress_vlan_tunnel+0x10b/0x134 [bridge] Code: e8 85 bc 01 e1 45 84 f6 74 90 45 31 f6 85 db 48 c7 c7 a0 02 19 a0 41 0f 94 c6 31 c9 31 d2 44 89 f6 e8 64 bc 01 e1 85 db 75 02 <0f> 0b 31 c9 31 d2 44 89 f6 48 c7 c7 70 02 19 a0 e8 4b bc 01 e1 49 RSP: 0018:ffff8881003d39e8 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffffa01902a0 RBP: ffff8881040c6700 R08: 0000000000000000 R09: 0000000000000001 R10: 2ce93d0054fe0d00 R11: 54fe0d00000e0000 R12: ffff888109515000 R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000401 FS: 0000000000000000(0000) GS:ffff88822bf40000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f42ba70f030 CR3: 0000000109926000 CR4: 00000000000006e0 Call Trace: br_handle_vlan+0xbc/0xca [bridge] __br_forward+0x23/0x164 [bridge] deliver_clone+0x41/0x48 [bridge] br_handle_frame_finish+0x36f/0x3aa [bridge] ? skb_dst+0x2e/0x38 [bridge] ? br_handle_ingress_vlan_tunnel+0x3e/0x1c8 [bridge] ? br_handle_frame_finish+0x3aa/0x3aa [bridge] br_handle_frame+0x2c3/0x377 [bridge] ? __skb_pull+0x33/0x51 ? vlan_do_receive+0x4f/0x36a ? br_handle_frame_finish+0x3aa/0x3aa [bridge] __netif_receive_skb_core+0x539/0x7c6 ? __list_del_entry_valid+0x16e/0x1c2 __netif_receive_skb_list_core+0x6d/0xd6 netif_receive_skb_list_internal+0x1d9/0x1fa gro_normal_list+0x22/0x3e dev_gro_receive+0x55b/0x600 ? detach_buf_split+0x58/0x140 napi_gro_receive+0x94/0x12e virtnet_poll+0x15d/0x315 [virtio_net] __napi_poll+0x2c/0x1c9 net_rx_action+0xe6/0x1fb __do_softirq+0x115/0x2d8 run_ksoftirqd+0x18/0x20 smpboot_thread_fn+0x183/0x19c ? smpboot_unregister_percpu_thread+0x66/0x66 kthread+0x10a/0x10f ? kthread_mod_delayed_work+0xb6/0xb6 ret_from_fork+0x22/0x30 ---[ end trace 49f61b07f775fd2b ]--- dst_release: dst:00000000c02d677a refcnt:-1 dst_release underflow",
        "technologies": "Linux\nLinux Kernel 4.11 以上 4.14.238 未満\nLinux Kernel 4.15 以上 4.19.196 未満\nLinux Kernel 4.20 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021810": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: peak_usb: fix use after free bugs After calling peak_usb_netif_rx_ni(skb), dereferencing skb is unsafe. Especially, the can_frame cf which aliases skb memory is accessed after the peak_usb_netif_rx_ni(). Reordering the lines solves the issue.",
        "technologies": "Linux\nLinux Kernel 4.0 以上 4.19.171 未満\nLinux Kernel 4.20 以上 5.4.93 未満\nLinux Kernel 5.5 以上 5.10.11 未満\nLinux Kernel 5.11"
    },
    "JVNDB-2021-021816": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing: Correct the length check which causes memory corruption We've suffered from severe kernel crashes due to memory corruption on our production environment, like, Call Trace: [1640542.554277] general protection fault: 0000 [#1] SMP PTI [1640542.554856] CPU: 17 PID: 26996 Comm: python Kdump: loaded Tainted:G [1640542.556629] RIP: 0010:kmem_cache_alloc+0x90/0x190 [1640542.559074] RSP: 0018:ffffb16faa597df8 EFLAGS: 00010286 [1640542.559587] RAX: 0000000000000000 RBX: 0000000000400200 RCX: 0000000006e931bf [1640542.560323] RDX: 0000000006e931be RSI: 0000000000400200 RDI: ffff9a45ff004300 [1640542.560996] RBP: 0000000000400200 R08: 0000000000023420 R09: 0000000000000000 [1640542.561670] R10: 0000000000000000 R11: 0000000000000000 R12: ffffffff9a20608d [1640542.562366] R13: ffff9a45ff004300 R14: ffff9a45ff004300 R15: 696c662f65636976 [1640542.563128] FS: 00007f45d7c6f740(0000) GS:ffff9a45ff840000(0000) knlGS:0000000000000000 [1640542.563937] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [1640542.564557] CR2: 00007f45d71311a0 CR3: 000000189d63e004 CR4: 00000000003606e0 [1640542.565279] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [1640542.566069] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [1640542.566742] Call Trace: [1640542.567009] anon_vma_clone+0x5d/0x170 [1640542.567417] __split_vma+0x91/0x1a0 [1640542.567777] do_munmap+0x2c6/0x320 [1640542.568128] vm_munmap+0x54/0x70 [1640542.569990] __x64_sys_munmap+0x22/0x30 [1640542.572005] do_syscall_64+0x5b/0x1b0 [1640542.573724] entry_SYSCALL_64_after_hwframe+0x44/0xa9 [1640542.575642] RIP: 0033:0x7f45d6e61e27 James Wang has reproduced it stably on the latest 4.19 LTS. After some debugging, we finally proved that it's due to ftrace buffer out-of-bound access using a debug tool as follows: [ 86.775200] BUG: Out-of-bounds write at addr 0xffff88aefe8b7000 [ 86.780806] no_context+0xdf/0x3c0 [ 86.784327] __do_page_fault+0x252/0x470 [ 86.788367] do_page_fault+0x32/0x140 [ 86.792145] page_fault+0x1e/0x30 [ 86.795576] strncpy_from_unsafe+0x66/0xb0 [ 86.799789] fetch_memory_string+0x25/0x40 [ 86.804002] fetch_deref_string+0x51/0x60 [ 86.808134] kprobe_trace_func+0x32d/0x3a0 [ 86.812347] kprobe_dispatcher+0x45/0x50 [ 86.816385] kprobe_ftrace_handler+0x90/0xf0 [ 86.820779] ftrace_ops_assist_func+0xa1/0x140 [ 86.825340] 0xffffffffc00750bf [ 86.828603] do_sys_open+0x5/0x1f0 [ 86.832124] do_syscall_64+0x5b/0x1b0 [ 86.835900] entry_SYSCALL_64_after_hwframe+0x44/0xa9 commit b220c049d519 (\"tracing: Check length before giving out the filter buffer\") adds length check to protect trace data overflow introduced in 0fc1b09ff1ff, seems that this fix can't prevent overflow entirely, the length check should also take the sizeof entry->array[0] into account, since this array[0] is filled the length of trace data and occupy addtional space and risk overflow.",
        "technologies": "Linux\nLinux Kernel 4.9.258 以上 4.9.273 未満\nLinux Kernel 4.14.222 以上 4.14.237 未満\nLinux Kernel 4.19.177 以上 4.19.195 未満\nLinux Kernel 5.4.99 以上 5.4.126 未満\nLinux Kernel 5.10.17 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021801": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: enetc: Fix illegal access when reading affinity_hint irq_set_affinity_hit() stores a reference to the cpumask_t parameter in the irq descriptor, and that reference can be accessed later from irq_affinity_hint_proc_show(). Since the cpu_mask parameter passed to irq_set_affinity_hit() has only temporary storage (it's on the stack memory), later accesses to it are illegal. Thus reads from the corresponding procfs affinity_hint file can result in paging request oops. The issue is fixed by the get_cpu_mask() helper, which provides a permanent storage for the cpumask_t parameter.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.150 未満\nLinux Kernel 5.5 以上 5.10.70 未満\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021805": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: thermal: Fix out-of-bounds memory accesses Currently, mlxsw allows cooling states to be set above the maximum cooling state supported by the driver: # cat /sys/class/thermal/thermal_zone2/cdev0/type mlxsw_fan # cat /sys/class/thermal/thermal_zone2/cdev0/max_state 10 # echo 18 > /sys/class/thermal/thermal_zone2/cdev0/cur_state # echo $? 0 This results in out-of-bounds memory accesses when thermal state transition statistics are enabled (CONFIG_THERMAL_STATISTICS=y), as the transition table is accessed with a too large index (state) [1]. According to the thermal maintainer, it is the responsibility of the driver to reject such operations [2]. Therefore, return an error when the state to be set exceeds the maximum cooling state supported by the driver. To avoid dead code, as suggested by the thermal maintainer [3], partially revert commit a421ce088ac8 (\"mlxsw: core: Extend cooling device with cooling levels\") that tried to interpret these invalid cooling states (above the maximum) in a special way. The cooling levels array is not removed in order to prevent the fans going below 20% PWM, which would cause them to get stuck at 0% PWM. [1] BUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x271/0x290 Read of size 4 at addr ffff8881052f7bf8 by task kworker/0:0/5 CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.15.0-rc3-custom-45935-gce1adf704b14 #122 Hardware name: Mellanox Technologies Ltd. \"MSN2410-CB2FO\"/\"SA000874\", BIOS 4.6.5 03/08/2016 Workqueue: events_freezable_power_ thermal_zone_device_check Call Trace: dump_stack_lvl+0x8b/0xb3 print_address_description.constprop.0+0x1f/0x140 kasan_report.cold+0x7f/0x11b thermal_cooling_device_stats_update+0x271/0x290 __thermal_cdev_update+0x15e/0x4e0 thermal_cdev_update+0x9f/0xe0 step_wise_throttle+0x770/0xee0 thermal_zone_device_update+0x3f6/0xdf0 process_one_work+0xa42/0x1770 worker_thread+0x62f/0x13e0 kthread+0x3ee/0x4e0 ret_from_fork+0x1f/0x30 Allocated by task 1: kasan_save_stack+0x1b/0x40 __kasan_kmalloc+0x7c/0x90 thermal_cooling_device_setup_sysfs+0x153/0x2c0 __thermal_cooling_device_register.part.0+0x25b/0x9c0 thermal_cooling_device_register+0xb3/0x100 mlxsw_thermal_init+0x5c5/0x7e0 __mlxsw_core_bus_device_register+0xcb3/0x19c0 mlxsw_core_bus_device_register+0x56/0xb0 mlxsw_pci_probe+0x54f/0x710 local_pci_probe+0xc6/0x170 pci_device_probe+0x2b2/0x4d0 really_probe+0x293/0xd10 __driver_probe_device+0x2af/0x440 driver_probe_device+0x51/0x1e0 __driver_attach+0x21b/0x530 bus_for_each_dev+0x14c/0x1d0 bus_add_driver+0x3ac/0x650 driver_register+0x241/0x3d0 mlxsw_sp_module_init+0xa2/0x174 do_one_initcall+0xee/0x5f0 kernel_init_freeable+0x45a/0x4de kernel_init+0x1f/0x210 ret_from_fork+0x1f/0x30 The buggy address belongs to the object at ffff8881052f7800 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 1016 bytes inside of 1024-byte region [ffff8881052f7800, ffff8881052f7c00) The buggy address belongs to the page: page:0000000052355272 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1052f0 head:0000000052355272 order:3 compound_mapcount:0 compound_pincount:0 flags: 0x200000000010200(slab|head|node=0|zone=2) raw: 0200000000010200 ffffea0005034800 0000000300000003 ffff888100041dc0 raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff8881052f7a80: 00 00 00 00 00 00 04 fc fc fc fc fc fc fc fc fc ffff8881052f7b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc >ffff8881052f7b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ^ ffff8881052f7c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffff8881052f7c80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [2] https://lore.kernel.org/linux-pm/9aca37cb-1629-5c67- ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.10 以上 5.4.155 未満\nLinux Kernel 5.5 以上 5.10.75 未満\nLinux Kernel 5.11 以上 5.14.14 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021808": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: dev: can_restart: fix use after free bug After calling netif_rx_ni(skb), dereferencing skb is unsafe. Especially, the can_frame cf which aliases skb memory is accessed after the netif_rx_ni() in: stats->rx_bytes += cf->len; Reordering the lines solves the issue.",
        "technologies": "Linux\nLinux Kernel 2.6.31 以上 4.4.254 未満\nLinux Kernel 4.5 以上 4.9.254 未満\nLinux Kernel 4.10 以上 4.14.218 未満\nLinux Kernel 4.15 以上 4.19.171 未満\nLinux Kernel 4.20 以上 5.4.93 未満\nLinux Kernel 5.5 以上 5.10.11 未満\nLinux Kernel 5.11"
    },
    "JVNDB-2021-021799": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: watchdog: sc520_wdt: Fix possible use-after-free in wdt_turnoff() This module's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021446": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: cancel vdm and state machine hrtimer when unregister tcpm port A pending hrtimer may expire after the kthread_worker of tcpm port is destroyed, see below kernel dump when do module unload, fix it by cancel the 2 hrtimers. [ 111.517018] Unable to handle kernel paging request at virtual address ffff8000118cb880 [ 111.518786] blk_update_request: I/O error, dev sda, sector 60061185 op 0x0:(READ) flags 0x0 phys_seg 1 prio class 0 [ 111.526594] Mem abort info: [ 111.526597] ESR = 0x96000047 [ 111.526600] EC = 0x25: DABT (current EL), IL = 32 bits [ 111.526604] SET = 0, FnV = 0 [ 111.526607] EA = 0, S1PTW = 0 [ 111.526610] Data abort info: [ 111.526612] ISV = 0, ISS = 0x00000047 [ 111.526615] CM = 0, WnR = 1 [ 111.526619] swapper pgtable: 4k pages, 48-bit VAs, pgdp=0000000041d75000 [ 111.526623] [ffff8000118cb880] pgd=10000001bffff003, p4d=10000001bffff003, pud=10000001bfffe003, pmd=10000001bfffa003, pte=0000000000000000 [ 111.526642] Internal error: Oops: 96000047 [#1] PREEMPT SMP [ 111.526647] Modules linked in: dwc3_imx8mp dwc3 phy_fsl_imx8mq_usb [last unloaded: tcpci] [ 111.526663] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.13.0-rc4-00927-gebbe9dbd802c-dirty #36 [ 111.526670] Hardware name: NXP i.MX8MPlus EVK board (DT) [ 111.526674] pstate: 800000c5 (Nzcv daIF -PAN -UAO -TCO BTYPE=--) [ 111.526681] pc : queued_spin_lock_slowpath+0x1a0/0x390 [ 111.526695] lr : _raw_spin_lock_irqsave+0x88/0xb4 [ 111.526703] sp : ffff800010003e20 [ 111.526706] x29: ffff800010003e20 x28: ffff00017f380180 [ 111.537156] buffer_io_error: 6 callbacks suppressed [ 111.537162] Buffer I/O error on dev sda1, logical block 60040704, async page read [ 111.539932] x27: ffff00017f3801c0 [ 111.539938] x26: ffff800010ba2490 x25: 0000000000000000 x24: 0000000000000001 [ 111.543025] blk_update_request: I/O error, dev sda, sector 60061186 op 0x0:(READ) flags 0x0 phys_seg 7 prio class 0 [ 111.548304] [ 111.548306] x23: 00000000000000c0 x22: ffff0000c2a9f184 x21: ffff00017f380180 [ 111.551374] Buffer I/O error on dev sda1, logical block 60040705, async page read [ 111.554499] [ 111.554503] x20: ffff0000c5f14210 x19: 00000000000000c0 x18: 0000000000000000 [ 111.557391] Buffer I/O error on dev sda1, logical block 60040706, async page read [ 111.561218] [ 111.561222] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 [ 111.564205] Buffer I/O error on dev sda1, logical block 60040707, async page read [ 111.570887] x14: 00000000000000f5 x13: 0000000000000001 x12: 0000000000000040 [ 111.570902] x11: ffff0000c05ac6d8 [ 111.583420] Buffer I/O error on dev sda1, logical block 60040708, async page read [ 111.588978] x10: 0000000000000000 x9 : 0000000000040000 [ 111.588988] x8 : 0000000000000000 [ 111.597173] Buffer I/O error on dev sda1, logical block 60040709, async page read [ 111.605766] x7 : ffff00017f384880 x6 : ffff8000118cb880 [ 111.605777] x5 : ffff00017f384880 [ 111.611094] Buffer I/O error on dev sda1, logical block 60040710, async page read [ 111.617086] x4 : 0000000000000000 x3 : ffff0000c2a9f184 [ 111.617096] x2 : ffff8000118cb880 [ 111.622242] Buffer I/O error on dev sda1, logical block 60040711, async page read [ 111.626927] x1 : ffff8000118cb880 x0 : ffff00017f384888 [ 111.626938] Call trace: [ 111.626942] queued_spin_lock_slowpath+0x1a0/0x390 [ 111.795809] kthread_queue_work+0x30/0xc0 [ 111.799828] state_machine_timer_handler+0x20/0x30 [ 111.804624] __hrtimer_run_queues+0x140/0x1e0 [ 111.808990] hrtimer_interrupt+0xec/0x2c0 [ 111.813004] arch_timer_handler_phys+0x38/0x50 [ 111.817456] handle_percpu_devid_irq+0x88/0x150 [ 111.821991] __handle_domain_irq+0x80/0xe0 [ 111.826093] gic_handle_irq+0xc0/0x140 [ 111.829848] el1_irq+0xbc/0x154 [ 111.832991] arch_cpu_idle+0x1c/0x2c [ 111.836572] default_idle_call+0x24/0x6c [ 111.840497] do_idle+0x238/0x2ac [ 1 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021452": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: igc: Fix use-after-free error during reset Cleans the next descriptor to watch (next_to_watch) when cleaning the TX ring. Failure to do so can cause invalid memory accesses. If igc_poll() runs while the controller is being reset this can lead to the driver try to free a skb that was already freed. Log message: [ 101.525242] refcount_t: underflow; use-after-free. [ 101.525251] WARNING: CPU: 1 PID: 646 at lib/refcount.c:28 refcount_warn_saturate+0xab/0xf0 [ 101.525259] Modules linked in: sch_etf(E) sch_mqprio(E) rfkill(E) intel_rapl_msr(E) intel_rapl_common(E) x86_pkg_temp_thermal(E) intel_powerclamp(E) coretemp(E) binfmt_misc(E) kvm_intel(E) kvm(E) irqbypass(E) crc32_pclmul(E) ghash_clmulni_intel(E) aesni_intel(E) mei_wdt(E) libaes(E) crypto_simd(E) cryptd(E) glue_helper(E) snd_hda_codec_hdmi(E) rapl(E) intel_cstate(E) snd_hda_intel(E) snd_intel_dspcfg(E) sg(E) soundwire_intel(E) intel_uncore(E) at24(E) soundwire_generic_allocation(E) iTCO_wdt(E) soundwire_cadence(E) intel_pmc_bxt(E) serio_raw(E) snd_hda_codec(E) iTCO_vendor_support(E) watchdog(E) snd_hda_core(E) snd_hwdep(E) snd_soc_core(E) snd_compress(E) snd_pcsp(E) soundwire_bus(E) snd_pcm(E) evdev(E) snd_timer(E) mei_me(E) snd(E) soundcore(E) mei(E) configfs(E) ip_tables(E) x_tables(E) autofs4(E) ext4(E) crc32c_generic(E) crc16(E) mbcache(E) jbd2(E) sd_mod(E) t10_pi(E) crc_t10dif(E) crct10dif_generic(E) i915(E) ahci(E) libahci(E) ehci_pci(E) igb(E) xhci_pci(E) ehci_hcd(E) [ 101.525303] drm_kms_helper(E) dca(E) xhci_hcd(E) libata(E) crct10dif_pclmul(E) cec(E) crct10dif_common(E) tsn(E) igc(E) e1000e(E) ptp(E) i2c_i801(E) crc32c_intel(E) psmouse(E) i2c_algo_bit(E) i2c_smbus(E) scsi_mod(E) lpc_ich(E) pps_core(E) usbcore(E) drm(E) button(E) video(E) [ 101.525318] CPU: 1 PID: 646 Comm: irq/37-enp7s0-T Tainted: G E 5.10.30-rt37-tsn1-rt-ipipe #ipipe [ 101.525320] Hardware name: SIEMENS AG SIMATIC IPC427D/A5E31233588, BIOS V17.02.09 03/31/2017 [ 101.525322] RIP: 0010:refcount_warn_saturate+0xab/0xf0 [ 101.525325] Code: 05 31 48 44 01 01 e8 f0 c6 42 00 0f 0b c3 80 3d 1f 48 44 01 00 75 90 48 c7 c7 78 a8 f3 a6 c6 05 0f 48 44 01 01 e8 d1 c6 42 00 <0f> 0b c3 80 3d fe 47 44 01 00 0f 85 6d ff ff ff 48 c7 c7 d0 a8 f3 [ 101.525327] RSP: 0018:ffffbdedc0917cb8 EFLAGS: 00010286 [ 101.525329] RAX: 0000000000000000 RBX: ffff98fd6becbf40 RCX: 0000000000000001 [ 101.525330] RDX: 0000000000000001 RSI: ffffffffa6f2700c RDI: 00000000ffffffff [ 101.525332] RBP: ffff98fd6becc14c R08: ffffffffa7463d00 R09: ffffbdedc0917c50 [ 101.525333] R10: ffffffffa74c3578 R11: 0000000000000034 R12: 00000000ffffff00 [ 101.525335] R13: ffff98fd6b0b1000 R14: 0000000000000039 R15: ffff98fd6be35c40 [ 101.525337] FS: 0000000000000000(0000) GS:ffff98fd6e240000(0000) knlGS:0000000000000000 [ 101.525339] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 101.525341] CR2: 00007f34135a3a70 CR3: 0000000150210003 CR4: 00000000001706e0 [ 101.525343] Call Trace: [ 101.525346] sock_wfree+0x9c/0xa0 [ 101.525353] unix_destruct_scm+0x7b/0xa0 [ 101.525358] skb_release_head_state+0x40/0x90 [ 101.525362] skb_release_all+0xe/0x30 [ 101.525364] napi_consume_skb+0x57/0x160 [ 101.525367] igc_poll+0xb7/0xc80 [igc] [ 101.525376] ? sched_clock+0x5/0x10 [ 101.525381] ? sched_clock_cpu+0xe/0x100 [ 101.525385] net_rx_action+0x14c/0x410 [ 101.525388] __do_softirq+0xe9/0x2f4 [ 101.525391] __local_bh_enable_ip+0xe3/0x110 [ 101.525395] ? irq_finalize_oneshot.part.47+0xe0/0xe0 [ 101.525398] irq_forced_thread_fn+0x6a/0x80 [ 101.525401] irq_thread+0xe8/0x180 [ 101.525403] ? wake_threads_waitq+0x30/0x30 [ 101.525406] ? irq_thread_check_affinity+0xd0/0xd0 [ 101.525408] kthread+0x183/0x1a0 [ 101.525412] ? kthread_park+0x80/0x80 [ 101.525415] ret_from_fork+0x22/0x30",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.136 未満\nLinux Kernel 5.5 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021449": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: qcom/emac: fix UAF in emac_remove adpt is netdev private data and it cannot be used after free_netdev() call. Using adpt after free_netdev() can cause UAF bug. Fix it by moving free_netdev() at the end of the function.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.9.277 未満\nLinux Kernel 4.10 以上 4.14.241 未満\nLinux Kernel 4.15 以上 4.19.199 未満\nLinux Kernel 4.20 以上 5.4.135 未満\nLinux Kernel 5.5 以上 5.10.53 未満\nLinux Kernel 5.11 以上 5.13.5 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021453": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: watchdog: Fix possible use-after-free by calling del_timer_sync() This driver's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.9 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021455": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: validate lwtstate->data before returning from skb_tunnel_info() skb_tunnel_info() returns pointer of lwtstate->data as ip_tunnel_info type without validation. lwtstate->data can have various types such as mpls_iptunnel_encap, etc and these are not compatible. So skb_tunnel_info() should validate before returning that pointer. Splat looks like: BUG: KASAN: slab-out-of-bounds in vxlan_get_route+0x418/0x4b0 [vxlan] Read of size 2 at addr ffff888106ec2698 by task ping/811 CPU: 1 PID: 811 Comm: ping Not tainted 5.13.0+ #1195 Call Trace: dump_stack_lvl+0x56/0x7b print_address_description.constprop.8.cold.13+0x13/0x2ee ? vxlan_get_route+0x418/0x4b0 [vxlan] ? vxlan_get_route+0x418/0x4b0 [vxlan] kasan_report.cold.14+0x83/0xdf ? vxlan_get_route+0x418/0x4b0 [vxlan] vxlan_get_route+0x418/0x4b0 [vxlan] [ ... ] vxlan_xmit_one+0x148b/0x32b0 [vxlan] [ ... ] vxlan_xmit+0x25c5/0x4780 [vxlan] [ ... ] dev_hard_start_xmit+0x1ae/0x6e0 __dev_queue_xmit+0x1f39/0x31a0 [ ... ] neigh_xmit+0x2f9/0x940 mpls_xmit+0x911/0x1600 [mpls_iptunnel] lwtunnel_xmit+0x18f/0x450 ip_finish_output2+0x867/0x2040 [ ... ]",
        "technologies": "Linux\nLinux Kernel 4.3 以上 4.4.277 未満\nLinux Kernel 4.5 以上 4.9.277 未満\nLinux Kernel 4.10 以上 4.14.241 未満\nLinux Kernel 4.15 以上 4.19.199 未満\nLinux Kernel 4.20 以上 5.4.135 未満\nLinux Kernel 5.5 以上 5.10.53 未満\nLinux Kernel 5.11 以上 5.13.5 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021459": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: atm: iphase: fix possible use-after-free in ia_module_exit() This module's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021461": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mcb: fix error handling in mcb_alloc_bus() There are two bugs: 1) If ida_simple_get() fails then this code calls put_device(carrier) but we haven't yet called get_device(carrier) and probably that leads to a use after free. 2) After device_initialize() then we need to use put_device() to release the bus. This will free the internal resources tied to the device and call mcb_free_bus() which will free the rest.",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.9.285 未満\nLinux Kernel 4.10 以上 4.14.249 未満\nLinux Kernel 4.15 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.150 未満\nLinux Kernel 5.5 以上 5.10.70 未満\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021456": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix possible UAF when remounting r/o a mmp-protected file system After commit 618f003199c6 (\"ext4: fix memory leak in ext4_fill_super\"), after the file system is remounted read-only, there is a race where the kmmpd thread can exit, causing sbi->s_mmp_tsk to point at freed memory, which the call to ext4_stop_mmpd() can trip over. Fix this by only allowing kmmpd() to exit when it is stopped via ext4_stop_mmpd(). Bug-Report-Link: <20210629143603.2166962-1-yebin10@huawei.com>",
        "technologies": "Linux\nLinux Kernel 5.10.77 未満\nLinux Kernel 5.11 以上 5.13.3 未満"
    },
    "JVNDB-2021-021476": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sch_cake: Fix out of bounds when parsing TCP options and header The TCP option parser in cake qdisc (cake_get_tcpopt and cake_tcph_may_drop) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1. This fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\"). v2 changes: Added doff validation in cake_get_tcphdr to avoid parsing garbage as TCP header. Although it wasn't strictly an out-of-bounds access (memory was allocated), garbage values could be read where CAKE expected the TCP header if doff was smaller than 5.",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.196 未満\nLinux Kernel 4.20 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021462": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: igb: Fix use-after-free error during reset Cleans the next descriptor to watch (next_to_watch) when cleaning the TX ring. Failure to do so can cause invalid memory accesses. If igb_poll() runs while the controller is reset this can lead to the driver try to free a skb that was already freed. (The crash is harder to reproduce with the igb driver, but the same potential problem exists as the code is identical to igc)",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.241 未満\nLinux Kernel 4.15 以上 4.19.199 未満\nLinux Kernel 4.20 以上 5.4.136 未満\nLinux Kernel 5.5 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021470": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: iscsi: Fix conn use after free during resets If we haven't done a unbind target call we can race where iscsi_conn_teardown wakes up the EH thread and then frees the conn while those threads are still accessing the conn ehwait. We can only do one TMF per session so this just moves the TMF fields from the conn to the session. We can then rely on the iscsi_session_teardown->iscsi_remove_session->__iscsi_unbind_session call to remove the target and it's devices, and know after that point there is no device or scsi-ml callout trying to access the session.",
        "technologies": "Linux\nLinux Kernel 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021475": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix use-after-free of encap entry in neigh update handler Function mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl lock removal from TC filter update path and properly handle concurrent encap entry insertion/deletion which can lead to following use-after-free: [23827.464923] ================================================================== [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72/0x140 [mlx5_core] [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker/u20:6/21635 [23827.472251] [23827.472615] CPU: 9 PID: 21635 Comm: kworker/u20:6 Not tainted 5.13.0-rc3+ #5 [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core] [23827.476731] Call Trace: [23827.477260] dump_stack+0xbb/0x107 [23827.477906] print_address_description.constprop.0+0x18/0x140 [23827.478896] ? mlx5e_encap_take+0x72/0x140 [mlx5_core] [23827.479879] ? mlx5e_encap_take+0x72/0x140 [mlx5_core] [23827.480905] kasan_report.cold+0x7c/0xd8 [23827.481701] ? mlx5e_encap_take+0x72/0x140 [mlx5_core] [23827.482744] kasan_check_range+0x145/0x1a0 [23827.493112] mlx5e_encap_take+0x72/0x140 [mlx5_core] [23827.494054] ? mlx5e_tc_tun_encap_info_equal_generic+0x140/0x140 [mlx5_core] [23827.495296] mlx5e_rep_neigh_update+0x41e/0x5e0 [mlx5_core] [23827.496338] ? mlx5e_rep_neigh_entry_release+0xb80/0xb80 [mlx5_core] [23827.497486] ? read_word_at_a_time+0xe/0x20 [23827.498250] ? strscpy+0xa0/0x2a0 [23827.498889] process_one_work+0x8ac/0x14e0 [23827.499638] ? lockdep_hardirqs_on_prepare+0x400/0x400 [23827.500537] ? pwq_dec_nr_in_flight+0x2c0/0x2c0 [23827.501359] ? rwlock_bug.part.0+0x90/0x90 [23827.502116] worker_thread+0x53b/0x1220 [23827.502831] ? process_one_work+0x14e0/0x14e0 [23827.503627] kthread+0x328/0x3f0 [23827.504254] ? _raw_spin_unlock_irq+0x24/0x40 [23827.505065] ? __kthread_bind_mask+0x90/0x90 [23827.505912] ret_from_fork+0x1f/0x30 [23827.506621] [23827.506987] Allocated by task 28248: [23827.507694] kasan_save_stack+0x1b/0x40 [23827.508476] __kasan_kmalloc+0x7c/0x90 [23827.509197] mlx5e_attach_encap+0xde1/0x1d40 [mlx5_core] [23827.510194] mlx5e_tc_add_fdb_flow+0x397/0xc40 [mlx5_core] [23827.511218] __mlx5e_add_fdb_flow+0x519/0xb30 [mlx5_core] [23827.512234] mlx5e_configure_flower+0x191c/0x4870 [mlx5_core] [23827.513298] tc_setup_cb_add+0x1d5/0x420 [23827.514023] fl_hw_replace_filter+0x382/0x6a0 [cls_flower] [23827.514975] fl_change+0x2ceb/0x4a51 [cls_flower] [23827.515821] tc_new_tfilter+0x89a/0x2070 [23827.516548] rtnetlink_rcv_msg+0x644/0x8c0 [23827.517300] netlink_rcv_skb+0x11d/0x340 [23827.518021] netlink_unicast+0x42b/0x700 [23827.518742] netlink_sendmsg+0x743/0xc20 [23827.519467] sock_sendmsg+0xb2/0xe0 [23827.520131] ____sys_sendmsg+0x590/0x770 [23827.520851] ___sys_sendmsg+0xd8/0x160 [23827.521552] __sys_sendmsg+0xb7/0x140 [23827.522238] do_syscall_64+0x3a/0x70 [23827.522907] entry_SYSCALL_64_after_hwframe+0x44/0xae [23827.523797] [23827.524163] Freed by task 25948: [23827.524780] kasan_save_stack+0x1b/0x40 [23827.525488] kasan_set_track+0x1c/0x30 [23827.526187] kasan_set_free_info+0x20/0x30 [23827.526968] __kasan_slab_free+0xed/0x130 [23827.527709] slab_free_freelist_hook+0xcf/0x1d0 [23827.528528] kmem_cache_free_bulk+0x33a/0x6e0 [23827.529317] kfree_rcu_work+0x55f/0xb70 [23827.530024] process_one_work+0x8ac/0x14e0 [23827.530770] worker_thread+0x53b/0x1220 [23827.531480] kthread+0x328/0x3f0 [23827.532114] ret_from_fork+0x1f/0x30 [23827.532785] [23827.533147] Last potentially related work creation: [23827.534007] kasan_save_stack+0x1b/0x40 [23827.534710] kasan_record_aux_stack+0xab/0xc0 [23827.535492] kvfree_call_rcu+0x31/0x7b0 [23827.536206] mlx5e_tc_del ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021471": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ti: fix UAF in tlan_remove_one priv is netdev private data and it cannot be used after free_netdev() call. Using priv after free_netdev() can cause UAF bug. Fix it by moving free_netdev() at the end of the function.",
        "technologies": "Linux\nLinux Kernel 3.10 以上 4.4.277 未満\nLinux Kernel 4.5 以上 4.9.277 未満\nLinux Kernel 4.10 以上 4.14.241 未満\nLinux Kernel 4.15 以上 4.19.199 未満\nLinux Kernel 4.20 以上 5.4.135 未満\nLinux Kernel 5.5 以上 5.10.53 未満\nLinux Kernel 5.11 以上 5.13.5 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021468": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: macb: fix use after free on rmmod plat_dev->dev->platform_data is released by platform_device_unregister(), use of pclk and hclk is a use-after-free. Since device unregister won't need a clk device we adjust the function call sequence to fix this issue. [ 31.261225] BUG: KASAN: use-after-free in macb_remove+0x77/0xc6 [macb_pci] [ 31.275563] Freed by task 306: [ 30.276782] platform_device_release+0x25/0x80",
        "technologies": "Linux\nLinux Kernel 4.14.249 未満\nLinux Kernel 4.15 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.150 未満\nLinux Kernel 5.5 以上 5.10.70 未満\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021466": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: atm: nicstar: Fix possible use-after-free in nicstar_cleanup() This module's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021469": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: staging: greybus: uart: fix tty use after free User space can hold a tty open indefinitely and tty drivers must not release the underlying structures until the last user is gone. Switch to using the tty-port reference counter to manage the life time of the greybus tty state to avoid use after free after a disconnect.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.9.285 未満\nLinux Kernel 4.10 以上 4.14.249 未満\nLinux Kernel 4.15 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.150 未満\nLinux Kernel 5.5 以上 5.10.70 未満\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021477": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ethernet: fix potential use-after-free in ec_bhf_remove static void ec_bhf_remove(struct pci_dev *dev) { ... struct ec_bhf_priv *priv = netdev_priv(net_dev); unregister_netdev(net_dev); free_netdev(net_dev); pci_iounmap(dev, priv->dma_io); pci_iounmap(dev, priv->io); ... } priv is netdev private data, but it is used after free_netdev(). It can cause use-after-free when accessing priv pointer. So, fix it by moving free_netdev() after pci_iounmap() calls.",
        "technologies": "Linux\nLinux Kernel 3.15 以上 4.4.274 未満\nLinux Kernel 4.5 以上 4.9.274 未満\nLinux Kernel 4.10 以上 4.14.238 未満\nLinux Kernel 4.15 以上 4.19.196 未満\nLinux Kernel 4.20 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021464": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arch_topology: Avoid use-after-free for scale_freq_data Currently topology_scale_freq_tick() (which gets called from scheduler_tick()) may end up using a pointer to \"struct scale_freq_data\", which was previously cleared by topology_clear_scale_freq_source(), as there is no protection in place here. The users of topology_clear_scale_freq_source() though needs a guarantee that the previously cleared scale_freq_data isn't used anymore, so they can free the related resources. Since topology_scale_freq_tick() is called from scheduler tick, we don't want to add locking in there. Use the RCU update mechanism instead (which is already used by the scheduler's utilization update path) to guarantee race free updates here. synchronize_rcu() makes sure that all RCU critical sections that started before it is called, will finish before it returns. And so the callers of topology_clear_scale_freq_source() don't need to worry about their callback getting called anymore.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021489": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: synproxy: Fix out of bounds when parsing TCP options The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1. This fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\"). v2 changes: Added an early return when length < 0 to avoid calling skb_header_pointer with negative length.",
        "technologies": "Linux\nLinux Kernel 3.12 以上 4.4.274 未満\nLinux Kernel 4.5 以上 4.9.274 未満\nLinux Kernel 4.10 以上 4.14.238 未満\nLinux Kernel 4.15 以上 4.19.196 未満\nLinux Kernel 4.20 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021478": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86: Fix stack-out-of-bounds memory access from ioapic_write_indirect() KASAN reports the following issue: BUG: KASAN: stack-out-of-bounds in kvm_make_vcpus_request_mask+0x174/0x440 [kvm] Read of size 8 at addr ffffc9001364f638 by task qemu-kvm/4798 CPU: 0 PID: 4798 Comm: qemu-kvm Tainted: G X --------- --- Hardware name: AMD Corporation DAYTONA_X/DAYTONA_X, BIOS RYM0081C 07/13/2020 Call Trace: dump_stack+0xa5/0xe6 print_address_description.constprop.0+0x18/0x130 ? kvm_make_vcpus_request_mask+0x174/0x440 [kvm] __kasan_report.cold+0x7f/0x114 ? kvm_make_vcpus_request_mask+0x174/0x440 [kvm] kasan_report+0x38/0x50 kasan_check_range+0xf5/0x1d0 kvm_make_vcpus_request_mask+0x174/0x440 [kvm] kvm_make_scan_ioapic_request_mask+0x84/0xc0 [kvm] ? kvm_arch_exit+0x110/0x110 [kvm] ? sched_clock+0x5/0x10 ioapic_write_indirect+0x59f/0x9e0 [kvm] ? static_obj+0xc0/0xc0 ? __lock_acquired+0x1d2/0x8c0 ? kvm_ioapic_eoi_inject_work+0x120/0x120 [kvm] The problem appears to be that 'vcpu_bitmap' is allocated as a single long on stack and it should really be KVM_MAX_VCPUS long. We also seem to clear the lower 16 bits of it with bitmap_zero() for no particular reason (my guess would be that 'bitmap' and 'vcpu_bitmap' variables in kvm_bitmap_or_dest_vcpus() caused the confusion: while the later is indeed 16-bit long, the later should accommodate all possible vCPUs).",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021483": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: ucsi: Retrieve all the PDOs instead of just the first 4 commit 4dbc6a4ef06d (\"usb: typec: ucsi: save power data objects in PD mode\") introduced retrieval of the PDOs when connected to a PD-capable source. But only the first 4 PDOs are received since that is the maximum number that can be fetched at a time given the MESSAGE_IN length limitation (16 bytes). However, as per the PD spec a connected source may advertise up to a maximum of 7 PDOs. If such a source is connected it's possible the PPM could have negotiated a power contract with one of the PDOs at index greater than 4, and would be reflected in the request data object's (RDO) object position field. This would result in an out-of-bounds access when the rdo_index() is used to index into the src_pdos array in ucsi_psy_get_voltage_now(). With the help of the UBSAN -fsanitize=array-bounds checker enabled this exact issue is revealed when connecting to a PD source adapter that advertise 5 PDOs and the PPM enters a contract having selected the 5th one. [ 151.545106][ T70] Unexpected kernel BRK exception at EL1 [ 151.545112][ T70] Internal error: BRK handler: f2005512 [#1] PREEMPT SMP ... [ 151.545499][ T70] pc : ucsi_psy_get_prop+0x208/0x20c [ 151.545507][ T70] lr : power_supply_show_property+0xc0/0x328 ... [ 151.545542][ T70] Call trace: [ 151.545544][ T70] ucsi_psy_get_prop+0x208/0x20c [ 151.545546][ T70] power_supply_uevent+0x1a4/0x2f0 [ 151.545550][ T70] dev_uevent+0x200/0x384 [ 151.545555][ T70] kobject_uevent_env+0x1d4/0x7e8 [ 151.545557][ T70] power_supply_changed_work+0x174/0x31c [ 151.545562][ T70] process_one_work+0x244/0x6f0 [ 151.545564][ T70] worker_thread+0x3e0/0xa64 We can resolve this by instead retrieving and storing up to the maximum of 7 PDOs in the con->src_pdos array. This would involve two calls to the GET_PDOS command.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021482": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: usb: fix possible use-after-free in smsc75xx_bind The commit 46a8b29c6306 (\"net: usb: fix memory leak in smsc75xx_bind\") fails to clean up the work scheduled in smsc75xx_reset-> smsc75xx_set_multicast, which leads to use-after-free if the work is scheduled to start after the deallocation. In addition, this patch also removes a dangling pointer - dev->data[0]. This patch calls cancel_work_sync to cancel the scheduled work and set the dangling pointer to NULL.",
        "technologies": "Linux\nLinux Kernel 4.4.271 以上 4.4.274 未満\nLinux Kernel 4.9.271 以上 4.9.274 未満\nLinux Kernel 4.14.235 以上 4.14.238 未満\nLinux Kernel 4.19.193 以上 4.19.196 未満\nLinux Kernel 5.4.124 以上 5.4.128 未満\nLinux Kernel 5.10.42 以上 5.10.46 未満\nLinux Kernel 5.12.9 以上 5.12.13 未満"
    },
    "JVNDB-2021-021479": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mac80211: fix use-after-free in CCMP/GCMP RX When PN checking is done in mac80211, for fragmentation we need to copy the PN to the RX struct so we can later use it to do a comparison, since commit bf30ca922a0c (\"mac80211: check defrag PN against current frame\"). Unfortunately, in that commit I used the 'hdr' variable without it being necessarily valid, so use-after-free could occur if it was necessary to reallocate (parts of) the frame. Fix this by reloading the variable after the code that results in the reallocations, if any. This fixes https://bugzilla.kernel.org/show_bug.cgi?id=214401.",
        "technologies": "Linux\nLinux Kernel 4.4.271 以上 4.4.286 未満\nLinux Kernel 4.9.271 以上 4.9.285 未満\nLinux Kernel 4.14.235 以上 4.14.249 未満\nLinux Kernel 4.19.193 以上 4.19.209 未満\nLinux Kernel 5.4.124 以上 5.4.151 未満\nLinux Kernel 5.10.42 以上 5.10.71 未満\nLinux Kernel 5.12.9 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021493": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: iscsi: Fix iscsi_task use after free Commit d39df158518c (\"scsi: iscsi: Have abort handler get ref to conn\") added iscsi_get_conn()/iscsi_put_conn() calls during abort handling but then also changed the handling of the case where we detect an already completed task where we now end up doing a goto to the common put/cleanup code. This results in a iscsi_task use after free, because the common cleanup code will do a put on the iscsi_task. This reverts the goto and moves the iscsi_get_conn() to after we've checked if the iscsi_task is valid.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.14.12 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021488": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gfs2: Fix use-after-free in gfs2_glock_shrink_scan The GLF_LRU flag is checked under lru_lock in gfs2_glock_remove_from_lru() to remove the glock from the lru list in __gfs2_glock_put(). On the shrink scan path, the same flag is cleared under lru_lock but because of cond_resched_lock(&lru_lock) in gfs2_dispose_glock_lru(), progress on the put side can be made without deleting the glock from the lru list. Keep GLF_LRU across the race window opened by cond_resched_lock(&lru_lock) to ensure correct behavior on both sides - clear GLF_LRU after list_del under lru_lock.",
        "technologies": "Linux\nLinux Kernel 4.4.274 未満\nLinux Kernel 4.5 以上 4.9.274 未満\nLinux Kernel 4.10 以上 4.14.238 未満\nLinux Kernel 4.15 以上 4.19.196 未満\nLinux Kernel 4.20 以上 5.4.127 未満\nLinux Kernel 5.5 以上 5.10.45 未満\nLinux Kernel 5.11 以上 5.12.12 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021498": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: regmap: Fix possible double-free in regcache_rbtree_exit() In regcache_rbtree_insert_to_block(), when 'present' realloc failed, the 'blk' which is supposed to assign to 'rbnode->block' will be freed, so 'rbnode->block' points a freed memory, in the error handling path of regcache_rbtree_init(), 'rbnode->block' will be freed again in regcache_rbtree_exit(), KASAN will report double-free as follows: BUG: KASAN: double-free or invalid-free in kfree+0xce/0x390 Call Trace: slab_free_freelist_hook+0x10d/0x240 kfree+0xce/0x390 regcache_rbtree_exit+0x15d/0x1a0 regcache_rbtree_init+0x224/0x2c0 regcache_init+0x88d/0x1310 __regmap_init+0x3151/0x4a80 __devm_regmap_init+0x7d/0x100 madera_spi_probe+0x10f/0x333 [madera_spi] spi_probe+0x183/0x210 really_probe+0x285/0xc30 To fix this, moving up the assignment of rbnode->block to immediately after the reallocation has succeeded so that the data structure stays valid even if the second reallocation fails.",
        "technologies": "Linux\nLinux Kernel 3.12 以上 4.4.291 未満\nLinux Kernel 4.5 以上 4.9.289 未満\nLinux Kernel 4.10 以上 4.14.254 未満\nLinux Kernel 4.15 以上 4.19.215 未満\nLinux Kernel 4.20 以上 5.4.157 未満\nLinux Kernel 5.5 以上 5.10.77 未満\nLinux Kernel 5.11 以上 5.14.16 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021499": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix even more out of bound writes from debugfs CVE-2021-42327 was fixed by: commit f23750b5b3d98653b31d4469592935ef6364ad67 Author: Thelford Williams <tdwilliamsiv@gmail.com> Date: Wed Oct 13 16:04:13 2021 -0400 drm/amdgpu: fix out of bounds write but amdgpu_dm_debugfs.c contains more of the same issue so fix the remaining ones. v2: * Add missing fix in dp_max_bpc_write (Harry Wentland)",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.14.16 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021542": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: act_ct: fix wild memory access when clearing fragments while testing re-assembly/re-fragmentation using act_ct, it's possible to observe a crash like the following one: KASAN: maybe wild-memory-access in range [0x0001000000000448-0x000100000000044f] CPU: 50 PID: 0 Comm: swapper/50 Tainted: G S 5.12.0-rc7+ #424 Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017 RIP: 0010:inet_frag_rbtree_purge+0x50/0xc0 Code: 00 fc ff df 48 89 c3 31 ed 48 89 df e8 a9 7a 38 ff 4c 89 fe 48 89 df 49 89 c6 e8 5b 3a 38 ff 48 8d 7b 40 48 89 f8 48 c1 e8 03 <42> 80 3c 20 00 75 59 48 8d bb d0 00 00 00 4c 8b 6b 40 48 89 f8 48 RSP: 0018:ffff888c31449db8 EFLAGS: 00010203 RAX: 0000200000000089 RBX: 000100000000040e RCX: ffffffff989eb960 RDX: 0000000000000140 RSI: ffffffff97cfb977 RDI: 000100000000044e RBP: 0000000000000900 R08: 0000000000000000 R09: ffffed1186289350 R10: 0000000000000003 R11: ffffed1186289350 R12: dffffc0000000000 R13: 000100000000040e R14: 0000000000000000 R15: ffff888155e02160 FS: 0000000000000000(0000) GS:ffff888c31440000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005600cb70a5b8 CR3: 0000000a2c014005 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> inet_frag_destroy+0xa9/0x150 call_timer_fn+0x2d/0x180 run_timer_softirq+0x4fe/0xe70 __do_softirq+0x197/0x5a0 irq_exit_rcu+0x1de/0x200 sysvec_apic_timer_interrupt+0x6b/0x80 </IRQ> when act_ct temporarily stores an IP fragment, restoring the skb qdisc cb results in putting random data in FRAG_CB(), and this causes those \"wild\" memory accesses later, when the rbtree is purged. Never overwrite the skb cb in case tcf_ct_handle_fragments() returns -EINPROGRESS.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.12.4 未満"
    },
    "JVNDB-2021-021501": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: mma8452: Fix trigger reference couting The mma8452 driver directly assigns a trigger to the struct iio_dev. The IIO core when done using this trigger will call `iio_trigger_put()` to drop the reference count by 1. Without the matching `iio_trigger_get()` in the driver the reference count can reach 0 too early, the trigger gets freed while still in use and a use-after-free occurs. Fix this by getting a reference to the trigger before assigning it to the IIO device.",
        "technologies": "Linux\nLinux Kernel 4.2 以上 4.4.295 未満\nLinux Kernel 4.5 以上 4.9.293 未満\nLinux Kernel 4.10 以上 4.14.258 未満\nLinux Kernel 4.15 以上 4.19.221 未満\nLinux Kernel 4.20 以上 5.4.165 未満\nLinux Kernel 5.5 以上 5.10.85 未満\nLinux Kernel 5.11 以上 5.15.8 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021505": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: fix use-after-free due to delegation race A delegation break could arrive as soon as we've called vfs_setlease. A delegation break runs a callback which immediately (in nfsd4_cb_recall_prepare) adds the delegation to del_recall_lru. If we then exit nfs4_set_delegation without hashing the delegation, it will be freed as soon as the callback is done with it, without ever being removed from del_recall_lru. Symptoms show up later as use-after-free or list corruption warnings, usually in the laundromat thread. I suspect aba2072f4523 \"nfsd: grant read delegations to clients holding writes\" made this bug easier to hit, but I looked as far back as v3.0 and it looks to me it already had the same problem. So I'm not sure where the bug was introduced; it may have been there from the beginning.",
        "technologies": "Linux\nLinux Kernel 4.4.296 未満\nLinux Kernel 4.5 以上 4.9.294 未満\nLinux Kernel 4.10 以上 4.14.259 未満\nLinux Kernel 4.15 以上 4.19.222 未満\nLinux Kernel 4.20 以上 5.4.168 未満\nLinux Kernel 5.5 以上 5.10.85 未満\nLinux Kernel 5.11 以上 5.15.8 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021506": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: qrtr: fix OOB Read in qrtr_endpoint_post Syzbot reported slab-out-of-bounds Read in qrtr_endpoint_post. The problem was in wrong _size_ type: if (len != ALIGN(size, 4) + hdrlen) goto err; If size from qrtr_hdr is 4294967293 (0xfffffffd), the result of ALIGN(size, 4) will be 0. In case of len == hdrlen and size == 4294967293 in header this check won't fail and skb_put_data(skb, data + hdrlen, size); will read out of bound from data, which is hdrlen allocated block.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 4.19.196 未満\nLinux Kernel 4.20 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021513": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: marvell: prestera: fix double free issue on err path fix error path handling in prestera_bridge_port_join() that cases prestera driver to crash (see below). Trace: Internal error: Oops: 96000044 [#1] SMP Modules linked in: prestera_pci prestera uio_pdrv_genirq CPU: 1 PID: 881 Comm: ip Not tainted 5.15.0 #1 pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : prestera_bridge_destroy+0x2c/0xb0 [prestera] lr : prestera_bridge_port_join+0x2cc/0x350 [prestera] sp : ffff800011a1b0f0 ... x2 : ffff000109ca6c80 x1 : dead000000000100 x0 : dead000000000122 Call trace: prestera_bridge_destroy+0x2c/0xb0 [prestera] prestera_bridge_port_join+0x2cc/0x350 [prestera] prestera_netdev_port_event.constprop.0+0x3c4/0x450 [prestera] prestera_netdev_event_handler+0xf4/0x110 [prestera] raw_notifier_call_chain+0x54/0x80 call_netdevice_notifiers_info+0x54/0xa0 __netdev_upper_dev_link+0x19c/0x380",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.83 未満\nLinux Kernel 5.11 以上 5.15.6 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021545": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ataflop: potential out of bounds in do_format() The function uses \"type\" as an array index: q = unit[drive].disk[type]->queue; Unfortunately the bounds check on \"type\" isn't done until later in the function. Fix this by moving the bounds check to the start.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-014774": {
        "title": "OpenGamePanel OGP-Agent-Linux における OS コマンドインジェクションの脆弱性",
        "description": "An issue was discovered in OpenGamePanel OGP-Agent-Linux through 2021-08-14. An authenticated attacker could inject OS commands by starting a Counter-Strike server and using the map field to enter a Bash command.",
        "technologies": "Open Game Panel\nOpen Game Panel 2021-08-14 まで"
    },
    "JVNDB-2021-021539": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bus: mhi: core: Fix invalid error returning in mhi_queue mhi_queue returns an error when the doorbell is not accessible in the current state. This can happen when the device is in non M0 state, like M3, and needs to be waken-up prior ringing the DB. This case is managed earlier by triggering an asynchronous M3 exit via controller resume/suspend callbacks, that in turn will cause M0 transition and DB update. So, since it's not an error but just delaying of doorbell update, there is no reason to return an error. This also fixes a use after free error for skb case, indeed a caller queuing skb will try to free the skb if the queueing fails, but in that case queueing has been done.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.3 未満"
    },
    "JVNDB-2021-021526": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sata_fsl: fix UAF in sata_fsl_port_stop when rmmod sata_fsl When the `rmmod sata_fsl.ko` command is executed in the PPC64 GNU/Linux, a bug is reported: ================================================================== BUG: Unable to handle kernel data access on read at 0x80000800805b502c Oops: Kernel access of bad area, sig: 11 [#1] NIP [c0000000000388a4] .ioread32+0x4/0x20 LR [80000000000c6034] .sata_fsl_port_stop+0x44/0xe0 [sata_fsl] Call Trace: .free_irq+0x1c/0x4e0 (unreliable) .ata_host_stop+0x74/0xd0 [libata] .release_nodes+0x330/0x3f0 .device_release_driver_internal+0x178/0x2c0 .driver_detach+0x64/0xd0 .bus_remove_driver+0x70/0xf0 .driver_unregister+0x38/0x80 .platform_driver_unregister+0x14/0x30 .fsl_sata_driver_exit+0x18/0xa20 [sata_fsl] .__se_sys_delete_module+0x1ec/0x2d0 .system_call_exception+0xfc/0x1f0 system_call_common+0xf8/0x200 ================================================================== The triggering of the BUG is shown in the following stack: driver_detach device_release_driver_internal __device_release_driver drv->remove(dev) --> platform_drv_remove/platform_remove drv->remove(dev) --> sata_fsl_remove iounmap(host_priv->hcr_base); <---- unmap kfree(host_priv); <---- free devres_release_all release_nodes dr->node.release(dev, dr->data) --> ata_host_stop ap->ops->port_stop(ap) --> sata_fsl_port_stop ioread32(hcr_base + HCONTROL) <---- UAF host->ops->host_stop(host) The iounmap(host_priv->hcr_base) and kfree(host_priv) functions should not be executed in drv->remove. These functions should be executed in host_stop after port_stop. Therefore, we move these functions to the new function sata_fsl_host_stop and bind the new function to host_stop.",
        "technologies": "Linux\nLinux Kernel 2.6.24 以上 4.4.294 未満\nLinux Kernel 4.5 以上 4.9.292 未満\nLinux Kernel 4.10 以上 4.14.257 未満\nLinux Kernel 4.15 以上 4.19.220 未満\nLinux Kernel 4.20 以上 5.4.164 未満\nLinux Kernel 5.5 以上 5.10.84 未満\nLinux Kernel 5.11 以上 5.15.7 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021524": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/prime: Fix use after free in mmap with drm_gem_ttm_mmap drm_gem_ttm_mmap() drops a reference to the gem object on success. If the gem object's refcount == 1 on entry to drm_gem_prime_mmap(), that drop will free the gem object, and the subsequent drm_gem_object_get() will be a UAF. Fix by grabbing a reference before calling the mmap helper. This issue was forseen when the reference dropping was adding in commit 9786b65bc61ac (\"drm/ttm: fix mmap refcounting\"): \"For that to work properly the drm_gem_object_get() call in drm_gem_ttm_mmap() must be moved so it happens before calling obj->funcs->mmap(), otherwise the gem refcount would go down to zero.\"",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.15.5 未満"
    },
    "JVNDB-2021-014782": {
        "title": "OpenGamePanel OGP-Agent-Linux における重要な情報の平文保存に関する脆弱性",
        "description": "An issue was discovered in OpenGamePanel OGP-Agent-Linux through 2021-08-14. $HOME/OGP/Cfg/Config.pm has the root password in cleartext.",
        "technologies": "Open Game Panel\nOpen Game Panel 2021-08-14 まで"
    },
    "JVNDB-2021-016114": {
        "title": "Linux、UNIX、Windows 用 IBM Db2 における暗号アルゴリズムの使用に関する脆弱性",
        "description": "IBM DB2 for Linux, UNIX and Windows (includes DB2 Connect Server) 9.7, 10.1, 10.5, 11.1, and 11.5 uses weaker than expected cryptographic algorithms that could allow an attacker to decrypt highly sensitive information.",
        "technologies": "IBM\nIBM DB2 9.7\nIBM DB2 10.1\nIBM DB2 10.5\nIBM DB2 11.1\nIBM DB2 11.5\nNetApp\nOnCommand Insight"
    },
    "JVNDB-2021-016118": {
        "title": "Linux、UNIX、Windows 用 IBM Db2 における不正な認証に関する脆弱性",
        "description": "IBM Db2 for Linux, UNIX and Windows (includes Db2 Connect Server) 9.7, 10.1, 10.5, 11.1, and 11.5 could allow a user with DBADM authority to access other databases and read or modify files. IBM X-Force ID: 199914.",
        "technologies": "IBM\nIBM DB2 9.7\nIBM DB2 10.1\nIBM DB2 10.5\nIBM DB2 11.1\nIBM DB2 11.5\nNetApp\nOnCommand Insight"
    },
    "JVNDB-2021-015767": {
        "title": "複数の Bitdefender 製品における脆弱性",
        "description": "Improper Access Control vulnerability in the patchesUpdate API as implemented in Bitdefender Endpoint Security Tools for Linux as a relay role allows an attacker to manipulate the remote address used for pulling patches. This issue affects: Bitdefender Endpoint Security Tools for Linux versions prior to 6.6.27.390; versions prior to 7.1.2.33. Bitdefender Unified Endpoint versions prior to 6.2.21.160. Bitdefender GravityZone versions prior to 6.24.1-1.",
        "technologies": "BitDefender\nBitdefender Endpoint Security Tools\nBitDefender GravityZone"
    },
    "JVNDB-2021-015517": {
        "title": "複数の OS 上で稼動する Acronis Agent におけるログファイルからの情報漏えいに関する脆弱性",
        "description": "Sensitive information could be logged. The following products are affected: Acronis Agent (Windows, Linux, macOS) before build 27147",
        "technologies": "Acronis International GmbH\nAgent build 27147 未満"
    },
    "JVNDB-2021-016846": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.15.11 まで\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-016633": {
        "title": "Linux 上で稼働する Google Chrome における解放済みメモリの使用に関する脆弱性",
        "description": "Use after free in UI in Google Chrome on Linux prior to 96.0.4664.93 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nGoogle\nGoogle Chrome 96.0.4664.93 未満"
    },
    "JVNDB-2021-016918": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In __f2fs_setxattr in fs/f2fs/xattr.c in the Linux kernel through 5.15.11, there is an out-of-bounds memory access when an inode has an invalid last xattr entry.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.15.11 まで\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-017885": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "A read-after-free memory flaw was found in the Linux kernel's garbage collection for Unix domain socket file handlers in the way users call close() and fget() simultaneously and can potentially trigger a race condition. This flaw allows a local user to crash the system or escalate their privileges on the system. This flaw affects Linux kernel versions prior to 5.16-rc4.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.16-rc4 未満\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-017434": {
        "title": "Linux Kernel における暗号アルゴリズムの使用に関する脆弱性",
        "description": "In the IPv6 implementation in the Linux kernel before 5.13.3, net/ipv6/output_core.c has an information leak because of certain use of a hash table which, although big, doesn't properly consider that IPv6-based attackers can typically choose among many IPv6 source addresses.",
        "technologies": "Linux\nLinux Kernel 5.13.3 未満\nNetApp\nE-Series SANtricity OS Controller Software\nFAS/AFF Baseboard Management Controller 8300\nFAS/AFF Baseboard Management Controller 8700\nFAS/AFF Baseboard Management Controller A400\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire Enterprise SDS & HCI Storage Node\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア"
    },
    "JVNDB-2021-018247": {
        "title": "Linux Kernel における二重解放に関する脆弱性",
        "description": "A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-018102": {
        "title": "Linux Kernel における型の取り違えに関する脆弱性",
        "description": "This vulnerability allows local attackers to escalate privileges on affected installations of Linux Kernel 5.14-rc3. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability. The specific flaw exists within the handling of eBPF programs. The issue results from the lack of proper validation of user-supplied eBPF programs, which can result in a type confusion condition. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel. Was ZDI-CAN-14689.",
        "technologies": "Linux\nLinux Kernel 5.14-rc3\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-018257": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in cgroup1_parse_param in kernel/cgroup/cgroup-v1.c in the Linux kernel's cgroup v1 parser. A local attacker with a user privilege could cause a privilege escalation by exploiting the fsconfig syscall parameter leading to a container breakout and a denial of service on the system.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nBaseboard Management Controller\nレッドハット\nRed Hat Virtualization\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-018093": {
        "title": "Cesanta MJS における境界外書き込みに関する脆弱性",
        "description": "Cesanta MJS v2.20.0 was discovered to contain a heap buffer overflow via /usr/lib/x86_64-linux-gnu/libasan.so.4+0xaff53.",
        "technologies": "Cesanta\nMJS 2.20.0"
    },
    "JVNDB-2021-018533": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Linux kernel. A use-after-free vulnerability in the NFC stack can lead to a threat to confidentiality, integrity, and system availability.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア"
    },
    "JVNDB-2021-018536": {
        "title": "Linux Kernel における脆弱性",
        "description": "A flaw in netfilter could allow a network-connected attacker to infer openvpn connection endpoint information for further use in traditional network attacks.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nオラクル\nOracle Communications Cloud Native Core Binding Support Function\nOracle Communications Cloud Native Core Network Exposure Function\nOracle Communications Cloud Native Core Policy\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-018534": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s Bluetooth subsystem in the way user calls connect to the socket and disconnect simultaneously due to a race condition. This flaw allows a user to crash the system or escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function\nレッドハット\nRed Hat 3scale\nRed Hat Virtualization Host\nRed Hat Enterprise Linux\nRed Hat Enterprise Linux for Real Time\nRed Hat Enterprise Linux for Real Time for NFV"
    },
    "JVNDB-2021-018860": {
        "title": "Red Hat Enterprise Linux における境界外書き込みに関する脆弱性",
        "description": "Missing fixes for CVE-2021-40438 and CVE-2021-26691 in the versions of httpd, as shipped in Red Hat Enterprise Linux 8.5.0, causes a security regression compared to the versions shipped in Red Hat Enterprise Linux 8.4. A user who installs or updates to Red Hat Enterprise Linux 8.5.0 would be vulnerable to the mentioned CVEs, even if they were properly fixed in Red Hat Enterprise Linux 8.4. CVE-2021-20325 was assigned to that Red Hat specific security regression and it does not affect the upstream versions of httpd.",
        "technologies": "レッドハット\nRed Hat Enterprise Linux 8.5.0"
    },
    "JVNDB-2021-018540": {
        "title": "polkit における例外的な状態のチェックに関する脆弱性",
        "description": "It was found that polkit could be tricked into bypassing the credential checks for D-Bus requests, elevating the privileges of the requestor to the root user. This flaw could be used by an unprivileged local attacker to, for example, create a new local administrator. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\npolkit project\npolkit\nレッドハット\nRed Hat OpenShift Container Platform\nRed Hat Virtualization\nRed Hat Virtualization Host"
    },
    "JVNDB-2021-018554": {
        "title": "Linux Kernel における不十分なランダム値の使用に関する脆弱性",
        "description": "A flaw in the processing of received ICMP errors (ICMP fragment needed and ICMP redirect) in the Linux kernel functionality was found to allow the ability to quickly scan open UDP ports. This flaw allows an off-path remote user to effectively bypass the source port UDP randomization. The highest threat from this vulnerability is to confidentiality and possibly integrity, because software that relies on UDP source port randomization are indirectly affected as well.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nActive IQ Unified Manager\nE-Series SANtricity OS Controller Software\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire Enterprise SDS & HCI Storage Node\nAFF Baseboard Management Controller ファームウェア\nFAS Baseboard Management Controller ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function"
    },
    "JVNDB-2021-018627": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds (OOB) memory write flaw was found in the NFSD in the Linux kernel. Missing sanity may lead to a write beyond bmval[bmlen-1] in nfsd4_decode_bitmap4 in fs/nfsd/nfs4xdr.c. In this flaw, a local attacker with user privilege may gain access to out-of-bounds memory, leading to a system integrity and confidentiality threat.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-018973": {
        "title": "Linux kernel における競合状態に関する脆弱性",
        "description": ".A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300S ファームウェア\nレッドハット\nbuild of Quarkus\ncodeready linux builder eus\ncodeready linux builder for power little endian eus\nRed Hat 3scale API Management Platform\nRed Hat OpenShift Container Platform\nRed Hat Virtualization\nRed Hat Virtualization Host\nRed Hat Enterprise Linux AUS"
    },
    "JVNDB-2021-001915": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.12.11 まで"
    },
    "JVNDB-2021-002344": {
        "title": "Sensormatic Electronics 製 Illustra に境界条件の判定に関する脆弱性",
        "description": "",
        "technologies": "Sensormatic Electronics\nFlex Gen 2 v1.9.4 より前のすべてのバージョン\nInsight v1.4.0 より前のすべてのバージョン\nPro 2 全てのバージョン\nPro Gen 3 v2.8.0 より前のすべてのバージョン"
    },
    "JVNDB-2021-002636": {
        "title": "Linux 用 NVIDIA GPU ディスプレイドライバにおける不適切なデフォルトパーミッションに関する脆弱性",
        "description": "",
        "technologies": "NVIDIA\nNVIDIA GPU ディスプレイドライバ"
    },
    "JVNDB-2021-002646": {
        "title": "Windows および Linux 用 NVIDIA GPU ディスプレイドライバにおける権限管理に関する脆弱性",
        "description": "",
        "technologies": "NVIDIA\nNVIDIA GPU ディスプレイドライバ"
    },
    "JVNDB-2021-002705": {
        "title": "Microsoft Windows 10 および Windows Server における権限を昇格される脆弱性",
        "description": "",
        "technologies": "マイクロソフト\nMicrosoft Windows 10 Version 1809 for 32-bit Systems\nMicrosoft Windows 10 Version 1809 for ARM64-based Systems\nMicrosoft Windows 10 Version 1809 for x64-based Systems\nMicrosoft Windows 10 Version 1909 for 32-bit Systems\nMicrosoft Windows 10 Version 1909 for ARM64-based Systems\nMicrosoft Windows 10 Version 1909 for x64-based Systems\nMicrosoft Windows 10 Version 2004 for 32-bit Systems\nMicrosoft Windows 10 Version 2004 for ARM64-based Systems\nMicrosoft Windows 10 Version 2004 for x64-based Systems\nMicrosoft Windows 10 Version 20H2 for 32-bit Systems\nMicrosoft Windows 10 Version 20H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 20H2 for x64-based Systems\nMicrosoft Windows 10 Version 21H1 for 32-bit Systems\nMicrosoft Windows 10 Version 21H1 for ARM64-based Systems\nMicrosoft Windows 10 Version 21H1 for x64-based Systems\nMicrosoft Windows Server version 2004 (Server Core installation)\nMicrosoft Windows Server version 20H2 (Server Core Installation)\nMicrosoft Windows Server 2019\nMicrosoft Windows Server 2019 (Server Core installation)"
    },
    "JVNDB-2021-003184": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.10.12 まで"
    },
    "JVNDB-2021-003030": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.10.11 まで"
    },
    "JVNDB-2021-003404": {
        "title": "Linux Kernel における権限管理に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.10.13 未満"
    },
    "JVNDB-2021-003791": {
        "title": "Linux kernel における脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 4.18 から 5.10.16"
    },
    "JVNDB-2021-003806": {
        "title": "Linux kernel における脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 3.11 から 5.10.16"
    },
    "JVNDB-2021-003207": {
        "title": "Linux 上で稼働する Google Chrome の Omnibox における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Google\nGoogle Chrome 88.0.4324.96 未満\nマイクロソフト\nMicrosoft Edge Chromium"
    },
    "JVNDB-2021-003818": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2021-003982": {
        "title": "Linux 上で稼動する Google Chrome における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 88.0.4324.182 未満"
    },
    "JVNDB-2021-003977": {
        "title": "Linux 上で稼動する Google Chrome における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 88.0.4324.182 未満\nマイクロソフト\nMicrosoft Edge\nMicrosoft Edge Chromium"
    },
    "JVNDB-2021-003981": {
        "title": "Linux 上で稼動する Google Chrome における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 88.0.4324.182 未満"
    },
    "JVNDB-2021-003985": {
        "title": "Linux 上で稼動する Google Chrome における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 88.0.4324.182 未満"
    },
    "JVNDB-2021-004058": {
        "title": "Linux Kernel における入力確認に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat OpenShift Container Platform\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-004006": {
        "title": "Linux 上で稼働する Google Chrome の Network Internals における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 89.0.4389.72 未満"
    },
    "JVNDB-2021-003997": {
        "title": "SUSE Linux Enterprise Server および openSUSE Tumbleweed 用 salt における認証に関する脆弱性",
        "description": "",
        "technologies": "SaltStack\nSalt 3002.2-3 未満 (SUSE SUSE Linux Enterprise Server 15 SP 3 salt)\nSalt 3002.2-2.1 およびそれ以前 (openSUSE Tumbleweed salt)"
    },
    "JVNDB-2021-004362": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.11.3 まで"
    },
    "JVNDB-2021-004363": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.11.3 まで"
    },
    "JVNDB-2021-004630": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2021-004397": {
        "title": "複数の OS 上で稼動する IBM DB2 における古典的バッファオーバーフローの脆弱性",
        "description": "",
        "technologies": "IBM\nIBM DB2 9.7\nIBM DB2 10.1\nIBM DB2 10.5\nIBM DB2 11.1\nIBM DB2 11.5\nNetApp\nOnCommand Insight"
    },
    "JVNDB-2021-004450": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2021-004458": {
        "title": "Linux Kernel における権限管理に関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.11.6 まで"
    },
    "JVNDB-2021-004396": {
        "title": "複数の OS 上で稼動する IBM DB2 における脆弱性",
        "description": "",
        "technologies": "IBM\nIBM DB2 9.7\nIBM DB2 10.1\nIBM DB2 10.5\nIBM DB2 11.1\nIBM DB2 11.5\nNetApp\nOnCommand Insight"
    },
    "JVNDB-2021-019350": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw use-after-free in function sco_sock_sendmsg() of the Linux kernel HCI subsystem was found in the way user calls ioct UFFDIO_REGISTER or other way triggers race condition of the call sco_conn_del() together with the call sco_sock_sendmsg() with the expected controllable faulting memory page. A privileged local user could use this flaw to crash the system or escalate their privileges on the system.",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.15.3 未満\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-004944": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.11.6 まで"
    },
    "JVNDB-2021-004835": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.11.9 未満"
    },
    "JVNDB-2021-004947": {
        "title": "Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.11.8 未満"
    },
    "JVNDB-2021-005267": {
        "title": "Linux 上で稼働する Google Chrome における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 89.0.4389.114 未満"
    },
    "JVNDB-2021-005289": {
        "title": "MacOS および Linux 用 Proofpoint Insider Threat Management Agent における証明書検証に関する脆弱性",
        "description": "",
        "technologies": "Proofpoint, Inc.\nInsider Threat Management 7.11.1 未満"
    },
    "JVNDB-2021-005641": {
        "title": "Alpine Linux apk-tools における境界外読み取りに関する脆弱性",
        "description": "",
        "technologies": "Alpine Linux Development Team\napk-tools 2.12.5 未満"
    },
    "JVNDB-2021-005670": {
        "title": "Linux kernel における競合状態に関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.12-rc8 未満"
    },
    "JVNDB-2021-005382": {
        "title": "Linux Kernel におけるコマンドインジェクションの脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.11.12 まで\nNetApp\nNetApp HCI Management Node\nNetApp SolidFire"
    },
    "JVNDB-2021-006176": {
        "title": "Windows および Linux 用 NVIDIA GPU ディスプレイドライバ における不正な認証に関する脆弱性",
        "description": "",
        "technologies": "NVIDIA\nNVIDIA GPU ディスプレイドライバ"
    },
    "JVNDB-2021-005772": {
        "title": "Pi-hole における OS コマンドインジェクションの脆弱性",
        "description": "",
        "technologies": "Pi-hole\nPi-hole 5.2.4"
    },
    "JVNDB-2021-005709": {
        "title": "Ubuntu Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "",
        "technologies": "Canonical\nUbuntu"
    },
    "JVNDB-2021-006238": {
        "title": "複数の SUSE Linux Enterprise High Availability 用 hawk2 におけるアクセスパーミションでの一時ファイル作成に関する脆弱性",
        "description": "",
        "technologies": "SUSE\nhawk2 2.6.3+git.1614685906.812c31e9 未満 (SUSE Linux Enterprise High Availability 12-SP3)\nhawk2 2.6.3+git.1614685906.812c31e9 未満 (SUSE Linux Enterprise High Availability 12-SP5)\nhawk2 2.6.3+git.1614684118.af555ad9 未満 (SUSE Linux Enterprise High Availability 15-SP2)"
    },
    "JVNDB-2021-005924": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.12.0-rc4 未満"
    },
    "JVNDB-2021-006241": {
        "title": "pvrsrvkm.ko における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "pvrsrvkm.ko project\npvrsrvkm.ko 2021/04/24 まで"
    },
    "JVNDB-2021-006353": {
        "title": "klibc における整数オーバーフローの脆弱性",
        "description": "",
        "technologies": "klib project\nklibc 2.0.9 未満"
    },
    "JVNDB-2021-006352": {
        "title": "klibc における整数オーバーフローの脆弱性",
        "description": "",
        "technologies": "klib project\nklibc 2.0.9 未満"
    },
    "JVNDB-2021-006351": {
        "title": "klibc における整数オーバーフローの脆弱性",
        "description": "",
        "technologies": "klib project\nklibc 2.0.9 未満"
    },
    "JVNDB-2021-020371": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるアクセス制御に関する脆弱性",
        "description": "A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux 6.0\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2021-019771": {
        "title": "Linux Kernel におけるバッファエラーの脆弱性",
        "description": "An out of memory bounds write flaw (1 or 2 bytes of memory) in the Linux kernel NFS subsystem was found in the way users use mirroring (replication of files with NFS). A user, having access to the NFS mount, could potentially use this flaw to crash the system or escalate privileges on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function"
    },
    "JVNDB-2021-020372": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるアクセス制御に関する脆弱性",
        "description": "A vulnerability was found in the fs/inode.c:inode_init_owner() function logic of the LInux kernel that allows local users to create files for the XFS file-system with an unintended group ownership and with group execution and SGID permission bits set, in a scenario where a directory is SGID and belongs to a certain group and is writable by a user who is not a member of this group. This can lead to excessive permissions granted in case when they should not. This vulnerability is similar to the previous CVE-2018-13405 and adds the missed fix for the XFS.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 5.11 未満"
    },
    "JVNDB-2021-019770": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "A use-after-free flaw was found in nci_request in net/nfc/nci/core.c in NFC Controller Interface (NCI) in the Linux kernel. This flaw could allow a local attacker with user privileges to cause a data race problem while the device is getting removed, leading to a privilege escalation problem.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2021-019572": {
        "title": "Linux 用 FortiClient における OS コマンドインジェクションの脆弱性",
        "description": "An improper input validation vulnerability in FortiClient for Linux 6.4.x before 6.4.3, FortiClient for Linux 6.2.x before 6.2.9 may allow an unauthenticated attacker to execute arbitrary code on the host operating system as root via tricking the user into connecting to a network with a malicious name.",
        "technologies": "フォーティネット\nFortiClient 6.2.9 未満の 6.2.x\nFortiClient 6.4.3 未満の 6.4.x"
    },
    "JVNDB-2021-019487": {
        "title": "Linux Kernel における認証に関する脆弱性",
        "description": "An unprivileged write to the file handler flaw in the Linux kernel's control groups and namespaces subsystem was found in the way users have access to some less privileged process that are controlled by cgroups and have higher privileged parent process. It is actually both for cgroup2 and cgroup1 versions of control groups. A local user could use this flaw to crash the system or escalate their privileges on the system.",
        "technologies": "Broadcom\nBrocade Fabric OS\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function"
    },
    "JVNDB-2021-019227": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires ‘CAP_SYS_ADMIN’. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア"
    },
    "JVNDB-2021-020414": {
        "title": "Linux Foundation の modular open smart network における不正な認証に関する脆弱性",
        "description": "Authentication vulnerability in MOSN v.0.23.0 allows attacker to escalate privileges via case-sensitive JWT authorization.",
        "technologies": "Linux Foundation\nmodular open smart network 0.23.0 未満"
    },
    "JVNDB-2021-020373": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw in the Linux kernel's implementation of RDMA communications manager listener code allowed an attacker with local access to setup a socket to listen on a high port allowing for a list element to be used after free. Given the ability to execute code, a local attacker could leverage this use-after-free to crash the system or possibly escalate privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nSUSE\nSUSE Linux Enterprise 15.0"
    },
    "JVNDB-2021-019226": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds (OOB) memory read flaw was found in the Qualcomm IPC router protocol in the Linux kernel. A missing sanity check allows a local attacker to gain access to out-of-bounds memory, leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function"
    },
    "JVNDB-2021-019178": {
        "title": "escanav の Linux 用 escan anti-virus における入力確認に関する脆弱性",
        "description": "An local privilege escalation vulnerability due to a \"runasroot\" command in eScan Anti-Virus. This vulnerability is due to invalid arguments and insufficient execution conditions related to \"runasroot\" command. This vulnerability can induce remote attackers to exploit root privileges by manipulating parameter values.",
        "technologies": "escanav\nescan anti-virus 7.0.31 未満"
    },
    "JVNDB-2021-020714": {
        "title": "garudalinux の garuda linux における認証に関する脆弱性",
        "description": "Garuda Linux performs an insecure user creation and authentication that allows any user to impersonate the created account. By creating users from the 'Garuda settings manager', an insecure procedure is performed that keeps the created user without an assigned password during some seconds. This could allow a potential attacker to exploit this vulnerability in order to authenticate without knowing the password.",
        "technologies": "garudalinux\ngaruda linux"
    },
    "JVNDB-2021-020875": {
        "title": "Linux の Linux Kernel におけるバッファサイズの計算の誤りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: staging/intel-ipu3: Fix set_fmt error handling If there in an error during a set_fmt, do not overwrite the previous sizes with the invalid config. Without this patch, v4l2-compliance ends up allocating 4GiB of RAM and causing the following OOPs [ 38.662975] ipu3-imgu 0000:00:05.0: swiotlb buffer is full (sz: 4096 bytes) [ 38.662980] DMA: Out of SW-IOMMU space for 4096 bytes at device 0000:00:05.0 [ 38.663010] general protection fault: 0000 [#1] PREEMPT SMP",
        "technologies": "Linux\nLinux Kernel 5.2.0 以上 5.4.118 未満\nLinux Kernel 5.5.0 以上 5.10.36 未満\nLinux Kernel 5.11.0 以上 5.11.20 未満\nLinux Kernel 5.12.0 以上 5.12.3 未満"
    },
    "JVNDB-2021-020883": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: md/raid1: properly indicate failure when ending a failed write request This patch addresses a data corruption bug in raid1 arrays using bitmaps. Without this fix, the bitmap bits for the failed I/O end up being cleared. Since we are in the failure leg of raid1_end_write_request, the request either needs to be retried (R1BIO_WriteError) or failed (R1BIO_Degraded).",
        "technologies": "Linux\nLinux Kernel 4.14.0 以上 4.14.233 未満\nLinux Kernel 4.15.0 以上 4.19.191 未満\nLinux Kernel 4.20.0 以上 5.4.118 未満\nLinux Kernel 5.5.0 以上 5.10.36 未満\nLinux Kernel 5.11.0 以上 5.11.20 未満\nLinux Kernel 5.12.0 以上 5.12.3 未満"
    },
    "JVNDB-2021-020842": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "It was discovered that the eBPF implementation in the Linux kernel did not properly track bounds information for 32 bit registers when performing div and mod operations. A local attacker could use this to possibly execute arbitrary code.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nFedora Project\nFedora 34\nLinux\nLinux Kernel 4.14 以上 4.19.206 未満\nLinux Kernel 4.20 以上 5.4.98 未満\nLinux Kernel 5.5 以上 5.10.16 未満\nLinux Kernel 5.11\nレッドハット\nRed Hat Enterprise Linux 8.0"
    },
    "JVNDB-2021-020882": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm rq: fix double free of blk_mq_tag_set in dev remove after table load fails When loading a device-mapper table for a request-based mapped device, and the allocation/initialization of the blk_mq_tag_set for the device fails, a following device remove will cause a double free. E.g. (dmesg): device-mapper: core: Cannot initialize queue for request-based dm-mq mapped device device-mapper: ioctl: unable to set up device queue for new table. Unable to handle kernel pointer dereference in virtual kernel address space Failing address: 0305e098835de000 TEID: 0305e098835de803 Fault in home space mode while using kernel ASCE. AS:000000025efe0007 R3:0000000000000024 Oops: 0038 ilc:3 [#1] SMP Modules linked in: ... lots of modules ... Supported: Yes, External CPU: 0 PID: 7348 Comm: multipathd Kdump: loaded Tainted: G W X 5.3.18-53-default #1 SLE15-SP3 Hardware name: IBM 8561 T01 7I2 (LPAR) Krnl PSW : 0704e00180000000 000000025e368eca (kfree+0x42/0x330) R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3 Krnl GPRS: 000000000000004a 000000025efe5230 c1773200d779968d 0000000000000000 000000025e520270 000000025e8d1b40 0000000000000003 00000007aae10000 000000025e5202a2 0000000000000001 c1773200d779968d 0305e098835de640 00000007a8170000 000003ff80138650 000000025e5202a2 000003e00396faa8 Krnl Code: 000000025e368eb8: c4180041e100 lgrl %r1,25eba50b8 000000025e368ebe: ecba06b93a55 risbg %r11,%r10,6,185,58 #000000025e368ec4: e3b010000008 ag %r11,0(%r1) >000000025e368eca: e310b0080004 lg %r1,8(%r11) 000000025e368ed0: a7110001 tmll %r1,1 000000025e368ed4: a7740129 brc 7,25e369126 000000025e368ed8: e320b0080004 lg %r2,8(%r11) 000000025e368ede: b904001b lgr %r1,%r11 Call Trace: [<000000025e368eca>] kfree+0x42/0x330 [<000000025e5202a2>] blk_mq_free_tag_set+0x72/0xb8 [<000003ff801316a8>] dm_mq_cleanup_mapped_device+0x38/0x50 [dm_mod] [<000003ff80120082>] free_dev+0x52/0xd0 [dm_mod] [<000003ff801233f0>] __dm_destroy+0x150/0x1d0 [dm_mod] [<000003ff8012bb9a>] dev_remove+0x162/0x1c0 [dm_mod] [<000003ff8012a988>] ctl_ioctl+0x198/0x478 [dm_mod] [<000003ff8012ac8a>] dm_ctl_ioctl+0x22/0x38 [dm_mod] [<000000025e3b11ee>] ksys_ioctl+0xbe/0xe0 [<000000025e3b127a>] __s390x_sys_ioctl+0x2a/0x40 [<000000025e8c15ac>] system_call+0xd8/0x2c8 Last Breaking-Event-Address: [<000000025e52029c>] blk_mq_free_tag_set+0x6c/0xb8 Kernel panic - not syncing: Fatal exception: panic_on_oops When allocation/initialization of the blk_mq_tag_set fails in dm_mq_init_request_queue(), it is uninitialized/freed, but the pointer is not reset to NULL; so when dev_remove() later gets into dm_mq_cleanup_mapped_device() it sees the pointer and tries to uninitialize and free it again. Fix this by setting the pointer to NULL in dm_mq_init_request_queue() error-handling. Also set it to NULL in dm_mq_cleanup_mapped_device().",
        "technologies": "Linux\nLinux Kernel 4.6.0 以上 4.9.269 未満\nLinux Kernel 4.10.0 以上 4.14.233 未満\nLinux Kernel 4.15.0 以上 4.19.191 未満\nLinux Kernel 4.20.0 以上 5.4.118 未満\nLinux Kernel 5.5.0 以上 5.10.36 未満\nLinux Kernel 5.11.0 以上 5.11.20 未満\nLinux Kernel 5.12.0 以上 5.12.3 未満"
    },
    "JVNDB-2021-008150": {
        "title": "ConnMan における境界外書き込みに関する脆弱性",
        "description": "ConnMan (aka Connection Manager) 1.30 through 1.39 has a stack-based buffer overflow in uncompress in dnsproxy.c via NAME, RDATA, or RDLENGTH (for A or AAAA).",
        "technologies": "ConnMan project\nConnMan 1.30 から 1.39\nDebian\nDebian GNU/Linux"
    },
    "JVNDB-2021-008982": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "technologies": "Broadcom\nFabric Operating System\nLinux\nLinux Kernel\nNetApp\nNetApp HCI Management Node\nAll Flash Fabric Attached Storage 500F ファームウェア\nAll Flash Fabric Attached Storage A250 ファームウェア\nAll Flash Fabric Attached Storage A400 ファームウェア\nFabric Attached Storage 8300 ファームウェア\nFabric Attached Storage 8700 ファームウェア\nH610C ファームウェア\nH610S ファームウェア\nH615C ファームウェア"
    },
    "JVNDB-2021-008230": {
        "title": "複数の OS 上で稼動する Db2 におけるインジェクションに関する脆弱性",
        "description": "Db2 for Linux, UNIX and Windows (includes Db2 Connect Server) 11.1.4 and 11.5.5 is vulnerable to a denial of service as the server terminates abnormally when executing a specially crafted SELECT statement. IBM X-Force ID: 200658.",
        "technologies": "IBM\nIBM DB2 11.1.4\nIBM DB2 11.5.5"
    },
    "JVNDB-2021-008062": {
        "title": "Linux および Windows 上で稼働する OpenPLC ScadaBR における危険なタイプのファイルの無制限アップロードに関する脆弱性",
        "description": "OpenPLC ScadaBR through 0.9.1 on Linux and through 1.12.4 on Windows allows remote authenticated users to upload and execute arbitrary JSP files via view_edit.shtm.",
        "technologies": "ScadaBR\nScadaBR 0.9.1 まで (Linux)\nScadaBR 1.12.4 まで (Windows)"
    },
    "JVNDB-2021-008484": {
        "title": "複数のプラットフォーム上で稼働する Db2 におけるコマンドインジェクションの脆弱性",
        "description": "Db2 for Linux, UNIX and Windows (includes Db2 Connect Server) is vulnerable to a denial of service as the server terminates abnormally when executing a specially crafted SELECT statement. IBM X-Force ID: 200659.",
        "technologies": "IBM\nIBM DB2"
    },
    "JVNDB-2021-007347": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "kernel/bpf/verifier.c in the Linux kernel through 5.12.7 enforces incorrect limits for pointer arithmetic operations, aka CID-bb01a1bba579. This can be abused to perform out-of-bounds reads and writes in kernel memory, leading to local privilege escalation to root. In particular, there is a corner case where the off reg causes a masking direction change, which then results in an incorrect final aux->alu_limit.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.12.7 まで"
    },
    "JVNDB-2021-008797": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "Guest triggered use-after-free in Linux xen-netback A malicious or buggy network PV frontend can force Linux netback to disable the interface and terminate the receive kernel thread associated with queue 0 in response to the frontend sending a malformed packet. Such kernel thread termination will lead to a use-after-free in Linux netback when the backend is destroyed, as the kernel thread associated with queue 0 will have already exited and thus the call to kthread_stop will be performed against a stale pointer.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2020-001365": {
        "title": "Bftpd における境界条件の判定に関する脆弱性",
        "description": "",
        "technologies": "The BFTPD Project\nBftpd 5.4 未満"
    },
    "JVNDB-2021-008595": {
        "title": "複数のプラットフォーム上で稼働する IBM Db2 における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "IBM Db2 for Linux, UNIX and Windows (includes Db2 Connect Server) 11.5 could allow an authenticated user to overwrite arbirary files due to improper group permissions. IBM X-Force ID: 191945.",
        "technologies": "IBM\nIBM DB2 11.5"
    },
    "JVNDB-2020-001425": {
        "title": "Microsoft Windows 10 および Windows Server における権限を昇格される脆弱性",
        "description": "",
        "technologies": "マイクロソフト\nMicrosoft Windows 10 Version 1903 for 32-bit Systems\nMicrosoft Windows 10 Version 1903 for ARM64-based Systems\nMicrosoft Windows 10 Version 1903 for x64-based Systems\nMicrosoft Windows 10 Version 1909 for 32-bit Systems\nMicrosoft Windows 10 Version 1909 for ARM64-based Systems\nMicrosoft Windows 10 Version 1909 for x64-based Systems\nMicrosoft Windows Server version 1903 (Server Core installation)\nMicrosoft Windows Server version 1909 (Server Core installation)"
    },
    "JVNDB-2020-001436": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2020-001542": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.5 未満"
    },
    "JVNDB-2020-001618": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.5.2 まで"
    },
    "JVNDB-2020-002358": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.5.6 まで"
    },
    "JVNDB-2020-003050": {
        "title": "antiX および MX Linux における入力確認に関する脆弱性",
        "description": "",
        "technologies": "antiX Linux\nantiX Linux\nMXLinux\nMX Linux"
    },
    "JVNDB-2020-003786": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.6.1 未満"
    },
    "JVNDB-2020-003829": {
        "title": "Linux 用 Palo Alto Networks Global Protect Agent における権限管理に関する脆弱性",
        "description": "",
        "technologies": "Palo Alto Networks\nGlobalProtect agent 5.0 以上 5.0.8 未満\nGlobalProtect agent 5.1 以上 5.1.1 未満"
    },
    "JVNDB-2020-003725": {
        "title": "Linux Kernel におけるバッファエラーの脆弱性",
        "description": "",
        "technologies": "Canonical\nUbuntu\nFedora Project\nFedora\nLinux\nLinux Kernel"
    },
    "JVNDB-2021-007425": {
        "title": "Linux Kernel におけるバッファエラーの脆弱性",
        "description": "An issue was discovered in Linux: KVM through Improper handling of VM_IO|VM_PFNMAP vmas in KVM can bypass RO checks and can lead to pages being freed while still accessible by the VMM and guest. This allows users with the ability to start and control a VM to read/write random pages of memory and can result in local privilege escalation.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nBaseboard Management Controller\nSolidfire Baseboard Management Controller"
    },
    "JVNDB-2020-004887": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.6.7 まで"
    },
    "JVNDB-2020-003936": {
        "title": "Linux Kernel における脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.6.3 まで"
    },
    "JVNDB-2020-004910": {
        "title": "libgit2 における入力確認に関する脆弱性",
        "description": "",
        "technologies": "libgit2\nlibgit2 0.28.4 未満\nlibgit2 0.99.0 未満の 0.9x"
    },
    "JVNDB-2020-004911": {
        "title": "libgit2 における入力確認に関する脆弱性",
        "description": "",
        "technologies": "libgit2\nlibgit2 0.28.4 未満\nlibgit2 0.99.0 未満の 0.9x"
    },
    "JVNDB-2020-004974": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel  5.5.4 未満"
    },
    "JVNDB-2020-004989": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.6.5 未満"
    },
    "JVNDB-2020-005020": {
        "title": "Linux Kernel における権限管理に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.5.4 未満"
    },
    "JVNDB-2020-005054": {
        "title": "Linux ディストリビューション用の SQLiteODBC パッケージにおける競合状態に関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nopenSUSE project\nBackports SLE\nSQLiteODBC project\nSQLiteODBC 0.9996"
    },
    "JVNDB-2020-005208": {
        "title": "SUSE Linux Enterprise Server における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "",
        "technologies": "SUSE\nSUSE Linux Enterprise Desktop 15 SP1"
    },
    "JVNDB-2020-006322": {
        "title": "AnyDesk における書式文字列に関する脆弱性",
        "description": "",
        "technologies": "AnyDesk\nAnyDesk 5.5.3 未満"
    },
    "JVNDB-2020-005322": {
        "title": "Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.0.10 未満\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-005476": {
        "title": "Linux 用 McAfee VirusScan Enterprise における権限管理に関する脆弱性",
        "description": "",
        "technologies": "マカフィー\nMcAfee VirusScan Enterprise 2.0.3 Hotfix 2635000 未満"
    },
    "JVNDB-2020-006556": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.7.1 まで"
    },
    "JVNDB-2020-007905": {
        "title": "Citrix ADC Gateway Linux client における権限管理に関する脆弱性",
        "description": "",
        "technologies": "シトリックス・システムズ\nCitrix Gateway Plug-in for Linux 1.0.0.137 未満"
    },
    "JVNDB-2020-006705": {
        "title": "Linux Kernel における権限管理に関する脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nopenSUSE project\nopenSUSE Leap\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-008122": {
        "title": "Microsoft Windows 10 および Windows Server における権限を昇格される脆弱性",
        "description": "",
        "technologies": "マイクロソフト\nMicrosoft Windows 10 Version 2004 for ARM64-based Systems\nMicrosoft Windows 10 Version 2004 for x64-based Systems\nMicrosoft Windows Server version 2004 (Server Core installation)"
    },
    "JVNDB-2020-008225": {
        "title": "Linux Kernel における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.5 から 5.7.9\nXen プロジェクト\nXen 4.13.x"
    },
    "JVNDB-2020-009056": {
        "title": "Intel 製 BlueZ に複数の脆弱性",
        "description": "",
        "technologies": "インテル\nBlueZ をサポートする Linux Kernel 5.9 より前のすべてのバージョン\n日本電気\nActSecure ポータル"
    },
    "JVNDB-2020-008762": {
        "title": "ServerProtect for Linux に OS コマンドインジェクションの脆弱性",
        "description": "",
        "technologies": "トレンドマイクロ\nTrend Micro ServerProtect for Linux 3.0"
    },
    "JVNDB-2020-009105": {
        "title": "Advantech 製 R-SeeNet に SQL インジェクションの脆弱性",
        "description": "",
        "technologies": "アドバンテック株式会社\nR-SeeNet Versions 1.5.1 から 2.4.10"
    },
    "JVNDB-2020-009247": {
        "title": "Linux 用 Active IQ Unified Manager における脆弱性",
        "description": "",
        "technologies": "NetApp\nActive IQ Unified Manager 9.6 未満"
    },
    "JVNDB-2020-009582": {
        "title": "linux-cmdline におけるオブジェクトプロトタイプ属性の不適切に制御された変更に関する脆弱性",
        "description": "",
        "technologies": "linux-cmdline_project\nlinux-cmdline 1.0.1 未満"
    },
    "JVNDB-2020-009257": {
        "title": "複数の B. Braun Melsungen 製品に複数の脆弱性",
        "description": "",
        "technologies": "ビー・ブラウンエースクラップ株式会社\nBattery Pack with Wi-Fi バージョン U61 およびそれ以前\nBattery Pack with Wi-Fi バージョン L81 およびそれ以前\nData module compactplus バージョン A10 および A11\nSpaceCom バージョン U61 およびそれ以前\nSpaceCom バージョン L81 およびそれ以前"
    },
    "JVNDB-2021-009147": {
        "title": "Linux Kernel における脆弱性",
        "description": "An issue was discovered in aspeed_lpc_ctrl_mmap in drivers/soc/aspeed/aspeed-lpc-ctrl.c in the Linux kernel before 5.14.6. Local attackers able to access the Aspeed LPC control interface could overwrite memory in the kernel and potentially execute privileges, aka CID-b49a0e69a7b1. This occurs because a certain comparison uses values that are not memory sizes.",
        "technologies": "Linux\nLinux Kernel 5.14.6 未満\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア\nSolidFire Baseboard Management Controller ファームウェア"
    },
    "JVNDB-2021-009150": {
        "title": "Linux Kernel における認証の欠如に関する脆弱性",
        "description": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"int_ctl\" field, this issue could allow a malicious L1 to enable AVIC support (Advanced Virtual Interrupt Controller) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape. This flaw affects Linux kernel versions prior to 5.14-rc7.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.14-rc7 未満\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-009649": {
        "title": "複数の VMware 製品に OS コマンドインジェクションの脆弱性",
        "description": "",
        "technologies": "VMware\nVMware Cloud Foundation バージョン 4.x\nVMware Identity Manager (Linux 版) バージョン 3.3.1\nVMware Identity Manager (Linux 版) バージョン 3.3.2\nVMware Identity Manager (Linux 版) バージョン 3.3.3\nVMware Identity Manager Connector (Linux 版) バージョン 3.3.1\nVMware Identity Manager Connector (Linux 版) バージョン 3.3.2\nVMware Identity Manager Connector (Windows 版) バージョン 3.3.1\nVMware Identity Manager Connector (Windows 版) バージョン 3.3.2\nVMware Identity Manager Connector (Windows 版) バージョン 3.3.3\nvRealize Suite Lifecycle Manager バージョン 8.x\nWorkspace One Access (Linux 版) バージョン 20.01\nWorkspace One Access (Linux 版) バージョン 20.10"
    },
    "JVNDB-2020-009705": {
        "title": "Linux 用 Network Watcher Agent 仮想マシン拡張機能における権限昇格の脆弱性",
        "description": "",
        "technologies": "マイクロソフト\nNetwork Watcher Agent  virtual machine extension for Linux"
    },
    "JVNDB-2021-009119": {
        "title": "linuxptp パッケージにおけるバッファエラーの脆弱性",
        "description": "A flaw was found in the ptp4l program of the linuxptp package. A missing length check when forwarding a PTP message between ports allows a remote attacker to cause an information leak, crash, or potentially remote code execution. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability. This flaw affects linuxptp versions before 3.1.1, before 2.0.1, before 1.9.3, before 1.8.1, before 1.7.1, before 1.6.1 and before 1.5.1.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nlinuxptp project\nlinuxptp 3.1.1 未満\nlinuxptp 2.0.1 未満\nlinuxptp 1.9.3 未満\nlinuxptp 1.8.1 未満\nlinuxptp 1.7.1 未満\nlinuxptp 1.6.1 未満\nlinuxptp 1.5.1 未満\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-007250": {
        "title": "Linux Kernel における計算の誤りに関する脆弱性",
        "description": "This vulnerability allows local attackers to escalate privileges on affected installations of Linux Kernel 5.11.15. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability. The specific flaw exists within the handling of eBPF programs. The issue results from the lack of proper validation of user-supplied eBPF programs prior to executing them. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel. Was ZDI-CAN-13661.",
        "technologies": "Linux\nLinux Kernel 5.11.15"
    },
    "JVNDB-2020-009994": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.7.10 未満\nopenSUSE project\nopenSUSE Leap\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-009754": {
        "title": "National Instruments 製 CompactRIO に重要なリソースに対する不適切なパーミッションの割り当ての脆弱性",
        "description": "",
        "technologies": "日本ナショナルインスツルメンツ\nCompactRIO ファームウエア 20.5 より前のドライババージョン"
    },
    "JVNDB-2020-010292": {
        "title": "Linux kernel における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "",
        "technologies": "Canonical\nUbuntu\nLinux\nLinux Kernel 5.7.8 未満\nopenSUSE project\nopenSUSE Leap"
    },
    "JVNDB-2021-007146": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Nosy driver in the Linux kernel. This issue allows a device to be inserted twice into a doubly-linked list, leading to a use-after-free when one of these devices is removed. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability. Versions before kernel 5.12-rc6 are affected",
        "technologies": "Linux\nLinux Kernel 5.12-rc6 未満"
    },
    "JVNDB-2020-010864": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 4.9.233 未満の 4.9.x\nLinux Kernel 4.14.194 未満の 4.14.x\nLinux Kernel 4.19.140 未満の 4.19.x"
    },
    "JVNDB-2020-010964": {
        "title": "Linux Kernel における有効期限後または解放後のリソースの操作に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.8.7 未満 の 5.8.x\nLinux Kernel 5.7.x"
    },
    "JVNDB-2020-010883": {
        "title": "Linux kernel におけるTime-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.8.3 未満"
    },
    "JVNDB-2020-011056": {
        "title": "Linux Kernel における重要な情報の平文での送信に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise MRG\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-011858": {
        "title": "Linux 上で稼働する Nakivo Backup & Replication Director における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "",
        "technologies": "Nakivo Inc.\nNAKIVO Backup and Replication 9.4.0.r43656"
    },
    "JVNDB-2020-012140": {
        "title": "Linux kernel における重要な情報の平文での送信に関する脆弱性",
        "description": "",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.9-rc7 未満\nNetApp\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire & HCI Storage Node\nNetApp HCI Compute Node BIOS\nopenSUSE project\nopenSUSE Leap"
    },
    "JVNDB-2020-012264": {
        "title": "Linux Kernel における入力確認に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.9-rc7 未満\nopenSUSE project\nopenSUSE Leap\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-009121": {
        "title": "Linux Kernel の joystick devices subsystem における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds memory write flaw was found in the Linux kernel's joystick devices subsystem in versions before 5.9-rc1, in the way the user calls ioctl JSIOCSBTNMAP. This flaw allows a local user to crash the system or possibly escalate their privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-012541": {
        "title": "The Monero Project の Monero の monero-wallet-gui における信頼できない検索パスに関する脆弱性",
        "description": "",
        "technologies": "The Monero Project\nMonero 0.17.1.0 未満"
    },
    "JVNDB-2020-013071": {
        "title": "Linux 用 Swift におけるスタックオーバーフローの脆弱性",
        "description": "",
        "technologies": "アップル\nSwift for Linux"
    },
    "JVNDB-2020-013421": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.8.2. 未満"
    },
    "JVNDB-2020-013422": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.10 未満"
    },
    "JVNDB-2020-013728": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.7.5 未満"
    },
    "JVNDB-2020-013729": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.7.11 未満\nNetApp\nNetApp HCI Management Node\nNetApp SolidFire\nNetApp HCI Compute Node\nNetApp HCI Storage Node"
    },
    "JVNDB-2020-013593": {
        "title": "Intel(R) QAT for Linux における認証情報の不十分な保護に関する脆弱性",
        "description": "",
        "technologies": "インテル\nIntel QuickAssist Technology for Linux 1.7.l.4.10.0 未満"
    },
    "JVNDB-2020-013730": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.5.11 未満"
    },
    "JVNDB-2020-013909": {
        "title": "Crux Linux Docker images における重要な機能に対する認証の欠如に関する脆弱性",
        "description": "",
        "technologies": "Docker\nCrux Linux Docker images 3.0 から 3.4"
    },
    "JVNDB-2020-013795": {
        "title": "Linux Kernel における不十分なランダム値の使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-013898": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2020-013805": {
        "title": "Zeroshell における OS コマンドインジェクションの脆弱性",
        "description": "",
        "technologies": "Zeroshell.org\nZeroshell 3.9.3 およびそれ以前のバージョン"
    },
    "JVNDB-2020-013958": {
        "title": "Linux Kernel における脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.9.3.io_uring 未満"
    },
    "JVNDB-2020-014022": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-014317": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat OpenShift Container Platform\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-014575": {
        "title": "Linux kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.10.1 まで\nNetApp\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire & HCI Storage Node\nHCI Compute Node Bios\nXen プロジェクト\nXen 4.14.x まで"
    },
    "JVNDB-2020-014023": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2020-014190": {
        "title": "Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.9.13 まで"
    },
    "JVNDB-2020-014683": {
        "title": "Linux-Pam における認証に関する脆弱性",
        "description": "",
        "technologies": "Linux-Pam\nLinux-PAM 1.5.1 未満"
    },
    "JVNDB-2020-014935": {
        "title": "TeamworkCloud における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "",
        "technologies": "Dassault Systemes\nTeamwork Cloud 18.0 から 19.0"
    },
    "JVNDB-2020-015529": {
        "title": "Linux Kernel におけるパストラバーサルの脆弱性",
        "description": "",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.10.7 未満"
    },
    "JVNDB-2020-015983": {
        "title": "Linux 用 Intel(R) FPGA OPAE ドライバにおける制御されていない検索パスの要素に関する脆弱性",
        "description": "",
        "technologies": "インテル\nIntel Trace Analyzer and Collector"
    },
    "JVNDB-2020-015564": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Canonical\nUbuntu\nLinux\nLinux Kernel"
    },
    "JVNDB-2020-016137": {
        "title": "Windows および Linux 用 Intel(R) Graphics Drivers における整数オーバーフローの脆弱性",
        "description": "",
        "technologies": "インテル\nIntel Graphics Drivers for Windows 26.20.100.7212 未満\nIntel Graphics Drivers for Linux kernel 5.5 未満"
    },
    "JVNDB-2020-016501": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.7 未満"
    },
    "JVNDB-2020-016691": {
        "title": "Exim における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Exim Development\nExim 4.94.2 未満の 4"
    },
    "JVNDB-2021-007246": {
        "title": "複数の OS 上で稼動する IBM DB2 における制御されていない検索パスの要素に関する脆弱性",
        "description": "IBM Db2 for Linux, UNIX and Windows (includes Db2 Connect Server) 9.7, 10.1, 10.5, 11.1, and 11.5 could allow a local user to execute arbitrary code and conduct DLL hijacking attacks.",
        "technologies": "IBM\nIBM DB2 9.7\nIBM DB2 10.1\nIBM DB2 10.5\nIBM DB2 11.1\nIBM DB2 11.5"
    },
    "JVNDB-2021-001912": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.11.14 未満"
    },
    "JVNDB-2021-006886": {
        "title": "Endpoint Security for Linux Threat Prevention and Firewall における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "By exploiting a time of check to time of use (TOCTOU) race condition during the Endpoint Security for Linux Threat Prevention and Firewall (ENSL TP/FW) installation process, a local user can perform a privilege escalation attack to obtain administrator privileges for the purpose of executing arbitrary code through insecure use of predictable temporary file locations.",
        "technologies": "マカフィー\nEndpoint Security for Linux Threat Prevention (ENSLTP)"
    },
    "JVNDB-2021-007006": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel before 5.12.4, net/bluetooth/hci_event.c has a use-after-free when destroying an hci_chan, aka CID-5c4c8c954409. This leads to writing an arbitrary value.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.12.4 未満"
    },
    "JVNDB-2021-006584": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A flaw was found in the Linux kernel in versions before 5.12. The value of internal.ndata, in the KVM API, is mapped to an array index, which can be updated by a user process at anytime which could lead to an out-of-bounds write. The highest threat from this vulnerability is to data integrity and system availability.",
        "technologies": "Linux\nLinux Kernel 5.12 未満\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2021-009120": {
        "title": "linuxptp パッケージにおけるバッファエラーの脆弱性",
        "description": "A flaw was found in the ptp4l program of the linuxptp package. When ptp4l is operating on a little-endian architecture as a PTP transparent clock, a remote attacker could send a crafted one-step sync message to cause an information leak or crash. The highest threat from this vulnerability is to data confidentiality and system availability. This flaw affects linuxptp versions before 3.1.1 and before 2.0.1.",
        "technologies": "Fedora Project\nFedora\nlinuxptp project\nlinuxptp 3.1.1 未満\nlinuxptp 2.0.1 未満\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2020-011333": {
        "title": "Linux 用 Private Internet Access VPN Client における情報漏えいに関する脆弱性",
        "description": "",
        "technologies": "London Trust Media, Inc.\nPrivate Internet Access 1.5 から 2.3"
    },
    "JVNDB-2020-011295": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.9-rc4 未満"
    },
    "JVNDB-2021-006571": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "net/bluetooth/hci_request.c in the Linux kernel through 5.12.2 has a race condition for removal of the HCI controller.",
        "technologies": "Linux\nLinux Kernel 5.12.2 まで"
    },
    "JVNDB-2021-009171": {
        "title": "Linux kernel における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 5.14.8. A use-after-free in selinux_ptrace_traceme (aka the SELinux handler for PTRACE_TRACEME) could be used by local attackers to cause memory corruption and escalate privileges, aka CID-a3727a8bac0a. This occurs because of an attempt to access the subjective credentials of another task.",
        "technologies": "Linux\nLinux Kernel 5.9-rc-7 まで\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-006453": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "Use After Free vulnerability in nfc sockets in the Linux Kernel before 5.12.4 allows local attackers to elevate their privileges. In typical configurations, the issue can only be triggered by a privileged local user with the CAP_NET_RAW capability.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.12.4 未満"
    },
    "JVNDB-2021-009166": {
        "title": "Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "drivers/net/ethernet/xilinx/ll_temac_main.c in the Linux kernel before 5.12.13 allows remote attackers to cause a denial of service (buffer overflow and lockup) by sending heavy network traffic for about ten minutes.",
        "technologies": "Linux\nLinux Kernel 5.12.13 未満"
    },
    "JVNDB-2021-009244": {
        "title": "Linux Kernel におけるパーミッションの不適切な保持に関する脆弱性",
        "description": "An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel"
    },
    "JVNDB-2021-009227": {
        "title": "Linux および ChromeOS 上で稼働する Google Chrome における境界外書き込みに関する脆弱性",
        "description": "Out of bounds write in Tab Groups in Google Chrome on Linux and ChromeOS prior to 92.0.4515.107 allowed an attacker who convinced a user to install a malicious extension to perform an out of bounds memory write via a crafted HTML page.",
        "technologies": "Fedora Project\nFedora\nGoogle\nGoogle Chrome 92.0.4515.107 未満"
    },
    "JVNDB-2021-006735": {
        "title": "Linux kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel 5.11 through 5.12.2, isotp_setsockopt in net/can/isotp.c allows privilege escalation to root by leveraging a use-after-free. (This does not affect earlier versions that lack CAN ISOTP SF_BROADCAST support.)",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.11 から 5.12.2"
    },
    "JVNDB-2020-016795": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A vulnerability was found in Linux Kernel, where a refcount leak in llcp_sock_connect() causing use-after-free which might lead to privilege escalations.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel"
    },
    "JVNDB-2020-016780": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "A memory leak vulnerability was found in Linux kernel in llcp_sock_connect",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel"
    },
    "JVNDB-2020-016716": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds (OOB) memory access flaw was found in x25_bind in net/x25/af_x25.c in the Linux kernel version v5.12-rc5. A bounds check failure allows a local attacker with a user account on the system to gain access to out-of-bounds memory, leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "technologies": "Linux\nLinux Kernel 5.12-rc5"
    },
    "JVNDB-2020-018211": {
        "title": "Linux Foundation の Indy Node におけるデジタル署名の検証に関する脆弱性",
        "description": "Hyperledger Indy Node is the server portion of a distributed ledger purpose-built for decentralized identity. In Hyperledger Indy before version 1.12.4, there is lack of signature verification on a specific transaction which enables an attacker to make certain unauthorized alterations to the ledger. Updating a DID with a nym transaction will be written to the ledger if neither ROLE or VERKEY are being changed, regardless of sender. A malicious DID with no particular role can ask an update for another DID (but cannot modify its verkey or role). This is bad because 1) Any DID can write a nym transaction to the ledger (i.e., any DID can spam the ledger with nym transactions), 2) Any DID can change any other DID's alias, 3) The update transaction modifies the ledger metadata associated with a DID.",
        "technologies": "Linux Foundation\nIndy Node 1.12.4 未満"
    },
    "JVNDB-2020-016797": {
        "title": "Linux Kernel における不適切な同期に関する脆弱性",
        "description": "A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel"
    },
    "JVNDB-2020-016799": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A flaw was found in the JFS filesystem code in the Linux Kernel which allows a local attacker with the ability to set extended attributes to panic the system, causing memory corruption or escalating privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-009551": {
        "title": "Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.13.4 未満\nNetApp\nElement Software\nNetApp HCI Management Node\nNetApp SolidFire\nHCI Bootstrap OS"
    },
    "JVNDB-2021-009251": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "fs/nfsd/trace.h in the Linux kernel before 5.13.4 might allow remote attackers to cause a denial of service (out-of-bounds read in strlen) by sending NFS traffic when the trace event framework is being used for nfsd.",
        "technologies": "Linux\nLinux Kernel 5.13.4 未満\nNetApp\nElement Software\nNetApp HCI Management Node\nHCI Bootstrap OS"
    },
    "JVNDB-2020-018339": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: atomisp: Fix use after free in atomisp_alloc_css_stat_bufs() The \"s3a_buf\" is freed along with all the other items on the \"asd->s3a_stats\" list. It leads to a double free and a use after free.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2020-017643": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the \"Routing decision\" classifier in the Linux kernel's Traffic Control networking subsystem in the way it handled changing of classification filters, leading to a use-after-free condition. This flaw allows unprivileged local users to escalate their privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2021-009554": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In kernel/bpf/hashtab.c in the Linux kernel through 5.13.8, there is an integer overflow and out-of-bounds write when many elements are placed in a single bucket. NOTE: exploitation might be impractical without the CAP_SYS_ADMIN capability.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.13.8 まで"
    },
    "JVNDB-2020-016805": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A vulnerability was found in Linux Kernel where refcount leak in llcp_sock_bind() causing use-after-free which might lead to privilege escalations.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel"
    },
    "JVNDB-2020-017341": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.14.12 未満\nNetApp\nNetApp Cloud Backup\nNetApp HCI Management Node\nNetApp SolidFire\nH300S ファームウェア\nH410C ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2020-018359": {
        "title": "フォーティネットの Linux 用 FortiClient における権限管理に関する脆弱性",
        "description": "An execution with unnecessary privileges vulnerability in the VCM engine of FortiClient for Linux versions 6.2.7 and below, version 6.4.0. may allow local users to elevate their privileges to root by creating a malicious script or program on the target machine.",
        "technologies": "フォーティネット\nFortiClient 6.0.0 以上 6.2.8 未満\nFortiClient 6.4.0"
    },
    "JVNDB-2020-018346": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/nouveau: avoid a use-after-free when BO init fails nouveau_bo_init() is backed by ttm_bo_init() and ferries its return code back to the caller. On failures, ttm_bo_init() invokes the provided destructor which should de-initialize and free the memory. Thus, when nouveau_bo_init() returns an error the gem object has already been released and the memory freed by nouveau_bo_del_ttm().",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.10.73 未満\nLinux Kernel 5.11 以上 5.14.12 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2020-017460": {
        "title": "Linux_Network_Project における古典的バッファオーバーフローの脆弱性",
        "description": "Buffer overflow vulnerability in Renleilei1992 Linux_Network_Project 1.0, allows attackers to execute arbitrary code, via the password field.",
        "technologies": "Linux_Network_Project\nLinux_Network_Project 1.0"
    },
    "JVNDB-2020-017290": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 5.8.1. net/bluetooth/hci_event.c has a slab out-of-bounds read in hci_extended_inquiry_result_evt, aka CID-51c19bf3d5cf.",
        "technologies": "Linux\nLinux Kernel 5.8.1 未満"
    },
    "JVNDB-2020-016950": {
        "title": "Linux-PAM 用 pam_setquota における脆弱性",
        "description": "pam_setquota.c in the pam_setquota module before 2020-05-29 for Linux-PAM allows local attackers to set their quota on an arbitrary filesystem, in certain situations where the attacker's home directory is a FUSE filesystem mounted under /home.",
        "technologies": "pam_setquota project\npam_setquota 2020/05/29 より前"
    },
    "JVNDB-2020-016798": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel"
    },
    "JVNDB-2021-009967": {
        "title": "Linux Kernel におけるバッファエラーの脆弱性",
        "description": "net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations.",
        "technologies": "Linux\nLinux Kernel 5.13.4 未満\nNetApp\nElement Software\nNetApp HCI Management Node\nNetApp SolidFire\nHCI Bootstrap OS"
    },
    "JVNDB-2021-009960": {
        "title": "Linux 上で稼働する iDrive RemotePC における脆弱性",
        "description": "iDrive RemotePC before 4.0.1 on Linux allows denial of service. A remote and unauthenticated attacker can disconnect a valid user session by connecting to an ephemeral port.",
        "technologies": "IDrive Inc.\nRemotePC 4.0.1 未満"
    },
    "JVNDB-2021-009775": {
        "title": "Cohesity Linux agent における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "A permission issue in the Cohesity Linux agent may allow privilege escalation in version 6.5.1b to 6.5.1d-hotfix10, 6.6.0a to 6.6.0b-hotfix1. An underprivileged linux user, if certain environment criteria are met, can gain additional privileges.",
        "technologies": "Cohesity\nLinux agent 6.5.1b から 6.5.1d-hotfix10\nLinux agent 6.6.0a から 6.6.0b-hotfix1"
    },
    "JVNDB-2021-010088": {
        "title": "Windows および Linux 用 NVIDIA GPU Display Driver における古典的バッファオーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Windows and Linux contains a vulnerability in the kernel mode layer (nvlddmkm.sys) handler for control calls where the software reads or writes to a buffer by using an index or pointer that references a memory location after the end of the buffer, which may lead to data tampering or denial of service.",
        "technologies": "NVIDIA\nNVIDIA GPU ディスプレイドライバ"
    },
    "JVNDB-2021-010519": {
        "title": "Jetson Linux における整数アンダーフローの脆弱性",
        "description": "NVIDIA Linux kernel distributions contain a vulnerability in FuSa Capture (VI/ISP), where integer underflow due to lack of input validation may lead to complete denial of service, partial integrity, and serious confidentiality loss for all processes in the system.",
        "technologies": "NVIDIA\nSHIELD Experience\nJetson Linux"
    },
    "JVNDB-2021-010520": {
        "title": "Jetson Linux における脆弱性",
        "description": "NVIDIA Linux kernel distributions contain a vulnerability in nvmap NVMAP_IOC_WRITE* paths, where improper access controls may lead to code execution, complete denial of service, and seriously compromised integrity of all system components.",
        "technologies": "NVIDIA\nSHIELD Experience\nJetson Linux"
    },
    "JVNDB-2021-010003": {
        "title": "Linux Kernel  におけるデジタル署名の検証に関する脆弱性",
        "description": "kernel/module.c in the Linux kernel before 5.12.14 mishandles Signature Verification, aka CID-0c18f29aae7c. Without CONFIG_MODULE_SIG, verification that a kernel module is signed, for loading via init_module, does not occur for a module.sig_enforce=1 command-line argument.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.12.14 未満"
    },
    "JVNDB-2021-010508": {
        "title": "Jetson Linux における入力確認に関する脆弱性",
        "description": "NVIDIA Linux kernel distributions on Jetson Xavier contain a vulnerability in camera firmware where a user can change input data after validation, which may lead to complete denial of service and serious data corruption of all kernel components.",
        "technologies": "NVIDIA\nJetson Linux"
    },
    "JVNDB-2021-010427": {
        "title": "Intel(R) Ethernet Controller 800 シリーズ Linux ドライバにおける例外的な状態のチェックに関する脆弱性",
        "description": "Improper conditions check in some Intel(R) Ethernet Controllers 800 series Linux drivers before version 1.4.11 may allow an authenticated user to potentially enable information disclosure or denial of service via local access.",
        "technologies": "Fedora Project\nFedora\nインテル\nIntel Ethernet Controller E810 ファームウェア 1.4.11 未満"
    },
    "JVNDB-2021-010521": {
        "title": "Jetson Linux における境界外書き込みに関する脆弱性",
        "description": "NVIDIA Linux kernel distributions contain a vulnerability in nvmap, where writes may be allowed to read-only buffers, which may result in escalation of privileges, complete denial of service, unconstrained information disclosure, and serious data tampering of all processes on the system.",
        "technologies": "NVIDIA\nSHIELD Experience\nJetson Linux"
    },
    "JVNDB-2021-010945": {
        "title": "klibc における整数オーバーフローの脆弱性",
        "description": "An issue was discovered in klibc before 2.0.9. Additions in the malloc() function may result in an integer overflow and a subsequent heap buffer overflow.",
        "technologies": "Debian\nDebian GNU/Linux\nklib project\nklibc 2.0.9 未満"
    },
    "JVNDB-2021-012136": {
        "title": "Linux Kernel における脆弱性",
        "description": "arch/mips/net/bpf_jit.c in the Linux kernel before 5.4.10 can generate undesirable machine code when transforming unprivileged cBPF programs, allowing execution of arbitrary code within the kernel context. This occurs because conditional branches can exceed the 128 KB limit of the MIPS architecture.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.4.10 未満\nNetApp\nNetApp Cloud Backup\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-010536": {
        "title": "Intel(R) Ethernet Controller X722 および 800 シリーズ Linux RMDA ドライバにおける入力確認に関する脆弱性",
        "description": "Improper input validation in the Intel(R) Ethernet Controllers X722 and 800 series Linux RMDA driver before version 1.3.19 may allow an authenticated user to potentially enable escalation of privilege via local access.",
        "technologies": "インテル\nIntel Ethernet Controller E810 ファームウェア 1.3.19 未満\nIntel Ethernet Network Adapter X722-DA2 ファームウェア 1.3.19 未満\nIntel Ethernet Network Adapter X722-DA4FH ファームウェア 1.3.19 未満\nIntel Ethernet Network Adapter X722-DA4G1P5 ファームウェア 1.3.19 未満"
    },
    "JVNDB-2021-011860": {
        "title": "Oracle Linux における脆弱性",
        "description": "Vulnerability in Oracle Linux (component: OSwatcher). Supported versions that are affected are 7 and 8. Easily exploitable vulnerability allows low privileged attacker with logon to the infrastructure where Oracle Linux executes to compromise Oracle Linux. Successful attacks of this vulnerability can result in takeover of Oracle Linux. CVSS 3.1 Base Score 7.8 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H).",
        "technologies": "オラクル\nOracle Linux 7\nOracle Linux 8"
    },
    "JVNDB-2021-011368": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "A race condition was discovered in ext4_write_inline_data_end in fs/ext4/inline.c in the ext4 subsystem in the Linux kernel through 5.13.13.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.13.13まで\nNetApp\nAFF A250 ファームウェア\nFAS500f ファームウェア\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-012234": {
        "title": "SUSE Linux Enterprise Server および openSUSE Factory におけるリンク解釈に関する脆弱性",
        "description": "A UNIX Symbolic Link (Symlink) Following vulnerability in the clone-master-clean-up.sh script of clone-master-clean-up in SUSE Linux Enterprise Server 12 SP3, SUSE Linux Enterprise Server 15 SP1; openSUSE Factory allows local attackers to delete arbitrary files. This issue affects: SUSE Linux Enterprise Server 12 SP3 clone-master-clean-up version 1.6-4.6.1 and prior versions. SUSE Linux Enterprise Server 15 SP1 clone-master-clean-up version 1.6-3.9.1 and prior versions. openSUSE Factory clone-master-clean-up version 1.6-1.4 and prior versions.",
        "technologies": "openSUSE project\nopenSUSE Factory\nSUSE\nSUSE Linux Enterprise Server"
    },
    "JVNDB-2021-011024": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "arch/x86/kvm/svm/nested.c in the Linux kernel before 5.11.12 has a use-after-free in which an AMD KVM guest can bypass access control on host OS MSRs when there are nested guests, aka CID-a58d9166a756. This occurs because of a TOCTOU race condition associated with a VMCB12 double fetch in nested_svm_vmrun.",
        "technologies": "Linux\nLinux Kernel 5.11.12 未満"
    },
    "JVNDB-2021-012170": {
        "title": "Linux、UNIX、Windows 用 IBM Db2 における脆弱性",
        "description": "IBM Db2 for Linux, UNIX and Windows (includes Db2 Connect Server) could disclose sensitive information when using ADMIN_CMD with LOAD or BACKUP. IBM X-Force ID: 204470.",
        "technologies": "IBM\nIBM DB2"
    },
    "JVNDB-2021-012801": {
        "title": "Linux Kernel における入力確認に関する脆弱性",
        "description": "An issue was discovered in net/tipc/crypto.c in the Linux kernel before 5.14.16. The Transparent Inter-Process Communication (TIPC) functionality allows remote attackers to exploit insufficient validation of user-supplied sizes for the MSG_CRYPTO message type.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.14.16 未満\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-013154": {
        "title": "Flatpak における脆弱性",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nFlatpak\nFlatpak 1.10.4 未満\nFlatpak 1.12.0 未満"
    },
    "JVNDB-2021-012742": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 3.16 から 5.13.4 未満の 5.13.x\nNetApp\nNetApp HCI Management Node\nNetApp SolidFire\nオラクル\nOracle Communications Session Border Controller\n日立\nHA8000V シリーズ\nRV3000"
    },
    "JVNDB-2021-013117": {
        "title": "Linux および Mac OS 用 Cisco AnyConnect Secure Mobility Client における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "A vulnerability in the shared library loading mechanism of Cisco AnyConnect Secure Mobility Client for Linux and Mac OS could allow an authenticated, local attacker to perform a shared library hijacking attack on an affected device if the VPN Posture (HostScan) Module is installed on the AnyConnect client. This vulnerability is due to a race condition in the signature verification process for shared library files that are loaded on an affected device. An attacker could exploit this vulnerability by sending a series of crafted interprocess communication (IPC) messages to the AnyConnect process. A successful exploit could allow the attacker to execute arbitrary code on the affected device with root privileges. To exploit this vulnerability, the attacker must have a valid account on the system.",
        "technologies": "シスコシステムズ\nCisco AnyConnect Secure Mobility Client"
    },
    "JVNDB-2021-020887": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFS: fs_context: validate UDP retrans to prevent shift out-of-bounds Fix shift out-of-bounds in xprt_calc_majortimeo(). This is caused by a garbage timeout (retrans) mount option being passed to nfs mount, in this case from syzkaller. If the protocol is XPRT_TRANSPORT_UDP, then 'retrans' is a shift value for a 64-bit long integer, so 'retrans' cannot be >= 64. If it is >= 64, fail the mount and return an error.",
        "technologies": "Linux\nLinux Kernel 5.6.0 以上 5.10.36 未満\nLinux Kernel 5.11.0 以上 5.11.20 未満\nLinux Kernel 5.12.0 以上 5.12.3 未満"
    },
    "JVNDB-2021-012329": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "The eBPF RINGBUF bpf_ringbuf_reserve() function in the Linux kernel did not check that the allocated size was smaller than the ringbuf size, allowing an attacker to perform out-of-bounds writes within the kernel and therefore, arbitrary code execution. This issue was fixed via commit 4b81ccebaeee (\"bpf, ringbuf: Deny reserve of buffers larger than ringbuf\") (v5.13-rc4) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced via 457f44363a88 (\"bpf: Implement BPF ring buffer and verifier support for it\") (v5.8-rc1).",
        "technologies": "Canonical\nUbuntu\nLinux\nLinux Kernel"
    },
    "JVNDB-2021-012533": {
        "title": "Linux Kernel における権限管理に関する脆弱性",
        "description": "loop_rw_iter in fs/io_uring.c in the Linux kernel 5.10 through 5.14.6 allows local users to gain privileges by using IORING_OP_PROVIDE_BUFFERS to trigger a free of a kernel buffer, as demonstrated by using /proc/<pid>/maps for exploitation.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.10 から 5.14.6\nNetApp\nNetApp Cloud Backup\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2021-012449": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.13.5 まで"
    },
    "JVNDB-2021-012326": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/<PID>/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b (\"io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers\") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c (\"io_uring: add IORING_OP_PROVIDE_BUFFERS\") (v5.7-rc1).",
        "technologies": "Canonical\nUbuntu\nLinux\nLinux Kernel"
    },
    "JVNDB-2021-012328": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "The eBPF ALU32 bounds tracking for bitwise ops (AND, OR and XOR) in the Linux kernel did not properly update 32-bit bounds, which could be turned into out of bounds reads and writes in the Linux kernel and therefore, arbitrary code execution. This issue was fixed via commit 049c4e13714e (\"bpf: Fix alu32 const subreg bound tracking on bitwise operations\") (v5.13-rc4) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. The AND/OR issues were introduced by commit 3f50f132d840 (\"bpf: Verifier, do explicit ALU32 bounds tracking\") (5.7-rc1) and the XOR variant was introduced by 2921c90d4718 (\"bpf:Fix a verifier failure with xor\") ( 5.10-rc1).",
        "technologies": "Canonical\nUbuntu\nLinux\nLinux Kernel"
    },
    "JVNDB-2021-020893": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: sch_frag: fix stack OOB read while fragmenting IPv4 packets when 'act_mirred' tries to fragment IPv4 packets that had been previously re-assembled using 'act_ct', splats like the following can be observed on kernels built with KASAN: BUG: KASAN: stack-out-of-bounds in ip_do_fragment+0x1b03/0x1f60 Read of size 1 at addr ffff888147009574 by task ping/947 CPU: 0 PID: 947 Comm: ping Not tainted 5.12.0-rc6+ #418 Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014 Call Trace: <IRQ> dump_stack+0x92/0xc1 print_address_description.constprop.7+0x1a/0x150 kasan_report.cold.13+0x7f/0x111 ip_do_fragment+0x1b03/0x1f60 sch_fragment+0x4bf/0xe40 tcf_mirred_act+0xc3d/0x11a0 [act_mirred] tcf_action_exec+0x104/0x3e0 fl_classify+0x49a/0x5e0 [cls_flower] tcf_classify_ingress+0x18a/0x820 __netif_receive_skb_core+0xae7/0x3340 __netif_receive_skb_one_core+0xb6/0x1b0 process_backlog+0x1ef/0x6c0 __napi_poll+0xaa/0x500 net_rx_action+0x702/0xac0 __do_softirq+0x1e4/0x97f do_softirq+0x71/0x90 </IRQ> __local_bh_enable_ip+0xdb/0xf0 ip_finish_output2+0x760/0x2120 ip_do_fragment+0x15a5/0x1f60 __ip_finish_output+0x4c2/0xea0 ip_output+0x1ca/0x4d0 ip_send_skb+0x37/0xa0 raw_sendmsg+0x1c4b/0x2d00 sock_sendmsg+0xdb/0x110 __sys_sendto+0x1d7/0x2b0 __x64_sys_sendto+0xdd/0x1b0 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f82e13853eb Code: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 f3 0f 1e fa 48 8d 05 75 42 2c 00 41 89 ca 8b 00 85 c0 75 14 b8 2c 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 75 c3 0f 1f 40 00 41 57 4d 89 c7 41 56 41 89 RSP: 002b:00007ffe01fad888 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 00005571aac13700 RCX: 00007f82e13853eb RDX: 0000000000002330 RSI: 00005571aac13700 RDI: 0000000000000003 RBP: 0000000000002330 R08: 00005571aac10500 R09: 0000000000000010 R10: 0000000000000000 R11: 0000000000000246 R12: 00007ffe01faefb0 R13: 00007ffe01fad890 R14: 00007ffe01fad980 R15: 00005571aac0f0a0 The buggy address belongs to the page: page:000000001dff2e03 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x147009 flags: 0x17ffffc0001000(reserved) raw: 0017ffffc0001000 ffffea00051c0248 ffffea00051c0248 0000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888147009400: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888147009480: f1 f1 f1 f1 04 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 >ffff888147009500: 00 00 00 00 00 00 00 00 00 00 f2 f2 f2 f2 f2 f2 ^ ffff888147009580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888147009600: 00 00 00 00 00 00 00 00 00 00 00 00 00 f2 f2 f2 for IPv4 packets, sch_fragment() uses a temporary struct dst_entry. Then, in the following call graph: ip_do_fragment() ip_skb_dst_mtu() ip_dst_mtu_maybe_forward() ip_mtu_locked() the pointer to struct dst_entry is used as pointer to struct rtable: this turns the access to struct members like rt_mtu_locked into an OOB read in the stack. Fix this changing the temporary variable used for IPv4 packets in sch_fragment(), similarly to what is done for IPv6 few lines below.",
        "technologies": "Linux\nLinux Kernel 5.11.0 以上 5.11.20 未満\nLinux Kernel 5.12.0 以上 5.12.3 未満"
    },
    "JVNDB-2021-020900": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: fix use-after-free in tw_timer_handler A real world panic issue was found as follow in Linux 5.4. BUG: unable to handle page fault for address: ffffde49a863de28 PGD 7e6fe62067 P4D 7e6fe62067 PUD 7e6fe63067 PMD f51e064067 PTE 0 RIP: 0010:tw_timer_handler+0x20/0x40 Call Trace: <IRQ> call_timer_fn+0x2b/0x120 run_timer_softirq+0x1ef/0x450 __do_softirq+0x10d/0x2b8 irq_exit+0xc7/0xd0 smp_apic_timer_interrupt+0x68/0x120 apic_timer_interrupt+0xf/0x20 This issue was also reported since 2017 in the thread [1], unfortunately, the issue was still can be reproduced after fixing DCCP. The ipv4_mib_exit_net is called before tcp_sk_exit_batch when a net namespace is destroyed since tcp_sk_ops is registered befrore ipv4_mib_ops, which means tcp_sk_ops is in the front of ipv4_mib_ops in the list of pernet_list. There will be a use-after-free on net->mib.net_statistics in tw_timer_handler after ipv4_mib_exit_net if there are some inflight time-wait timers. This bug is not introduced by commit f2bf415cfed7 (\"mib: add net to NET_ADD_STATS_BH\") since the net_statistics is a global variable instead of dynamic allocation and freeing. Actually, commit 61a7e26028b9 (\"mib: put net statistics on struct net\") introduces the bug since it put net statistics on struct net and free it when net namespace is destroyed. Moving init_ipv4_mibs() to the front of tcp_init() to fix this bug and replace pr_crit() with panic() since continuing is meaningless when init_ipv4_mibs() fails. [1] https://groups.google.com/g/syzkaller/c/p1tn-_Kc6l4/m/smuL_FMAAgAJ?pli=1",
        "technologies": "Linux\nLinux Kernel 2.6.27 以上 4.4.298 未満\nLinux Kernel 4.5.0 以上 4.9.296 未満\nLinux Kernel 4.10.0 以上 4.14.261 未満\nLinux Kernel 4.15.0 以上 4.19.224 未満\nLinux Kernel 4.20.0 以上 5.4.170 未満\nLinux Kernel 5.5.0 以上 5.10.90 未満\nLinux Kernel 5.11.0 以上 5.15.13 未満"
    },
    "JVNDB-2021-020925": {
        "title": "Linux の Linux Kernel における初期化に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cfg80211: call cfg80211_stop_ap when switch from P2P_GO type If the userspace tools switch from NL80211_IFTYPE_P2P_GO to NL80211_IFTYPE_ADHOC via send_msg(NL80211_CMD_SET_INTERFACE), it does not call the cleanup cfg80211_stop_ap(), this leads to the initialization of in-use data. For example, this path re-init the sdata->assigned_chanctx_list while it is still an element of assigned_vifs list, and makes that linked list corrupt.",
        "technologies": "Linux\nLinux Kernel 3.6.0 以上 4.4.293 未満\nLinux Kernel 4.5.0 以上 4.9.291 未満\nLinux Kernel 4.10.0 以上 4.14.256 未満\nLinux Kernel 4.15.0 以上 4.19.218 未満\nLinux Kernel 4.20.0 以上 5.4.162 未満\nLinux Kernel 5.5.0 以上 5.10.82 未満\nLinux Kernel 5.11.0 以上 5.15.5 未満"
    },
    "JVNDB-2021-020923": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Fix use-after-free in lpfc_unreg_rpi() routine An error is detected with the following report when unloading the driver: \"KASAN: use-after-free in lpfc_unreg_rpi+0x1b1b\" The NLP_REG_LOGIN_SEND nlp_flag is set in lpfc_reg_fab_ctrl_node(), but the flag is not cleared upon completion of the login. This allows a second call to lpfc_unreg_rpi() to proceed with nlp_rpi set to LPFC_RPI_ALLOW_ERROR. This results in a use after free access when used as an rpi_ids array index. Fix by clearing the NLP_REG_LOGIN_SEND nlp_flag in lpfc_mbx_cmpl_fc_reg_login().",
        "technologies": "Linux\nLinux Kernel 5.15.5 未満"
    },
    "JVNDB-2021-020936": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx4_en: Fix an use-after-free bug in mlx4_en_try_alloc_resources() In mlx4_en_try_alloc_resources(), mlx4_en_copy_priv() is called and tmp->tx_cq will be freed on the error path of mlx4_en_copy_priv(). After that mlx4_en_alloc_resources() is called and there is a dereference of &tmp->tx_cq[t][i] in mlx4_en_alloc_resources(), which could lead to a use after free problem on failure of mlx4_en_copy_priv(). Fix this bug by adding a check of mlx4_en_copy_priv() This bug was found by a static analyzer. The analysis employs differential checking to identify inconsistent security operations (e.g., checks or kfrees) between two code paths and confirms that the inconsistent operations are not recovered in the current function or the callers, so they constitute bugs. Note that, as a bug found by static analysis, it can be a false positive or hard to trigger. Multiple researchers have cross-reviewed the bug. Builds with CONFIG_MLX4_EN=m show no new warnings, and our static analyzer no longer warns about this code.",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.14.257 未満\nLinux Kernel 4.15 以上 4.19.220 未満\nLinux Kernel 4.20 以上 5.4.164 未満\nLinux Kernel 5.5 以上 5.10.84 未満\nLinux Kernel 5.11 以上 5.15.7 未満"
    },
    "JVNDB-2021-020942": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: pch_can: pch_can_rx_normal: fix use after free After calling netif_receive_skb(skb), dereferencing skb is unsafe. Especially, the can_frame cf which aliases skb memory is dereferenced just after the call netif_receive_skb(skb). Reordering the lines solves the issue.",
        "technologies": "Linux\nLinux Kernel 2.6.37 以上 4.4.295 未満\nLinux Kernel 4.5 以上 4.9.293 未満\nLinux Kernel 4.10 以上 4.14.258 未満\nLinux Kernel 4.15 以上 4.19.221 未満\nLinux Kernel 4.20 以上 5.4.165 未満\nLinux Kernel 5.5 以上 5.10.85 未満\nLinux Kernel 5.11 以上 5.15.8 未満"
    },
    "JVNDB-2021-020947": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: serial: liteuart: fix use-after-free and memleak on unbind Deregister the port when unbinding the driver to prevent it from being used after releasing the driver data and leaking memory allocated by serial core.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.7 未満"
    },
    "JVNDB-2021-020950": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: staging: rtl8192e: Fix use after free in _rtl92e_pci_disconnect() The free_rtllib() function frees the \"dev\" pointer so there is use after free on the next line. Re-arrange things to avoid that.",
        "technologies": "Linux\nLinux Kernel 3.2 以上 4.4.294 未満\nLinux Kernel 4.5 以上 4.9.292 未満\nLinux Kernel 4.10 以上 4.14.257 未満\nLinux Kernel 4.15 以上 4.19.219 未満\nLinux Kernel 4.20 以上 5.4.163 未満\nLinux Kernel 5.5 以上 5.10.83 未満\nLinux Kernel 5.11 以上 5.15.6 未満"
    },
    "JVNDB-2021-020941": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: sja1000: fix use after free in ems_pcmcia_add_card() If the last channel is not available then \"dev\" is freed. Fortunately, we can just use \"pdev->irq\" instead. Also we should check if at least one channel was set up.",
        "technologies": "Linux\nLinux Kernel 3.2 以上 4.4.295 未満\nLinux Kernel 4.5 以上 4.9.293 未満\nLinux Kernel 4.10 以上 4.14.258 未満\nLinux Kernel 4.15 以上 4.19.221 未満\nLinux Kernel 4.20 以上 5.4.165 未満\nLinux Kernel 5.5 以上 5.10.85 未満\nLinux Kernel 5.11 以上 5.15.8 未満"
    },
    "JVNDB-2021-021259": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: fix use-after-free bug in hclgevf_send_mbx_msg Currently, the hns3_remove function firstly uninstall client instance, and then uninstall acceletion engine device. The netdevice is freed in client instance uninstall process, but acceletion engine device uninstall process still use it to trace runtime information. This causes a use after free problem. So fixes it by check the instance register state to avoid use after free.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.88 未満\nLinux Kernel 5.11 以上 5.15.11 未満"
    },
    "JVNDB-2021-021262": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sunrpc: fix reference count leaks in rpc_sysfs_xprt_state_change The refcount leak issues take place in an error handling path. When the 3rd argument buf doesn't match with \"offline\", \"online\" or \"remove\", the function simply returns -EINVAL and forgets to decrease the reference count of a rpc_xprt object and a rpc_xprt_switch object increased by rpc_sysfs_xprt_kobj_get_xprt() and rpc_sysfs_xprt_kobj_get_xprt_switch(), causing reference count leaks of both unused objects. Fix this issue by jumping to the error handling path labelled with out_put when buf matches none of \"offline\", \"online\" or \"remove\".",
        "technologies": "Linux\nLinux Kernel 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満"
    },
    "JVNDB-2021-021264": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA: Fix use-after-free in rxe_queue_cleanup On error handling path in rxe_qp_from_init() qp->sq.queue is freed and then rxe_create_qp() will drop last reference to this object. qp clean up function will try to free this queue one time and it causes UAF bug. Fix it by zeroing queue pointer after freeing queue in rxe_qp_from_init().",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.10 未満"
    },
    "JVNDB-2021-021242": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "The decode_data function in drivers/net/hamradio/6pack.c in the Linux kernel before 5.13.13 has a slab out-of-bounds write. Input from a process that has the CAP_NET_ADMIN capability can lead to root access.",
        "technologies": "Debian\nDebian GNU/Linux 9.0\nLinux\nLinux Kernel 2.6.12 以上 4.4.282 未満\nLinux Kernel 4.5 以上 4.9.281 未満\nLinux Kernel 4.10 以上 4.14.245 未満\nLinux Kernel 4.15 以上 4.19.205 未満\nLinux Kernel 4.20 以上 5.4.143 未満\nLinux Kernel 5.5 以上 5.10.61 未満\nLinux Kernel 5.11 以上 5.13.13 未満\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア\nSolidFire Baseboard Management Controller ファームウェア"
    },
    "JVNDB-2021-021269": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sch_cake: do not call cake_destroy() from cake_init() qdiscs are not supposed to call their own destroy() method from init(), because core stack already does that. syzbot was able to trigger use after free: DEBUG_LOCKS_WARN_ON(lock->magic != lock) WARNING: CPU: 0 PID: 21902 at kernel/locking/mutex.c:586 __mutex_lock_common kernel/locking/mutex.c:586 [inline] WARNING: CPU: 0 PID: 21902 at kernel/locking/mutex.c:586 __mutex_lock+0x9ec/0x12f0 kernel/locking/mutex.c:740 Modules linked in: CPU: 0 PID: 21902 Comm: syz-executor189 Not tainted 5.16.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP: 0010:__mutex_lock_common kernel/locking/mutex.c:586 [inline] RIP: 0010:__mutex_lock+0x9ec/0x12f0 kernel/locking/mutex.c:740 Code: 08 84 d2 0f 85 19 08 00 00 8b 05 97 38 4b 04 85 c0 0f 85 27 f7 ff ff 48 c7 c6 20 00 ac 89 48 c7 c7 a0 fe ab 89 e8 bf 76 ba ff <0f> 0b e9 0d f7 ff ff 48 8b 44 24 40 48 8d b8 c8 08 00 00 48 89 f8 RSP: 0018:ffffc9000627f290 EFLAGS: 00010282 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 RDX: ffff88802315d700 RSI: ffffffff815f1db8 RDI: fffff52000c4fe44 RBP: ffff88818f28e000 R08: 0000000000000000 R09: 0000000000000000 R10: ffffffff815ebb5e R11: 0000000000000000 R12: 0000000000000000 R13: dffffc0000000000 R14: ffffc9000627f458 R15: 0000000093c30000 FS: 0000555556abc400(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fda689c3303 CR3: 000000001cfbb000 CR4: 0000000000350ef0 Call Trace: <TASK> tcf_chain0_head_change_cb_del+0x2e/0x3d0 net/sched/cls_api.c:810 tcf_block_put_ext net/sched/cls_api.c:1381 [inline] tcf_block_put_ext net/sched/cls_api.c:1376 [inline] tcf_block_put+0xbc/0x130 net/sched/cls_api.c:1394 cake_destroy+0x3f/0x80 net/sched/sch_cake.c:2695 qdisc_create.constprop.0+0x9da/0x10f0 net/sched/sch_api.c:1293 tc_modify_qdisc+0x4c5/0x1980 net/sched/sch_api.c:1660 rtnetlink_rcv_msg+0x413/0xb80 net/core/rtnetlink.c:5571 netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2496 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x904/0xdf0 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:704 [inline] sock_sendmsg+0xcf/0x120 net/socket.c:724 ____sys_sendmsg+0x6e8/0x810 net/socket.c:2409 ___sys_sendmsg+0xf3/0x170 net/socket.c:2463 __sys_sendmsg+0xe5/0x1b0 net/socket.c:2492 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f1bb06badb9 Code: Unable to access opcode bytes at RIP 0x7f1bb06bad8f. RSP: 002b:00007fff3012a658 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f1bb06badb9 RDX: 0000000000000000 RSI: 00000000200007c0 RDI: 0000000000000003 RBP: 0000000000000000 R08: 0000000000000003 R09: 0000000000000003 R10: 0000000000000003 R11: 0000000000000246 R12: 00007fff3012a688 R13: 00007fff3012a6a0 R14: 00007fff3012a6e0 R15: 00000000000013c2 </TASK>",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.222 未満\nLinux Kernel 4.20 以上 5.4.168 未満\nLinux Kernel 5.5 以上 5.10.88 未満\nLinux Kernel 5.11 以上 5.15.11 未満"
    },
    "JVNDB-2021-021265": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: scsi_debug: Sanity check block descriptor length in resp_mode_select() In resp_mode_select() sanity check the block descriptor len to avoid UAF. BUG: KASAN: use-after-free in resp_mode_select+0xa4c/0xb40 drivers/scsi/scsi_debug.c:2509 Read of size 1 at addr ffff888026670f50 by task scsicmd/15032 CPU: 1 PID: 15032 Comm: scsicmd Not tainted 5.15.0-01d0625 #15 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Call Trace: <TASK> dump_stack_lvl+0x89/0xb5 lib/dump_stack.c:107 print_address_description.constprop.9+0x28/0x160 mm/kasan/report.c:257 kasan_report.cold.14+0x7d/0x117 mm/kasan/report.c:443 __asan_report_load1_noabort+0x14/0x20 mm/kasan/report_generic.c:306 resp_mode_select+0xa4c/0xb40 drivers/scsi/scsi_debug.c:2509 schedule_resp+0x4af/0x1a10 drivers/scsi/scsi_debug.c:5483 scsi_debug_queuecommand+0x8c9/0x1e70 drivers/scsi/scsi_debug.c:7537 scsi_queue_rq+0x16b4/0x2d10 drivers/scsi/scsi_lib.c:1521 blk_mq_dispatch_rq_list+0xb9b/0x2700 block/blk-mq.c:1640 __blk_mq_sched_dispatch_requests+0x28f/0x590 block/blk-mq-sched.c:325 blk_mq_sched_dispatch_requests+0x105/0x190 block/blk-mq-sched.c:358 __blk_mq_run_hw_queue+0xe5/0x150 block/blk-mq.c:1762 __blk_mq_delay_run_hw_queue+0x4f8/0x5c0 block/blk-mq.c:1839 blk_mq_run_hw_queue+0x18d/0x350 block/blk-mq.c:1891 blk_mq_sched_insert_request+0x3db/0x4e0 block/blk-mq-sched.c:474 blk_execute_rq_nowait+0x16b/0x1c0 block/blk-exec.c:63 sg_common_write.isra.18+0xeb3/0x2000 drivers/scsi/sg.c:837 sg_new_write.isra.19+0x570/0x8c0 drivers/scsi/sg.c:775 sg_ioctl_common+0x14d6/0x2710 drivers/scsi/sg.c:941 sg_ioctl+0xa2/0x180 drivers/scsi/sg.c:1166 __x64_sys_ioctl+0x19d/0x220 fs/ioctl.c:52 do_syscall_64+0x3a/0x80 arch/x86/entry/common.c:50 entry_SYSCALL_64_after_hwframe+0x44/0xae arch/x86/entry/entry_64.S:113",
        "technologies": "Linux\nLinux Kernel 4.9.294 未満\nLinux Kernel 4.10 以上 4.14.259 未満\nLinux Kernel 4.15 以上 4.19.222 未満\nLinux Kernel 4.20 以上 5.4.168 未満\nLinux Kernel 5.5 以上 5.10.88 未満\nLinux Kernel 5.11 以上 5.15.11 未満"
    },
    "JVNDB-2021-021274": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/irdma: Fix a user-after-free in add_pble_prm When irdma_hmc_sd_one fails, 'chunk' is freed while its still on the PBLE info list. Add the chunk entry to the PBLE info list only after successful setting of the SD in irdma_hmc_sd_one.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.10 未満"
    },
    "JVNDB-2021-021272": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vduse: check that offset is within bounds in get_config() This condition checks \"len\" but it does not check \"offset\" and that could result in an out of bounds read if \"offset > dev->config_size\". The problem is that since both variables are unsigned the \"dev->config_size - offset\" subtraction would result in a very high unsigned value. I think these checks might not be necessary because \"len\" and \"offset\" are supposed to already have been validated using the vhost_vdpa_config_validate() function. But I do not know the code perfectly, and I like to be safe.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.11 未満"
    },
    "JVNDB-2021-021293": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: isdn: cpai: check ctr->cnr to avoid array index out of bound The cmtp_add_connection() would add a cmtp session to a controller and run a kernel thread to process cmtp. __module_get(THIS_MODULE); session->task = kthread_run(cmtp_session, session, \"kcmtpd_ctr_%d\", session->num); During this process, the kernel thread would call detach_capi_ctr() to detach a register controller. if the controller was not attached yet, detach_capi_ctr() would trigger an array-index-out-bounds bug. [ 46.866069][ T6479] UBSAN: array-index-out-of-bounds in drivers/isdn/capi/kcapi.c:483:21 [ 46.867196][ T6479] index -1 is out of range for type 'capi_ctr *[32]' [ 46.867982][ T6479] CPU: 1 PID: 6479 Comm: kcmtpd_ctr_0 Not tainted 5.15.0-rc2+ #8 [ 46.869002][ T6479] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014 [ 46.870107][ T6479] Call Trace: [ 46.870473][ T6479] dump_stack_lvl+0x57/0x7d [ 46.870974][ T6479] ubsan_epilogue+0x5/0x40 [ 46.871458][ T6479] __ubsan_handle_out_of_bounds.cold+0x43/0x48 [ 46.872135][ T6479] detach_capi_ctr+0x64/0xc0 [ 46.872639][ T6479] cmtp_session+0x5c8/0x5d0 [ 46.873131][ T6479] ? __init_waitqueue_head+0x60/0x60 [ 46.873712][ T6479] ? cmtp_add_msgpart+0x120/0x120 [ 46.874256][ T6479] kthread+0x147/0x170 [ 46.874709][ T6479] ? set_kthread_struct+0x40/0x40 [ 46.875248][ T6479] ret_from_fork+0x1f/0x30 [ 46.875773][ T6479]",
        "technologies": "Linux\nLinux Kernel 4.4.290 未満\nLinux Kernel 4.5 以上 4.9.288 未満\nLinux Kernel 4.10 以上 4.14.253 未満\nLinux Kernel 4.15 以上 4.19.214 未満\nLinux Kernel 4.20 以上 5.4.156 未満\nLinux Kernel 5.5 以上 5.10.76 未満\nLinux Kernel 5.11 以上 5.14.15 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021275": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: igbvf: fix double free in `igbvf_probe` In `igbvf_probe`, if register_netdev() fails, the program will go to label err_hw_init, and then to label err_ioremap. In free_netdev() which is just below label err_ioremap, there is `list_for_each_entry_safe` and `netif_napi_del` which aims to delete all entries in `dev->napi_list`. The program has added an entry `adapter->rx_ring->napi` which is added by `netif_napi_add` in igbvf_alloc_queues(). However, adapter->rx_ring has been freed below label err_hw_init. So this a UAF. In terms of how to patch the problem, we can refer to igbvf_remove() and delete the entry before `adapter->rx_ring`. The KASAN logs are as follows: [ 35.126075] BUG: KASAN: use-after-free in free_netdev+0x1fd/0x450 [ 35.127170] Read of size 8 at addr ffff88810126d990 by task modprobe/366 [ 35.128360] [ 35.128643] CPU: 1 PID: 366 Comm: modprobe Not tainted 5.15.0-rc2+ #14 [ 35.129789] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014 [ 35.131749] Call Trace: [ 35.132199] dump_stack_lvl+0x59/0x7b [ 35.132865] print_address_description+0x7c/0x3b0 [ 35.133707] ? free_netdev+0x1fd/0x450 [ 35.134378] __kasan_report+0x160/0x1c0 [ 35.135063] ? free_netdev+0x1fd/0x450 [ 35.135738] kasan_report+0x4b/0x70 [ 35.136367] free_netdev+0x1fd/0x450 [ 35.137006] igbvf_probe+0x121d/0x1a10 [igbvf] [ 35.137808] ? igbvf_vlan_rx_add_vid+0x100/0x100 [igbvf] [ 35.138751] local_pci_probe+0x13c/0x1f0 [ 35.139461] pci_device_probe+0x37e/0x6c0 [ 35.165526] [ 35.165806] Allocated by task 366: [ 35.166414] ____kasan_kmalloc+0xc4/0xf0 [ 35.167117] foo_kmem_cache_alloc_trace+0x3c/0x50 [igbvf] [ 35.168078] igbvf_probe+0x9c5/0x1a10 [igbvf] [ 35.168866] local_pci_probe+0x13c/0x1f0 [ 35.169565] pci_device_probe+0x37e/0x6c0 [ 35.179713] [ 35.179993] Freed by task 366: [ 35.180539] kasan_set_track+0x4c/0x80 [ 35.181211] kasan_set_free_info+0x1f/0x40 [ 35.181942] ____kasan_slab_free+0x103/0x140 [ 35.182703] kfree+0xe3/0x250 [ 35.183239] igbvf_probe+0x1173/0x1a10 [igbvf] [ 35.184040] local_pci_probe+0x13c/0x1f0",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 4.4.296 未満\nLinux Kernel 4.5 以上 4.9.294 未満\nLinux Kernel 4.10 以上 4.14.259 未満\nLinux Kernel 4.15 以上 4.19.222 未満\nLinux Kernel 4.20 以上 5.4.168 未満\nLinux Kernel 5.5 以上 5.10.88 未満\nLinux Kernel 5.11 以上 5.15.11 未満"
    },
    "JVNDB-2021-021310": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vduse: fix memory corruption in vduse_dev_ioctl() The \"config.offset\" comes from the user. There needs to a check to prevent it being out of bounds. The \"config.offset\" and \"dev->config_size\" variables are both type u32. So if the offset if out of bounds then the \"dev->config_size - config.offset\" subtraction results in a very high u32 value. The out of bounds offset can result in memory corruption.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.11 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021327": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ACPI: custom_method: fix potential use-after-free issue In cm_write(), buf is always freed when reaching the end of the function. If the requested count is less than table.length, the allocated buffer will be freed but subsequent calls to cm_write() will still try to access it. Remove the unconditional kfree(buf) at the end of the function and set the buf to NULL in the -EINVAL error path to match the rest of function.",
        "technologies": "Linux\nLinux Kernel 4.4.195 以上 4.4.269 未満\nLinux Kernel 4.9.195 以上 4.9.269 未満\nLinux Kernel 4.14.147 以上 4.14.233 未満\nLinux Kernel 4.19.77 以上 4.19.191 未満\nLinux Kernel 5.4 以上 5.4.118 未満\nLinux Kernel 5.5 以上 5.10.36 未満\nLinux Kernel 5.11 以上 5.11.20 未満\nLinux Kernel 5.12 以上 5.12.3 未満"
    },
    "JVNDB-2021-021270": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm btree remove: fix use after free in rebalance_children() Move dm_tm_unlock() after dm_tm_dec().",
        "technologies": "Linux\nLinux Kernel 4.4.296 未満\nLinux Kernel 4.5 以上 4.9.294 未満\nLinux Kernel 4.10 以上 4.14.259 未満\nLinux Kernel 4.15 以上 4.19.222 未満\nLinux Kernel 4.20 以上 5.4.168 未満\nLinux Kernel 5.5 以上 5.10.88 未満\nLinux Kernel 5.11 以上 5.15.11 未満"
    },
    "JVNDB-2021-021309": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i2c: virtio: fix completion handling The driver currently assumes that the notify callback is only received when the device is done with all the queued buffers. However, this is not true, since the notify callback could be called without any of the queued buffers being completed (for example, with virtio-pci and shared interrupts) or with only some of the buffers being completed (since the driver makes them available to the device in multiple separate virtqueue_add_sgs() calls). This can lead to incorrect data on the I2C bus or memory corruption in the guest if the device operates on buffers which are have been freed by the driver. (The WARN_ON in the driver is also triggered.) BUG kmalloc-128 (Tainted: G W ): Poison overwritten First byte 0x0 instead of 0x6b Allocated in i2cdev_ioctl_rdwr+0x9d/0x1de age=243 cpu=0 pid=28 memdup_user+0x2e/0xbd i2cdev_ioctl_rdwr+0x9d/0x1de i2cdev_ioctl+0x247/0x2ed vfs_ioctl+0x21/0x30 sys_ioctl+0xb18/0xb41 Freed in i2cdev_ioctl_rdwr+0x1bb/0x1de age=68 cpu=0 pid=28 kfree+0x1bd/0x1cc i2cdev_ioctl_rdwr+0x1bb/0x1de i2cdev_ioctl+0x247/0x2ed vfs_ioctl+0x21/0x30 sys_ioctl+0xb18/0xb41 Fix this by calling virtio_get_buf() from the notify handler like other virtio drivers and by actually waiting for all the buffers to be completed.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.10 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021304": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scpi: Fix string overflow in SCPI genpd driver Without the bound checks for scpi_pd->name, it could result in the buffer overflow when copying the SCPI device name from the corresponding device tree node as the name string is set at maximum size of 30. Let us fix it by using devm_kasprintf so that the string buffer is allocated dynamically.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.9.294 未満\nLinux Kernel 4.10 以上 4.14.259 未満\nLinux Kernel 4.15 以上 4.19.222 未満\nLinux Kernel 4.20 以上 5.4.168 未満\nLinux Kernel 5.5 以上 5.10.88 未満\nLinux Kernel 5.11 以上 5.15.11 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021332": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i40e: Fix use-after-free in i40e_client_subtask() Currently the call to i40e_client_del_instance frees the object pf->cinst, however pf->cinst->lan_info is being accessed after the free. Fix this by adding the missing return. Addresses-Coverity: (\"Read from pointer after free\")",
        "technologies": "Linux\nLinux Kernel 4.16 以上 4.19.191 未満\nLinux Kernel 4.20 以上 5.4.120 未満\nLinux Kernel 5.5 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満"
    },
    "JVNDB-2021-021334": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: openvswitch: fix stack OOB read while fragmenting IPv4 packets running openvswitch on kernels built with KASAN, it's possible to see the following splat while testing fragmentation of IPv4 packets: BUG: KASAN: stack-out-of-bounds in ip_do_fragment+0x1b03/0x1f60 Read of size 1 at addr ffff888112fc713c by task handler2/1367 CPU: 0 PID: 1367 Comm: handler2 Not tainted 5.12.0-rc6+ #418 Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014 Call Trace: dump_stack+0x92/0xc1 print_address_description.constprop.7+0x1a/0x150 kasan_report.cold.13+0x7f/0x111 ip_do_fragment+0x1b03/0x1f60 ovs_fragment+0x5bf/0x840 [openvswitch] do_execute_actions+0x1bd5/0x2400 [openvswitch] ovs_execute_actions+0xc8/0x3d0 [openvswitch] ovs_packet_cmd_execute+0xa39/0x1150 [openvswitch] genl_family_rcv_msg_doit.isra.15+0x227/0x2d0 genl_rcv_msg+0x287/0x490 netlink_rcv_skb+0x120/0x380 genl_rcv+0x24/0x40 netlink_unicast+0x439/0x630 netlink_sendmsg+0x719/0xbf0 sock_sendmsg+0xe2/0x110 ____sys_sendmsg+0x5ba/0x890 ___sys_sendmsg+0xe9/0x160 __sys_sendmsg+0xd3/0x170 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f957079db07 Code: c3 66 90 41 54 41 89 d4 55 48 89 f5 53 89 fb 48 83 ec 10 e8 eb ec ff ff 44 89 e2 48 89 ee 89 df 41 89 c0 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 48 89 44 24 08 e8 24 ed ff ff 48 RSP: 002b:00007f956ce35a50 EFLAGS: 00000293 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 0000000000000019 RCX: 00007f957079db07 RDX: 0000000000000000 RSI: 00007f956ce35ae0 RDI: 0000000000000019 RBP: 00007f956ce35ae0 R08: 0000000000000000 R09: 00007f9558006730 R10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000000 R13: 00007f956ce37308 R14: 00007f956ce35f80 R15: 00007f956ce35ae0 The buggy address belongs to the page: page:00000000af2a1d93 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x112fc7 flags: 0x17ffffc0000000() raw: 0017ffffc0000000 0000000000000000 dead000000000122 0000000000000000 raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: kasan: bad access detected addr ffff888112fc713c is located in stack of task handler2/1367 at offset 180 in frame: ovs_fragment+0x0/0x840 [openvswitch] this frame has 2 objects: [32, 144) 'ovs_dst' [192, 424) 'ovs_rt' Memory state around the buggy address: ffff888112fc7000: f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888112fc7080: 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00 00 00 00 >ffff888112fc7100: 00 00 00 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00 ^ ffff888112fc7180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888112fc7200: 00 00 00 00 00 00 f2 f2 f2 00 00 00 00 00 00 00 for IPv4 packets, ovs_fragment() uses a temporary struct dst_entry. Then, in the following call graph: ip_do_fragment() ip_skb_dst_mtu() ip_dst_mtu_maybe_forward() ip_mtu_locked() the pointer to struct dst_entry is used as pointer to struct rtable: this turns the access to struct members like rt_mtu_locked into an OOB read in the stack. Fix this changing the temporary variable used for IPv4 packets in ovs_fragment(), similarly to what is done for IPv6 few lines below.",
        "technologies": "Linux\nLinux Kernel 4.4.134 以上 4.4.269 未満\nLinux Kernel 4.9.104 以上 4.9.269 未満\nLinux Kernel 4.14.45 以上 4.14.233 未満\nLinux Kernel 4.16 以上 4.19.191 未満\nLinux Kernel 4.20 以上 5.4.118 未満\nLinux Kernel 5.5 以上 5.10.36 未満\nLinux Kernel 5.11 以上 5.11.20 未満\nLinux Kernel 5.12 以上 5.12.3 未満"
    },
    "JVNDB-2021-021350": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix off by one in hdmi_14_process_transaction() The hdcp_i2c_offsets[] array did not have an entry for HDCP_MESSAGE_ID_WRITE_CONTENT_STREAM_TYPE so it led to an off by one read overflow. I added an entry and copied the 0x0 value for the offset from similar code in drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c. I also declared several of these arrays as having HDCP_MESSAGE_ID_MAX entries. This doesn't change the code, but it's just a belt and suspenders approach to try future proof the code.",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021331": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ethernet:enic: Fix a use after free bug in enic_hard_start_xmit In enic_hard_start_xmit, it calls enic_queue_wq_skb(). Inside enic_queue_wq_skb, if some error happens, the skb will be freed by dev_kfree_skb(skb). But the freed skb is still used in skb_tx_timestamp(skb). My patch makes enic_queue_wq_skb() return error and goto spin_unlock() incase of error. The solution is provided by Govind. See https://lkml.org/lkml/2021/4/30/961.",
        "technologies": "Linux\nLinux Kernel 4.16 以上 4.19.191 未満\nLinux Kernel 4.20 以上 5.4.120 未満\nLinux Kernel 5.5 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満"
    },
    "JVNDB-2021-021353": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/siw: Fix a use after free in siw_alloc_mr Our code analyzer reported a UAF. In siw_alloc_mr(), it calls siw_mr_add_mem(mr,..). In the implementation of siw_mr_add_mem(), mem is assigned to mr->mem and then mem is freed via kfree(mem) if xa_alloc_cyclic() failed. Here, mr->mem still point to a freed object. After, the execution continue up to the err_out branch of siw_alloc_mr, and the freed mr->mem is used in siw_mr_drop_mem(mr). My patch moves \"mr->mem = mem\" behind the if (xa_alloc_cyclic(..)<0) {} section, to avoid the uaf.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.119 未満\nLinux Kernel 5.5 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021349": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommu/mediatek: Always enable the clk on resume In mtk_iommu_runtime_resume always enable the clk, even if m4u_dom is null. Otherwise the 'suspend' cb might disable the clk which is already disabled causing the warning: [ 1.586104] infra_m4u already disabled [ 1.586133] WARNING: CPU: 0 PID: 121 at drivers/clk/clk.c:952 clk_core_disable+0xb0/0xb8 [ 1.594391] mtk-iommu 10205000.iommu: bound 18001000.larb (ops mtk_smi_larb_component_ops) [ 1.598108] Modules linked in: [ 1.598114] CPU: 0 PID: 121 Comm: kworker/0:2 Not tainted 5.12.0-rc5 #69 [ 1.609246] mtk-iommu 10205000.iommu: bound 14027000.larb (ops mtk_smi_larb_component_ops) [ 1.617487] Hardware name: Google Elm (DT) [ 1.617491] Workqueue: pm pm_runtime_work [ 1.620545] mtk-iommu 10205000.iommu: bound 19001000.larb (ops mtk_smi_larb_component_ops) [ 1.627229] pstate: 60000085 (nZCv daIf -PAN -UAO -TCO BTYPE=--) [ 1.659297] pc : clk_core_disable+0xb0/0xb8 [ 1.663475] lr : clk_core_disable+0xb0/0xb8 [ 1.667652] sp : ffff800011b9bbe0 [ 1.670959] x29: ffff800011b9bbe0 x28: 0000000000000000 [ 1.676267] x27: ffff800011448000 x26: ffff8000100cfd98 [ 1.681574] x25: ffff800011b9bd48 x24: 0000000000000000 [ 1.686882] x23: 0000000000000000 x22: ffff8000106fad90 [ 1.692189] x21: 000000000000000a x20: ffff0000c0048500 [ 1.697496] x19: ffff0000c0048500 x18: ffffffffffffffff [ 1.702804] x17: 0000000000000000 x16: 0000000000000000 [ 1.708112] x15: ffff800011460300 x14: fffffffffffe0000 [ 1.713420] x13: ffff8000114602d8 x12: 0720072007200720 [ 1.718727] x11: 0720072007200720 x10: 0720072007200720 [ 1.724035] x9 : ffff800011b9bbe0 x8 : ffff800011b9bbe0 [ 1.729342] x7 : 0000000000000009 x6 : ffff8000114b8328 [ 1.734649] x5 : 0000000000000000 x4 : 0000000000000000 [ 1.739956] x3 : 00000000ffffffff x2 : ffff800011460298 [ 1.745263] x1 : 1af1d7de276f4500 x0 : 0000000000000000 [ 1.750572] Call trace: [ 1.753010] clk_core_disable+0xb0/0xb8 [ 1.756840] clk_core_disable_lock+0x24/0x40 [ 1.761105] clk_disable+0x20/0x30 [ 1.764501] mtk_iommu_runtime_suspend+0x88/0xa8 [ 1.769114] pm_generic_runtime_suspend+0x2c/0x48 [ 1.773815] __rpm_callback+0xe0/0x178 [ 1.777559] rpm_callback+0x24/0x88 [ 1.781041] rpm_suspend+0xdc/0x470 [ 1.784523] rpm_idle+0x12c/0x170 [ 1.787831] pm_runtime_work+0xa8/0xc0 [ 1.791573] process_one_work+0x1e8/0x360 [ 1.795580] worker_thread+0x44/0x478 [ 1.799237] kthread+0x150/0x158 [ 1.802460] ret_from_fork+0x10/0x30 [ 1.806034] ---[ end trace 82402920ef64573b ]--- [ 1.810728] ------------[ cut here ]------------ In addition, we now don't need to enable the clock from the function mtk_iommu_hw_init since it is already enabled by the resume.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021347": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kyber: fix out of bounds access when preempted __blk_mq_sched_bio_merge() gets the ctx and hctx for the current CPU and passes the hctx to ->bio_merge(). kyber_bio_merge() then gets the ctx for the current CPU again and uses that to get the corresponding Kyber context in the passed hctx. However, the thread may be preempted between the two calls to blk_mq_get_ctx(), and the ctx returned the second time may no longer correspond to the passed hctx. This \"works\" accidentally most of the time, but it can cause us to read garbage if the second ctx came from an hctx with more ctx's than the first one (i.e., if ctx->index_hw[hctx->type] > hctx->nr_ctx). This manifested as this UBSAN array index out of bounds error reported by Jakub: UBSAN: array-index-out-of-bounds in ../kernel/locking/qspinlock.c:130:9 index 13106 is out of range for type 'long unsigned int [128]' Call Trace: dump_stack+0xa4/0xe5 ubsan_epilogue+0x5/0x40 __ubsan_handle_out_of_bounds.cold.13+0x2a/0x34 queued_spin_lock_slowpath+0x476/0x480 do_raw_spin_lock+0x1c2/0x1d0 kyber_bio_merge+0x112/0x180 blk_mq_submit_bio+0x1f5/0x1100 submit_bio_noacct+0x7b0/0x870 submit_bio+0xc2/0x3a0 btrfs_map_bio+0x4f0/0x9d0 btrfs_submit_data_bio+0x24e/0x310 submit_one_bio+0x7f/0xb0 submit_extent_page+0xc4/0x440 __extent_writepage_io+0x2b8/0x5e0 __extent_writepage+0x28d/0x6e0 extent_write_cache_pages+0x4d7/0x7a0 extent_writepages+0xa2/0x110 do_writepages+0x8f/0x180 __writeback_single_inode+0x99/0x7f0 writeback_sb_inodes+0x34e/0x790 __writeback_inodes_wb+0x9e/0x120 wb_writeback+0x4d2/0x660 wb_workfn+0x64d/0xa10 process_one_work+0x53a/0xa80 worker_thread+0x69/0x5b0 kthread+0x20b/0x240 ret_from_fork+0x1f/0x30 Only Kyber uses the hctx, so fix it by passing the request_queue to ->bio_merge() instead. BFQ and mq-deadline just use that, and Kyber can map the queues itself to avoid the mismatch.",
        "technologies": "Linux\nLinux Kernel 4.18 以上 5.4.120 未満\nLinux Kernel 5.5 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021341": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: mt7915: fix txrate reporting Properly check rate_info to fix unexpected reporting. [ 1215.161863] Call trace: [ 1215.164307] cfg80211_calculate_bitrate+0x124/0x200 [cfg80211] [ 1215.170139] ieee80211s_update_metric+0x80/0xc0 [mac80211] [ 1215.175624] ieee80211_tx_status_ext+0x508/0x838 [mac80211] [ 1215.181190] mt7915_mcu_get_rx_rate+0x28c/0x8d0 [mt7915e] [ 1215.186580] mt7915_mac_tx_free+0x324/0x7c0 [mt7915e] [ 1215.191623] mt7915_queue_rx_skb+0xa8/0xd0 [mt7915e] [ 1215.196582] mt76_dma_cleanup+0x7b0/0x11d0 [mt76] [ 1215.201276] __napi_poll+0x38/0xf8 [ 1215.204668] napi_workfn+0x40/0x80 [ 1215.208062] process_one_work+0x1fc/0x390 [ 1215.212062] worker_thread+0x48/0x4d0 [ 1215.215715] kthread+0x120/0x128 [ 1215.218935] ret_from_fork+0x10/0x1c",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021357": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Drivers: hv: vmbus: Use after free in __vmbus_open() The \"open_info\" variable is added to the &vmbus_connection.chn_msg_list, but the error handling frees \"open_info\" without removing it from the list. This will result in a use after free. First remove it from the list, and then free it.",
        "technologies": "Linux\nLinux Kernel 4.14 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021354": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: spi-zynqmp-gqspi: fix use-after-free in zynqmp_qspi_exec_op When handling op->addr, it is using the buffer \"tmpbuf\" which has been freed. This will trigger a use-after-free KASAN warning. Let's use temporary variables to store op->addr.val and op->cmd.opcode to fix this issue.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021361": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rtw88: Fix array overrun in rtw_get_tx_power_params() Using a kernel with the Undefined Behaviour Sanity Checker (UBSAN) enabled, the following array overrun is logged: ================================================================================ UBSAN: array-index-out-of-bounds in /home/finger/wireless-drivers-next/drivers/net/wireless/realtek/rtw88/phy.c:1789:34 index 5 is out of range for type 'u8 [5]' CPU: 2 PID: 84 Comm: kworker/u16:3 Tainted: G O 5.12.0-rc5-00086-gd88bba47038e-dirty #651 Hardware name: TOSHIBA TECRA A50-A/TECRA A50-A, BIOS Version 4.50 09/29/2014 Workqueue: phy0 ieee80211_scan_work [mac80211] Call Trace: dump_stack+0x64/0x7c ubsan_epilogue+0x5/0x40 __ubsan_handle_out_of_bounds.cold+0x43/0x48 rtw_get_tx_power_params+0x83a/drivers/net/wireless/realtek/rtw88/0xad0 [rtw_core] ? rtw_pci_read16+0x20/0x20 [rtw_pci] ? check_hw_ready+0x50/0x90 [rtw_core] rtw_phy_get_tx_power_index+0x4d/0xd0 [rtw_core] rtw_phy_set_tx_power_level+0xee/0x1b0 [rtw_core] rtw_set_channel+0xab/0x110 [rtw_core] rtw_ops_config+0x87/0xc0 [rtw_core] ieee80211_hw_config+0x9d/0x130 [mac80211] ieee80211_scan_state_set_channel+0x81/0x170 [mac80211] ieee80211_scan_work+0x19f/0x2a0 [mac80211] process_one_work+0x1dd/0x3a0 worker_thread+0x49/0x330 ? rescuer_thread+0x3a0/0x3a0 kthread+0x134/0x150 ? kthread_create_worker_on_cpu+0x70/0x70 ret_from_fork+0x22/0x30 ================================================================================ The statement where an array is being overrun is shown in the following snippet: if (rate <= DESC_RATE11M) tx_power = pwr_idx_2g->cck_base[group]; else ====> tx_power = pwr_idx_2g->bw40_base[group]; The associated arrays are defined in main.h as follows: struct rtw_2g_txpwr_idx { u8 cck_base[6]; u8 bw40_base[5]; struct rtw_2g_1s_pwr_idx_diff ht_1s_diff; struct rtw_2g_ns_pwr_idx_diff ht_2s_diff; struct rtw_2g_ns_pwr_idx_diff ht_3s_diff; struct rtw_2g_ns_pwr_idx_diff ht_4s_diff; }; The problem arises because the value of group is 5 for channel 14. The trivial increase in the dimension of bw40_base fails as this struct must match the layout of efuse. The fix is to add the rate as an argument to rtw_get_channel_group() and set the group for channel 14 to 4 if rate <= DESC_RATE11M. This patch fixes commit fa6dfe6bff24 (\"rtw88: resolve order of tx power setting routines\")",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.119 未満\nLinux Kernel 5.5 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021345": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net:emac/emac-mac: Fix a use after free in emac_mac_tx_buf_send In emac_mac_tx_buf_send, it calls emac_tx_fill_tpd(..,skb,..). If some error happens in emac_tx_fill_tpd(), the skb will be freed via dev_kfree_skb(skb) in error branch of emac_tx_fill_tpd(). But the freed skb is still used via skb->len by netdev_sent_queue(,skb->len). As i observed that emac_tx_fill_tpd() haven't modified the value of skb->len, thus my patch assigns skb->len to 'len' before the possible free and use 'len' instead of skb->len later.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.9.269 未満\nLinux Kernel 4.10 以上 4.14.233 未満\nLinux Kernel 4.15 以上 4.19.191 未満\nLinux Kernel 4.20 以上 5.4.119 未満\nLinux Kernel 5.5 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021360": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: regmap: set debugfs_name to NULL after it is freed There is a upstream commit cffa4b2122f5(\"regmap:debugfs: Fix a memory leak when calling regmap_attach_dev\") that adds a if condition when create name for debugfs_name. With below function invoking logical, debugfs_name is freed in regmap_debugfs_exit(), but it is not created again because of the if condition introduced by above commit. regmap_reinit_cache() regmap_debugfs_exit() ... regmap_debugfs_init() So, set debugfs_name to NULL after it is freed.",
        "technologies": "Linux\nLinux Kernel 4.19.168 以上 4.19.191 未満\nLinux Kernel 5.4.90 以上 5.4.119 未満\nLinux Kernel 5.10.8 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021362": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm: bridge/panel: Cleanup connector on bridge detach If we don't call drm_connector_cleanup() manually in panel_bridge_detach(), the connector will be cleaned up with the other DRM objects in the call to drm_mode_config_cleanup(). However, since our drm_connector is devm-allocated, by the time drm_mode_config_cleanup() will be called, our connector will be long gone. Therefore, the connector must be cleaned up when the bridge is detached to avoid use-after-free conditions. v2: Cleanup connector only if it was created v3: Add FIXME v4: (Use connector->dev) directly in if() block",
        "technologies": "Linux\nLinux Kernel 4.13 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021374": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/nfc: fix use-after-free llcp_sock_bind/connect Commits 8a4cd82d (\"nfc: fix refcount leak in llcp_sock_connect()\") and c33b1cc62 (\"nfc: fix refcount leak in llcp_sock_bind()\") fixed a refcount leak bug in bind/connect but introduced a use-after-free if the same local is assigned to 2 different sockets. This can be triggered by the following simple program: int sock1 = socket( AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP ); int sock2 = socket( AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP ); memset( &addr, 0, sizeof(struct sockaddr_nfc_llcp) ); addr.sa_family = AF_NFC; addr.nfc_protocol = NFC_PROTO_NFC_DEP; bind( sock1, (struct sockaddr*) &addr, sizeof(struct sockaddr_nfc_llcp) ) bind( sock2, (struct sockaddr*) &addr, sizeof(struct sockaddr_nfc_llcp) ) close(sock1); close(sock2); Fix this by assigning NULL to llcp_sock->local after calling nfc_llcp_local_put. This addresses CVE-2021-23134.",
        "technologies": "Linux\nLinux Kernel 4.4.267 以上 4.4.269 未満\nLinux Kernel 4.9.267 以上 4.9.269 未満\nLinux Kernel 4.14.231 以上 4.14.233 未満\nLinux Kernel 4.19.187 以上 4.19.191 未満\nLinux Kernel 5.4.112 以上 5.4.119 未満\nLinux Kernel 5.10.30 以上 5.10.37 未満\nLinux Kernel 5.11.14 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021365": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: Destroy I/O bus devices on unregister failure _after_ sync'ing SRCU If allocating a new instance of an I/O bus fails when unregistering a device, wait to destroy the device until after all readers are guaranteed to see the new null bus. Destroying devices before the bus is nullified could lead to use-after-free since readers expect the devices on their reference of the bus to remain valid.",
        "technologies": "Linux\nLinux Kernel 5.9 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021372": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: Fix use-after-free with devm_spi_alloc_* We can't rely on the contents of the devres list during spi_unregister_controller(), as the list is already torn down at the time we perform devres_find() for devm_spi_release_controller. This causes devices registered with devm_spi_alloc_{master,slave}() to be mistakenly identified as legacy, non-devm managed devices and have their reference counters decremented below 0. ------------[ cut here ]------------ WARNING: CPU: 1 PID: 660 at lib/refcount.c:28 refcount_warn_saturate+0x108/0x174 [<b0396f04>] (refcount_warn_saturate) from [<b03c56a4>] (kobject_put+0x90/0x98) [<b03c5614>] (kobject_put) from [<b0447b4c>] (put_device+0x20/0x24) r4:b6700140 [<b0447b2c>] (put_device) from [<b07515e8>] (devm_spi_release_controller+0x3c/0x40) [<b07515ac>] (devm_spi_release_controller) from [<b045343c>] (release_nodes+0x84/0xc4) r5:b6700180 r4:b6700100 [<b04533b8>] (release_nodes) from [<b0454160>] (devres_release_all+0x5c/0x60) r8:b1638c54 r7:b117ad94 r6:b1638c10 r5:b117ad94 r4:b163dc10 [<b0454104>] (devres_release_all) from [<b044e41c>] (__device_release_driver+0x144/0x1ec) r5:b117ad94 r4:b163dc10 [<b044e2d8>] (__device_release_driver) from [<b044f70c>] (device_driver_detach+0x84/0xa0) r9:00000000 r8:00000000 r7:b117ad94 r6:b163dc54 r5:b1638c10 r4:b163dc10 [<b044f688>] (device_driver_detach) from [<b044d274>] (unbind_store+0xe4/0xf8) Instead, determine the devm allocation state as a flag on the controller which is guaranteed to be stable during cleanup.",
        "technologies": "Linux\nLinux Kernel 4.4.248 以上 4.4.271 未満\nLinux Kernel 4.9.248 以上 4.9.271 未満\nLinux Kernel 4.14.212 以上 4.14.233 未満\nLinux Kernel 4.19.163 以上 4.19.191 未満\nLinux Kernel 5.4.80 以上 5.4.119 未満\nLinux Kernel 5.10 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021371": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: habanalabs/gaudi: Fix a potential use after free in gaudi_memset_device_memory Our code analyzer reported a uaf. In gaudi_memset_device_memory, cb is get via hl_cb_kernel_create() with 2 refcount. If hl_cs_allocate_job() failed, the execution runs into release_cb branch. One ref of cb is dropped by hl_cb_put(cb) and could be freed if other thread also drops one ref. Then cb is used by cb->id later, which is a potential uaf. My patch add a variable 'id' to accept the value of cb->id before the hl_cb_put(cb) is called, to avoid the potential uaf.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.7 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021384": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ath10k: Fix a use after free in ath10k_htc_send_bundle In ath10k_htc_send_bundle, the bundle_skb could be freed by dev_kfree_skb_any(bundle_skb). But the bundle_skb is used later by bundle_skb->len. As skb_len = bundle_skb->len, my patch replaces bundle_skb->len to skb_len after the bundle_skb was freed.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021414": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: blk-cgroup: fix UAF by grabbing blkcg lock before destroying blkg pd KASAN reports a use-after-free report when doing fuzz test: [693354.104835] ================================================================== [693354.105094] BUG: KASAN: use-after-free in bfq_io_set_weight_legacy+0xd3/0x160 [693354.105336] Read of size 4 at addr ffff888be0a35664 by task sh/1453338 [693354.105607] CPU: 41 PID: 1453338 Comm: sh Kdump: loaded Not tainted 4.18.0-147 [693354.105610] Hardware name: Huawei 2288H V5/BC11SPSCB0, BIOS 0.81 07/02/2018 [693354.105612] Call Trace: [693354.105621] dump_stack+0xf1/0x19b [693354.105626] ? show_regs_print_info+0x5/0x5 [693354.105634] ? printk+0x9c/0xc3 [693354.105638] ? cpumask_weight+0x1f/0x1f [693354.105648] print_address_description+0x70/0x360 [693354.105654] kasan_report+0x1b2/0x330 [693354.105659] ? bfq_io_set_weight_legacy+0xd3/0x160 [693354.105665] ? bfq_io_set_weight_legacy+0xd3/0x160 [693354.105670] bfq_io_set_weight_legacy+0xd3/0x160 [693354.105675] ? bfq_cpd_init+0x20/0x20 [693354.105683] cgroup_file_write+0x3aa/0x510 [693354.105693] ? ___slab_alloc+0x507/0x540 [693354.105698] ? cgroup_file_poll+0x60/0x60 [693354.105702] ? 0xffffffff89600000 [693354.105708] ? usercopy_abort+0x90/0x90 [693354.105716] ? mutex_lock+0xef/0x180 [693354.105726] kernfs_fop_write+0x1ab/0x280 [693354.105732] ? cgroup_file_poll+0x60/0x60 [693354.105738] vfs_write+0xe7/0x230 [693354.105744] ksys_write+0xb0/0x140 [693354.105749] ? __ia32_sys_read+0x50/0x50 [693354.105760] do_syscall_64+0x112/0x370 [693354.105766] ? syscall_return_slowpath+0x260/0x260 [693354.105772] ? do_page_fault+0x9b/0x270 [693354.105779] ? prepare_exit_to_usermode+0xf9/0x1a0 [693354.105784] ? enter_from_user_mode+0x30/0x30 [693354.105793] entry_SYSCALL_64_after_hwframe+0x65/0xca [693354.105875] Allocated by task 1453337: [693354.106001] kasan_kmalloc+0xa0/0xd0 [693354.106006] kmem_cache_alloc_node_trace+0x108/0x220 [693354.106010] bfq_pd_alloc+0x96/0x120 [693354.106015] blkcg_activate_policy+0x1b7/0x2b0 [693354.106020] bfq_create_group_hierarchy+0x1e/0x80 [693354.106026] bfq_init_queue+0x678/0x8c0 [693354.106031] blk_mq_init_sched+0x1f8/0x460 [693354.106037] elevator_switch_mq+0xe1/0x240 [693354.106041] elevator_switch+0x25/0x40 [693354.106045] elv_iosched_store+0x1a1/0x230 [693354.106049] queue_attr_store+0x78/0xb0 [693354.106053] kernfs_fop_write+0x1ab/0x280 [693354.106056] vfs_write+0xe7/0x230 [693354.106060] ksys_write+0xb0/0x140 [693354.106064] do_syscall_64+0x112/0x370 [693354.106069] entry_SYSCALL_64_after_hwframe+0x65/0xca [693354.106114] Freed by task 1453336: [693354.106225] __kasan_slab_free+0x130/0x180 [693354.106229] kfree+0x90/0x1b0 [693354.106233] blkcg_deactivate_policy+0x12c/0x220 [693354.106238] bfq_exit_queue+0xf5/0x110 [693354.106241] blk_mq_exit_sched+0x104/0x130 [693354.106245] __elevator_exit+0x45/0x60 [693354.106249] elevator_switch_mq+0xd6/0x240 [693354.106253] elevator_switch+0x25/0x40 [693354.106257] elv_iosched_store+0x1a1/0x230 [693354.106261] queue_attr_store+0x78/0xb0 [693354.106264] kernfs_fop_write+0x1ab/0x280 [693354.106268] vfs_write+0xe7/0x230 [693354.106271] ksys_write+0xb0/0x140 [693354.106275] do_syscall_64+0x112/0x370 [693354.106280] entry_SYSCALL_64_after_hwframe+0x65/0xca [693354.106329] The buggy address belongs to the object at ffff888be0a35580 which belongs to the cache kmalloc-1k of size 1024 [693354.106736] The buggy address is located 228 bytes inside of 1024-byte region [ffff888be0a35580, ffff888be0a35980) [693354.107114] The buggy address belongs to the page: [693354.107273] page:ffffea002f828c00 count:1 mapcount:0 mapping:ffff888107c17080 index:0x0 compound_mapcount: 0 [693354.107606] flags: 0x17ffffc0008100(slab|head) [693354.107760] raw: 0017ffffc0008100 ffffea002fcbc808 ffffea0030bd3a08 ffff888107c17080 [693354.108020] r ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.4.150 未満\nLinux Kernel 5.5 以上 5.10.70 未満\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021388": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: fix a buffer overflow in otx2_set_rxfh_context() This function is called from ethtool_set_rxfh() and \"*rss_context\" comes from the user. Add some bounds checking to prevent memory corruption.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.9 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021433": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched: Fix out-of-bound access in uclamp Util-clamp places tasks in different buckets based on their clamp values for performance reasons. However, the size of buckets is currently computed using a rounding division, which can lead to an off-by-one error in some configurations. For instance, with 20 buckets, the bucket size will be 1024/20=51. A task with a clamp of 1024 will be mapped to bucket id 1024/51=20. Sadly, correct indexes are in range [0,19], hence leading to an out of bound memory access. Clamp the bucket id to fix the issue.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.120 未満\nLinux Kernel 5.5 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満"
    },
    "JVNDB-2021-021409": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: fix another slab-out-of-bounds in fib6_nh_flush_exceptions While running the self-tests on a KASAN enabled kernel, I observed a slab-out-of-bounds splat very similar to the one reported in commit 821bbf79fe46 (\"ipv6: Fix KASAN: slab-out-of-bounds Read in fib6_nh_flush_exceptions\"). We additionally need to take care of fib6_metrics initialization failure when the caller provides an nh. The fix is similar, explicitly free the route instead of calling fib6_info_release on a half-initialized object.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.136 未満\nLinux Kernel 5.5 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021432": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nftables: avoid overflows in nft_hash_buckets() Number of buckets being stored in 32bit variables, we have to ensure that no overflows occur in nft_hash_buckets() syzbot injected a size == 0x40000000 and reported: UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13 shift exponent 64 is too large for 64-bit type 'long unsigned int' CPU: 1 PID: 29539 Comm: syz-executor.4 Not tainted 5.12.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: __dump_stack lib/dump_stack.c:79 [inline] dump_stack+0x141/0x1d7 lib/dump_stack.c:120 ubsan_epilogue+0xb/0x5a lib/ubsan.c:148 __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:327 __roundup_pow_of_two include/linux/log2.h:57 [inline] nft_hash_buckets net/netfilter/nft_set_hash.c:411 [inline] nft_hash_estimate.cold+0x19/0x1e net/netfilter/nft_set_hash.c:652 nft_select_set_ops net/netfilter/nf_tables_api.c:3586 [inline] nf_tables_newset+0xe62/0x3110 net/netfilter/nf_tables_api.c:4322 nfnetlink_rcv_batch+0xa09/0x24b0 net/netfilter/nfnetlink.c:488 nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:612 [inline] nfnetlink_rcv+0x3af/0x420 net/netfilter/nfnetlink.c:630 netlink_unicast_kernel net/netlink/af_netlink.c:1312 [inline] netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1338 netlink_sendmsg+0x856/0xd90 net/netlink/af_netlink.c:1927 sock_sendmsg_nosec net/socket.c:654 [inline] sock_sendmsg+0xcf/0x120 net/socket.c:674 ____sys_sendmsg+0x6e8/0x810 net/socket.c:2350 ___sys_sendmsg+0xf3/0x170 net/socket.c:2404 __sys_sendmsg+0xe5/0x1b0 net/socket.c:2433 do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.14.233 未満\nLinux Kernel 4.15 以上 4.19.191 未満\nLinux Kernel 4.20 以上 5.4.120 未満\nLinux Kernel 5.5 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満"
    },
    "JVNDB-2021-021425": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: seq: Fix race of snd_seq_timer_open() The timer instance per queue is exclusive, and snd_seq_timer_open() should have managed the concurrent accesses. It looks as if it's checking the already existing timer instance at the beginning, but it's not right, because there is no protection, hence any later concurrent call of snd_seq_timer_open() may override the timer instance easily. This may result in UAF, as the leftover timer instance can keep running while the queue itself gets closed, as spotted by syzkaller recently. For avoiding the race, add a proper check at the assignment of tmr->timeri again, and return -EBUSY if it's been already registered.",
        "technologies": "Linux\nLinux Kernel 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021417": {
        "title": "Linux の Linux Kernel における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm: Fix use-after-free read in drm_getunique() There is a time-of-check-to-time-of-use error in drm_getunique() due to retrieving file_priv->master prior to locking the device's master mutex. An example can be seen in the crash report of the use-after-free error found by Syzbot: https://syzkaller.appspot.com/bug?id=148d2f1dfac64af52ffd27b661981a540724f803 In the report, the master pointer was used after being freed. This is because another process had acquired the device's master mutex in drm_setmaster_ioctl(), then overwrote fpriv->master in drm_new_set_master(). The old value of fpriv->master was subsequently freed before the mutex was unlocked. To fix this, we lock the device's master mutex before retrieving the pointer from from fpriv->master. This patch passes the Syzbot reproducer test.",
        "technologies": "Linux\nLinux Kernel 4.14.237 未満\nLinux Kernel 4.15 以上 4.19.195 未満\nLinux Kernel 4.20 以上 5.4.126 未満\nLinux Kernel 5.5 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021415": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: ngene: Fix out-of-bounds bug in ngene_command_config_free_buf() Fix an 11-year old bug in ngene_command_config_free_buf() while addressing the following warnings caught with -Warray-bounds: arch/alpha/include/asm/string.h:22:16: warning: '__builtin_memcpy' offset [12, 16] from the object at 'com' is out of the bounds of referenced subobject 'config' with type 'unsigned char' at offset 10 [-Warray-bounds] arch/x86/include/asm/string_32.h:182:25: warning: '__builtin_memcpy' offset [12, 16] from the object at 'com' is out of the bounds of referenced subobject 'config' with type 'unsigned char' at offset 10 [-Warray-bounds] The problem is that the original code is trying to copy 6 bytes of data into a one-byte size member _config_ of the wrong structue FW_CONFIGURE_BUFFERS, in a single call to memcpy(). This causes a legitimate compiler warning because memcpy() overruns the length of &com.cmd.ConfigureBuffers.config. It seems that the right structure is FW_CONFIGURE_FREE_BUFFERS, instead, because it contains 6 more members apart from the header _hdr_. Also, the name of the function ngene_command_config_free_buf() suggests that the actual intention is to ConfigureFreeBuffers, instead of ConfigureBuffers (which takes place in the function ngene_command_config_buf(), above). Fix this by enclosing those 6 members of struct FW_CONFIGURE_FREE_BUFFERS into new struct config, and use &com.cmd.ConfigureFreeBuffers.config as the destination address, instead of &com.cmd.ConfigureBuffers.config, when calling memcpy(). This also helps with the ongoing efforts to globally enable -Warray-bounds and get us closer to being able to tighten the FORTIFY_SOURCE routines on memcpy().",
        "technologies": "Linux\nLinux Kernel 2.6.34 以上 4.4.277 未満\nLinux Kernel 4.5 以上 4.9.277 未満\nLinux Kernel 4.10 以上 4.14.241 未満\nLinux Kernel 4.15 以上 4.19.199 未満\nLinux Kernel 4.20 以上 5.4.136 未満\nLinux Kernel 5.5 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021438": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fbmem: Do not delete the mode that is still in use The execution of fb_delete_videomode() is not based on the result of the previous fbcon_mode_deleted(). As a result, the mode is directly deleted, regardless of whether it is still in use, which may cause UAF. ================================================================== BUG: KASAN: use-after-free in fb_mode_is_equal+0x36e/0x5e0 \\ drivers/video/fbdev/core/modedb.c:924 Read of size 4 at addr ffff88807e0ddb1c by task syz-executor.0/18962 CPU: 2 PID: 18962 Comm: syz-executor.0 Not tainted 5.10.45-rc1+ #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ... Call Trace: __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x137/0x1be lib/dump_stack.c:118 print_address_description+0x6c/0x640 mm/kasan/report.c:385 __kasan_report mm/kasan/report.c:545 [inline] kasan_report+0x13d/0x1e0 mm/kasan/report.c:562 fb_mode_is_equal+0x36e/0x5e0 drivers/video/fbdev/core/modedb.c:924 fbcon_mode_deleted+0x16a/0x220 drivers/video/fbdev/core/fbcon.c:2746 fb_set_var+0x1e1/0xdb0 drivers/video/fbdev/core/fbmem.c:975 do_fb_ioctl+0x4d9/0x6e0 drivers/video/fbdev/core/fbmem.c:1108 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl+0xfb/0x170 fs/ioctl.c:739 do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Freed by task 18960: kasan_save_stack mm/kasan/common.c:48 [inline] kasan_set_track+0x3d/0x70 mm/kasan/common.c:56 kasan_set_free_info+0x17/0x30 mm/kasan/generic.c:355 __kasan_slab_free+0x108/0x140 mm/kasan/common.c:422 slab_free_hook mm/slub.c:1541 [inline] slab_free_freelist_hook+0xd6/0x1a0 mm/slub.c:1574 slab_free mm/slub.c:3139 [inline] kfree+0xca/0x3d0 mm/slub.c:4121 fb_delete_videomode+0x56a/0x820 drivers/video/fbdev/core/modedb.c:1104 fb_set_var+0x1f3/0xdb0 drivers/video/fbdev/core/fbmem.c:978 do_fb_ioctl+0x4d9/0x6e0 drivers/video/fbdev/core/fbmem.c:1108 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl+0xfb/0x170 fs/ioctl.c:739 do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x44/0xa9",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021510": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: IB/qib: Protect from buffer overflow in struct qib_user_sdma_pkt fields Overflowing either addrlimit or bytes_togo can allow userspace to trigger a buffer overflow of kernel memory. Check for overflows in all the places doing math on user controlled buffers.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.4.292 未満\nLinux Kernel 4.5 以上 4.9.290 未満\nLinux Kernel 4.10 以上 4.14.255 未満\nLinux Kernel 4.15 以上 4.19.216 未満\nLinux Kernel 4.20 以上 5.4.157 未満\nLinux Kernel 5.5 以上 5.10.77 未満\nLinux Kernel 5.11 以上 5.14.16 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021440": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: betop: fix slab-out-of-bounds Write in betop_probe Syzbot reported slab-out-of-bounds Write bug in hid-betopff driver. The problem is the driver assumes the device must have an input report but some malicious devices violate this assumption. So this patch checks hid_device's input is non empty before it's been used.",
        "technologies": "Linux\nLinux Kernel 4.4.286 未満\nLinux Kernel 4.5 以上 4.9.285 未満\nLinux Kernel 4.10 以上 4.14.249 未満\nLinux Kernel 4.15 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.151 未満\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021443": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: fddi: fix UAF in fza_probe fp is netdev private data and it cannot be used after free_netdev() call. Using fp after free_netdev() can cause UAF bug. Fix it by moving free_netdev() after error message. TURBOchannel adapter\")",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.135 未満\nLinux Kernel 5.5 以上 5.10.53 未満\nLinux Kernel 5.11 以上 5.13.5 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021555": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mtd: physmap: physmap-bt1-rom: Fix unintentional stack access Cast &data to (char *) in order to avoid unintentionally accessing the stack. Notice that data is of type u32, so any increment to &data will be in the order of 4-byte chunks, and this piece of code is actually intended to be a byte offset. Addresses-Coverity-ID: 1497765 (\"Out-of-bounds access\")",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.36 未満\nLinux Kernel 5.11 以上 5.11.20 未満\nLinux Kernel 5.12 以上 5.12.3 未満"
    },
    "JVNDB-2021-021445": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bus: mhi: pci_generic: Fix possible use-after-free in mhi_pci_remove() This driver's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021552": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid touching checkpointed data in get_victim() In CP disabling mode, there are two issues when using LFS or SSR | AT_SSR mode to select victim: 1. LFS is set to find source section during GC, the victim should have no checkpointed data, since after GC, section could not be set free for reuse. Previously, we only check valid chpt blocks in current segment rather than section, fix it. 2. SSR | AT_SSR are set to find target segment for writes which can be fully filled by checkpointed and newly written blocks, we should never select such segment, otherwise it can cause panic or data corruption during allocation, potential case is described as below: a) target segment has 'n' (n < 512) ckpt valid blocks b) GC migrates 'n' valid blocks to other segment (segment is still in dirty list) c) GC migrates '512 - n' blocks to target segment (segment has 'n' cp_vblocks and '512 - n' vblocks) d) If GC selects target segment via {AT,}SSR allocator, however there is no free space in targe segment.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満"
    },
    "JVNDB-2021-021546": {
        "title": "Linux の Linux Kernel における有効期限後または解放後のリソースの操作に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipc/mqueue, msg, sem: avoid relying on a stack reference past its expiry do_mq_timedreceive calls wq_sleep with a stack local address. The sender (do_mq_timedsend) uses this address to later call pipelined_send. This leads to a very hard to trigger race where a do_mq_timedreceive call might return and leave do_mq_timedsend to rely on an invalid address, causing the following crash: RIP: 0010:wake_q_add_safe+0x13/0x60 Call Trace: __x64_sys_mq_timedsend+0x2a9/0x490 do_syscall_64+0x80/0x680 entry_SYSCALL_64_after_hwframe+0x44/0xa9 RIP: 0033:0x7f5928e40343 The race occurs as: 1. do_mq_timedreceive calls wq_sleep with the address of `struct ext_wait_queue` on function stack (aliased as `ewq_addr` here) - it holds a valid `struct ext_wait_queue *` as long as the stack has not been overwritten. 2. `ewq_addr` gets added to info->e_wait_q[RECV].list in wq_add, and do_mq_timedsend receives it via wq_get_first_waiter(info, RECV) to call __pipelined_op. 3. Sender calls __pipelined_op::smp_store_release(&this->state, STATE_READY). Here is where the race window begins. (`this` is `ewq_addr`.) 4. If the receiver wakes up now in do_mq_timedreceive::wq_sleep, it will see `state == STATE_READY` and break. 5. do_mq_timedreceive returns, and `ewq_addr` is no longer guaranteed to be a `struct ext_wait_queue *` since it was on do_mq_timedreceive's stack. (Although the address may not get overwritten until another function happens to touch it, which means it can persist around for an indefinite time.) 6. do_mq_timedsend::__pipelined_op() still believes `ewq_addr` is a `struct ext_wait_queue *`, and uses it to find a task_struct to pass to the wake_q_add_safe call. In the lucky case where nothing has overwritten `ewq_addr` yet, `ewq_addr->task` is the right task_struct. In the unlucky case, __pipelined_op::wake_q_add_safe gets handed a bogus address as the receiver's task_struct causing the crash. do_mq_timedsend::__pipelined_op() should not dereference `this` after setting STATE_READY, as the receiver counterpart is now free to return. Change __pipelined_op to call wake_q_add_safe on the receiver's task_struct returned by get_task_struct, instead of dereferencing `this` which sits on the receiver's stack. As Manfred pointed out, the race potentially also exists in ipc/msg.c::expunge_all and ipc/sem.c::wake_up_sem_queue_prepare. Fix those in the same way.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.40 未満\nLinux Kernel 5.11 以上 5.12.7 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021444": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Track subprog poke descriptors correctly and fix use-after-free Subprograms are calling map_poke_track(), but on program release there is no hook to call map_poke_untrack(). However, on program release, the aux memory (and poke descriptor table) is freed even though we still have a reference to it in the element list of the map aux data. When we run map_poke_run(), we then end up accessing free'd memory, triggering KASAN in prog_array_map_poke_run(): [...] [ 402.824689] BUG: KASAN: use-after-free in prog_array_map_poke_run+0xc2/0x34e [ 402.824698] Read of size 4 at addr ffff8881905a7940 by task hubble-fgs/4337 [ 402.824705] CPU: 1 PID: 4337 Comm: hubble-fgs Tainted: G I 5.12.0+ #399 [ 402.824715] Call Trace: [ 402.824719] dump_stack+0x93/0xc2 [ 402.824727] print_address_description.constprop.0+0x1a/0x140 [ 402.824736] ? prog_array_map_poke_run+0xc2/0x34e [ 402.824740] ? prog_array_map_poke_run+0xc2/0x34e [ 402.824744] kasan_report.cold+0x7c/0xd8 [ 402.824752] ? prog_array_map_poke_run+0xc2/0x34e [ 402.824757] prog_array_map_poke_run+0xc2/0x34e [ 402.824765] bpf_fd_array_map_update_elem+0x124/0x1a0 [...] The elements concerned are walked as follows: for (i = 0; i < elem->aux->size_poke_tab; i++) { poke = &elem->aux->poke_tab[i]; [...] The access to size_poke_tab is a 4 byte read, verified by checking offsets in the KASAN dump: [ 402.825004] The buggy address belongs to the object at ffff8881905a7800 which belongs to the cache kmalloc-1k of size 1024 [ 402.825008] The buggy address is located 320 bytes inside of 1024-byte region [ffff8881905a7800, ffff8881905a7c00) The pahole output of bpf_prog_aux: struct bpf_prog_aux { [...] /* --- cacheline 5 boundary (320 bytes) --- */ u32 size_poke_tab; /* 320 4 */ [...] In general, subprograms do not necessarily manage their own data structures. For example, BTF func_info and linfo are just pointers to the main program structure. This allows reference counting and cleanup to be done on the latter which simplifies their management a bit. The aux->poke_tab struct, however, did not follow this logic. The initial proposed fix for this use-after-free bug further embedded poke data tracking into the subprogram with proper reference counting. However, Daniel and Alexei questioned why we were treating these objects special; I agree, its unnecessary. The fix here removes the per subprogram poke table allocation and map tracking and instead simply points the aux->poke_tab pointer at the main programs poke table. This way, map tracking is simplified to the main program and we do not need to manage them per subprogram. This also means, bpf_prog_free_deferred(), which unwinds the program reference counting and kfrees objects, needs to ensure that we don't try to double free the poke_tab when free'ing the subprog structures. This is easily solved by NULL'ing the poke_tab pointer. The second detail is to ensure that per subprogram JIT logic only does fixups on poke_tab[] entries it owns. To do this, we add a pointer in the poke structure to point at the subprogram value so JITs can easily check while walking the poke_tab structure if the current entry belongs to the current program. The aux pointer is stable and therefore suitable for such comparison. On the jit_subprogs() error path, we omit cleaning up the poke->aux field because these are only ever referenced from the JIT side, but on error we will never make it to the JIT, so its fine to leave them dangling. Removing these pointers would complicate the error path for no reason. However, we do need to untrack all poke descriptors from the main program as otherwise they could race with the freeing of JIT memory from the subprograms. Lastly, a748c6975dea3 (\"bpf: propagate poke des ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.53 未満\nLinux Kernel 5.11 以上 5.13.5 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021442": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc/libmasm/module: Fix two use after free in ibmasm_init_one In ibmasm_init_one, it calls ibmasm_init_remote_input_dev(). Inside ibmasm_init_remote_input_dev, mouse_dev and keybd_dev are allocated by input_allocate_device(), and assigned to sp->remote.mouse_dev and sp->remote.keybd_dev respectively. In the err_free_devices error branch of ibmasm_init_one, mouse_dev and keybd_dev are freed by input_free_device(), and return error. Then the execution runs into error_send_message error branch of ibmasm_init_one, where ibmasm_free_remote_input_dev(sp) is called to unregister the freed sp->remote.mouse_dev and sp->remote.keybd_dev. My patch add a \"error_init_remote\" label to handle the error of ibmasm_init_remote_input_dev(), to avoid the uaf bugs.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021560": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring: fix overflows checks in provide buffers Colin reported before possible overflow and sign extension problems in io_provide_buffers_prep(). As Linus pointed out previous attempt did nothing useful, see d81269fecb8ce (\"io_uring: fix provide_buffers sign extension\"). Do that with help of check_<op>_overflow helpers. And fix struct io_provide_buf::len type, as it doesn't make much sense to keep it signed.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021590": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: mmio: Fix use-after-free Read in kvm_vm_ioctl_unregister_coalesced_mmio BUG: KASAN: use-after-free in kvm_vm_ioctl_unregister_coalesced_mmio+0x7c/0x1ec arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:183 Read of size 8 at addr ffff0000c03a2500 by task syz-executor083/4269 CPU: 5 PID: 4269 Comm: syz-executor083 Not tainted 5.10.0 #7 Hardware name: linux,dummy-virt (DT) Call trace: dump_backtrace+0x0/0x2d0 arch/arm64/kernel/stacktrace.c:132 show_stack+0x28/0x34 arch/arm64/kernel/stacktrace.c:196 __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x110/0x164 lib/dump_stack.c:118 print_address_description+0x78/0x5c8 mm/kasan/report.c:385 __kasan_report mm/kasan/report.c:545 [inline] kasan_report+0x148/0x1e4 mm/kasan/report.c:562 check_memory_region_inline mm/kasan/generic.c:183 [inline] __asan_load8+0xb4/0xbc mm/kasan/generic.c:252 kvm_vm_ioctl_unregister_coalesced_mmio+0x7c/0x1ec arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:183 kvm_vm_ioctl+0xe30/0x14c4 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:3755 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __arm64_sys_ioctl+0xf88/0x131c fs/ioctl.c:739 __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline] invoke_syscall arch/arm64/kernel/syscall.c:48 [inline] el0_svc_common arch/arm64/kernel/syscall.c:158 [inline] do_el0_svc+0x120/0x290 arch/arm64/kernel/syscall.c:220 el0_svc+0x1c/0x28 arch/arm64/kernel/entry-common.c:367 el0_sync_handler+0x98/0x170 arch/arm64/kernel/entry-common.c:383 el0_sync+0x140/0x180 arch/arm64/kernel/entry.S:670 Allocated by task 4269: stack_trace_save+0x80/0xb8 kernel/stacktrace.c:121 kasan_save_stack mm/kasan/common.c:48 [inline] kasan_set_track mm/kasan/common.c:56 [inline] __kasan_kmalloc+0xdc/0x120 mm/kasan/common.c:461 kasan_kmalloc+0xc/0x14 mm/kasan/common.c:475 kmem_cache_alloc_trace include/linux/slab.h:450 [inline] kmalloc include/linux/slab.h:552 [inline] kzalloc include/linux/slab.h:664 [inline] kvm_vm_ioctl_register_coalesced_mmio+0x78/0x1cc arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:146 kvm_vm_ioctl+0x7e8/0x14c4 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:3746 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __arm64_sys_ioctl+0xf88/0x131c fs/ioctl.c:739 __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline] invoke_syscall arch/arm64/kernel/syscall.c:48 [inline] el0_svc_common arch/arm64/kernel/syscall.c:158 [inline] do_el0_svc+0x120/0x290 arch/arm64/kernel/syscall.c:220 el0_svc+0x1c/0x28 arch/arm64/kernel/entry-common.c:367 el0_sync_handler+0x98/0x170 arch/arm64/kernel/entry-common.c:383 el0_sync+0x140/0x180 arch/arm64/kernel/entry.S:670 Freed by task 4269: stack_trace_save+0x80/0xb8 kernel/stacktrace.c:121 kasan_save_stack mm/kasan/common.c:48 [inline] kasan_set_track+0x38/0x6c mm/kasan/common.c:56 kasan_set_free_info+0x20/0x40 mm/kasan/generic.c:355 __kasan_slab_free+0x124/0x150 mm/kasan/common.c:422 kasan_slab_free+0x10/0x1c mm/kasan/common.c:431 slab_free_hook mm/slub.c:1544 [inline] slab_free_freelist_hook mm/slub.c:1577 [inline] slab_free mm/slub.c:3142 [inline] kfree+0x104/0x38c mm/slub.c:4124 coalesced_mmio_destructor+0x94/0xa4 arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:102 kvm_iodevice_destructor include/kvm/iodev.h:61 [inline] kvm_io_bus_unregister_dev+0x248/0x280 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:4374 kvm_vm_ioctl_unregister_coalesced_mmio+0x158/0x1ec arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:186 kvm_vm_ioctl+0xe30/0x14c4 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:3755 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __arm64_sys_ioctl+0xf88/0x131c fs/ioctl.c:739 __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline] invoke_syscall arch/arm64/kernel/sys ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.4.119 以上 5.4.134 未満\nLinux Kernel 5.10.37 以上 5.10.52 未満\nLinux Kernel 5.11.21 以上 5.12 未満\nLinux Kernel 5.12.4 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021579": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: aio: fix use-after-free due to missing POLLFREE handling signalfd_poll() and binder_poll() are special in that they use a waitqueue whose lifetime is the current task, rather than the struct file as is normally the case. This is okay for blocking polls, since a blocking poll occurs within one task; however, non-blocking polls require another solution. This solution is for the queue to be cleared before it is freed, by sending a POLLFREE notification to all waiters. Unfortunately, only eventpoll handles POLLFREE. A second type of non-blocking poll, aio poll, was added in kernel v4.18, and it doesn't handle POLLFREE. This allows a use-after-free to occur if a signalfd or binder fd is polled with aio poll, and the waitqueue gets freed. Fix this by making aio poll handle POLLFREE. A patch by Ramji Jiyani <ramjiyani@google.com> (https://lore.kernel.org/r/20211027011834.2497484-1-ramjiyani@google.com) tried to do this by making aio_poll_wake() always complete the request inline if POLLFREE is seen. However, that solution had two bugs. First, it introduced a deadlock, as it unconditionally locked the aio context while holding the waitqueue lock, which inverts the normal locking order. Second, it didn't consider that POLLFREE notifications are missed while the request has been temporarily de-queued. The second problem was solved by my previous patch. This patch then properly fixes the use-after-free by handling POLLFREE in a deadlock-free way. It does this by taking advantage of the fact that freeing of the waitqueue is RCU-delayed, similar to what eventpoll does.",
        "technologies": "Linux\nLinux Kernel 4.18 以上 4.19.221 未満\nLinux Kernel 4.20 以上 5.4.165 未満\nLinux Kernel 5.5 以上 5.10.85 未満\nLinux Kernel 5.11 以上 5.15.8 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021587": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: scsi_debug: Fix out-of-bound read in resp_readcap16() The following warning was observed running syzkaller: [ 3813.830724] sg_write: data in/out 65466/242 bytes for SCSI command 0x9e-- guessing data in; [ 3813.830724] program syz-executor not setting count and/or reply_len properly [ 3813.836956] ================================================================== [ 3813.839465] BUG: KASAN: stack-out-of-bounds in sg_copy_buffer+0x157/0x1e0 [ 3813.841773] Read of size 4096 at addr ffff8883cf80f540 by task syz-executor/1549 [ 3813.846612] Call Trace: [ 3813.846995] dump_stack+0x108/0x15f [ 3813.847524] print_address_description+0xa5/0x372 [ 3813.848243] kasan_report.cold+0x236/0x2a8 [ 3813.849439] check_memory_region+0x240/0x270 [ 3813.850094] memcpy+0x30/0x80 [ 3813.850553] sg_copy_buffer+0x157/0x1e0 [ 3813.853032] sg_copy_from_buffer+0x13/0x20 [ 3813.853660] fill_from_dev_buffer+0x135/0x370 [ 3813.854329] resp_readcap16+0x1ac/0x280 [ 3813.856917] schedule_resp+0x41f/0x1630 [ 3813.858203] scsi_debug_queuecommand+0xb32/0x17e0 [ 3813.862699] scsi_dispatch_cmd+0x330/0x950 [ 3813.863329] scsi_request_fn+0xd8e/0x1710 [ 3813.863946] __blk_run_queue+0x10b/0x230 [ 3813.864544] blk_execute_rq_nowait+0x1d8/0x400 [ 3813.865220] sg_common_write.isra.0+0xe61/0x2420 [ 3813.871637] sg_write+0x6c8/0xef0 [ 3813.878853] __vfs_write+0xe4/0x800 [ 3813.883487] vfs_write+0x17b/0x530 [ 3813.884008] ksys_write+0x103/0x270 [ 3813.886268] __x64_sys_write+0x77/0xc0 [ 3813.886841] do_syscall_64+0x106/0x360 [ 3813.887415] entry_SYSCALL_64_after_hwframe+0x44/0xa9 This issue can be reproduced with the following syzkaller log: r0 = openat(0xffffffffffffff9c, &(0x7f0000000040)='./file0\\x00', 0x26e1, 0x0) r1 = syz_open_procfs(0xffffffffffffffff, &(0x7f0000000000)='fd/3\\x00') open_by_handle_at(r1, &(0x7f00000003c0)=ANY=[@ANYRESHEX], 0x602000) r2 = syz_open_dev$sg(&(0x7f0000000000), 0x0, 0x40782) write$binfmt_aout(r2, &(0x7f0000000340)=ANY=[@ANYBLOB=\"00000000deff000000000000000000000000000000000000000000000000000047f007af9e107a41ec395f1bded7be24277a1501ff6196a83366f4e6362bc0ff2b247f68a972989b094b2da4fb3607fcf611a22dd04310d28c75039d\"], 0x126) In resp_readcap16() we get \"int alloc_len\" value -1104926854, and then pass the huge arr_len to fill_from_dev_buffer(), but arr is only 32 bytes. This leads to OOB in sg_copy_buffer(). To solve this issue, define alloc_len as u32.",
        "technologies": "Linux\nLinux Kernel 5.10.82 未満\nLinux Kernel 5.11 以上 5.15.5 未満"
    },
    "JVNDB-2021-021588": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring: fix ltout double free on completion race Always remove linked timeout on io_link_timeout_fn() from the master request link list, otherwise we may get use-after-free when first io_link_timeout_fn() puts linked timeout in the fail path, and then will be found and put on master's free.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021572": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sctp: do asoc update earlier in sctp_sf_do_dupcook_a There's a panic that occurs in a few of envs, the call trace is as below: [] general protection fault, ... 0x29acd70f1000a: 0000 [#1] SMP PTI [] RIP: 0010:sctp_ulpevent_notify_peer_addr_change+0x4b/0x1fa [sctp] [] sctp_assoc_control_transport+0x1b9/0x210 [sctp] [] sctp_do_8_2_transport_strike.isra.16+0x15c/0x220 [sctp] [] sctp_cmd_interpreter.isra.21+0x1231/0x1a10 [sctp] [] sctp_do_sm+0xc3/0x2a0 [sctp] [] sctp_generate_timeout_event+0x81/0xf0 [sctp] This is caused by a transport use-after-free issue. When processing a duplicate COOKIE-ECHO chunk in sctp_sf_do_dupcook_a(), both COOKIE-ACK and SHUTDOWN chunks are allocated with the transort from the new asoc. However, later in the sideeffect machine, the old asoc is used to send them out and old asoc's shutdown_last_sent_to is set to the transport that SHUTDOWN chunk attached to in sctp_cmd_setup_t2(), which actually belongs to the new asoc. After the new_asoc is freed and the old asoc T2 timeout, the old asoc's shutdown_last_sent_to that is already freed would be accessed in sctp_sf_t2_timer_expire(). Thanks Alexander and Jere for helping dig into this issue. To fix it, this patch is to do the asoc update first, then allocate the COOKIE-ACK and SHUTDOWN chunks with the 'updated' old asoc. This would make more sense, as a chunk from an asoc shouldn't be sent out with another asoc. We had fixed quite a few issues caused by this.",
        "technologies": "Linux\nLinux Kernel 4.19.123 以上 4.19.191 未満\nLinux Kernel 5.4.41 以上 5.4.120 未満\nLinux Kernel 5.7 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満"
    },
    "JVNDB-2021-021589": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: j1939: j1939_netdev_start(): fix UAF for rx_kref of j1939_priv It will trigger UAF for rx_kref of j1939_priv as following. cpu0 cpu1 j1939_sk_bind(socket0, ndev0, ...) j1939_netdev_start j1939_sk_bind(socket1, ndev0, ...) j1939_netdev_start j1939_priv_set j1939_priv_get_by_ndev_locked j1939_jsk_add ..... j1939_netdev_stop kref_put_lock(&priv->rx_kref, ...) kref_get(&priv->rx_kref, ...) REFCOUNT_WARN(\"addition on 0;...\") ==================================================== refcount_t: addition on 0; use-after-free. WARNING: CPU: 1 PID: 20874 at lib/refcount.c:25 refcount_warn_saturate+0x169/0x1e0 RIP: 0010:refcount_warn_saturate+0x169/0x1e0 Call Trace: j1939_netdev_start+0x68b/0x920 j1939_sk_bind+0x426/0xeb0 ? security_socket_bind+0x83/0xb0 The rx_kref's kref_get() and kref_put() should use j1939_netdev_lock to protect.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.156 未満\nLinux Kernel 5.5 以上 5.10.76 未満\nLinux Kernel 5.11 以上 5.14.15 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021593": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: fix use-after-free in nft_set_catchall_destroy() We need to use list_for_each_entry_safe() iterator because we can not access @catchall after kfree_rcu() call. syzbot reported: BUG: KASAN: use-after-free in nft_set_catchall_destroy net/netfilter/nf_tables_api.c:4486 [inline] BUG: KASAN: use-after-free in nft_set_destroy net/netfilter/nf_tables_api.c:4504 [inline] BUG: KASAN: use-after-free in nft_set_destroy+0x3fd/0x4f0 net/netfilter/nf_tables_api.c:4493 Read of size 8 at addr ffff8880716e5b80 by task syz-executor.3/8871 CPU: 1 PID: 8871 Comm: syz-executor.3 Not tainted 5.16.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0x8d/0x2ed mm/kasan/report.c:247 __kasan_report mm/kasan/report.c:433 [inline] kasan_report.cold+0x83/0xdf mm/kasan/report.c:450 nft_set_catchall_destroy net/netfilter/nf_tables_api.c:4486 [inline] nft_set_destroy net/netfilter/nf_tables_api.c:4504 [inline] nft_set_destroy+0x3fd/0x4f0 net/netfilter/nf_tables_api.c:4493 __nft_release_table+0x79f/0xcd0 net/netfilter/nf_tables_api.c:9626 nft_rcv_nl_event+0x4f8/0x670 net/netfilter/nf_tables_api.c:9688 notifier_call_chain+0xb5/0x200 kernel/notifier.c:83 blocking_notifier_call_chain kernel/notifier.c:318 [inline] blocking_notifier_call_chain+0x67/0x90 kernel/notifier.c:306 netlink_release+0xcb6/0x1dd0 net/netlink/af_netlink.c:788 __sock_release+0xcd/0x280 net/socket.c:649 sock_close+0x18/0x20 net/socket.c:1314 __fput+0x286/0x9f0 fs/file_table.c:280 task_work_run+0xdd/0x1a0 kernel/task_work.c:164 tracehook_notify_resume include/linux/tracehook.h:189 [inline] exit_to_user_mode_loop kernel/entry/common.c:175 [inline] exit_to_user_mode_prepare+0x27e/0x290 kernel/entry/common.c:207 __syscall_exit_to_user_mode_work kernel/entry/common.c:289 [inline] syscall_exit_to_user_mode+0x19/0x60 kernel/entry/common.c:300 do_syscall_64+0x42/0xb0 arch/x86/entry/common.c:86 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f75fbf28adb Code: 0f 05 48 3d 00 f0 ff ff 77 45 c3 0f 1f 40 00 48 83 ec 18 89 7c 24 0c e8 63 fc ff ff 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 a1 fc ff ff 8b 44 RSP: 002b:00007ffd8da7ec10 EFLAGS: 00000293 ORIG_RAX: 0000000000000003 RAX: 0000000000000000 RBX: 0000000000000004 RCX: 00007f75fbf28adb RDX: 00007f75fc08e828 RSI: ffffffffffffffff RDI: 0000000000000003 RBP: 00007f75fc08a960 R08: 0000000000000000 R09: 00007f75fc08e830 R10: 00007ffd8da7ed10 R11: 0000000000000293 R12: 00000000002067c3 R13: 00007ffd8da7ed10 R14: 00007f75fc088f60 R15: 0000000000000032 </TASK> Allocated by task 8886: kasan_save_stack+0x1e/0x50 mm/kasan/common.c:38 kasan_set_track mm/kasan/common.c:46 [inline] set_alloc_info mm/kasan/common.c:434 [inline] ____kasan_kmalloc mm/kasan/common.c:513 [inline] ____kasan_kmalloc mm/kasan/common.c:472 [inline] __kasan_kmalloc+0xa6/0xd0 mm/kasan/common.c:522 kasan_kmalloc include/linux/kasan.h:269 [inline] kmem_cache_alloc_trace+0x1ea/0x4a0 mm/slab.c:3575 kmalloc include/linux/slab.h:590 [inline] nft_setelem_catchall_insert net/netfilter/nf_tables_api.c:5544 [inline] nft_setelem_insert net/netfilter/nf_tables_api.c:5562 [inline] nft_add_set_elem+0x232e/0x2f40 net/netfilter/nf_tables_api.c:5936 nf_tables_newsetelem+0x6ff/0xbb0 net/netfilter/nf_tables_api.c:6032 nfnetlink_rcv_batch+0x1710/0x25f0 net/netfilter/nfnetlink.c:513 nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:634 [inline] nfnetlink_rcv+0x3af/0x420 net/netfilter/nfnetlink.c:652 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x904/0xdf0 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/ ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021557": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/rtrs-clt: destroy sysfs after removing session from active list A session can be removed dynamically by sysfs interface \"remove_path\" that eventually calls rtrs_clt_remove_path_from_sysfs function. The current rtrs_clt_remove_path_from_sysfs first removes the sysfs interfaces and frees sess->stats object. Second it removes the session from the active list. Therefore some functions could access non-connected session and access the freed sess->stats object even-if they check the session status before accessing the session. For instance rtrs_clt_request and get_next_path_min_inflight check the session status and try to send IO to the session. The session status could be changed when they are trying to send IO but they could not catch the change and update the statistics information in sess->stats object, and generate use-after-free problem. (see: \"RDMA/rtrs-clt: Check state of the rtrs_clt_sess before reading its stats\") This patch changes the rtrs_clt_remove_path_from_sysfs to remove the session from the active session list and then destroy the sysfs interfaces. Each function still should check the session status because closing or error recovery paths can change the status.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021598": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm, slub: fix potential use-after-free in slab_debugfs_fops When sysfs_slab_add failed, we shouldn't call debugfs_slab_add() for s because s will be freed soon. And slab_debugfs_fops will use s later leading to a use-after-free.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.14.15 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021599": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: flower: protect fl_walk() with rcu Patch that refactored fl_walk() to use idr_for_each_entry_continue_ul() also removed rcu protection of individual filters which causes following use-after-free when filter is deleted concurrently. Fix fl_walk() to obtain rcu read lock while iterating and taking the filter reference and temporary release the lock while calling arg->fn() callback that can sleep. KASAN trace: [ 352.773640] ================================================================== [ 352.775041] BUG: KASAN: use-after-free in fl_walk+0x159/0x240 [cls_flower] [ 352.776304] Read of size 4 at addr ffff8881c8251480 by task tc/2987 [ 352.777862] CPU: 3 PID: 2987 Comm: tc Not tainted 5.15.0-rc2+ #2 [ 352.778980] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [ 352.781022] Call Trace: [ 352.781573] dump_stack_lvl+0x46/0x5a [ 352.782332] print_address_description.constprop.0+0x1f/0x140 [ 352.783400] ? fl_walk+0x159/0x240 [cls_flower] [ 352.784292] ? fl_walk+0x159/0x240 [cls_flower] [ 352.785138] kasan_report.cold+0x83/0xdf [ 352.785851] ? fl_walk+0x159/0x240 [cls_flower] [ 352.786587] kasan_check_range+0x145/0x1a0 [ 352.787337] fl_walk+0x159/0x240 [cls_flower] [ 352.788163] ? fl_put+0x10/0x10 [cls_flower] [ 352.789007] ? __mutex_unlock_slowpath.constprop.0+0x220/0x220 [ 352.790102] tcf_chain_dump+0x231/0x450 [ 352.790878] ? tcf_chain_tp_delete_empty+0x170/0x170 [ 352.791833] ? __might_sleep+0x2e/0xc0 [ 352.792594] ? tfilter_notify+0x170/0x170 [ 352.793400] ? __mutex_unlock_slowpath.constprop.0+0x220/0x220 [ 352.794477] tc_dump_tfilter+0x385/0x4b0 [ 352.795262] ? tc_new_tfilter+0x1180/0x1180 [ 352.796103] ? __mod_node_page_state+0x1f/0xc0 [ 352.796974] ? __build_skb_around+0x10e/0x130 [ 352.797826] netlink_dump+0x2c0/0x560 [ 352.798563] ? netlink_getsockopt+0x430/0x430 [ 352.799433] ? __mutex_unlock_slowpath.constprop.0+0x220/0x220 [ 352.800542] __netlink_dump_start+0x356/0x440 [ 352.801397] rtnetlink_rcv_msg+0x3ff/0x550 [ 352.802190] ? tc_new_tfilter+0x1180/0x1180 [ 352.802872] ? rtnl_calcit.isra.0+0x1f0/0x1f0 [ 352.803668] ? tc_new_tfilter+0x1180/0x1180 [ 352.804344] ? _copy_from_iter_nocache+0x800/0x800 [ 352.805202] ? kasan_set_track+0x1c/0x30 [ 352.805900] netlink_rcv_skb+0xc6/0x1f0 [ 352.806587] ? rht_deferred_worker+0x6b0/0x6b0 [ 352.807455] ? rtnl_calcit.isra.0+0x1f0/0x1f0 [ 352.808324] ? netlink_ack+0x4d0/0x4d0 [ 352.809086] ? netlink_deliver_tap+0x62/0x3d0 [ 352.809951] netlink_unicast+0x353/0x480 [ 352.810744] ? netlink_attachskb+0x430/0x430 [ 352.811586] ? __alloc_skb+0xd7/0x200 [ 352.812349] netlink_sendmsg+0x396/0x680 [ 352.813132] ? netlink_unicast+0x480/0x480 [ 352.813952] ? __import_iovec+0x192/0x210 [ 352.814759] ? netlink_unicast+0x480/0x480 [ 352.815580] sock_sendmsg+0x6c/0x80 [ 352.816299] ____sys_sendmsg+0x3a5/0x3c0 [ 352.817096] ? kernel_sendmsg+0x30/0x30 [ 352.817873] ? __ia32_sys_recvmmsg+0x150/0x150 [ 352.818753] ___sys_sendmsg+0xd8/0x140 [ 352.819518] ? sendmsg_copy_msghdr+0x110/0x110 [ 352.820402] ? ___sys_recvmsg+0xf4/0x1a0 [ 352.821110] ? __copy_msghdr_from_user+0x260/0x260 [ 352.821934] ? _raw_spin_lock+0x81/0xd0 [ 352.822680] ? __handle_mm_fault+0xef3/0x1b20 [ 352.823549] ? rb_insert_color+0x2a/0x270 [ 352.824373] ? copy_page_range+0x16b0/0x16b0 [ 352.825209] ? perf_event_update_userpage+0x2d0/0x2d0 [ 352.826190] ? __fget_light+0xd9/0xf0 [ 352.826941] __sys_sendmsg+0xb3/0x130 [ 352.827613] ? __sys_sendmsg_sock+0x20/0x20 [ 352.828377] ? do_user_addr_fault+0x2c5/0x8a0 [ 352.829184] ? fpregs_assert_state_consistent+0x52/0x60 [ 352.830001] ? exit_to_user_mode_prepare+0x32/0x160 [ 352.830845] do_syscall_64+0x35/0x80 [ 352.831445] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 352.832331] RIP: 0033:0x7f7bee973c17 [ ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.151 未満\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021601": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pinctrl: mediatek: fix global-out-of-bounds issue When eint virtual eint number is greater than gpio number, it maybe produce 'desc[eint_n]' size globle-out-of-bounds issue.",
        "technologies": "Linux\nLinux Kernel 5.4.169 未満\nLinux Kernel 5.5 以上 5.10.89 未満\nLinux Kernel 5.11 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021603": {
        "title": "Linux の Linux Kernel における無効なポインタや参照の解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tee: optee: Fix incorrect page free bug Pointer to the allocated pages (struct page *page) has already progressed towards the end of allocation. It is incorrect to perform __free_pages(page, order) using this pointer as we would free any arbitrary pages. Fix this by stop modifying the page pointer.",
        "technologies": "Linux\nLinux Kernel 5.4.140 以上 5.4.169 未満\nLinux Kernel 5.10.58 以上 5.10.89 未満\nLinux Kernel 5.14 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021602": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/damon/dbgfs: protect targets destructions with kdamond_lock DAMON debugfs interface iterates current monitoring targets in 'dbgfs_target_ids_read()' while holding the corresponding 'kdamond_lock'. However, it also destructs the monitoring targets in 'dbgfs_before_terminate()' without holding the lock. This can result in a use_after_free bug. This commit avoids the race by protecting the destruction with the corresponding 'kdamond_lock'.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021615": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: unlink table before deleting it syzbot reports following UAF: BUG: KASAN: use-after-free in memcmp+0x18f/0x1c0 lib/string.c:955 nla_strcmp+0xf2/0x130 lib/nlattr.c:836 nft_table_lookup.part.0+0x1a2/0x460 net/netfilter/nf_tables_api.c:570 nft_table_lookup net/netfilter/nf_tables_api.c:4064 [inline] nf_tables_getset+0x1b3/0x860 net/netfilter/nf_tables_api.c:4064 nfnetlink_rcv_msg+0x659/0x13f0 net/netfilter/nfnetlink.c:285 netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2504 Problem is that all get operations are lockless, so the commit_mutex held by nft_rcv_nl_event() isn't enough to stop a parallel GET request from doing read-accesses to the table object even after synchronize_rcu(). To avoid this, unlink the table first and store the table objects in on-stack scratch space.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021625": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFSD: Fix READDIR buffer overflow If a client sends a READDIR count argument that is too small (say, zero), then the buffer size calculation in the new init_dirlist helper functions results in an underflow, allowing the XDR stream functions to write beyond the actual buffer. This calculation has always been suspect. NFSD has never sanity- checked the READDIR count argument, but the old entry encoders managed the problem correctly. With the commits below, entry encoding changed, exposing the underflow to the pointer arithmetic in xdr_reserve_space(). Modern NFS clients attempt to retrieve as much data as possible for each READDIR request. Also, we have no unit tests that exercise the behavior of READDIR at the lower bound of @count values. Thus this case was missed during testing.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021620": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (lm90) Prevent integer overflow/underflow in hysteresis calculations Commit b50aa49638c7 (\"hwmon: (lm90) Prevent integer underflows of temperature calculations\") addressed a number of underflow situations when writing temperature limits. However, it missed one situation, seen when an attempt is made to set the hysteresis value to MAX_LONG and the critical temperature limit is negative. Use clamp_val() when setting the hysteresis temperature to ensure that the provided value can never overflow or underflow.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.2 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021623": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Input: elantech - fix stack out of bound access in elantech_change_report_id() The array param[] in elantech_change_report_id() must be at least 3 bytes, because elantech_read_reg_params() is calling ps2_command() with PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but it's defined in the stack as an array of 2 bytes, therefore we have a potential stack out-of-bounds access here, also confirmed by KASAN: [ 6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0 [ 6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118 [ 6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110 [ 6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020 [ 6.512436] Workqueue: events_long serio_handle_event [ 6.512453] Call Trace: [ 6.512462] show_stack+0x52/0x58 [ 6.512474] dump_stack+0xa1/0xd3 [ 6.512487] print_address_description.constprop.0+0x1d/0x140 [ 6.512502] ? __ps2_command+0x372/0x7e0 [ 6.512516] __kasan_report.cold+0x7d/0x112 [ 6.512527] ? _raw_write_lock_irq+0x20/0xd0 [ 6.512539] ? __ps2_command+0x372/0x7e0 [ 6.512552] kasan_report+0x3c/0x50 [ 6.512564] __asan_load1+0x6a/0x70 [ 6.512575] __ps2_command+0x372/0x7e0 [ 6.512589] ? ps2_drain+0x240/0x240 [ 6.512601] ? dev_printk_emit+0xa2/0xd3 [ 6.512612] ? dev_vprintk_emit+0xc5/0xc5 [ 6.512621] ? __kasan_check_write+0x14/0x20 [ 6.512634] ? mutex_lock+0x8f/0xe0 [ 6.512643] ? __mutex_lock_slowpath+0x20/0x20 [ 6.512655] ps2_command+0x52/0x90 [ 6.512670] elantech_ps2_command+0x4f/0xc0 [psmouse] [ 6.512734] elantech_change_report_id+0x1e6/0x256 [psmouse] [ 6.512799] ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse] [ 6.512863] ? ps2_command+0x7f/0x90 [ 6.512877] elantech_query_info.cold+0x6bd/0x9ed [psmouse] [ 6.512943] ? elantech_setup_ps2+0x460/0x460 [psmouse] [ 6.513005] ? psmouse_reset+0x69/0xb0 [psmouse] [ 6.513064] ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse] [ 6.513122] ? phys_pmd_init+0x30e/0x521 [ 6.513137] elantech_init+0x8a/0x200 [psmouse] [ 6.513200] ? elantech_init_ps2+0xf0/0xf0 [psmouse] [ 6.513249] ? elantech_query_info+0x440/0x440 [psmouse] [ 6.513296] ? synaptics_send_cmd+0x60/0x60 [psmouse] [ 6.513342] ? elantech_query_info+0x440/0x440 [psmouse] [ 6.513388] ? psmouse_try_protocol+0x11e/0x170 [psmouse] [ 6.513432] psmouse_extensions+0x65d/0x6e0 [psmouse] [ 6.513476] ? psmouse_try_protocol+0x170/0x170 [psmouse] [ 6.513519] ? mutex_unlock+0x22/0x40 [ 6.513526] ? ps2_command+0x7f/0x90 [ 6.513536] ? psmouse_probe+0xa3/0xf0 [psmouse] [ 6.513580] psmouse_switch_protocol+0x27d/0x2e0 [psmouse] [ 6.513624] psmouse_connect+0x272/0x530 [psmouse] [ 6.513669] serio_driver_probe+0x55/0x70 [ 6.513679] really_probe+0x190/0x720 [ 6.513689] driver_probe_device+0x160/0x1f0 [ 6.513697] device_driver_attach+0x119/0x130 [ 6.513705] ? device_driver_attach+0x130/0x130 [ 6.513713] __driver_attach+0xe7/0x1a0 [ 6.513720] ? device_driver_attach+0x130/0x130 [ 6.513728] bus_for_each_dev+0xfb/0x150 [ 6.513738] ? subsys_dev_iter_exit+0x10/0x10 [ 6.513748] ? _raw_write_unlock_bh+0x30/0x30 [ 6.513757] driver_attach+0x2d/0x40 [ 6.513764] serio_handle_event+0x199/0x3d0 [ 6.513775] process_one_work+0x471/0x740 [ 6.513785] worker_thread+0x2d2/0x790 [ 6.513794] ? process_one_work+0x740/0x740 [ 6.513802] kthread+0x1b4/0x1e0 [ 6.513809] ? set_kthread_struct+0x80/0x80 [ 6.513816] ret_from_fork+0x22/0x30 [ 6.513832] The buggy address belongs to the page: [ 6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7 [ 6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff) [ 6.513860] raw: 0 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.4.103 以上 5.4.169 未満\nLinux Kernel 5.10.21 以上 5.10.89 未満\nLinux Kernel 5.11 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021605": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dpaa2-eth: fix use-after-free in dpaa2_eth_remove Access to netdev after free_netdev() will cause use-after-free bug. Move debug log before free_netdev() call to avoid it.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 5.4.162 未満\nLinux Kernel 5.5 以上 5.10.82 未満\nLinux Kernel 5.11 以上 5.15.5 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021628": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: inet: fully convert sk->sk_rx_dst to RCU rules syzbot reported various issues around early demux, one being included in this changelog [1] sk->sk_rx_dst is using RCU protection without clearly documenting it. And following sequences in tcp_v4_do_rcv()/tcp_v6_do_rcv() are not following standard RCU rules. [a] dst_release(dst); [b] sk->sk_rx_dst = NULL; They look wrong because a delete operation of RCU protected pointer is supposed to clear the pointer before the call_rcu()/synchronize_rcu() guarding actual memory freeing. In some cases indeed, dst could be freed before [b] is done. We could cheat by clearing sk_rx_dst before calling dst_release(), but this seems the right time to stick to standard RCU annotations and debugging facilities. [1] BUG: KASAN: use-after-free in dst_check include/net/dst.h:470 [inline] BUG: KASAN: use-after-free in tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792 Read of size 2 at addr ffff88807f1cb73a by task syz-executor.5/9204 CPU: 0 PID: 9204 Comm: syz-executor.5 Not tainted 5.16.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c:247 __kasan_report mm/kasan/report.c:433 [inline] kasan_report.cold+0x83/0xdf mm/kasan/report.c:450 dst_check include/net/dst.h:470 [inline] tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792 ip_rcv_finish_core.constprop.0+0x15de/0x1e80 net/ipv4/ip_input.c:340 ip_list_rcv_finish.constprop.0+0x1b2/0x6e0 net/ipv4/ip_input.c:583 ip_sublist_rcv net/ipv4/ip_input.c:609 [inline] ip_list_rcv+0x34e/0x490 net/ipv4/ip_input.c:644 __netif_receive_skb_list_ptype net/core/dev.c:5508 [inline] __netif_receive_skb_list_core+0x549/0x8e0 net/core/dev.c:5556 __netif_receive_skb_list net/core/dev.c:5608 [inline] netif_receive_skb_list_internal+0x75e/0xd80 net/core/dev.c:5699 gro_normal_list net/core/dev.c:5853 [inline] gro_normal_list net/core/dev.c:5849 [inline] napi_complete_done+0x1f1/0x880 net/core/dev.c:6590 virtqueue_napi_complete drivers/net/virtio_net.c:339 [inline] virtnet_poll+0xca2/0x11b0 drivers/net/virtio_net.c:1557 __napi_poll+0xaf/0x440 net/core/dev.c:7023 napi_poll net/core/dev.c:7090 [inline] net_rx_action+0x801/0xb40 net/core/dev.c:7177 __do_softirq+0x29b/0x9c2 kernel/softirq.c:558 invoke_softirq kernel/softirq.c:432 [inline] __irq_exit_rcu+0x123/0x180 kernel/softirq.c:637 irq_exit_rcu+0x5/0x20 kernel/softirq.c:649 common_interrupt+0x52/0xc0 arch/x86/kernel/irq.c:240 asm_common_interrupt+0x1e/0x40 arch/x86/include/asm/idtentry.h:629 RIP: 0033:0x7f5e972bfd57 Code: 39 d1 73 14 0f 1f 80 00 00 00 00 48 8b 50 f8 48 83 e8 08 48 39 ca 77 f3 48 39 c3 73 3e 48 89 13 48 8b 50 f8 48 89 38 49 8b 0e <48> 8b 3e 48 83 c3 08 48 83 c6 08 eb bc 48 39 d1 72 9e 48 39 d0 73 RSP: 002b:00007fff8a413210 EFLAGS: 00000283 RAX: 00007f5e97108990 RBX: 00007f5e97108338 RCX: ffffffff81d3aa45 RDX: ffffffff81d3aa45 RSI: 00007f5e97108340 RDI: ffffffff81d3aa45 RBP: 00007f5e97107eb8 R08: 00007f5e97108d88 R09: 0000000093c2e8d9 R10: 0000000000000000 R11: 0000000000000000 R12: 00007f5e97107eb0 R13: 00007f5e97108338 R14: 00007f5e97107ea8 R15: 0000000000000019 </TASK> Allocated by task 13: kasan_save_stack+0x1e/0x50 mm/kasan/common.c:38 kasan_set_track mm/kasan/common.c:46 [inline] set_alloc_info mm/kasan/common.c:434 [inline] __kasan_slab_alloc+0x90/0xc0 mm/kasan/common.c:467 kasan_slab_alloc include/linux/kasan.h:259 [inline] slab_post_alloc_hook mm/slab.h:519 [inline] slab_alloc_node mm/slub.c:3234 [inline] slab_alloc mm/slub.c:3242 [inline] kmem_cache_alloc+0x202/0x3a0 mm/slub.c:3247 dst_alloc+0x146/0x1f0 net/core/dst.c:92 rt_dst_alloc+0x73/0x430 net/ipv4/route.c:1613 ip_route_input_slow+0x1817/0x3a20 net/ipv4/route.c:234 ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.6 以上 4.9.331 未満\nLinux Kernel 4.10 以上 4.14.296 未満\nLinux Kernel 4.15 以上 4.19.262 未満\nLinux Kernel 4.20 以上 5.4.220 未満\nLinux Kernel 5.5 以上 5.10.150 未満\nLinux Kernel 5.11 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021617": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: asix: fix uninit-value in asix_mdio_read() asix_read_cmd() may read less than sizeof(smsr) bytes and in this case smsr will be uninitialized. Fail log: BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497 BUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497 asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497 asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497",
        "technologies": "Linux\nLinux Kernel 4.9 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021607": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tun: avoid double free in tun_free_netdev Avoid double free in tun_free_netdev() by moving the dev->tstats and tun->security allocs to a new ndo_init routine (tun_net_init()) that will be called by register_netdevice(). ndo_init is paired with the desctructor (tun_free_netdev()), so if there's an error in register_netdevice() the destructor will handle the frees. BUG: KASAN: double-free or invalid-free in selinux_tun_dev_free_security+0x1a/0x20 security/selinux/hooks.c:5605 CPU: 0 PID: 25750 Comm: syz-executor416 Not tainted 5.16.0-rc2-syzk #1 Hardware name: Red Hat KVM, BIOS Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x89/0xb5 lib/dump_stack.c:106 print_address_description.constprop.9+0x28/0x160 mm/kasan/report.c:247 kasan_report_invalid_free+0x55/0x80 mm/kasan/report.c:372 ____kasan_slab_free mm/kasan/common.c:346 [inline] __kasan_slab_free+0x107/0x120 mm/kasan/common.c:374 kasan_slab_free include/linux/kasan.h:235 [inline] slab_free_hook mm/slub.c:1723 [inline] slab_free_freelist_hook mm/slub.c:1749 [inline] slab_free mm/slub.c:3513 [inline] kfree+0xac/0x2d0 mm/slub.c:4561 selinux_tun_dev_free_security+0x1a/0x20 security/selinux/hooks.c:5605 security_tun_dev_free_security+0x4f/0x90 security/security.c:2342 tun_free_netdev+0xe6/0x150 drivers/net/tun.c:2215 netdev_run_todo+0x4df/0x840 net/core/dev.c:10627 rtnl_unlock+0x13/0x20 net/core/rtnetlink.c:112 __tun_chr_ioctl+0x80c/0x2870 drivers/net/tun.c:3302 tun_chr_ioctl+0x2f/0x40 drivers/net/tun.c:3311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:874 [inline] __se_sys_ioctl fs/ioctl.c:860 [inline] __x64_sys_ioctl+0x19d/0x220 fs/ioctl.c:860 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3a/0x80 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 4.19.280 未満\nLinux Kernel 4.20 以上 5.4.240 未満\nLinux Kernel 5.5 以上 5.10.136 未満\nLinux Kernel 5.11 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021631": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/tls: Fix use-after-free after the TLS device goes down and up When a netdev with active TLS offload goes down, tls_device_down is called to stop the offload and tear down the TLS context. However, the socket stays alive, and it still points to the TLS context, which is now deallocated. If a netdev goes up, while the connection is still active, and the data flow resumes after a number of TCP retransmissions, it will lead to a use-after-free of the TLS context. This commit addresses this bug by keeping the context alive until its normal destruction, and implements the necessary fallbacks, so that the connection can resume in software (non-offloaded) kTLS mode. On the TX side tls_sw_fallback is used to encrypt all packets. The RX side already has all the necessary fallbacks, because receiving non-decrypted packets is supported. The thing needed on the RX side is to block resync requests, which are normally produced after receiving non-decrypted packets. The necessary synchronization is implemented for a graceful teardown: first the fallbacks are deployed, then the driver resources are released (it used to be possible to have a tls_dev_resync after tls_dev_del). A new flag called TLS_RX_DEV_DEGRADED is added to indicate the fallback mode. It's used to skip the RX resync logic completely, as it becomes useless, and some objects may be released (for example, resync_async, which is allocated and freed by the driver).",
        "technologies": "Linux\nLinux Kernel 4.18 以上 5.10.43 未満\nLinux Kernel 5.11 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021629": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xen-netback: take a reference to the RX task thread Do this in order to prevent the task from being freed if the thread returns (which can be triggered by the frontend) before the call to kthread_stop done as part of the backend tear down. Not taking the reference will lead to a use-after-free in that scenario. Such reference was taken before but dropped as part of the rework done in 2ac061ce97f4. Reintroduce the reference taking and add a comment this time explaining why it's needed. This is XSA-374 / CVE-2021-28691.",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.43 未満\nLinux Kernel 5.11 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021632": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: mt7921: fix possible AOOB issue in mt7921_mcu_tx_rate_report Fix possible array out of bound access in mt7921_mcu_tx_rate_report. Remove unnecessary varibable in mt7921_mcu_tx_rate_report",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021626": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: marvell: prestera: fix incorrect structure access In line: upper = info->upper_dev; We access upper_dev field, which is related only for particular events (e.g. event == NETDEV_CHANGEUPPER). So, this line cause invalid memory access for another events, when ptr is not netdev_notifier_changeupper_info. The KASAN logs are as follows: [ 30.123165] BUG: KASAN: stack-out-of-bounds in prestera_netdev_port_event.constprop.0+0x68/0x538 [prestera] [ 30.133336] Read of size 8 at addr ffff80000cf772b0 by task udevd/778 [ 30.139866] [ 30.141398] CPU: 0 PID: 778 Comm: udevd Not tainted 5.16.0-rc3 #6 [ 30.147588] Hardware name: DNI AmazonGo1 A7040 board (DT) [ 30.153056] Call trace: [ 30.155547] dump_backtrace+0x0/0x2c0 [ 30.159320] show_stack+0x18/0x30 [ 30.162729] dump_stack_lvl+0x68/0x84 [ 30.166491] print_address_description.constprop.0+0x74/0x2b8 [ 30.172346] kasan_report+0x1e8/0x250 [ 30.176102] __asan_load8+0x98/0xe0 [ 30.179682] prestera_netdev_port_event.constprop.0+0x68/0x538 [prestera] [ 30.186847] prestera_netdev_event_handler+0x1b4/0x1c0 [prestera] [ 30.193313] raw_notifier_call_chain+0x74/0xa0 [ 30.197860] call_netdevice_notifiers_info+0x68/0xc0 [ 30.202924] register_netdevice+0x3cc/0x760 [ 30.207190] register_netdev+0x24/0x50 [ 30.211015] prestera_device_register+0x8a0/0xba0 [prestera]",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.12 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021648": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/core: Set send and receive CQ before forwarding to the driver Preset both receive and send CQ pointers prior to call to the drivers and overwrite it later again till the mlx4 is going to be changed do not overwrite ibqp properties. This change is needed for mlx5, because in case of QP creation failure, it will go to the path of QP destroy which relies on proper CQ pointers. BUG: KASAN: use-after-free in create_qp.cold+0x164/0x16e [mlx5_ib] Write of size 8 at addr ffff8880064c55c0 by task a.out/246 CPU: 0 PID: 246 Comm: a.out Not tainted 5.15.0+ #291 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: dump_stack_lvl+0x45/0x59 print_address_description.constprop.0+0x1f/0x140 kasan_report.cold+0x83/0xdf create_qp.cold+0x164/0x16e [mlx5_ib] mlx5_ib_create_qp+0x358/0x28a0 [mlx5_ib] create_qp.part.0+0x45b/0x6a0 [ib_core] ib_create_qp_user+0x97/0x150 [ib_core] ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs] ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs] ib_uverbs_ioctl+0x169/0x260 [ib_uverbs] __x64_sys_ioctl+0x866/0x14d0 do_syscall_64+0x3d/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae Allocated by task 246: kasan_save_stack+0x1b/0x40 __kasan_kmalloc+0xa4/0xd0 create_qp.part.0+0x92/0x6a0 [ib_core] ib_create_qp_user+0x97/0x150 [ib_core] ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs] ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs] ib_uverbs_ioctl+0x169/0x260 [ib_uverbs] __x64_sys_ioctl+0x866/0x14d0 do_syscall_64+0x3d/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae Freed by task 246: kasan_save_stack+0x1b/0x40 kasan_set_track+0x1c/0x30 kasan_set_free_info+0x20/0x30 __kasan_slab_free+0x10c/0x150 slab_free_freelist_hook+0xb4/0x1b0 kfree+0xe7/0x2a0 create_qp.part.0+0x52b/0x6a0 [ib_core] ib_create_qp_user+0x97/0x150 [ib_core] ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs] ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs] ib_uverbs_ioctl+0x169/0x260 [ib_uverbs] __x64_sys_ioctl+0x866/0x14d0 do_syscall_64+0x3d/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.5 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021659": {
        "title": "Linux の Linux Kernel における不完全なクリーンアップに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/kvm: Disable kvmclock on all CPUs on shutdown Currenly, we disable kvmclock from machine_shutdown() hook and this only happens for boot CPU. We need to disable it for all CPUs to guard against memory corruption e.g. on restore from hibernate. Note, writing '0' to kvmclock MSR doesn't clear memory location, it just prevents hypervisor from updating the location so for the short while after write and while CPU is still alive, the clock remains usable and correct so we don't need to switch to some other clocksource.",
        "technologies": "Linux\nLinux Kernel 5.4.125 未満\nLinux Kernel 5.5 以上 5.10.43 未満\nLinux Kernel 5.11 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021665": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dsa: mt7530: fix VLAN traffic leaks PCR_MATRIX field was set to all 1's when VLAN filtering is enabled, but was not reset when it is disabled, which may cause traffic leaks: ip link add br0 type bridge vlan_filtering 1 ip link add br1 type bridge vlan_filtering 1 ip link set swp0 master br0 ip link set swp1 master br1 ip link set br0 type bridge vlan_filtering 0 ip link set br1 type bridge vlan_filtering 0 # traffic in br0 and br1 will start leaking to each other As port_bridge_{add,del} have set up PCR_MATRIX properly, remove the PCR_MATRIX write from mt7530_port_set_vlan_aware.",
        "technologies": "Linux\nLinux Kernel 4.16 以上 4.19.193 未満\nLinux Kernel 4.20 以上 5.4.124 未満\nLinux Kernel 5.5 以上 5.10.42 未満\nLinux Kernel 5.11 以上 5.12.9 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021630": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pid: take a reference when initializing `cad_pid` During boot, kernel_init_freeable() initializes `cad_pid` to the init task's struct pid. Later on, we may change `cad_pid` via a sysctl, and when this happens proc_do_cad_pid() will increment the refcount on the new pid via get_pid(), and will decrement the refcount on the old pid via put_pid(). As we never called get_pid() when we initialized `cad_pid`, we decrement a reference we never incremented, can therefore free the init task's struct pid early. As there can be dangling references to the struct pid, we can later encounter a use-after-free (e.g. when delivering signals). This was spotted when fuzzing v5.13-rc3 with Syzkaller, but seems to have been around since the conversion of `cad_pid` to struct pid in commit 9ec52099e4b8 (\"[PATCH] replace cad_pid by a struct pid\") from the pre-KASAN stone age of v2.6.19. Fix this by getting a reference to the init task's struct pid when we assign it to `cad_pid`. Full KASAN splat below. ================================================================== BUG: KASAN: use-after-free in ns_of_pid include/linux/pid.h:153 [inline] BUG: KASAN: use-after-free in task_active_pid_ns+0xc0/0xc8 kernel/pid.c:509 Read of size 4 at addr ffff23794dda0004 by task syz-executor.0/273 CPU: 1 PID: 273 Comm: syz-executor.0 Not tainted 5.12.0-00001-g9aef892b2d15 #1 Hardware name: linux,dummy-virt (DT) Call trace: ns_of_pid include/linux/pid.h:153 [inline] task_active_pid_ns+0xc0/0xc8 kernel/pid.c:509 do_notify_parent+0x308/0xe60 kernel/signal.c:1950 exit_notify kernel/exit.c:682 [inline] do_exit+0x2334/0x2bd0 kernel/exit.c:845 do_group_exit+0x108/0x2c8 kernel/exit.c:922 get_signal+0x4e4/0x2a88 kernel/signal.c:2781 do_signal arch/arm64/kernel/signal.c:882 [inline] do_notify_resume+0x300/0x970 arch/arm64/kernel/signal.c:936 work_pending+0xc/0x2dc Allocated by task 0: slab_post_alloc_hook+0x50/0x5c0 mm/slab.h:516 slab_alloc_node mm/slub.c:2907 [inline] slab_alloc mm/slub.c:2915 [inline] kmem_cache_alloc+0x1f4/0x4c0 mm/slub.c:2920 alloc_pid+0xdc/0xc00 kernel/pid.c:180 copy_process+0x2794/0x5e18 kernel/fork.c:2129 kernel_clone+0x194/0x13c8 kernel/fork.c:2500 kernel_thread+0xd4/0x110 kernel/fork.c:2552 rest_init+0x44/0x4a0 init/main.c:687 arch_call_rest_init+0x1c/0x28 start_kernel+0x520/0x554 init/main.c:1064 0x0 Freed by task 270: slab_free_hook mm/slub.c:1562 [inline] slab_free_freelist_hook+0x98/0x260 mm/slub.c:1600 slab_free mm/slub.c:3161 [inline] kmem_cache_free+0x224/0x8e0 mm/slub.c:3177 put_pid.part.4+0xe0/0x1a8 kernel/pid.c:114 put_pid+0x30/0x48 kernel/pid.c:109 proc_do_cad_pid+0x190/0x1b0 kernel/sysctl.c:1401 proc_sys_call_handler+0x338/0x4b0 fs/proc/proc_sysctl.c:591 proc_sys_write+0x34/0x48 fs/proc/proc_sysctl.c:617 call_write_iter include/linux/fs.h:1977 [inline] new_sync_write+0x3ac/0x510 fs/read_write.c:518 vfs_write fs/read_write.c:605 [inline] vfs_write+0x9c4/0x1018 fs/read_write.c:585 ksys_write+0x124/0x240 fs/read_write.c:658 __do_sys_write fs/read_write.c:670 [inline] __se_sys_write fs/read_write.c:667 [inline] __arm64_sys_write+0x78/0xb0 fs/read_write.c:667 __invoke_syscall arch/arm64/kernel/syscall.c:37 [inline] invoke_syscall arch/arm64/kernel/syscall.c:49 [inline] el0_svc_common.constprop.1+0x16c/0x388 arch/arm64/kernel/syscall.c:129 do_el0_svc+0xf8/0x150 arch/arm64/kernel/syscall.c:168 el0_svc+0x28/0x38 arch/arm64/kernel/entry-common.c:416 el0_sync_handler+0x134/0x180 arch/arm64/kernel/entry-common.c:432 el0_sync+0x154/0x180 arch/arm64/kernel/entry.S:701 The buggy address belongs to the object at ffff23794dda0000 which belongs to the cache pid of size 224 The buggy address is located 4 bytes inside of 224-byte region [ff ---truncated---",
        "technologies": "Linux\nLinux Kernel 2.6.19 以上 4.4.272 未満\nLinux Kernel 4.5 以上 4.9.272 未満\nLinux Kernel 4.10 以上 4.14.236 未満\nLinux Kernel 4.15 以上 4.19.194 未満\nLinux Kernel 4.20 以上 5.4.125 未満\nLinux Kernel 5.5 以上 5.10.43 未満\nLinux Kernel 5.11 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021657": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: scsi_debug: Fix out-of-bound read in resp_report_tgtpgs() The following issue was observed running syzkaller: BUG: KASAN: slab-out-of-bounds in memcpy include/linux/string.h:377 [inline] BUG: KASAN: slab-out-of-bounds in sg_copy_buffer+0x150/0x1c0 lib/scatterlist.c:831 Read of size 2132 at addr ffff8880aea95dc8 by task syz-executor.0/9815 CPU: 0 PID: 9815 Comm: syz-executor.0 Not tainted 4.19.202-00874-gfc0fe04215a9 #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014 Call Trace: __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0xe4/0x14a lib/dump_stack.c:118 print_address_description+0x73/0x280 mm/kasan/report.c:253 kasan_report_error mm/kasan/report.c:352 [inline] kasan_report+0x272/0x370 mm/kasan/report.c:410 memcpy+0x1f/0x50 mm/kasan/kasan.c:302 memcpy include/linux/string.h:377 [inline] sg_copy_buffer+0x150/0x1c0 lib/scatterlist.c:831 fill_from_dev_buffer+0x14f/0x340 drivers/scsi/scsi_debug.c:1021 resp_report_tgtpgs+0x5aa/0x770 drivers/scsi/scsi_debug.c:1772 schedule_resp+0x464/0x12f0 drivers/scsi/scsi_debug.c:4429 scsi_debug_queuecommand+0x467/0x1390 drivers/scsi/scsi_debug.c:5835 scsi_dispatch_cmd+0x3fc/0x9b0 drivers/scsi/scsi_lib.c:1896 scsi_request_fn+0x1042/0x1810 drivers/scsi/scsi_lib.c:2034 __blk_run_queue_uncond block/blk-core.c:464 [inline] __blk_run_queue+0x1a4/0x380 block/blk-core.c:484 blk_execute_rq_nowait+0x1c2/0x2d0 block/blk-exec.c:78 sg_common_write.isra.19+0xd74/0x1dc0 drivers/scsi/sg.c:847 sg_write.part.23+0x6e0/0xd00 drivers/scsi/sg.c:716 sg_write+0x64/0xa0 drivers/scsi/sg.c:622 __vfs_write+0xed/0x690 fs/read_write.c:485 kill_bdev:block_device:00000000e138492c vfs_write+0x184/0x4c0 fs/read_write.c:549 ksys_write+0x107/0x240 fs/read_write.c:599 do_syscall_64+0xc2/0x560 arch/x86/entry/common.c:293 entry_SYSCALL_64_after_hwframe+0x49/0xbe We get 'alen' from command its type is int. If userspace passes a large length we will get a negative 'alen'. Switch n, alen, and rlen to u32.",
        "technologies": "Linux\nLinux Kernel 5.10.82 未満\nLinux Kernel 5.11 以上 5.15.5 未満"
    },
    "JVNDB-2021-021655": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: coresight: tmc-etf: Fix global-out-of-bounds in tmc_update_etf_buffer() commit 6f755e85c332 (\"coresight: Add helper for inserting synchronization packets\") removed trailing '\\0' from barrier_pkt array and updated the call sites like etb_update_buffer() to have proper checks for barrier_pkt size before read but missed updating tmc_update_etf_buffer() which still reads barrier_pkt past the array size resulting in KASAN out-of-bounds bug. Fix this by adding a check for barrier_pkt size before accessing like it is done in etb_update_buffer(). BUG: KASAN: global-out-of-bounds in tmc_update_etf_buffer+0x4b8/0x698 Read of size 4 at addr ffffffd05b7d1030 by task perf/2629 Call trace: dump_backtrace+0x0/0x27c show_stack+0x20/0x2c dump_stack+0x11c/0x188 print_address_description+0x3c/0x4a4 __kasan_report+0x140/0x164 kasan_report+0x10/0x18 __asan_report_load4_noabort+0x1c/0x24 tmc_update_etf_buffer+0x4b8/0x698 etm_event_stop+0x248/0x2d8 etm_event_del+0x20/0x2c event_sched_out+0x214/0x6f0 group_sched_out+0xd0/0x270 ctx_sched_out+0x2ec/0x518 __perf_event_task_sched_out+0x4fc/0xe6c __schedule+0x1094/0x16a0 preempt_schedule_irq+0x88/0x170 arm64_preempt_schedule_irq+0xf0/0x18c el1_irq+0xe8/0x180 perf_event_exec+0x4d8/0x56c setup_new_exec+0x204/0x400 load_elf_binary+0x72c/0x18c0 search_binary_handler+0x13c/0x420 load_script+0x500/0x6c4 search_binary_handler+0x13c/0x420 exec_binprm+0x118/0x654 __do_execve_file+0x77c/0xba4 __arm64_compat_sys_execve+0x98/0xac el0_svc_common+0x1f8/0x5e0 el0_svc_compat_handler+0x84/0xb0 el0_svc_compat+0x10/0x50 The buggy address belongs to the variable: barrier_pkt+0x10/0x40 Memory state around the buggy address: ffffffd05b7d0f00: fa fa fa fa 04 fa fa fa fa fa fa fa 00 00 00 00 ffffffd05b7d0f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffffffd05b7d1000: 00 00 00 00 00 00 fa fa fa fa fa fa 00 00 00 03 ^ ffffffd05b7d1080: fa fa fa fa 00 02 fa fa fa fa fa fa 03 fa fa fa ffffffd05b7d1100: fa fa fa fa 00 00 00 00 05 fa fa fa fa fa fa fa ==================================================================",
        "technologies": "Linux\nLinux Kernel 4.14 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021666": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cxgb4: avoid accessing registers when clearing filters Hardware register having the server TID base can contain invalid values when adapter is in bad state (for example, due to AER fatal error). Reading these invalid values in the register can lead to out-of-bound memory access. So, fix by using the saved server TID base when clearing filters.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.124 未満\nLinux Kernel 5.5 以上 5.10.42 未満\nLinux Kernel 5.11 以上 5.12.9 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021635": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ethtool: do not perform operations on net devices being unregistered There is a short period between a net device starts to be unregistered and when it is actually gone. In that time frame ethtool operations could still be performed, which might end up in unwanted or undefined behaviours[1]. Do not allow ethtool operations after a net device starts its unregistration. This patch targets the netlink part as the ioctl one isn't affected: the reference to the net device is taken and the operation is executed within an rtnl lock section and the net device won't be found after unregister. [1] For example adding Tx queues after unregister ends up in NULL pointer exceptions and UaFs, such as: BUG: KASAN: use-after-free in kobject_get+0x14/0x90 Read of size 1 at addr ffff88801961248c by task ethtool/755 CPU: 0 PID: 755 Comm: ethtool Not tainted 5.15.0-rc6+ #778 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04/014 Call Trace: dump_stack_lvl+0x57/0x72 print_address_description.constprop.0+0x1f/0x140 kasan_report.cold+0x7f/0x11b kobject_get+0x14/0x90 kobject_add_internal+0x3d1/0x450 kobject_init_and_add+0xba/0xf0 netdev_queue_update_kobjects+0xcf/0x200 netif_set_real_num_tx_queues+0xb4/0x310 veth_set_channels+0x1c3/0x550 ethnl_set_channels+0x524/0x610",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.87 未満\nLinux Kernel 5.11 以上 5.15.8 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021667": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: fix sk_forward_memory corruption on retransmission MPTCP sk_forward_memory handling is a bit special, as such field is protected by the msk socket spin_lock, instead of the plain socket lock. Currently we have a code path updating such field without handling the relevant lock: __mptcp_retrans() -> __mptcp_clean_una_wakeup() Several helpers in __mptcp_clean_una_wakeup() will update sk_forward_alloc, possibly causing such field corruption, as reported by Matthieu. Address the issue providing and using a new variant of blamed function which explicitly acquires the msk spin lock.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.12.10 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021674": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: nVMX: Always make an attempt to map eVMCS after migration When enlightened VMCS is in use and nested state is migrated with vmx_get_nested_state()/vmx_set_nested_state() KVM can't map evmcs page right away: evmcs gpa is not 'struct kvm_vmx_nested_state_hdr' and we can't read it from VP assist page because userspace may decide to restore HV_X64_MSR_VP_ASSIST_PAGE after restoring nested state (and QEMU, for example, does exactly that). To make sure eVMCS is mapped /vmx_set_nested_state() raises KVM_REQ_GET_NESTED_STATE_PAGES request. Commit f2c7ef3ba955 (\"KVM: nSVM: cancel KVM_REQ_GET_NESTED_STATE_PAGES on nested vmexit\") added KVM_REQ_GET_NESTED_STATE_PAGES clearing to nested_vmx_vmexit() to make sure MSR permission bitmap is not switched when an immediate exit from L2 to L1 happens right after migration (caused by a pending event, for example). Unfortunately, in the exact same situation we still need to have eVMCS mapped so nested_sync_vmcs12_to_shadow() reflects changes in VMCS12 to eVMCS. As a band-aid, restore nested_get_evmcs_page() when clearing KVM_REQ_GET_NESTED_STATE_PAGES in nested_vmx_vmexit(). The 'fix' is far from being ideal as we can't easily propagate possible failures and even if we could, this is most likely already too late to do so. The whole 'KVM_REQ_GET_NESTED_STATE_PAGES' idea for mapping eVMCS after migration seems to be fragile as we diverge too much from the 'native' path when vmptr loading happens on vmx_set_nested_state().",
        "technologies": "Linux\nLinux Kernel 5.10.13 以上 5.10.38 未満\nLinux Kernel 5.11 以上 5.11.22 未満\nLinux Kernel 5.12 以上 5.12.5 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021691": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ubifs: Fix read out-of-bounds in ubifs_wbuf_write_nolock() Function ubifs_wbuf_write_nolock() may access buf out of bounds in following process: ubifs_wbuf_write_nolock(): aligned_len = ALIGN(len, 8); // Assume len = 4089, aligned_len = 4096 if (aligned_len <= wbuf->avail) ... // Not satisfy if (wbuf->used) { ubifs_leb_write() // Fill some data in avail wbuf len -= wbuf->avail; // len is still not 8-bytes aligned aligned_len -= wbuf->avail; } n = aligned_len >> c->max_write_shift; if (n) { n <<= c->max_write_shift; err = ubifs_leb_write(c, wbuf->lnum, buf + written, wbuf->offs, n); // n > len, read out of bounds less than 8(n-len) bytes } , which can be catched by KASAN: ========================================================= BUG: KASAN: slab-out-of-bounds in ecc_sw_hamming_calculate+0x1dc/0x7d0 Read of size 4 at addr ffff888105594ff8 by task kworker/u8:4/128 Workqueue: writeback wb_workfn (flush-ubifs_0_0) Call Trace: kasan_report.cold+0x81/0x165 nand_write_page_swecc+0xa9/0x160 ubifs_leb_write+0xf2/0x1b0 [ubifs] ubifs_wbuf_write_nolock+0x421/0x12c0 [ubifs] write_head+0xdc/0x1c0 [ubifs] ubifs_jnl_write_inode+0x627/0x960 [ubifs] wb_workfn+0x8af/0xb80 Function ubifs_wbuf_write_nolock() accepts that parameter 'len' is not 8 bytes aligned, the 'len' represents the true length of buf (which is allocated in 'ubifs_jnl_xxx', eg. ubifs_jnl_write_inode), so ubifs_wbuf_write_nolock() must handle the length read from 'buf' carefully to write leb safely. Fetch a reproducer in [Link].",
        "technologies": "Linux\nLinux Kernel 2.6.27 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021675": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: qrtr: Avoid potential use after free in MHI send It is possible that the MHI ul_callback will be invoked immediately following the queueing of the skb for transmission, leading to the callback decrementing the refcount of the associated sk and freeing the skb. As such the dereference of skb and the increment of the sk refcount must happen before the skb is queued, to avoid the skb to be used after free and potentially the sk to drop its last refcount..",
        "technologies": "Linux\nLinux Kernel 5.8 から  5.10.35\nLinux Kernel 5.11 から 5.11.19\nLinux Kernel 5.12 から 5.12.2"
    },
    "JVNDB-2021-021695": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: fq_pie: fix OOB access in the traffic path the following script: # tc qdisc add dev eth0 handle 0x1 root fq_pie flows 2 # tc qdisc add dev eth0 clsact # tc filter add dev eth0 egress matchall action skbedit priority 0x10002 # ping 192.0.2.2 -I eth0 -c2 -w1 -q produces the following splat: BUG: KASAN: slab-out-of-bounds in fq_pie_qdisc_enqueue+0x1314/0x19d0 [sch_fq_pie] Read of size 4 at addr ffff888171306924 by task ping/942 CPU: 3 PID: 942 Comm: ping Not tainted 5.12.0+ #441 Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014 Call Trace: dump_stack+0x92/0xc1 print_address_description.constprop.7+0x1a/0x150 kasan_report.cold.13+0x7f/0x111 fq_pie_qdisc_enqueue+0x1314/0x19d0 [sch_fq_pie] __dev_queue_xmit+0x1034/0x2b10 ip_finish_output2+0xc62/0x2120 __ip_finish_output+0x553/0xea0 ip_output+0x1ca/0x4d0 ip_send_skb+0x37/0xa0 raw_sendmsg+0x1c4b/0x2d00 sock_sendmsg+0xdb/0x110 __sys_sendto+0x1d7/0x2b0 __x64_sys_sendto+0xdd/0x1b0 do_syscall_64+0x3c/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7fe69735c3eb Code: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 f3 0f 1e fa 48 8d 05 75 42 2c 00 41 89 ca 8b 00 85 c0 75 14 b8 2c 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 75 c3 0f 1f 40 00 41 57 4d 89 c7 41 56 41 89 RSP: 002b:00007fff06d7fb38 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 000055e961413700 RCX: 00007fe69735c3eb RDX: 0000000000000040 RSI: 000055e961413700 RDI: 0000000000000003 RBP: 0000000000000040 R08: 000055e961410500 R09: 0000000000000010 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff06d81260 R13: 00007fff06d7fb40 R14: 00007fff06d7fc30 R15: 000055e96140f0a0 Allocated by task 917: kasan_save_stack+0x19/0x40 __kasan_kmalloc+0x7f/0xa0 __kmalloc_node+0x139/0x280 fq_pie_init+0x555/0x8e8 [sch_fq_pie] qdisc_create+0x407/0x11b0 tc_modify_qdisc+0x3c2/0x17e0 rtnetlink_rcv_msg+0x346/0x8e0 netlink_rcv_skb+0x120/0x380 netlink_unicast+0x439/0x630 netlink_sendmsg+0x719/0xbf0 sock_sendmsg+0xe2/0x110 ____sys_sendmsg+0x5ba/0x890 ___sys_sendmsg+0xe9/0x160 __sys_sendmsg+0xd3/0x170 do_syscall_64+0x3c/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae The buggy address belongs to the object at ffff888171306800 which belongs to the cache kmalloc-256 of size 256 The buggy address is located 36 bytes to the right of 256-byte region [ffff888171306800, ffff888171306900) The buggy address belongs to the page: page:00000000bcfb624e refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x171306 head:00000000bcfb624e order:1 compound_mapcount:0 flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff) raw: 0017ffffc0010200 dead000000000100 dead000000000122 ffff888100042b40 raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888171306800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888171306880: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc >ffff888171306900: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ^ ffff888171306980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffff888171306a00: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fix fq_pie traffic path to avoid selecting 'q->flows + q->flows_cnt' as a valid flow: it's an address beyond the allocated memory.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.42 未満\nLinux Kernel 5.11 以上 5.12.9 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021702": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: Only allow init netns to set default tcp cong to a restricted algo tcp_set_default_congestion_control() is netns-safe in that it writes to &net->ipv4.tcp_congestion_control, but it also sets ca->flags |= TCP_CONG_NON_RESTRICTED which is not namespaced. This has the unintended side-effect of changing the global net.ipv4.tcp_allowed_congestion_control sysctl, despite the fact that it is read-only: 97684f0970f6 (\"net: Make tcp_allowed_congestion_control readonly in non-init netns\") Resolve this netns \"leak\" by only allowing the init netns to set the default algorithm to one that is restricted. This restriction could be removed if tcp_allowed_congestion_control were namespace-ified in the future. This bug was uncovered with https://github.com/JonathonReinhart/linux-netns-sysctl-verify",
        "technologies": "Linux\nLinux Kernel 4.15 以上 4.19.191 未満\nLinux Kernel 4.20 以上 5.4.119 未満\nLinux Kernel 5.5 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021708": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/kasan: Fix early region not updated correctly The shadow's page table is not updated when PTE_RPN_SHIFT is 24 and PAGE_SHIFT is 12. It not only causes false positives but also false negative as shown the following text. Fix it by bringing the logic of kasan_early_shadow_page_entry here. 1. False Positive: ================================================================== BUG: KASAN: vmalloc-out-of-bounds in pcpu_alloc+0x508/0xa50 Write of size 16 at addr f57f3be0 by task swapper/0/1 CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.15.0-12267-gdebe436e77c7 #1 Call Trace: [c80d1c20] [c07fe7b8] dump_stack_lvl+0x4c/0x6c (unreliable) [c80d1c40] [c02ff668] print_address_description.constprop.0+0x88/0x300 [c80d1c70] [c02ff45c] kasan_report+0x1ec/0x200 [c80d1cb0] [c0300b20] kasan_check_range+0x160/0x2f0 [c80d1cc0] [c03018a4] memset+0x34/0x90 [c80d1ce0] [c0280108] pcpu_alloc+0x508/0xa50 [c80d1d40] [c02fd7bc] __kmem_cache_create+0xfc/0x570 [c80d1d70] [c0283d64] kmem_cache_create_usercopy+0x274/0x3e0 [c80d1db0] [c2036580] init_sd+0xc4/0x1d0 [c80d1de0] [c00044a0] do_one_initcall+0xc0/0x33c [c80d1eb0] [c2001624] kernel_init_freeable+0x2c8/0x384 [c80d1ef0] [c0004b14] kernel_init+0x24/0x170 [c80d1f10] [c001b26c] ret_from_kernel_thread+0x5c/0x64 Memory state around the buggy address: f57f3a80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f57f3b00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 >f57f3b80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ^ f57f3c00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f57f3c80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ================================================================== 2. False Negative (with KASAN tests): ================================================================== Before fix: ok 45 - kmalloc_double_kzfree # vmalloc_oob: EXPECTATION FAILED at lib/test_kasan.c:1039 KASAN failure expected in \"((volatile char *)area)[3100]\", but none occurred not ok 46 - vmalloc_oob not ok 1 - kasan ================================================================== After fix: ok 1 - kasan",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021726": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ubi: Fix race condition between ctrl_cdev_ioctl and ubi_cdev_ioctl Hulk Robot reported a KASAN report about use-after-free: ================================================================== BUG: KASAN: use-after-free in __list_del_entry_valid+0x13d/0x160 Read of size 8 at addr ffff888035e37d98 by task ubiattach/1385 [...] Call Trace: klist_dec_and_del+0xa7/0x4a0 klist_put+0xc7/0x1a0 device_del+0x4d4/0xed0 cdev_device_del+0x1a/0x80 ubi_attach_mtd_dev+0x2951/0x34b0 [ubi] ctrl_cdev_ioctl+0x286/0x2f0 [ubi] Allocated by task 1414: device_add+0x60a/0x18b0 cdev_device_add+0x103/0x170 ubi_create_volume+0x1118/0x1a10 [ubi] ubi_cdev_ioctl+0xb7f/0x1ba0 [ubi] Freed by task 1385: cdev_device_del+0x1a/0x80 ubi_remove_volume+0x438/0x6c0 [ubi] ubi_cdev_ioctl+0xbf4/0x1ba0 [ubi] [...] ================================================================== The lock held by ctrl_cdev_ioctl is ubi_devices_mutex, but the lock held by ubi_cdev_ioctl is ubi->device_mutex. Therefore, the two locks can be concurrent. ctrl_cdev_ioctl contains two operations: ubi_attach and ubi_detach. ubi_detach is bug-free because it uses reference counting to prevent concurrency. However, uif_init and uif_close in ubi_attach may race with ubi_cdev_ioctl. uif_init will race with ubi_cdev_ioctl as in the following stack. cpu1 cpu2 cpu3 _______________________|________________________|______________________ ctrl_cdev_ioctl ubi_attach_mtd_dev uif_init ubi_cdev_ioctl ubi_create_volume cdev_device_add ubi_add_volume // sysfs exist kill_volumes ubi_cdev_ioctl ubi_remove_volume cdev_device_del // first free ubi_free_volume cdev_del // double free cdev_device_del And uif_close will race with ubi_cdev_ioctl as in the following stack. cpu1 cpu2 cpu3 _______________________|________________________|______________________ ctrl_cdev_ioctl ubi_attach_mtd_dev uif_init ubi_cdev_ioctl ubi_create_volume cdev_device_add ubi_debugfs_init_dev //error goto out_uif; uif_close kill_volumes ubi_cdev_ioctl ubi_remove_volume cdev_device_del // first free ubi_free_volume // double free The cause of this problem is that commit 714fb87e8bc0 make device \"available\" before it becomes accessible via sysfs. Therefore, we roll back the modification. We will fix the race condition between ubi device creation and udev by removing ubi_get_device in vol_attribute_show and dev_attribute_show.This avoids accessing uninitialized ubi_devices[ubi_num]. ubi_get_device is used to prevent devices from being deleted during sysfs execution. However, now kernfs ensures that devices will not be deleted before all reference counting are released. The key process is shown in the following stack. device_del device_remove_attrs device_remove_groups sysfs_remove_groups sysfs_remove_group remove_files kernfs_remove_by_name kernfs_remove_by_name_ns __kernfs_remove kernfs_drain",
        "technologies": "Linux\nLinux Kernel 3.2.84 以上 3.3 未満\nLinux Kernel 3.10.103 以上 3.11 未満\nLinux Kernel 3.12.63 以上 3.13 未満\nLinux Kernel 3.14.77 以上 3.15 未満\nLinux Kernel 3.16.39 以上 3.17 未満\nLinux Kernel 3.18.40 以上 3.19 未満\nLinux Kernel 4.1.31 以上 4.2 未満\nLinux Kernel 4.4.19 以上 4.5 未満\nLinux Kernel 4.7.2 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021714": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: marvell: prestera: fix port event handling on init For some reason there might be a crash during ports creation if port events are handling at the same time because fw may send initial port event with down state. The crash points to cancel_delayed_work() which is called when port went is down. Currently I did not find out the real cause of the issue, so fixed it by cancel port stats work only if previous port's state was up & runnig. The following is the crash which can be triggered: [ 28.311104] Unable to handle kernel paging request at virtual address 000071775f776600 [ 28.319097] Mem abort info: [ 28.321914] ESR = 0x96000004 [ 28.324996] EC = 0x25: DABT (current EL), IL = 32 bits [ 28.330350] SET = 0, FnV = 0 [ 28.333430] EA = 0, S1PTW = 0 [ 28.336597] Data abort info: [ 28.339499] ISV = 0, ISS = 0x00000004 [ 28.343362] CM = 0, WnR = 0 [ 28.346354] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000100bf7000 [ 28.352842] [000071775f776600] pgd=0000000000000000, p4d=0000000000000000 [ 28.359695] Internal error: Oops: 96000004 [#1] PREEMPT SMP [ 28.365310] Modules linked in: prestera_pci(+) prestera uio_pdrv_genirq [ 28.372005] CPU: 0 PID: 1291 Comm: kworker/0:1H Not tainted 5.11.0-rc4 #1 [ 28.378846] Hardware name: DNI AmazonGo1 A7040 board (DT) [ 28.384283] Workqueue: prestera_fw_wq prestera_fw_evt_work_fn [prestera_pci] [ 28.391413] pstate: 60000085 (nZCv daIf -PAN -UAO -TCO BTYPE=--) [ 28.397468] pc : get_work_pool+0x48/0x60 [ 28.401442] lr : try_to_grab_pending+0x6c/0x1b0 [ 28.406018] sp : ffff80001391bc60 [ 28.409358] x29: ffff80001391bc60 x28: 0000000000000000 [ 28.414725] x27: ffff000104fc8b40 x26: ffff80001127de88 [ 28.420089] x25: 0000000000000000 x24: ffff000106119760 [ 28.425452] x23: ffff00010775dd60 x22: ffff00010567e000 [ 28.430814] x21: 0000000000000000 x20: ffff80001391bcb0 [ 28.436175] x19: ffff00010775deb8 x18: 00000000000000c0 [ 28.441537] x17: 0000000000000000 x16: 000000008d9b0e88 [ 28.446898] x15: 0000000000000001 x14: 00000000000002ba [ 28.452261] x13: 80a3002c00000002 x12: 00000000000005f4 [ 28.457622] x11: 0000000000000030 x10: 000000000000000c [ 28.462985] x9 : 000000000000000c x8 : 0000000000000030 [ 28.468346] x7 : ffff800014400000 x6 : ffff000106119758 [ 28.473708] x5 : 0000000000000003 x4 : ffff00010775dc60 [ 28.479068] x3 : 0000000000000000 x2 : 0000000000000060 [ 28.484429] x1 : 000071775f776600 x0 : ffff00010775deb8 [ 28.489791] Call trace: [ 28.492259] get_work_pool+0x48/0x60 [ 28.495874] cancel_delayed_work+0x38/0xb0 [ 28.500011] prestera_port_handle_event+0x90/0xa0 [prestera] [ 28.505743] prestera_evt_recv+0x98/0xe0 [prestera] [ 28.510683] prestera_fw_evt_work_fn+0x180/0x228 [prestera_pci] [ 28.516660] process_one_work+0x1e8/0x360 [ 28.520710] worker_thread+0x44/0x480 [ 28.524412] kthread+0x154/0x160 [ 28.527670] ret_from_fork+0x10/0x38 [ 28.531290] Code: a8c17bfd d50323bf d65f03c0 9278dc21 (f9400020) [ 28.537429] ---[ end trace 5eced933df3a080b ]---",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021725": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Revert \"Revert \"block, bfq: honor already-setup queue merges\"\" A crash [1] happened to be triggered in conjunction with commit 2d52c58b9c9b (\"block, bfq: honor already-setup queue merges\"). The latter was then reverted by commit ebc69e897e17 (\"Revert \"block, bfq: honor already-setup queue merges\"\"). Yet, the reverted commit was not the one introducing the bug. In fact, it actually triggered a UAF introduced by a different commit, and now fixed by commit d29bd41428cf (\"block, bfq: reset last_bfqq_created on group change\"). So, there is no point in keeping commit 2d52c58b9c9b (\"block, bfq: honor already-setup queue merges\") out. This commit restores it. [1] https://bugzilla.kernel.org/show_bug.cgi?id=214503",
        "technologies": "Linux\nLinux Kernel 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021724": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/xen: Drop USERGS_SYSRET64 paravirt call commit afd30525a659ac0ae0904f0cb4a2ca75522c3123 upstream. USERGS_SYSRET64 is used to return from a syscall via SYSRET, but a Xen PV guest will nevertheless use the IRET hypercall, as there is no sysret PV hypercall defined. So instead of testing all the prerequisites for doing a sysret and then mangling the stack for Xen PV again for doing an iret just use the iret exit from the beginning. This can easily be done via an ALTERNATIVE like it is done for the sysenter compat case already. It should be noted that this drops the optimization in Xen for not restoring a few registers when returning to user mode, but it seems as if the saved instructions in the kernel more than compensate for this drop (a kernel build in a Xen PV guest was slightly faster with this patch applied). While at it remove the stale sysret32 remnants. [ pawan: Brad Spengler and Salvatore Bonaccorso <carnil@debian.org> reported a problem with the 5.10 backport commit edc702b4a820 (\"x86/entry_64: Add VERW just before userspace transition\"). When CONFIG_PARAVIRT_XXL=y, CLEAR_CPU_BUFFERS is not executed in syscall_return_via_sysret path as USERGS_SYSRET64 is runtime patched to: .cpu_usergs_sysret64 = { 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }, // swapgs; sysretq which is missing CLEAR_CPU_BUFFERS. It turns out dropping USERGS_SYSRET64 simplifies the code, allowing CLEAR_CPU_BUFFERS to be explicitly added to syscall_return_via_sysret path. Below is with CONFIG_PARAVIRT_XXL=y and this patch applied: syscall_return_via_sysret: ... <+342>: swapgs <+345>: xchg %ax,%ax <+347>: verw -0x1a2(%rip) <------ <+354>: sysretq ]",
        "technologies": "Linux\nLinux Kernel 5.10.215 以上 5.10.218 未満"
    },
    "JVNDB-2021-021727": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jffs2: fix use-after-free in jffs2_clear_xattr_subsystem When we mount a jffs2 image, assume that the first few blocks of the image are normal and contain at least one xattr-related inode, but the next block is abnormal. As a result, an error is returned in jffs2_scan_eraseblock(). jffs2_clear_xattr_subsystem() is then called in jffs2_build_filesystem() and then again in jffs2_do_fill_super(). Finally we can observe the following report: ================================================================== BUG: KASAN: use-after-free in jffs2_clear_xattr_subsystem+0x95/0x6ac Read of size 8 at addr ffff8881243384e0 by task mount/719 Call Trace: dump_stack+0x115/0x16b jffs2_clear_xattr_subsystem+0x95/0x6ac jffs2_do_fill_super+0x84f/0xc30 jffs2_fill_super+0x2ea/0x4c0 mtd_get_sb+0x254/0x400 mtd_get_sb_by_nr+0x4f/0xd0 get_tree_mtd+0x498/0x840 jffs2_get_tree+0x25/0x30 vfs_get_tree+0x8d/0x2e0 path_mount+0x50f/0x1e50 do_mount+0x107/0x130 __se_sys_mount+0x1c5/0x2f0 __x64_sys_mount+0xc7/0x160 do_syscall_64+0x45/0x70 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Allocated by task 719: kasan_save_stack+0x23/0x60 __kasan_kmalloc.constprop.0+0x10b/0x120 kasan_slab_alloc+0x12/0x20 kmem_cache_alloc+0x1c0/0x870 jffs2_alloc_xattr_ref+0x2f/0xa0 jffs2_scan_medium.cold+0x3713/0x4794 jffs2_do_mount_fs.cold+0xa7/0x2253 jffs2_do_fill_super+0x383/0xc30 jffs2_fill_super+0x2ea/0x4c0 [...] Freed by task 719: kmem_cache_free+0xcc/0x7b0 jffs2_free_xattr_ref+0x78/0x98 jffs2_clear_xattr_subsystem+0xa1/0x6ac jffs2_do_mount_fs.cold+0x5e6/0x2253 jffs2_do_fill_super+0x383/0xc30 jffs2_fill_super+0x2ea/0x4c0 [...] The buggy address belongs to the object at ffff8881243384b8 which belongs to the cache jffs2_xattr_ref of size 48 The buggy address is located 40 bytes inside of 48-byte region [ffff8881243384b8, ffff8881243384e8) [...] ================================================================== The triggering of the BUG is shown in the following stack: ----------------------------------------------------------- jffs2_fill_super jffs2_do_fill_super jffs2_do_mount_fs jffs2_build_filesystem jffs2_scan_medium jffs2_scan_eraseblock <--- ERROR jffs2_clear_xattr_subsystem <--- free jffs2_clear_xattr_subsystem <--- free again ----------------------------------------------------------- An error is returned in jffs2_do_mount_fs(). If the error is returned by jffs2_sum_init(), the jffs2_clear_xattr_subsystem() does not need to be executed. If the error is returned by jffs2_build_filesystem(), the jffs2_clear_xattr_subsystem() also does not need to be executed again. So move jffs2_clear_xattr_subsystem() from 'out_inohash' to 'out_root' to fix this UAF problem.",
        "technologies": "Linux\nLinux Kernel 2.6.18 以上 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021711": {
        "title": "Linux の Linux Kernel における制限またはスロットリング無しのリソースの割り当てに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: lantiq: fix memory corruption in RX ring In a situation where memory allocation or dma mapping fails, an invalid address is programmed into the descriptor. This can lead to memory corruption. If the memory allocation fails, DMA should reuse the previous skb and mapping and drop the packet. This patch also increments rx drop counter.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.124 未満\nLinux Kernel 5.5 以上 5.10.42 未満\nLinux Kernel 5.11 以上 5.12.9 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021729": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: davinci: vpif: fix use-after-free on driver unbind The driver allocates and registers two platform device structures during probe, but the devices were never deregistered on driver unbind. This results in a use-after-free on driver unbind as the device structures were allocated using devres and would be freed by driver core when remove() returns. Fix this by adding the missing deregistration calls to the remove() callback and failing probe on registration errors. Note that the platform device structures must be freed using a proper release callback to avoid leaking associated resources like device names.",
        "technologies": "Linux\nLinux Kernel 4.13 以上 5.15.54 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021728": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86/mmu: Zap _all_ roots when unmapping gfn range in TDP MMU Zap both valid and invalid roots when zapping/unmapping a gfn range, as KVM must ensure it holds no references to the freed page after returning from the unmap operation. Most notably, the TDP MMU doesn't zap invalid roots in mmu_notifier callbacks. This leads to use-after-free and other issues if the mmu_notifier runs to completion while an invalid root zapper yields as KVM fails to honor the requirement that there must be _no_ references to the page after the mmu_notifier returns. The bug is most easily reproduced by hacking KVM to cause a collision between set_nx_huge_pages() and kvm_mmu_notifier_release(), but the bug exists between kvm_mmu_notifier_invalidate_range_start() and memslot updates as well. Invalidating a root ensures pages aren't accessible by the guest, and KVM won't read or write page data itself, but KVM will trigger e.g. kvm_set_pfn_dirty() when zapping SPTEs, and thus completing a zap of an invalid root _after_ the mmu_notifier returns is fatal. WARNING: CPU: 24 PID: 1496 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:173 [kvm] RIP: 0010:kvm_is_zone_device_pfn+0x96/0xa0 [kvm] Call Trace: <TASK> kvm_set_pfn_dirty+0xa8/0xe0 [kvm] __handle_changed_spte+0x2ab/0x5e0 [kvm] __handle_changed_spte+0x2ab/0x5e0 [kvm] __handle_changed_spte+0x2ab/0x5e0 [kvm] zap_gfn_range+0x1f3/0x310 [kvm] kvm_tdp_mmu_zap_invalidated_roots+0x50/0x90 [kvm] kvm_mmu_zap_all_fast+0x177/0x1a0 [kvm] set_nx_huge_pages+0xb4/0x190 [kvm] param_attr_store+0x70/0x100 module_attr_store+0x19/0x30 kernfs_fop_write_iter+0x119/0x1b0 new_sync_write+0x11c/0x1b0 vfs_write+0x1cc/0x270 ksys_write+0x5f/0xe0 do_syscall_64+0x38/0xc0 entry_SYSCALL_64_after_hwframe+0x44/0xae </TASK>",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021717": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched/fair: Fix shift-out-of-bounds in load_balance() Syzbot reported a handful of occurrences where an sd->nr_balance_failed can grow to much higher values than one would expect. A successful load_balance() resets it to 0; a failed one increments it. Once it gets to sd->cache_nice_tries + 3, this *should* trigger an active balance, which will either set it to sd->cache_nice_tries+1 or reset it to 0. However, in case the to-be-active-balanced task is not allowed to run on env->dst_cpu, then the increment is done without any further modification. This could then be repeated ad nauseam, and would explain the absurdly high values reported by syzbot (86, 149). VincentG noted there is value in letting sd->cache_nice_tries grow, so the shift itself should be fixed. That means preventing: \"\"\" If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined. \"\"\" Thus we need to cap the shift exponent to BITS_PER_TYPE(typeof(lefthand)) - 1. I had a look around for other similar cases via coccinelle: @expr@ position pos; expression E1; expression E2; @@ ( E1 >> E2@pos | E1 >> E2@pos ) @cst depends on expr@ position pos; expression expr.E1; constant cst; @@ ( E1 >> cst@pos | E1 << cst@pos ) @script:python depends on !cst@ pos << expr.pos; exp << expr.E2; @@ # Dirty hack to ignore constexpr if exp.upper() != exp: coccilib.report.print_report(pos[0], \"Possible UB shift here\") The only other match in kernel/sched is rq_clock_thermal() which employs sched_thermal_decay_shift, and that exponent is already capped to 10, so that one is fine.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.37 未満\nLinux Kernel 5.11 以上 5.11.21 未満\nLinux Kernel 5.12 以上 5.12.4 未満"
    },
    "JVNDB-2021-021754": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: watchdog: Fix possible use-after-free in wdt_startup() This module's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.134 未満\nLinux Kernel 5.5 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021749": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: fix soft lookup in subflow_error_report() Maxim reported a soft lookup in subflow_error_report(): watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [swapper/0:0] RIP: 0010:native_queued_spin_lock_slowpath RSP: 0018:ffffa859c0003bc0 EFLAGS: 00000202 RAX: 0000000000000101 RBX: 0000000000000001 RCX: 0000000000000000 RDX: ffff9195c2772d88 RSI: 0000000000000000 RDI: ffff9195c2772d88 RBP: ffff9195c2772d00 R08: 00000000000067b0 R09: c6e31da9eb1e44f4 R10: ffff9195ef379700 R11: ffff9195edb50710 R12: ffff9195c2772d88 R13: ffff9195f500e3d0 R14: ffff9195ef379700 R15: ffff9195ef379700 FS: 0000000000000000(0000) GS:ffff91961f400000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000c000407000 CR3: 0000000002988000 CR4: 00000000000006f0 Call Trace: <IRQ> _raw_spin_lock_bh subflow_error_report mptcp_subflow_data_available __mptcp_move_skbs_from_subflow mptcp_data_ready tcp_data_queue tcp_rcv_established tcp_v4_do_rcv tcp_v4_rcv ip_protocol_deliver_rcu ip_local_deliver_finish __netif_receive_skb_one_core netif_receive_skb rtl8139_poll 8139too __napi_poll net_rx_action __do_softirq __irq_exit_rcu common_interrupt </IRQ> The calling function - mptcp_subflow_data_available() - can be invoked from different contexts: - plain ssk socket lock - ssk socket lock + mptcp_data_lock - ssk socket lock + mptcp_data_lock + msk socket lock. Since subflow_error_report() tries to acquire the mptcp_data_lock, the latter two call chains will cause soft lookup. This change addresses the issue moving the error reporting call to outer functions, where the held locks list is known and the we can acquire only the needed one.",
        "technologies": "Linux\nLinux Kernel 5.11.12 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021748": {
        "title": "Linux の Linux Kernel における不適切な権限設定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ethtool: strset: fix message length calculation Outer nest for ETHTOOL_A_STRSET_STRINGSETS is not accounted for. This may result in ETHTOOL_MSG_STRSET_GET producing a warning like: calculated message payload length (684) not sufficient WARNING: CPU: 0 PID: 30967 at net/ethtool/netlink.c:369 ethnl_default_doit+0x87a/0xa20 and a splat. As usually with such warnings three conditions must be met for the warning to trigger: - there must be no skb size rounding up (e.g. reply_size of 684); - string set must be per-device (so that the header gets populated); - the device name must be at least 12 characters long. all in all with current user space it looks like reading priv flags is the only place this could potentially happen. Or with syzbot :)",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021757": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nexthop: Fix memory leaks in nexthop notification chain listeners syzkaller discovered memory leaks [1] that can be reduced to the following commands: # ip nexthop add id 1 blackhole # devlink dev reload pci/0000:06:00.0 As part of the reload flow, mlxsw will unregister its netdevs and then unregister from the nexthop notification chain. Before unregistering from the notification chain, mlxsw will receive delete notifications for nexthop objects using netdevs registered by mlxsw or their uppers. mlxsw will not receive notifications for nexthops using netdevs that are not dismantled as part of the reload flow. For example, the blackhole nexthop above that internally uses the loopback netdev as its nexthop device. One way to fix this problem is to have listeners flush their nexthop tables after unregistering from the notification chain. This is error-prone as evident by this patch and also not symmetric with the registration path where a listener receives a dump of all the existing nexthops. Therefore, fix this problem by replaying delete notifications for the listener being unregistered. This is symmetric to the registration path and also consistent with the netdev notification chain. The above means that unregister_nexthop_notifier(), like register_nexthop_notifier(), will have to take RTNL in order to iterate over the existing nexthops and that any callers of the function cannot hold RTNL. This is true for mlxsw and netdevsim, but not for the VXLAN driver. To avoid a deadlock, change the latter to unregister its nexthop listener without holding RTNL, making it symmetric to the registration path. [1] unreferenced object 0xffff88806173d600 (size 512): comm \"syz-executor.0\", pid 1290, jiffies 4295583142 (age 143.507s) hex dump (first 32 bytes): 41 9d 1e 60 80 88 ff ff 08 d6 73 61 80 88 ff ff A..`......sa.... 08 d6 73 61 80 88 ff ff 01 00 00 00 00 00 00 00 ..sa............ backtrace: [<ffffffff81a6b576>] kmemleak_alloc_recursive include/linux/kmemleak.h:43 [inline] [<ffffffff81a6b576>] slab_post_alloc_hook+0x96/0x490 mm/slab.h:522 [<ffffffff81a716d3>] slab_alloc_node mm/slub.c:3206 [inline] [<ffffffff81a716d3>] slab_alloc mm/slub.c:3214 [inline] [<ffffffff81a716d3>] kmem_cache_alloc_trace+0x163/0x370 mm/slub.c:3231 [<ffffffff82e8681a>] kmalloc include/linux/slab.h:591 [inline] [<ffffffff82e8681a>] kzalloc include/linux/slab.h:721 [inline] [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_group_create drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:4918 [inline] [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_new drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5054 [inline] [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_event+0x59a/0x2910 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5239 [<ffffffff813ef67d>] notifier_call_chain+0xbd/0x210 kernel/notifier.c:83 [<ffffffff813f0662>] blocking_notifier_call_chain kernel/notifier.c:318 [inline] [<ffffffff813f0662>] blocking_notifier_call_chain+0x72/0xa0 kernel/notifier.c:306 [<ffffffff8384b9c6>] call_nexthop_notifiers+0x156/0x310 net/ipv4/nexthop.c:244 [<ffffffff83852bd8>] insert_nexthop net/ipv4/nexthop.c:2336 [inline] [<ffffffff83852bd8>] nexthop_add net/ipv4/nexthop.c:2644 [inline] [<ffffffff83852bd8>] rtm_new_nexthop+0x14e8/0x4d10 net/ipv4/nexthop.c:2913 [<ffffffff833e9a78>] rtnetlink_rcv_msg+0x448/0xbf0 net/core/rtnetlink.c:5572 [<ffffffff83608703>] netlink_rcv_skb+0x173/0x480 net/netlink/af_netlink.c:2504 [<ffffffff833de032>] rtnetlink_rcv+0x22/0x30 net/core/rtnetlink.c:5590 [<ffffffff836069de>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline] [<ffffffff836069de>] netlink_unicast+0x5ae/0x7f0 net/netlink/af_netlink.c:1340 [<ffffffff83607501>] netlink_sendmsg+0x8e1/0xe30 net/netlink/af_netlink.c:1929 [<ffffffff832fde84>] sock_sendmsg_nosec net/socket.c:704 [inline ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.14.9 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021755": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Avoid HDCP over-read and corruption Instead of reading the desired 5 bytes of the actual target field, the code was reading 8. This could result in a corrupted value if the trailing 3 bytes were non-zero, so instead use an appropriately sized and zero-initialized bounce buffer, and read only 5 bytes before casting to u64.",
        "technologies": "Linux\nLinux Kernel 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021753": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cpufreq: CPPC: Fix potential memleak in cppc_cpufreq_cpu_init It's a classic example of memleak, we allocate something, we fail and never free the resources. Make sure we free all resources on policy ->init() failures.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021764": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: peak_pci: peak_pci_remove(): fix UAF When remove the module peek_pci, referencing 'chan' again after releasing 'dev' will cause UAF. Fix this by releasing 'dev' later. The following log reveals it: [ 35.961814 ] BUG: KASAN: use-after-free in peak_pci_remove+0x16f/0x270 [peak_pci] [ 35.963414 ] Read of size 8 at addr ffff888136998ee8 by task modprobe/5537 [ 35.965513 ] Call Trace: [ 35.965718 ] dump_stack_lvl+0xa8/0xd1 [ 35.966028 ] print_address_description+0x87/0x3b0 [ 35.966420 ] kasan_report+0x172/0x1c0 [ 35.966725 ] ? peak_pci_remove+0x16f/0x270 [peak_pci] [ 35.967137 ] ? trace_irq_enable_rcuidle+0x10/0x170 [ 35.967529 ] ? peak_pci_remove+0x16f/0x270 [peak_pci] [ 35.967945 ] __asan_report_load8_noabort+0x14/0x20 [ 35.968346 ] peak_pci_remove+0x16f/0x270 [peak_pci] [ 35.968752 ] pci_device_remove+0xa9/0x250",
        "technologies": "Linux\nLinux Kernel 3.4 以上 4.4.290 未満\nLinux Kernel 4.5 以上 4.9.288 未満\nLinux Kernel 4.10 以上 4.14.253 未満\nLinux Kernel 4.15 以上 4.19.214 未満\nLinux Kernel 4.20 以上 5.4.156 未満\nLinux Kernel 5.5 以上 5.10.76 未満\nLinux Kernel 5.11 以上 5.14.15 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021763": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: fix locking for Tx timestamp tracking flush Commit 4dd0d5c33c3e (\"ice: add lock around Tx timestamp tracker flush\") added a lock around the Tx timestamp tracker flow which is used to cleanup any left over SKBs and prepare for device removal. This lock is problematic because it is being held around a call to ice_clear_phy_tstamp. The clear function takes a mutex to send a PHY write command to firmware. This could lead to a deadlock if the mutex actually sleeps, and causes the following warning on a kernel with preemption debugging enabled: [ 715.419426] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:573 [ 715.427900] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 3100, name: rmmod [ 715.435652] INFO: lockdep is turned off. [ 715.439591] Preemption disabled at: [ 715.439594] [<0000000000000000>] 0x0 [ 715.446678] CPU: 52 PID: 3100 Comm: rmmod Tainted: G W OE 5.15.0-rc4+ #42 bdd7ec3018e725f159ca0d372ce8c2c0e784891c [ 715.458058] Hardware name: Intel Corporation S2600STQ/S2600STQ, BIOS SE5C620.86B.02.01.0010.010620200716 01/06/2020 [ 715.468483] Call Trace: [ 715.470940] dump_stack_lvl+0x6a/0x9a [ 715.474613] ___might_sleep.cold+0x224/0x26a [ 715.478895] __mutex_lock+0xb3/0x1440 [ 715.482569] ? stack_depot_save+0x378/0x500 [ 715.486763] ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.494979] ? kfree+0xc1/0x520 [ 715.498128] ? mutex_lock_io_nested+0x12a0/0x12a0 [ 715.502837] ? kasan_set_free_info+0x20/0x30 [ 715.507110] ? __kasan_slab_free+0x10b/0x140 [ 715.511385] ? slab_free_freelist_hook+0xc7/0x220 [ 715.516092] ? kfree+0xc1/0x520 [ 715.519235] ? ice_deinit_lag+0x16c/0x220 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.527359] ? ice_remove+0x1cf/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.535133] ? pci_device_remove+0xab/0x1d0 [ 715.539318] ? __device_release_driver+0x35b/0x690 [ 715.544110] ? driver_detach+0x214/0x2f0 [ 715.548035] ? bus_remove_driver+0x11d/0x2f0 [ 715.552309] ? pci_unregister_driver+0x26/0x250 [ 715.556840] ? ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.564799] ? __do_sys_delete_module.constprop.0+0x2d8/0x4e0 [ 715.570554] ? do_syscall_64+0x3b/0x90 [ 715.574303] ? entry_SYSCALL_64_after_hwframe+0x44/0xae [ 715.579529] ? start_flush_work+0x542/0x8f0 [ 715.583719] ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.591923] ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.599960] ? wait_for_completion_io+0x250/0x250 [ 715.604662] ? lock_acquire+0x196/0x200 [ 715.608504] ? do_raw_spin_trylock+0xa5/0x160 [ 715.612864] ice_sbq_rw_reg+0x1e6/0x2f0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.620813] ? ice_reset+0x130/0x130 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.628497] ? __debug_check_no_obj_freed+0x1e8/0x3c0 [ 715.633550] ? trace_hardirqs_on+0x1c/0x130 [ 715.637748] ice_write_phy_reg_e810+0x70/0xf0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.646220] ? do_raw_spin_trylock+0xa5/0x160 [ 715.650581] ? ice_ptp_release+0x910/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.658797] ? ice_ptp_release+0x255/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.667013] ice_clear_phy_tstamp+0x2c/0x110 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.675403] ice_ptp_release+0x408/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.683440] ice_remove+0x560/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d] [ 715.691037] ? _raw_spin_unlock_irqrestore+0x46/0x73 [ 715.696005] pci_device_remove+0xab/0x1d0 [ 715.700018] __device_release_driver+0x35b/0x690 [ 715.704637] driver_detach+0x214/0x2f0 [ 715.708389] bus_remove_driver+0x11d/0x2f0 [ 715.712489] pci_unregister_driver+0x26/0x250 [ 71 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.14.4 以上 5.14.14 未満"
    },
    "JVNDB-2021-021765": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: audit: fix possible null-pointer dereference in audit_filter_rules Fix possible null-pointer dereference in audit_filter_rules. audit_filter_rules() error: we previously assumed 'ctx' could be null",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.156 未満\nLinux Kernel 5.5 以上 5.10.76 未満\nLinux Kernel 5.11 以上 5.14.15 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021797": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: fix memory leak in tcindex_partial_destroy_work Syzbot reported memory leak in tcindex_set_parms(). The problem was in non-freed perfect hash in tcindex_partial_destroy_work(). In tcindex_set_parms() new tcindex_data is allocated and some fields from old one are copied to new one, but not the perfect hash. Since tcindex_partial_destroy_work() is the destroy function for old tcindex_data, we need to free perfect hash to avoid memory leak.",
        "technologies": "Linux\nLinux Kernel 3.18 以上 5.4.136 未満\nLinux Kernel 5.5 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021785": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mISDN: fix possible use-after-free in HFC_cleanup() This module's remove path calls del_timer(). However, that function does not wait until the timer handler finishes. This means that the timer handler may still be running after the driver's remove function has finished, which would result in a use-after-free. Fix by calling del_timer_sync(), which makes sure the timer handler has finished, and unable to re-schedule itself.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021831": {
        "title": "Linux の Linux Kernel における入力で指定された数量の不適切な検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mac80211: fix skb length check in ieee80211_scan_rx() Replace hard-coded compile-time constants for header length check with dynamic determination based on the frame type. Otherwise, we hit a validation WARN_ON in cfg80211 later. [style fixes, reword commit message]",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021759": {
        "title": "Linux の Linux Kernel における情報漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipack: ipoctal: fix module reference leak A reference to the carrier module was taken on every open but was only released once when the final reference to the tty struct was dropped. Fix this by taking the module reference and initialising the tty driver data when installing the tty.",
        "technologies": "Linux\nLinux Kernel 3.18 以上 4.4.286 未満\nLinux Kernel 4.5 以上 4.9.285 未満\nLinux Kernel 4.10 以上 4.14.249 未満\nLinux Kernel 4.15 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.151 未満\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021839": {
        "title": "Linux の Linux Kernel における観測可能な不一致に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/fpu: Invalidate FPU state after a failed XRSTOR from a user buffer Both Intel and AMD consider it to be architecturally valid for XRSTOR to fail with #PF but nonetheless change the register state. The actual conditions under which this might occur are unclear [1], but it seems plausible that this might be triggered if one sibling thread unmaps a page and invalidates the shared TLB while another sibling thread is executing XRSTOR on the page in question. __fpu__restore_sig() can execute XRSTOR while the hardware registers are preserved on behalf of a different victim task (using the fpu_fpregs_owner_ctx mechanism), and, in theory, XRSTOR could fail but modify the registers. If this happens, then there is a window in which __fpu__restore_sig() could schedule out and the victim task could schedule back in without reloading its own FPU registers. This would result in part of the FPU state that __fpu__restore_sig() was attempting to load leaking into the victim task's user-visible state. Invalidate preserved FPU registers on XRSTOR failure to prevent this situation from corrupting any state. [1] Frequent readers of the errata lists might imagine \"complex microarchitectural conditions\".",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021841": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kvm: avoid speculation-based attacks from out-of-range memslot accesses KVM's mechanism for accessing guest memory translates a guest physical address (gpa) to a host virtual address using the right-shifted gpa (also known as gfn) and a struct kvm_memory_slot. The translation is performed in __gfn_to_hva_memslot using the following formula: hva = slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE It is expected that gfn falls within the boundaries of the guest's physical memory. However, a guest can access invalid physical addresses in such a way that the gfn is invalid. __gfn_to_hva_memslot is called from kvm_vcpu_gfn_to_hva_prot, which first retrieves a memslot through __gfn_to_memslot. While __gfn_to_memslot does check that the gfn falls within the boundaries of the guest's physical memory or not, a CPU can speculate the result of the check and continue execution speculatively using an illegal gfn. The speculation can result in calculating an out-of-bounds hva. If the resulting host virtual address is used to load another guest physical address, this is effectively a Spectre gadget consisting of two consecutive reads, the second of which is data dependent on the first. Right now it's not clear if there are any cases in which this is exploitable. One interesting case was reported by the original author of this patch, and involves visiting guest page tables on x86. Right now these are not vulnerable because the hva read goes through get_user(), which contains an LFENCE speculation barrier. However, there are patches in progress for x86 uaccess.h to mask kernel addresses instead of using LFENCE; once these land, a guest could use speculation to read from the VMM's ring 3 address space. Other architectures such as ARM already use the address masking method, and would be susceptible to this same kind of data-dependent access gadgets. Therefore, this patch proactively protects from these attacks by masking out-of-bounds gfns in __gfn_to_hva_memslot, which blocks speculation of invalid hvas. Sean Christopherson noted that this patch does not cover kvm_read_guest_offset_cached. This however is limited to a few bytes past the end of the cache, and therefore it is unlikely to be useful in the context of building a chain of data dependent accesses.",
        "technologies": "Linux\nLinux Kernel 4.4.273 未満\nLinux Kernel 4.5 以上 4.9.273 未満\nLinux Kernel 4.10 以上 4.14.237 未満\nLinux Kernel 4.15 以上 4.19.195 未満\nLinux Kernel 4.20 以上 5.4.126 未満\nLinux Kernel 5.5 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021843": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bus: mhi: core: Validate channel ID when processing command completions MHI reads the channel ID from the event ring element sent by the device which can be any value between 0 and 255. In order to prevent any out of bound accesses, add a check against the maximum number of channels supported by the controller and those channels not configured yet so as to skip processing of that event ring element.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021834": {
        "title": "Linux の Linux Kernel における誤って解決された名前や参照の使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: IB/mlx5: Fix initializing CQ fragments buffer The function init_cq_frag_buf() can be called to initialize the current CQ fragments buffer cq->buf, or the temporary cq->resize_buf that is filled during CQ resize operation. However, the offending commit started to use function get_cqe() for getting the CQEs, the issue with this change is that get_cqe() always returns CQEs from cq->buf, which leads us to initialize the wrong buffer, and in case of enlarging the CQ we try to access elements beyond the size of the current cq->buf and eventually hit a kernel panic. [exception RIP: init_cq_frag_buf+103] [ffff9f799ddcbcd8] mlx5_ib_resize_cq at ffffffffc0835d60 [mlx5_ib] [ffff9f799ddcbdb0] ib_resize_cq at ffffffffc05270df [ib_core] [ffff9f799ddcbdc0] llt_rdma_setup_qp at ffffffffc0a6a712 [llt] [ffff9f799ddcbe10] llt_rdma_cc_event_action at ffffffffc0a6b411 [llt] [ffff9f799ddcbe98] llt_rdma_client_conn_thread at ffffffffc0a6bb75 [llt] [ffff9f799ddcbec8] kthread at ffffffffa66c5da1 [ffff9f799ddcbf50] ret_from_fork_nospec_begin at ffffffffa6d95ddd Fix it by getting the needed CQE by calling mlx5_frag_buf_get_wqe() that takes the correct source buffer as a parameter.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.195 未満\nLinux Kernel 4.20 以上 5.4.126 未満\nLinux Kernel 5.5 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021832": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kvm: LAPIC: Restore guard to prevent illegal APIC register access Per the SDM, \"any access that touches bytes 4 through 15 of an APIC register may cause undefined behavior and must not be executed.\" Worse, such an access in kvm_lapic_reg_read can result in a leak of kernel stack contents. Prior to commit 01402cf81051 (\"kvm: LAPIC: write down valid APIC registers\"), such an access was explicitly disallowed. Restore the guard that was removed in that commit.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.128 未満\nLinux Kernel 5.5 以上 5.10.46 未満\nLinux Kernel 5.11 以上 5.12.13 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021842": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: bcm2835: Fix out-of-bounds access with more than 4 slaves Commit 571e31fa60b3 (\"spi: bcm2835: Cache CS register value for ->prepare_message()\") limited the number of slaves to 3 at compile-time. The limitation was necessitated by a statically-sized array prepare_cs[] in the driver private data which contains a per-slave register value. The commit sought to enforce the limitation at run-time by setting the controller's num_chipselect to 3: Slaves with a higher chipselect are rejected by spi_add_device(). However the commit neglected that num_chipselect only limits the number of *native* chipselects. If GPIO chipselects are specified in the device tree for more than 3 slaves, num_chipselect is silently raised by of_spi_get_gpio_numbers() and the result are out-of-bounds accesses to the statically-sized array prepare_cs[]. As a bandaid fix which is backportable to stable, raise the number of allowed slaves to 24 (which \"ought to be enough for anybody\"), enforce the limitation on slave ->setup and revert num_chipselect to 3 (which is the number of native chipselects supported by the controller). An upcoming for-next commit will allow an arbitrary number of slaves.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.126 未満\nLinux Kernel 5.5 以上 5.10.44 未満\nLinux Kernel 5.11 以上 5.12.11 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021848": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: act_skbmod: Skip non-Ethernet packets Currently tcf_skbmod_act() assumes that packets use Ethernet as their L2 protocol, which is not always the case. As an example, for CAN devices: $ ip link add dev vcan0 type vcan $ ip link set up vcan0 $ tc qdisc add dev vcan0 root handle 1: htb $ tc filter add dev vcan0 parent 1: protocol ip prio 10 \\ matchall action skbmod swap mac Doing the above silently corrupts all the packets. Do not perform skbmod actions for non-Ethernet packets.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.19.199 未満\nLinux Kernel 4.20 以上 5.4.136 未満\nLinux Kernel 5.5 以上 5.10.54 未満\nLinux Kernel 5.11 以上 5.13.6 未満\nLinux Kernel 5.14"
    },
    "JVNDB-2021-021863": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFSv4: Fix an Oops in pnfs_mark_request_commit() when doing O_DIRECT Fix an Oopsable condition in pnfs_mark_request_commit() when we're putting a set of writes on the commit list to reschedule them after a failed pNFS attempt.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.52 未満\nLinux Kernel 5.11 以上 5.12.19 未満\nLinux Kernel 5.13 以上 5.13.4 未満"
    },
    "JVNDB-2021-021940": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i2c: i801: Don't generate an interrupt on bus reset Now that the i2c-i801 driver supports interrupts, setting the KILL bit in a attempt to recover from a timed out transaction triggers an interrupt. Unfortunately, the interrupt handler (i801_isr) is not prepared for this situation and will try to process the interrupt as if it was signaling the end of a successful transaction. In the case of a block transaction, this can result in an out-of-range memory access. This condition was reproduced several times by syzbot: https://syzkaller.appspot.com/bug?extid=ed71512d469895b5b34e https://syzkaller.appspot.com/bug?extid=8c8dedc0ba9e03f6c79e https://syzkaller.appspot.com/bug?extid=c8ff0b6d6c73d81b610e https://syzkaller.appspot.com/bug?extid=33f6c360821c399d69eb https://syzkaller.appspot.com/bug?extid=be15dc0b1933f04b043a https://syzkaller.appspot.com/bug?extid=b4d3fd1dfd53e90afd79 So disable interrupts while trying to reset the bus. Interrupts will be enabled again for the following transaction.",
        "technologies": "Linux\nLinux Kernel 3.6 以上 4.4.271 未満\nLinux Kernel 4.5 以上 4.9.271 未満\nLinux Kernel 4.10 以上 4.14.235 未満\nLinux Kernel 4.15 以上 4.19.193 未満\nLinux Kernel 4.20 以上 5.4.124 未満\nLinux Kernel 5.5 以上 5.10.42 未満\nLinux Kernel 5.11 以上 5.12.9 未満\nLinux Kernel 5.13"
    },
    "JVNDB-2021-021864": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smackfs: restrict bytes count in smk_set_cipso() Oops, I failed to update subject line. From 07571157c91b98ce1a4aa70967531e64b78e8346 Mon Sep 17 00:00:00 2001 Date: Mon, 12 Apr 2021 22:25:06 +0900 Subject: [PATCH] smackfs: restrict bytes count in smk_set_cipso() Commit 7ef4c19d245f3dc2 (\"smackfs: restrict bytes count in smackfs write functions\") missed that count > SMK_CIPSOMAX check applies to only format == SMK_FIXED24_FMT case.",
        "technologies": "Linux\nLinux Kernel 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.133 未満\nLinux Kernel 5.5 以上 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021949": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i2c: virtio: disable timeout handling If a timeout is hit, it can result is incorrect data on the I2C bus and/or memory corruptions in the guest since the device can still be operating on the buffers it was given while the guest has freed them. Here is, for example, the start of a slub_debug splat which was triggered on the next transfer after one transfer was forced to timeout by setting a breakpoint in the backend (rust-vmm/vhost-device): BUG kmalloc-1k (Not tainted): Poison overwritten First byte 0x1 instead of 0x6b Allocated in virtio_i2c_xfer+0x65/0x35c age=350 cpu=0 pid=29 __kmalloc+0xc2/0x1c9 virtio_i2c_xfer+0x65/0x35c __i2c_transfer+0x429/0x57d i2c_transfer+0x115/0x134 i2cdev_ioctl_rdwr+0x16a/0x1de i2cdev_ioctl+0x247/0x2ed vfs_ioctl+0x21/0x30 sys_ioctl+0xb18/0xb41 Freed in virtio_i2c_xfer+0x32e/0x35c age=244 cpu=0 pid=29 kfree+0x1bd/0x1cc virtio_i2c_xfer+0x32e/0x35c __i2c_transfer+0x429/0x57d i2c_transfer+0x115/0x134 i2cdev_ioctl_rdwr+0x16a/0x1de i2cdev_ioctl+0x247/0x2ed vfs_ioctl+0x21/0x30 sys_ioctl+0xb18/0xb41 There is no simple fix for this (the driver would have to always create bounce buffers and hold on to them until the device eventually returns the buffers), so just disable the timeout support for now.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.6 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021860": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: virtio-net: Add validation for used length This adds validation for used length (might come from an untrusted device) to avoid data corruption or loss.",
        "technologies": "Linux\nLinux Kernel 5.10.51 未満\nLinux Kernel 5.11 以上 5.12.18 未満\nLinux Kernel 5.13 以上 5.13.3 未満"
    },
    "JVNDB-2021-021970": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: comedi: dt9812: fix DMA buffers on stack USB transfer buffers are typically mapped for DMA and must not be allocated on the stack or transfers will fail. Allocate proper transfer buffers in the various command helpers and return an error on short transfers instead of acting on random stack data. Note that this also fixes a stack info leak on systems where DMA is not used as 32 bytes are always sent to the device regardless of how short the command is.",
        "technologies": "Linux\nLinux Kernel 2.6.29 以上 4.4.292 未満\nLinux Kernel 4.5 以上 4.9.290 未満\nLinux Kernel 4.10 以上 4.14.255 未満\nLinux Kernel 4.15 以上 4.19.217 未満\nLinux Kernel 4.20 以上 5.4.159 未満\nLinux Kernel 5.5 以上 5.10.79 未満\nLinux Kernel 5.11 以上 5.14.18 未満\nLinux Kernel 5.15 以上 5.15.2 未満"
    },
    "JVNDB-2021-021942": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vc4: kms: Clear the HVS FIFO commit pointer once done Commit 9ec03d7f1ed3 (\"drm/vc4: kms: Wait on previous FIFO users before a commit\") introduced a wait on the previous commit done on a given HVS FIFO. However, we never cleared that pointer once done. Since drm_crtc_commit_put can free the drm_crtc_commit structure directly if we were the last user, this means that it can lead to a use-after free if we were to duplicate the state, and that stale pointer would even be copied to the new state. Set the pointer to NULL once we're done with the wait so that we don't carry over a pointer to a free'd structure.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.7 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021966": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/cma: Ensure rdma_addr_cancel() happens before issuing more requests The FSM can run in a circle allowing rdma_resolve_ip() to be called twice on the same id_priv. While this cannot happen without going through the work, it violates the invariant that the same address resolution background request cannot be active twice. CPU 1 CPU 2 rdma_resolve_addr(): RDMA_CM_IDLE -> RDMA_CM_ADDR_QUERY rdma_resolve_ip(addr_handler) #1 process_one_req(): for #1 addr_handler(): RDMA_CM_ADDR_QUERY -> RDMA_CM_ADDR_BOUND mutex_unlock(&id_priv->handler_mutex); [.. handler still running ..] rdma_resolve_addr(): RDMA_CM_ADDR_BOUND -> RDMA_CM_ADDR_QUERY rdma_resolve_ip(addr_handler) !! two requests are now on the req_list rdma_destroy_id(): destroy_id_handler_unlock(): _destroy_id(): cma_cancel_operation(): rdma_addr_cancel() // process_one_req() self removes it spin_lock_bh(&lock); cancel_delayed_work(&req->work); if (!list_empty(&req->list)) == true ! rdma_addr_cancel() returns after process_on_req #1 is done kfree(id_priv) process_one_req(): for #2 addr_handler(): mutex_lock(&id_priv->handler_mutex); !! Use after free on id_priv rdma_addr_cancel() expects there to be one req on the list and only cancels the first one. The self-removal behavior of the work only happens after the handler has returned. This yields a situations where the req_list can have two reqs for the same \"handle\" but rdma_addr_cancel() only cancels the first one. The second req remains active beyond rdma_destroy_id() and will use-after-free id_priv once it inevitably triggers. Fix this by remembering if the id_priv has called rdma_resolve_ip() and always cancel before calling it again. This ensures the req_list never gets more than one item in it and doesn't cost anything in the normal flow that never uses this strange error path.",
        "technologies": "Linux\nLinux Kernel 2.6.18 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021962": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: video: fbdev: nvidiafb: Use strscpy() to prevent buffer overflow Coverity complains of a possible buffer overflow. However, given the 'static' scope of nvidia_setup_i2c_bus() it looks like that can't happen after examiniing the call sites. CID 19036 (#1 of 1): Copy into fixed size buffer (STRING_OVERFLOW) 1. fixed_size_dest: You might overrun the 48-character fixed-size string chan->adapter.name by copying name without checking the length. 2. parameter_as_source: Note: This defect has an elevated risk because the source argument is a parameter of the current function. 89 strcpy(chan->adapter.name, name); Fix this warning by using strscpy() which will silence the warning and prevent any future buffer overflows should the names used to identify the channel become much longer.",
        "technologies": "Linux\nLinux Kernel 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2021-021957": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: mpt3sas: Fix kernel panic during drive powercycle test While looping over shost's sdev list it is possible that one of the drives is getting removed and its sas_target object is freed but its sdev object remains intact. Consequently, a kernel panic can occur while the driver is trying to access the sas_address field of sas_target object without also checking the sas_target object for NULL.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 4.4.294 未満\nLinux Kernel 4.5 以上 4.9.292 未満\nLinux Kernel 4.10 以上 4.14.257 未満\nLinux Kernel 4.15 以上 4.19.219 未満\nLinux Kernel 4.20 以上 5.4.163 未満\nLinux Kernel 5.5 以上 5.10.83 未満\nLinux Kernel 5.11 以上 5.15.6 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021955": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: fix wrong list_del in smc_lgr_cleanup_early smc_lgr_cleanup_early() meant to delete the link group from the link group list, but it deleted the list head by mistake. This may cause memory corruption since we didn't remove the real link group from the list and later memseted the link group structure. We got a list corruption panic when testing: [  231.277259] list_del corruption. prev->next should be ffff8881398a8000, but was 0000000000000000 [  231.278222] ------------[ cut here ]------------ [  231.278726] kernel BUG at lib/list_debug.c:53! [  231.279326] invalid opcode: 0000 [#1] SMP NOPTI [  231.279803] CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.10.46+ #435 [  231.280466] Hardware name: Alibaba Cloud ECS, BIOS 8c24b4c 04/01/2014 [  231.281248] Workqueue: events smc_link_down_work [  231.281732] RIP: 0010:__list_del_entry_valid+0x70/0x90 [  231.282258] Code: 4c 60 82 e8 7d cc 6a 00 0f 0b 48 89 fe 48 c7 c7 88 4c 60 82 e8 6c cc 6a 00 0f 0b 48 89 fe 48 c7 c7 c0 4c 60 82 e8 5b cc 6a 00 <0f> 0b 48 89 fe 48 c7 c7 00 4d 60 82 e8 4a cc 6a 00 0f 0b cc cc cc [  231.284146] RSP: 0018:ffffc90000033d58 EFLAGS: 00010292 [  231.284685] RAX: 0000000000000054 RBX: ffff8881398a8000 RCX: 0000000000000000 [  231.285415] RDX: 0000000000000001 RSI: ffff88813bc18040 RDI: ffff88813bc18040 [  231.286141] RBP: ffffffff8305ad40 R08: 0000000000000003 R09: 0000000000000001 [  231.286873] R10: ffffffff82803da0 R11: ffffc90000033b90 R12: 0000000000000001 [  231.287606] R13: 0000000000000000 R14: ffff8881398a8000 R15: 0000000000000003 [  231.288337] FS:  0000000000000000(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000 [  231.289160] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  231.289754] CR2: 0000000000e72058 CR3: 000000010fa96006 CR4: 00000000003706f0 [  231.290485] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [  231.291211] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [  231.291940] Call Trace: [  231.292211]  smc_lgr_terminate_sched+0x53/0xa0 [  231.292677]  smc_switch_conns+0x75/0x6b0 [  231.293085]  ? update_load_avg+0x1a6/0x590 [  231.293517]  ? ttwu_do_wakeup+0x17/0x150 [  231.293907]  ? update_load_avg+0x1a6/0x590 [  231.294317]  ? newidle_balance+0xca/0x3d0 [  231.294716]  smcr_link_down+0x50/0x1a0 [  231.295090]  ? __wake_up_common_lock+0x77/0x90 [  231.295534]  smc_link_down_work+0x46/0x60 [  231.295933]  process_one_work+0x18b/0x350",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.84 未満\nLinux Kernel 5.11 以上 5.15.7 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021947": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched/scs: Reset task stack state in bringup_cpu() To hot unplug a CPU, the idle task on that CPU calls a few layers of C code before finally leaving the kernel. When KASAN is in use, poisoned shadow is left around for each of the active stack frames, and when shadow call stacks are in use. When shadow call stacks (SCS) are in use the task's saved SCS SP is left pointing at an arbitrary point within the task's shadow call stack. When a CPU is offlined than onlined back into the kernel, this stale state can adversely affect execution. Stale KASAN shadow can alias new stackframes and result in bogus KASAN warnings. A stale SCS SP is effectively a memory leak, and prevents a portion of the shadow call stack being used. Across a number of hotplug cycles the idle task's entire shadow call stack can become unusable. We previously fixed the KASAN issue in commit: e1b77c92981a5222 (\"sched/kasan: remove stale KASAN poison after hotplug\") ... by removing any stale KASAN stack poison immediately prior to onlining a CPU. Subsequently in commit: f1a0a376ca0c4ef1 (\"sched/core: Initialize the idle task with preemption disabled\") ... the refactoring left the KASAN and SCS cleanup in one-time idle thread initialization code rather than something invoked prior to each CPU being onlined, breaking both as above. We fixed SCS (but not KASAN) in commit: 63acd42c0d4942f7 (\"sched/scs: Reset the shadow stack when idle_task_exit\") ... but as this runs in the context of the idle task being offlined it's potentially fragile. To fix these consistently and more robustly, reset the SCS SP and KASAN shadow of a CPU's idle task immediately before we online that CPU in bringup_cpu(). This ensures the idle task always has a consistent state when it is running, and removes the need to so so when exiting an idle task. Whenever any thread is created, dup_task_struct() will give the task a stack which is free of KASAN shadow, and initialize the task's SCS SP, so there's no need to specially initialize either for idle thread within init_idle(), as this was only necessary to handle hotplug cycles. I've tested this on arm64 with: * gcc 11.1.0, defconfig +KASAN_INLINE, KASAN_STACK * clang 12.0.0, defconfig +KASAN_INLINE, KASAN_STACK, SHADOW_CALL_STACK ... offlining and onlining CPUS with: | while true; do | for C in /sys/devices/system/cpu/cpu*/online; do | echo 0 > $C; | echo 1 > $C; | done | done",
        "technologies": "Linux\nLinux Kernel 5.10.50 以上 5.10.83 未満\nLinux Kernel 5.12.17 以上 5.13 未満\nLinux Kernel 5.13.2 以上 5.15.6 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021971": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: staging: rtl8712: fix use-after-free in rtl8712_dl_fw Syzbot reported use-after-free in rtl8712_dl_fw(). The problem was in race condition between r871xu_dev_remove() ->ndo_open() callback. It's easy to see from crash log, that driver accesses released firmware in ->ndo_open() callback. It may happen, since driver was releasing firmware _before_ unregistering netdev. Fix it by moving unregister_netdev() before cleaning up resources. Call Trace: ... rtl871x_open_fw drivers/staging/rtl8712/hal_init.c:83 [inline] rtl8712_dl_fw+0xd95/0xe10 drivers/staging/rtl8712/hal_init.c:170 rtl8712_hal_init drivers/staging/rtl8712/hal_init.c:330 [inline] rtl871x_hal_init+0xae/0x180 drivers/staging/rtl8712/hal_init.c:394 netdev_open+0xe6/0x6c0 drivers/staging/rtl8712/os_intfs.c:380 __dev_open+0x2bc/0x4d0 net/core/dev.c:1484 Freed by task 1306: ... release_firmware+0x1b/0x30 drivers/base/firmware_loader/main.c:1053 r871xu_dev_remove+0xcc/0x2c0 drivers/staging/rtl8712/usb_intf.c:599 usb_unbind_interface+0x1d8/0x8d0 drivers/usb/core/driver.c:458",
        "technologies": "Linux\nLinux Kernel 3.2.6 以上 3.3 未満\nLinux Kernel 3.3.1 以上 5.10.79 未満\nLinux Kernel 5.11 以上 5.14.18 未満\nLinux Kernel 5.15 以上 5.15.2 未満\nLinux Kernel 3.3"
    },
    "JVNDB-2021-021943": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: proc/vmcore: fix clearing user buffer by properly using clear_user() To clear a user buffer we cannot simply use memset, we have to use clear_user(). With a virtio-mem device that registers a vmcore_cb and has some logically unplugged memory inside an added Linux memory block, I can easily trigger a BUG by copying the vmcore via \"cp\": systemd[1]: Starting Kdump Vmcore Save Service... kdump[420]: Kdump is using the default log level(3). kdump[453]: saving to /sysroot/var/crash/127.0.0.1-2021-11-11-14:59:22/ kdump[458]: saving vmcore-dmesg.txt to /sysroot/var/crash/127.0.0.1-2021-11-11-14:59:22/ kdump[465]: saving vmcore-dmesg.txt complete kdump[467]: saving vmcore BUG: unable to handle page fault for address: 00007f2374e01000 #PF: supervisor write access in kernel mode #PF: error_code(0x0003) - permissions violation PGD 7a523067 P4D 7a523067 PUD 7a528067 PMD 7a525067 PTE 800000007048f867 Oops: 0003 [#1] PREEMPT SMP NOPTI CPU: 0 PID: 468 Comm: cp Not tainted 5.15.0+ #6 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.14.0-27-g64f37cc530f1-prebuilt.qemu.org 04/01/2014 RIP: 0010:read_from_oldmem.part.0.cold+0x1d/0x86 Code: ff ff ff e8 05 ff fe ff e9 b9 e9 7f ff 48 89 de 48 c7 c7 38 3b 60 82 e8 f1 fe fe ff 83 fd 08 72 3c 49 8d 7d 08 4c 89 e9 89 e8 <49> c7 45 00 00 00 00 00 49 c7 44 05 f8 00 00 00 00 48 83 e7 f81 RSP: 0018:ffffc9000073be08 EFLAGS: 00010212 RAX: 0000000000001000 RBX: 00000000002fd000 RCX: 00007f2374e01000 RDX: 0000000000000001 RSI: 00000000ffffdfff RDI: 00007f2374e01008 RBP: 0000000000001000 R08: 0000000000000000 R09: ffffc9000073bc50 R10: ffffc9000073bc48 R11: ffffffff829461a8 R12: 000000000000f000 R13: 00007f2374e01000 R14: 0000000000000000 R15: ffff88807bd421e8 FS: 00007f2374e12140(0000) GS:ffff88807f000000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f2374e01000 CR3: 000000007a4aa000 CR4: 0000000000350eb0 Call Trace: read_vmcore+0x236/0x2c0 proc_reg_read+0x55/0xa0 vfs_read+0x95/0x190 ksys_read+0x4f/0xc0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae Some x86-64 CPUs have a CPU feature called \"Supervisor Mode Access Prevention (SMAP)\", which is used to detect wrong access from the kernel to user buffers like this: SMAP triggers a permissions violation on wrong access. In the x86-64 variant of clear_user(), SMAP is properly handled via clac()+stac(). To fix, properly use clear_user() when we're dealing with a user buffer.",
        "technologies": "Linux\nLinux Kernel 3.0 以上 4.4.294 未満\nLinux Kernel 4.5 以上 4.9.292 未満\nLinux Kernel 4.10 以上 4.14.257 未満\nLinux Kernel 4.15 以上 4.19.219 未満\nLinux Kernel 4.20 以上 5.4.163 未満\nLinux Kernel 5.5 以上 5.10.83 未満\nLinux Kernel 5.11 以上 5.15.6 未満\nLinux Kernel 5.16"
    },
    "JVNDB-2021-021958": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (mlxreg-fan) Return non-zero value when fan current state is enforced from sysfs Fan speed minimum can be enforced from sysfs. For example, setting current fan speed to 20 is used to enforce fan speed to be at 100% speed, 19 - to be not below 90% speed, etcetera. This feature provides ability to limit fan speed according to some system wise considerations, like absence of some replaceable units or high system ambient temperature. Request for changing fan minimum speed is configuration request and can be set only through 'sysfs' write procedure. In this situation value of argument 'state' is above nominal fan speed maximum. Return non-zero code in this case to avoid thermal_cooling_device_stats_update() call, because in this case statistics update violates thermal statistics table range. The issues is observed in case kernel is configured with option CONFIG_THERMAL_STATISTICS. Here is the trace from KASAN: [ 159.506659] BUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x7d/0xb0 [ 159.516016] Read of size 4 at addr ffff888116163840 by task hw-management.s/7444 [ 159.545625] Call Trace: [ 159.548366] dump_stack+0x92/0xc1 [ 159.552084] ? thermal_cooling_device_stats_update+0x7d/0xb0 [ 159.635869] thermal_zone_device_update+0x345/0x780 [ 159.688711] thermal_zone_device_set_mode+0x7d/0xc0 [ 159.694174] mlxsw_thermal_modules_init+0x48f/0x590 [mlxsw_core] [ 159.700972] ? mlxsw_thermal_set_cur_state+0x5a0/0x5a0 [mlxsw_core] [ 159.731827] mlxsw_thermal_init+0x763/0x880 [mlxsw_core] [ 160.070233] RIP: 0033:0x7fd995909970 [ 160.074239] Code: 73 01 c3 48 8b 0d 28 d5 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 99 2d 2c 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff .. [ 160.095242] RSP: 002b:00007fff54f5d938 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 [ 160.103722] RAX: ffffffffffffffda RBX: 0000000000000013 RCX: 00007fd995909970 [ 160.111710] RDX: 0000000000000013 RSI: 0000000001906008 RDI: 0000000000000001 [ 160.119699] RBP: 0000000001906008 R08: 00007fd995bc9760 R09: 00007fd996210700 [ 160.127687] R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000013 [ 160.135673] R13: 0000000000000001 R14: 00007fd995bc8600 R15: 0000000000000013 [ 160.143671] [ 160.145338] Allocated by task 2924: [ 160.149242] kasan_save_stack+0x19/0x40 [ 160.153541] __kasan_kmalloc+0x7f/0xa0 [ 160.157743] __kmalloc+0x1a2/0x2b0 [ 160.161552] thermal_cooling_device_setup_sysfs+0xf9/0x1a0 [ 160.167687] __thermal_cooling_device_register+0x1b5/0x500 [ 160.173833] devm_thermal_of_cooling_device_register+0x60/0xa0 [ 160.180356] mlxreg_fan_probe+0x474/0x5e0 [mlxreg_fan] [ 160.248140] [ 160.249807] The buggy address belongs to the object at ffff888116163400 [ 160.249807] which belongs to the cache kmalloc-1k of size 1024 [ 160.263814] The buggy address is located 64 bytes to the right of [ 160.263814] 1024-byte region [ffff888116163400, ffff888116163800) [ 160.277536] The buggy address belongs to the page: [ 160.282898] page:0000000012275840 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888116167000 pfn:0x116160 [ 160.294872] head:0000000012275840 order:3 compound_mapcount:0 compound_pincount:0 [ 160.303251] flags: 0x200000000010200(slab|head|node=0|zone=2) [ 160.309694] raw: 0200000000010200 ffffea00046f7208 ffffea0004928208 ffff88810004dbc0 [ 160.318367] raw: ffff888116167000 00000000000a0006 00000001ffffffff 0000000000000000 [ 160.327033] page dumped because: kasan: bad access detected [ 160.333270] [ 160.334937] Memory state around the buggy address: [ 160.356469] >ffff888116163800: fc ..",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.151 未満\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-022020": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: comedi: vmk80xx: fix transfer-buffer overflows The driver uses endpoint-sized USB transfer buffers but up until recently had no sanity checks on the sizes. Commit e1f13c879a7c (\"staging: comedi: check validity of wMaxPacketSize of usb endpoints found\") inadvertently fixed NULL-pointer dereferences when accessing the transfer buffers in case a malicious device has a zero wMaxPacketSize. Make sure to allocate buffers large enough to handle also the other accesses that are done without a size check (e.g. byte 18 in vmk80xx_cnt_insn_read() for the VMK8061_MODEL) to avoid writing beyond the buffers, for example, when doing descriptor fuzzing. The original driver was for a low-speed device with 8-byte buffers. Support was later added for a device that uses bulk transfers and is presumably a full-speed device with a maximum 64-byte wMaxPacketSize.",
        "technologies": "Linux\nLinux Kernel 2.6.31 以上 4.4.292 未満\nLinux Kernel 4.5 以上 4.9.290 未満\nLinux Kernel 4.10 以上 4.14.255 未満\nLinux Kernel 4.15 以上 4.19.217 未満\nLinux Kernel 4.20 以上 5.4.159 未満\nLinux Kernel 5.5 以上 5.10.79 未満\nLinux Kernel 5.11 以上 5.14.18 未満\nLinux Kernel 5.15 以上 5.15.2 未満"
    },
    "JVNDB-2022-001097": {
        "title": "トレンドマイクロ製 Deep Security および Cloud One Workload Security の Linux 版 Agent における複数の脆弱性",
        "description": "A directory traversal vulnerability in Trend Micro Deep Security and Cloud One - Workload Security Agent for Linux version 20 and below could allow an attacker to read arbitrary files from the file system. Please note: an attacker must first obtain compromised access to the target Deep Security Manager (DSM) or the target agent must be not yet activated or configured in order to exploit this vulnerability.",
        "technologies": "トレンドマイクロ\nCloud One Workload Security\nDeep Security Agent Linux 版 バージョン 10.0、11.0、12.0、20.0"
    },
    "JVNDB-2021-021985": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: comedi: vmk80xx: fix bulk-buffer overflow The driver is using endpoint-sized buffers but must not assume that the tx and rx buffers are of equal size or a malicious device could overflow the slab-allocated receive buffer when doing bulk transfers.",
        "technologies": "Linux\nLinux Kernel 2.6.31 以上 4.4.292 未満\nLinux Kernel 4.5 以上 4.9.290 未満\nLinux Kernel 4.10 以上 4.14.255 未満\nLinux Kernel 4.15 以上 4.19.217 未満\nLinux Kernel 4.20 以上 5.4.159 未満\nLinux Kernel 5.5 以上 5.10.79 未満\nLinux Kernel 5.11 以上 5.14.18 未満\nLinux Kernel 5.15 以上 5.15.2 未満"
    },
    "JVNDB-2021-022021": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/tls: Fix flipped sign in tls_err_abort() calls sk->sk_err appears to expect a positive value, a convention that ktls doesn't always follow and that leads to memory corruption in other code. For instance, [kworker] tls_encrypt_done(..., err=<negative error from crypto request>) tls_err_abort(.., err) sk->sk_err = err; [task] splice_from_pipe_feed ... tls_sw_do_sendpage if (sk->sk_err) { ret = -sk->sk_err; // ret is positive splice_from_pipe_feed (continued) ret = actor(...) // ret is still positive and interpreted as bytes // written, resulting in underflow of buf->len and // sd->len, leading to huge buf->offset and bogus // addresses computed in later calls to actor() Fix all tls_err_abort() callers to pass a negative error code consistently and centralize the error-prone sign flip there, throwing in a warning to catch future misuse and uninlining the function so it really does only warn once.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 5.4.157 未満\nLinux Kernel 5.5 以上 5.10.77 未満\nLinux Kernel 5.11 以上 5.14.16 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021981": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: mount fails with buffer overflow in strlen Starting with kernel 5.11 built with CONFIG_FORTIFY_SOURCE mouting an ocfs2 filesystem with either o2cb or pcmk cluster stack fails with the trace below. Problem seems to be that strings for cluster stack and cluster name are not guaranteed to be null terminated in the disk representation, while strlcpy assumes that the source string is always null terminated. This causes a read outside of the source string triggering the buffer overflow detection. detected buffer overflow in strlen ------------[ cut here ]------------ kernel BUG at lib/string.c:1149! invalid opcode: 0000 [#1] SMP PTI CPU: 1 PID: 910 Comm: mount.ocfs2 Not tainted 5.14.0-1-amd64 #1 Debian 5.14.6-2 RIP: 0010:fortify_panic+0xf/0x11 ... Call Trace: ocfs2_initialize_super.isra.0.cold+0xc/0x18 [ocfs2] ocfs2_fill_super+0x359/0x19b0 [ocfs2] mount_bdev+0x185/0x1b0 legacy_get_tree+0x27/0x40 vfs_get_tree+0x25/0xb0 path_mount+0x454/0xa20 __x64_sys_mount+0x103/0x140 do_syscall_64+0x3b/0xc0 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 4.4.290 未満\nLinux Kernel 4.5 以上 4.9.288 未満\nLinux Kernel 4.10 以上 4.14.253 未満\nLinux Kernel 4.15 以上 4.19.214 未満\nLinux Kernel 4.20 以上 5.4.156 未満\nLinux Kernel 5.5 以上 5.10.76 未満\nLinux Kernel 5.11 以上 5.14.15 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021978": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tty: Fix out-of-bound vmalloc access in imageblit This issue happens when a userspace program does an ioctl FBIOPUT_VSCREENINFO passing the fb_var_screeninfo struct containing only the fields xres, yres, and bits_per_pixel with values. If this struct is the same as the previous ioctl, the vc_resize() detects it and doesn't call the resize_screen(), leaving the fb_var_screeninfo incomplete. And this leads to the updatescrollmode() calculates a wrong value to fbcon_display->vrows, which makes the real_y() return a wrong value of y, and that value, eventually, causes the imageblit to access an out-of-bound address value. To solve this issue I made the resize_screen() be called even if the screen does not need any resizing, so it will \"fix and fill\" the fb_var_screeninfo independently.",
        "technologies": "Linux\nLinux Kernel 4.4.286 未満\nLinux Kernel 4.5 以上 4.9.285 未満\nLinux Kernel 4.10 以上 4.14.249 未満\nLinux Kernel 4.15 以上 4.19.209 未満\nLinux Kernel 4.20 以上 5.4.151 未満\nLinux Kernel 5.5 以上 5.10.71 未満\nLinux Kernel 5.11 以上 5.14.10 未満"
    },
    "JVNDB-2021-021974": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvmem: Fix shift-out-of-bound (UBSAN) with byte size cells If a cell has 'nbits' equal to a multiple of BITS_PER_BYTE the logic *p &= GENMASK((cell->nbits%BITS_PER_BYTE) - 1, 0); will become undefined behavior because nbits modulo BITS_PER_BYTE is 0, and we subtract one from that making a large number that is then shifted more than the number of bits that fit into an unsigned long. UBSAN reports this problem: UBSAN: shift-out-of-bounds in drivers/nvmem/core.c:1386:8 shift exponent 64 is too large for 64-bit type 'unsigned long' CPU: 6 PID: 7 Comm: kworker/u16:0 Not tainted 5.15.0-rc3+ #9 Hardware name: Google Lazor (rev3+) with KB Backlight (DT) Workqueue: events_unbound deferred_probe_work_func Call trace: dump_backtrace+0x0/0x170 show_stack+0x24/0x30 dump_stack_lvl+0x64/0x7c dump_stack+0x18/0x38 ubsan_epilogue+0x10/0x54 __ubsan_handle_shift_out_of_bounds+0x180/0x194 __nvmem_cell_read+0x1ec/0x21c nvmem_cell_read+0x58/0x94 nvmem_cell_read_variable_common+0x4c/0xb0 nvmem_cell_read_variable_le_u32+0x40/0x100 a6xx_gpu_init+0x170/0x2f4 adreno_bind+0x174/0x284 component_bind_all+0xf0/0x264 msm_drm_bind+0x1d8/0x7a0 try_to_bring_up_master+0x164/0x1ac __component_add+0xbc/0x13c component_add+0x20/0x2c dp_display_probe+0x340/0x384 platform_probe+0xc0/0x100 really_probe+0x110/0x304 __driver_probe_device+0xb8/0x120 driver_probe_device+0x4c/0xfc __device_attach_driver+0xb0/0x128 bus_for_each_drv+0x90/0xdc __device_attach+0xc8/0x174 device_initial_probe+0x20/0x2c bus_probe_device+0x40/0xa4 deferred_probe_work_func+0x7c/0xb8 process_one_work+0x128/0x21c process_scheduled_works+0x40/0x54 worker_thread+0x1ec/0x2a8 kthread+0x138/0x158 ret_from_fork+0x10/0x20 Fix it by making sure there are any bits to mask out.",
        "technologies": "Linux\nLinux Kernel 4.3 以上 4.4.290 未満\nLinux Kernel 4.5 以上 4.9.288 未満\nLinux Kernel 4.10 以上 4.14.252 未満\nLinux Kernel 4.15 以上 4.19.213 未満\nLinux Kernel 4.20 以上 5.4.155 未満\nLinux Kernel 5.5 以上 5.10.75 未満\nLinux Kernel 5.11 以上 5.14.14 未満\nLinux Kernel 5.15"
    },
    "JVNDB-2021-021982": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ath5k: fix OOB in ath5k_eeprom_read_pcal_info_5111 The bug was found during fuzzing. Stacktrace locates it in ath5k_eeprom_convert_pcal_info_5111. When none of the curve is selected in the loop, idx can go up to AR5K_EEPROM_N_PD_CURVES. The line makes pd out of bound. pd = &chinfo[pier].pd_curves[idx]; There are many OOB writes using pd later in the code. So I added a sanity check for idx. Checks for other loops involving AR5K_EEPROM_N_PD_CURVES are not needed as the loop index is not used outside the loops. The patch is NOT tested with real device. The following is the fuzzing report BUG: KASAN: slab-out-of-bounds in ath5k_eeprom_read_pcal_info_5111+0x126a/0x1390 [ath5k] Write of size 1 at addr ffff8880174a4d60 by task modprobe/214 CPU: 0 PID: 214 Comm: modprobe Not tainted 5.6.0 #1 Call Trace: dump_stack+0x76/0xa0 print_address_description.constprop.0+0x16/0x200 ? ath5k_eeprom_read_pcal_info_5111+0x126a/0x1390 [ath5k] ? ath5k_eeprom_read_pcal_info_5111+0x126a/0x1390 [ath5k] __kasan_report.cold+0x37/0x7c ? ath5k_eeprom_read_pcal_info_5111+0x126a/0x1390 [ath5k] kasan_report+0xe/0x20 ath5k_eeprom_read_pcal_info_5111+0x126a/0x1390 [ath5k] ? apic_timer_interrupt+0xa/0x20 ? ath5k_eeprom_init_11a_pcal_freq+0xbc0/0xbc0 [ath5k] ? ath5k_pci_eeprom_read+0x228/0x3c0 [ath5k] ath5k_eeprom_init+0x2513/0x6290 [ath5k] ? ath5k_eeprom_init_11a_pcal_freq+0xbc0/0xbc0 [ath5k] ? usleep_range+0xb8/0x100 ? apic_timer_interrupt+0xa/0x20 ? ath5k_eeprom_read_pcal_info_2413+0x2f20/0x2f20 [ath5k] ath5k_hw_init+0xb60/0x1970 [ath5k] ath5k_init_ah+0x6fe/0x2530 [ath5k] ? kasprintf+0xa6/0xe0 ? ath5k_stop+0x140/0x140 [ath5k] ? _dev_notice+0xf6/0xf6 ? apic_timer_interrupt+0xa/0x20 ath5k_pci_probe.cold+0x29a/0x3d6 [ath5k] ? ath5k_pci_eeprom_read+0x3c0/0x3c0 [ath5k] ? mutex_lock+0x89/0xd0 ? ath5k_pci_eeprom_read+0x3c0/0x3c0 [ath5k] local_pci_probe+0xd3/0x160 pci_device_probe+0x23f/0x3e0 ? pci_device_remove+0x280/0x280 ? pci_device_remove+0x280/0x280 really_probe+0x209/0x5d0",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-002688": {
        "title": "Linux 上で稼働する Hitachi Infrastructure Analytics Advisor および Hitachi Ops Center Analyzer におけるサーバサイドのリクエストフォージェリの脆弱性",
        "description": "Server-Side Request Forgery (SSRF) vulnerability in Hitachi Infrastructure Analytics Advisor on Linux (Data Center Analytics, Analytics probe components), Hitachi Ops Center Analyzer on Linux (Hitachi Ops Center Analyzer detail view, Hitachi Ops Center Analyzer probe components) allows Server Side Request Forgery. This issue affects Hitachi Infrastructure Analytics Advisor: from 2.0.0-00 through 4.4.0-00; Hitachi Ops Center Analyzer: from 10.0.0-00 before 10.9.0-00.",
        "technologies": "日立\nHitachi Infrastructure Analytics Advisor\nHitachi Ops Center Analyzer\nHitachi Ops Center Viewpoint"
    },
    "JVNDB-2022-001324": {
        "title": "SQL Server for Linux Containers における権限を昇格される脆弱性",
        "description": "SQL Server for Linux Containers Elevation of Privilege Vulnerability",
        "technologies": "マイクロソフト\nMicrosoft SQL Server 2019 for Linux Containers"
    },
    "JVNDB-2022-003150": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2pdu.c has a use-after-free and OOPS for SMB2_TREE_DISCONNECT.",
        "technologies": "Linux\nLinux Kernel 5.15 から 5.19\nLinux Kernel 5.19.2 未満"
    },
    "JVNDB-2022-003151": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.18 before 5.18.18. fs/ksmbd/smb2pdu.c lacks length validation in the non-padding case in smb2_write.",
        "technologies": "Linux\nLinux Kernel 5.15 から 5.18\nLinux Kernel 5.18.18 未満"
    },
    "JVNDB-2022-003776": {
        "title": "Linux 用 NVIDIA GPU Display Driver における整数オーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an integer overflow may lead to information disclosure, data tampering or denial of service.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-002759": {
        "title": "Azure EFLOW および Windows Subsystem for Linux における権限を昇格される脆弱性",
        "description": "Windows Subsystem for Linux (WSL2) Kernel Elevation of Privilege Vulnerability",
        "technologies": "マイクロソフト\nAzure EFLOW\nWindows Subsystem for Linux (WSL2)"
    },
    "JVNDB-2022-003385": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "kernel/bpf/verifier.c in the Linux kernel through 5.15.14 allows local users to gain privileges because of the availability of pointer arithmetic via certain *_OR_NULL pointer types.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.15.14 まで\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-003777": {
        "title": "Linux 用 NVIDIA GPU Display Driver における数値型間の変換の誤りに関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer handler, where an unprivileged regular user can cause an integer to be truncated, which may lead to denial of service or data tampering.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-003153": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.",
        "technologies": "Linux\nLinux Kernel 5.15 から 5.19\nLinux Kernel 5.19.2 未満"
    },
    "JVNDB-2022-003152": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2pdu.c omits a kfree call in certain smb2_handle_negotiate error conditions, aka a memory leak.",
        "technologies": "Linux\nLinux Kernel 5.15 から 5.19\nLinux Kernel 5.19.2 未満"
    },
    "JVNDB-2022-002946": {
        "title": "Alpine Linux 用 zabbix-agent2 パッケージにおける権限管理に関する脆弱性",
        "description": "The zabbix-agent2 package before 5.4.9-r1 for Alpine Linux sometimes allows privilege escalation to root because the design incorrectly expected that systemd would (in effect) determine part of the configuration.",
        "technologies": "Zabbix\nzabbix-agent2 5.4.9-r1 未満"
    },
    "JVNDB-2022-004226": {
        "title": "Jetson Linux における入力確認に関する脆弱性",
        "description": "NVIDIA Trusted OS contains a vulnerability in an SMC call handler, where failure to validate untrusted input may allow a highly privileged local attacker to cause information disclosure and compromise integrity. The scope of the impact can extend to other components.",
        "technologies": "NVIDIA\nJetson Linux"
    },
    "JVNDB-2022-004229": {
        "title": "Linux 用 NVIDIA GPU Display Driver における配列インデックスの検証に関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an out-of-bounds array access may lead to denial of service, information disclosure, or data tampering.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nVirtual GPU"
    },
    "JVNDB-2022-003948": {
        "title": "Linux 用 NVIDIA GPU Display Driver における整数オーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an integer overflow may lead to denial of service, data tampering, or information disclosure.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-002800": {
        "title": "複数の Microsoft Windows 製品における権限を昇格される脆弱性",
        "description": "Windows Subsystem for Linux (WSL2) Kernel Elevation of Privilege Vulnerability",
        "technologies": "マイクロソフト\nWindows Subsystem for Linux (WSL2)\nMicrosoft Windows 10 Version 1809 for 32-bit Systems\nMicrosoft Windows 10 Version 1809 for ARM64-based Systems\nMicrosoft Windows 10 Version 1809 for x64-based Systems\nMicrosoft Windows 10 Version 20H2 for 32-bit Systems\nMicrosoft Windows 10 Version 20H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 20H2 for x64-based Systems\nMicrosoft Windows 10 Version 21H1 for 32-bit Systems\nMicrosoft Windows 10 Version 21H1 for ARM64-based Systems\nMicrosoft Windows 10 Version 21H1 for x64-based Systems\nMicrosoft Windows 10 Version 21H2 for 32-bit Systems\nMicrosoft Windows 10 Version 21H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 21H2 for x64-based Systems\nMicrosoft Windows 10 Version 22H2 for 32-bit Systems\nMicrosoft Windows 10 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 for ARM64-based Systems\nMicrosoft Windows 11 for x64-based Systems\nMicrosoft Windows Server 2019\nMicrosoft Windows Server 2019 (Server Core installation)\nMicrosoft Windows Server 2022\nMicrosoft Windows Server 2022 (Server Core installation)\nMicrosoft Windows Server 2022 Datacenter: Azure Edition"
    },
    "JVNDB-2022-004014": {
        "title": "Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is an out-of-bounds read and OOPS for SMB2_WRITE, when there is a large length in the zero DataOffset case.",
        "technologies": "Linux\nLinux Kernel 5.15 から 5.19.2 未満の 5.19"
    },
    "JVNDB-2022-004235": {
        "title": "Linux 用 NVIDIA GPU Display Driver における境界外読み取りに関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer handler, where an out-of-bounds read may lead to denial of service, information disclosure, or data tampering.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nVirtual GPU"
    },
    "JVNDB-2022-004228": {
        "title": "Linux 用 NVIDIA GPU Display Driver における整数オーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an integer overflow in index validation may lead to denial of service, information disclosure, or data tampering.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nVirtual GPU"
    },
    "JVNDB-2022-004408": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A stack overflow flaw was found in the Linux kernel's SYSCTL subsystem in how a user changes certain kernel parameters and variables. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-004224": {
        "title": "Jetson Linux における境界外書き込みに関する脆弱性",
        "description": "NVIDIA distributions of Linux contain a vulnerability in nvdla_emu_task_submit, where unvalidated input may allow a local attacker to cause stack-based buffer overflow in kernel code, which may lead to escalation of privileges, compromised integrity and confidentiality, and denial of service.",
        "technologies": "NVIDIA\nJetson Linux"
    },
    "JVNDB-2022-004523": {
        "title": "Linux 用 NVIDIA GPU Display Driver における配列インデックスの検証に関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an out-of-bounds array access may lead to denial of service, data tampering, or information disclosure.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-004524": {
        "title": "Linux 用 NVIDIA GPU Display Driver における境界条件の判定に関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an off-by-one error may lead to data tampering or information disclosure.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-004236": {
        "title": "Linux 用 NVIDIA GPU Display Driver における境界外読み取りに関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an out-of-bounds array access may lead to denial of service, information disclosure, or data tampering.",
        "technologies": "NVIDIA\nNVIDIA GPU ディスプレイドライバ"
    },
    "JVNDB-2022-004527": {
        "title": "Linux 用 NVIDIA GPU Display Driver における数値型間の変換の誤りに関する脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer handler, where an unprivileged regular user can cause truncation errors when casting a primitive to a primitive of smaller size causes data to be lost in the conversion, which may lead to denial of service or information disclosure.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-005175": {
        "title": "Linux Kernel におけるリソースの安全ではないデフォルト値への初期化に関する脆弱性",
        "description": "A regression exists in the Linux Kernel within KVM: nVMX that allowed for speculative execution attacks. L2 can carry out Spectre v2 attacks on L1 due to L1 thinking it doesn't need retpolines or IBPB after running L2 due to KVM (L0) advertising eIBRS support to L1. An attacker at L2 with code execution can execute code on an indirect branch on the host machine. We recommend upgrading to Kernel 6.2 or past commit 2e7eab81425a",
        "technologies": "Linux\nLinux Kernel 6.2 未満"
    },
    "JVNDB-2022-004624": {
        "title": "Linux 用 NVIDIA GPU Display Driver におけるバッファエラーの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer, where an unprivileged regular user can cause the use of an out-of-range pointer offset, which may lead to data tampering, data loss, information disclosure, or denial of service.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-004964": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability was found in __nfs42_ssc_open() in fs/nfs/nfs4file.c in the Linux kernel. This flaw allows an attacker to conduct a remote denial",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel"
    },
    "JVNDB-2022-005120": {
        "title": "Linux 用 Citrix Workspace における脆弱性",
        "description": "An Improper Access Control vulnerability exists in Citrix Workspace App for Linux 2012 - 2111 with App Protection installed that can allow an attacker to perform local privilege escalation.",
        "technologies": "シトリックス・システムズ\nCitrix Workspace"
    },
    "JVNDB-2022-004835": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "kernel/ucount.c in the Linux kernel 5.14 through 5.16.4, when unprivileged user namespaces are enabled, allows a use-after-free and privilege escalation because a ucounts object can outlive its namespace.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel 5.14 から 5.16.4\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア"
    },
    "JVNDB-2022-004625": {
        "title": "Linux 用 NVIDIA GPU Display Driver における整数オーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer handler, where an Integer overflow may lead to denial of service or information disclosure.",
        "technologies": "NVIDIA\nNVIDIA Cloud Gaming\nNVIDIA GPU ディスプレイドライバ\nVirtual GPU"
    },
    "JVNDB-2022-004917": {
        "title": "Linux 用 NVIDIA GPU Display Driver における整数オーバーフローの脆弱性",
        "description": "NVIDIA GPU Display Driver for Linux contains a vulnerability in the kernel mode layer (nvidia.ko), where an integer overflow may lead to information disclosure or data tampering.",
        "technologies": "NVIDIA\nNVIDIA GPU ディスプレイドライバ"
    },
    "JVNDB-2022-005305": {
        "title": "Linux Kernel における無効なポインタや参照の解放に関する脆弱性",
        "description": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.16.8 まで\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-005415": {
        "title": "Windows、Linux、UNIX 用 XCOM Data Transport における権限管理に関する脆弱性",
        "description": "XCOM Data Transport for Windows, Linux, and UNIX 11.6 releases contain a vulnerability due to insufficient input validation that could potentially allow remote attackers to execute arbitrary commands with elevated privileges.",
        "technologies": "Broadcom\nXCOM Data Transport 11.6"
    },
    "JVNDB-2022-005516": {
        "title": "Linux Kernel における整数アンダーフローの脆弱性",
        "description": "A heap-based buffer overflow flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-005428": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "There exists a use-after-free vulnerability in the Linux kernel through io_uring and the IORING_OP_SPLICE operation. If IORING_OP_SPLICE is missing the IO_WQ_WORK_FILES flag, which signals that the operation won't use current->nsproxy, so its reference counter is not increased. This assumption is not always true as calling io_splice on specific files will call the get_uts function which will use current->nsproxy leading to invalidly decreasing its reference counter later causing the use-after-free vulnerability. We recommend upgrading to version 5.10.160 or above",
        "technologies": "Linux\nLinux Kernel 5.10.160 未満"
    },
    "JVNDB-2022-005496": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-005752": {
        "title": "Linux Kernel におけるパーミッションの不適切な保持に関する脆弱性",
        "description": "A random memory access flaw was found in the Linux kernel's GPU i915 kernel driver functionality in the way a user may run malicious code on the GPU. This flaw allows a local user to crash the system or escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\ncodeready linux builder\nRed Hat 3scale API Management Platform\nRed Hat Developer Tools\nRed Hat Virtualization\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-005900": {
        "title": "Linux Kernel における動的に操作されるコードリソースの不適切な制御に関する脆弱性",
        "description": "In the Linux kernel through 5.16.10, certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g., with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.",
        "technologies": "Linux\nLinux Kernel 5.16.10 まで\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア"
    },
    "JVNDB-2022-005960": {
        "title": "Linux および UNIX 上で稼働する Qt における脆弱性",
        "description": "In Qt 5.9.x through 5.15.x before 5.15.9 and 6.x before 6.2.4 on Linux and UNIX, QProcess could execute a binary from the current working directory when not found in the PATH.",
        "technologies": "The Qt Company\nQt 5.15.9 未満の 5.9.x から 5.15.x\nQt 6.2.4 未満の 6.x"
    },
    "JVNDB-2022-006387": {
        "title": "Linux Foundation の containerd 他複数ベンダの製品における脆弱性",
        "description": "containerd is a container runtime available as a daemon for Linux and Windows. A bug was found in containerd prior to versions 1.6.1, 1.5.10, and 1.14.12 where containers launched through containerd’s CRI implementation on Linux with a specially-crafted image configuration could gain access to read-only copies of arbitrary files and directories on the host. This may bypass any policy-based enforcement on container setup (including a Kubernetes Pod Security Policy) and expose potentially sensitive information. Kubernetes and crictl can both be configured to use containerd’s CRI implementation. This bug has been fixed in containerd 1.6.1, 1.5.10, and 1.4.12. Users should update to these versions to resolve the issue.",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nFedora Project\nFedora 34\nFedora 35\nFedora 36\nLinux Foundation\ncontainerd 1.4.13 未満\ncontainerd 1.5.0 以上 1.5.10 未満\ncontainerd 1.6.0 以上 1.6.1 未満"
    },
    "JVNDB-2022-006065": {
        "title": "Linux Kernel における権限管理に関する脆弱性",
        "description": "net/netfilter/nf_dup_netdev.c in the Linux kernel 5.4 through 5.6.10 allows local users to gain privileges because of a heap out-of-bounds write. This is related to nf_tables_offload.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.4 から 5.6.10\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nオラクル\nOracle Communications Cloud Native Core Binding Support Function"
    },
    "JVNDB-2022-005813": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw use after free in the Linux kernel Management Component Transport Protocol (MCTP) subsystem was found in the way user triggers cancel_work_sync after the unregister_netdev during removing device. A local user could use this flaw to crash the system or escalate their privileges on the system. It is actual from Linux Kernel 5.17-rc1 (when mctp-serial.c introduced) till 5.17-rc5.",
        "technologies": "Linux\nLinux Kernel 5.17-rc1 から 5.17-rc5\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410C ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア"
    },
    "JVNDB-2022-007328": {
        "title": "Linux Foundation の argocd における認証の欠如に関する脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All unpatched versions of Argo CD starting with 1.0.0 are vulnerable to an improper access control bug, allowing a malicious user to potentially escalate their privileges to admin-level. Versions starting with 0.8.0 and 0.5.0 contain limited versions of this issue. To perform exploits, an authorized Argo CD user must have push access to an Application's source git or Helm repository or `sync` and `override` access to an Application. Once a user has that access, different exploitation levels are possible depending on their other RBAC privileges. A patch for this vulnerability has been released in Argo CD versions 2.3.2, 2.2.8, and 2.1.14. Some mitigation measures are available but do not serve as a substitute for upgrading. To avoid privilege escalation, limit who has push access to Application source repositories or `sync` + `override` access to Applications; and limit which repositories are available in projects where users have `update` access to Applications. To avoid unauthorized resource inspection/tampering, limit who has `delete`, `get`, or `action` access to Applications.",
        "technologies": "Linux Foundation\nargocd 0.5.0 以上 2.1.14 未満\nargocd 2.2.0 以上 2.2.8 未満\nargocd 2.3.0 以上 2.3.2 未満"
    },
    "JVNDB-2022-010769": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A stack overflow flaw was found in the Linux kernel's TIPC protocol functionality in the way a user sends a packet with malicious content where the number of domain member nodes is higher than the 64 allowed. This flaw allows a remote user to crash the system or possibly escalate their privileges if they have access to the TIPC network.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH410S ファームウェア\nH500E ファームウェア\noVirt\nNode\nレッドハット\ncodeready linux builder\ncodeready linux builder for power little endian eus\nRed Hat Virtualization\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-010277": {
        "title": "Linux Kernel における競合状態に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s sound subsystem in the way a user triggers concurrent calls of PCM hw_params. The hw_free ioctls or similar race condition happens inside ALSA PCM for other ioctls. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nHCI Baseboard Management Controller (BMC) H300E ファームウェア\nHCI Baseboard Management Controller (BMC) H300S ファームウェア\nHCI Baseboard Management Controller (BMC) H410S ファームウェア\nHCI Baseboard Management Controller (BMC) H500E ファームウェア\nHCI Baseboard Management Controller (BMC) H500S ファームウェア\nHCI Baseboard Management Controller (BMC) H700E ファームウェア\nHCI Baseboard Management Controller (BMC) H700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-005577": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel MCTP (Management Component Transport Protocol) functionality. This issue occurs when a user simultaneously calls DROPTAG ioctl and socket close happens, which could allow a local user to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-006394": {
        "title": "NVIDIA の Jetson Linux における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "NVIDIA distributions of Jetson Linux contain a vulnerability where an error in the IOMMU configuration may allow an unprivileged attacker with physical access to the board direct read/write access to the entire system address space through the PCI bus. Such an attack could result in denial of service, code execution, escalation of privileges, and impact to data integrity and confidentiality. The scope impact may extend to other components.",
        "technologies": "NVIDIA\nJetson Linux 32.1 以上 32.7.1 未満"
    },
    "JVNDB-2022-010595": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s Atheros wireless adapter driver in the way a user forces the ath9k_htc_wait_for_target function to fail with some input messages. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-010424": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "An integer overflow flaw was found in the Linux kernel’s virtio device driver code in the way a user triggers the vhost_vdpa_config_validate function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-010423": {
        "title": "Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A flaw was found in unrestricted eBPF usage by the BPF_BTF_LOAD, leading to a possible out-of-bounds memory write in the Linux kernel’s BPF subsystem due to the way a user loads BTF. This flaw allows a local user to crash or escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-010788": {
        "title": "Linux Kernel における脆弱性",
        "description": "Improper Update of Reference Count vulnerability in net/sched of Linux Kernel allows local attacker to cause privilege escalation to root. This issue affects: Linux Kernel versions prior to 5.18; version 4.14 and later versions.",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-007452": {
        "title": "Linux Foundation の gRPC Swift における到達可能なアサーションに関する脆弱性",
        "description": "grpc-swift is the Swift language implementation of gRPC, a remote procedure call (RPC) framework. Prior to version 1.7.2, a grpc-swift server is vulnerable to a denial of service attack via a reachable assertion. This is due to incorrect logic when handling GOAWAY frames. The attack is low-effort: it takes very little resources to construct and send the required sequence of frames. The impact on availability is high as the server will crash, dropping all in flight connections and requests. This issue is fixed in version 1.7.2. There are currently no known workarounds.",
        "technologies": "Linux Foundation\ngRPC Swift 1.7.2 未満"
    },
    "JVNDB-2022-007117": {
        "title": "Linux Kernel における初期化に関する脆弱性",
        "description": "A flaw was found in the way the \"flags\" member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\noVirt\noVirt-engine\nSonicWALL\nSMA1000 ファームウェア\nシーメンス\nSCALANCE LPE9403 ファームウェア\nレッドハット\nRed Hat Enterprise Linux\nRed Hat Enterprise Linux EUS\nRed Hat Enterprise Linux for IBM z Systems\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support"
    },
    "JVNDB-2022-010425": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free exists in the Linux Kernel in tc_new_tfilter that could allow a local attacker to gain privilege escalation. The exploit requires unprivileged user namespaces. We recommend upgrading past commit 04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5",
        "technologies": "Canonical\nUbuntu\nFedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-006784": {
        "title": "複数の Linux 用 ESET 製品における解放済みメモリの使用に関する脆弱性",
        "description": "Use-after-free in eset_rtp kernel module used in ESET products for Linux allows potential attacker to trigger denial-of-service condition on the system.",
        "technologies": "ESET\nESET Endpoint Antivirus\nESET Server Security"
    },
    "JVNDB-2022-010812": {
        "title": "Linux Kernel における整数オーバーフローの脆弱性",
        "description": "Integer Overflow or Wraparound vulnerability in io_uring of Linux Kernel allows local attacker to cause memory corruption and escalate privileges to root. This issue affects: Linux Kernel versions prior to 5.4.189; version 5.4.24 and later versions.",
        "technologies": "Linux\nLinux Kernel 5.4.24 以上 5.4.189 未満\nNetApp\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-011227": {
        "title": "Linux Kernel における認証の欠如に関する脆弱性",
        "description": "The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP flag.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.17.2 未満\nNetApp\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire Enterprise SDS & HCI Storage Node\n8300 ファームウェア\n8700 ファームウェア\nA400 ファームウェア\nH300S ファームウェア\nH500S ファームウェア\nhci compute node"
    },
    "JVNDB-2022-011222": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s pipes functionality in how a user performs manipulations with the pipe post_one_notification() after free_pipe_info() that is already called. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-011211": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "The root cause of this vulnerability is that the ioctl$DRM_IOCTL_MODE_DESTROY_DUMB can decrease refcount of *drm_vgem_gem_object *(created in *vgem_gem_dumb_create*) concurrently, and *vgem_gem_dumb_create *will access the freed drm_vgem_gem_object.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel"
    },
    "JVNDB-2022-011237": {
        "title": "Linux Kernel における脆弱性",
        "description": "An issue was discovered in the Linux Kernel from 4.18 to 4.19, an improper update of sock reference in TCP pacing can lead to memory/netns leak, which can be used by remote clients.",
        "technologies": "Linux\nLinux Kernel 4.18 から 4.19\nNetApp\nActive IQ Unified Manager\nCloud Volumes ONTAP メディエータ\nE-Series SANtricity OS Controller Software\nElement Software\nNetApp HCI Management Node\nNetApp SolidFire\nStorageGRID\nBootstrap OS\nH300S ファームウェア"
    },
    "JVNDB-2022-011264": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "net/netfilter/nf_tables_api.c in the Linux kernel through 5.18.1 allows a local user (able to create user/net namespaces) to escalate privileges to root because an incorrect NFT_STATEFUL_EXPR check leads to a use-after-free.",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel 5.18.1 まで\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-011201": {
        "title": "Linux 用 FortiClient における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "An incorrect permission assignment for critical resource vulnerability [CWE-732] in FortiClient for Linux version 6.0.8 and below, 6.2.9 and below, 6.4.7 and below, 7.0.2 and below may allow an unauthenticated attacker to access sensitive information in log files and directories via symbolic links.",
        "technologies": "フォーティネット\nFortiClient 6.0.8 およびそれ以前\nFortiClient 6.2.9 およびそれ以前\nFortiClient 6.4.7 およびそれ以前\nFortiClient 7.0.2 およびそれ以前"
    },
    "JVNDB-2022-011256": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "Linux Kernel could allow a local attacker to execute arbitrary code on the system, caused by a concurrency use-after-free flaw in the bad_flp_intr function. By executing a specially-crafted program, an attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service condition on the system.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-011258": {
        "title": "Linux Kernel UDF ファイルシステム機能における境界外書き込みに関する脆弱性",
        "description": "A flaw out of bounds memory write in the Linux kernel UDF file system functionality was found in the way user triggers some file operation which triggers udf_write_fi(). A local user could use this flaw to crash the system or potentially",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-011268": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s io_uring subsystem in the way a user sets up a ring with IORING_SETUP_IOPOLL with more than one task completing submissions on this ring. This flaw allows a local user to crash or escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-011641": {
        "title": "Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "An issue was discovered in the Linux kernel through 5.18.3 on powerpc 32-bit platforms. There is a buffer overflow in ptrace PEEKUSER and POKEUSER (aka PEEKUSR and POKEUSR) when accessing floating point registers.",
        "technologies": "Linux\nLinux Kernel 5.18.3 まで"
    },
    "JVNDB-2022-011007": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-012506": {
        "title": "Linux Foundation の argocd におけるエントロピー不足に関する脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All versions of Argo CD starting with v0.11.0 are vulnerable to a variety of attacks when an SSO login is initiated from the Argo CD CLI or UI. The vulnerabilities are due to the use of insufficiently random values in parameters in Oauth2/OIDC login flows. In each case, using a relatively-predictable (time-based) seed in a non-cryptographically-secure pseudo-random number generator made the parameter less random than required by the relevant spec or by general best practices. In some cases, using too short a value made the entropy even less sufficient. The attacks on login flows which are meant to be mitigated by these parameters are difficult to accomplish but can have a high impact potentially granting an attacker admin access to Argo CD. Patches for this vulnerability has been released in the following Argo CD versions: v2.4.1, v2.3.5, v2.2.10 and v2.1.16. There are no known workarounds for this vulnerability.",
        "technologies": "Linux Foundation\nargocd 0.11.0 以上 2.1.16 未満\nargocd 2.2.9\nargocd 2.3.4\nargocd 2.4.0"
    },
    "JVNDB-2022-011271": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use after free in the Linux kernel File System notify functionality was found in the way user triggers copy_info_records_to_user() call to fail in copy_event_to_user(). A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux"
    },
    "JVNDB-2022-014681": {
        "title": "Linux、UNIX、Windows 用 IBM Db2 における権限管理に関する脆弱性",
        "description": "IBM Db2 for Linux, UNIX and Windows 9.7, 10.1, 10.5, 11.1, and 11.5 may be vulnerable to an information disclosure caused by improper privilege management when table function is used. IBM X-Force ID: 221973.",
        "technologies": "IBM\nIBM DB2 9.7\nIBM DB2 10.1\nIBM DB2 10.5\nIBM DB2 11.1\nIBM DB2 11.5"
    },
    "JVNDB-2022-013722": {
        "title": "Linux Foundation の Ceph 他複数ベンダの製品における脆弱性",
        "description": "A flaw was found in Openstack manilla owning a Ceph File system \"share\", which enables the owner to read/write any manilla share or entire file system. The vulnerability is due to a bug in the \"volumes\" plugin in Ceph Manager. This allows an attacker to compromise Confidentiality and Integrity of a file system. Fixed in RHCS 5.2 and Ceph 17.2.2.",
        "technologies": "Fedora Project\nFedora 35\nFedora 36\nLinux Foundation\nCeph 15.0.0 以上 15.2.17 未満\nCeph 16.0.0 以上 16.2.10 未満\nCeph 17.0.0 以上 17.2.2 未満\nレッドハット\nRed Hat Ceph Storage 5.2 未満"
    },
    "JVNDB-2022-014750": {
        "title": "Linux Foundation の Node.js 用 loopback-connector-postgresql における SQL インジェクションの脆弱性",
        "description": "Improper input validation on the `contains` LoopBack filter may allow for arbitrary SQL injection. When the extended filter property `contains` is permitted to be interpreted by the Postgres connector, it is possible to inject arbitrary SQL which may affect the confidentiality and integrity of data stored on the connected database. A patch was released in version 5.5.1. This affects users who does any of the following: - Connect to the database via the DataSource with `allowExtendedProperties: true` setting OR - Uses the connector's CRUD methods directly OR - Uses the connector's other methods to interpret the LoopBack filter. Users who are unable to upgrade should do the following if applicable: - Remove `allowExtendedProperties: true` DataSource setting - Add `allowExtendedProperties: false` DataSource setting - When passing directly to the connector functions, manually sanitize the user input for the `contains` LoopBack filter beforehand.",
        "technologies": "Linux Foundation\nloopback-connector-postgresql 5.5.1 未満"
    },
    "JVNDB-2022-013674": {
        "title": "デルの Linux 用 powerstore command line interface における制御されていない検索パスの要素に関する脆弱性",
        "description": "Dell EMC PowerStore, Versions prior to v3.0.0.0 contain a DLL Hijacking vulnerability in PSTCLI. A local attacker can potentially exploit this vulnerability to execute arbitrary code, escalate privileges, and bypass software allow list solutions, leading to system takeover or IP exposure.",
        "technologies": "デル\npowerstore command line interface 3.0.0.0-1732745 未満"
    },
    "JVNDB-2022-013890": {
        "title": "libtirpc project の LIBTIRPC 他複数ベンダの製品における例外的な状態の処理に関する脆弱性",
        "description": "In libtirpc before 1.3.3rc1, remote attackers could exhaust the file descriptors of a process that uses libtirpc because idle TCP connections are mishandled. This can, in turn, lead to an svc_run infinite loop without accepting new connections.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nlibtirpc project\nLIBTIRPC 1.3.3 未満"
    },
    "JVNDB-2022-014708": {
        "title": "Linux Kernel における脆弱性",
        "description": "network backend may cause Linux netfront to use freed SKBs While adding logic to support XDP (eXpress Data Path), a code label was moved in a way allowing for SKBs having references (pointers) retained for further processing to nevertheless be freed.",
        "technologies": "Debian\nDebian GNU/Linux\nLinux\nLinux Kernel\nXen プロジェクト\nXen"
    },
    "JVNDB-2022-013302": {
        "title": "Linux Foundation の argocd における脆弱性",
        "description": "All unpatched versions of Argo CD starting with v1.0.0 are vulnerable to an improper access control bug, allowing a malicious user to potentially escalate their privileges to admin-level.",
        "technologies": "Linux Foundation\nargocd 0.5.0 から 2.1.12\nargocd 2.2.0 から 2.2.7\nargocd 2.3.0 から 2.3.1"
    },
    "JVNDB-2022-013510": {
        "title": "Linux Foundation の rocket chip generator における暗号アルゴリズムの使用に関する脆弱性",
        "description": "Rocket-Chip commit 4f8114374d8824dfdec03f576a8cd68bebce4e56 was discovered to contain insufficient cryptography via the component /rocket/RocketCore.scala.",
        "technologies": "Linux Foundation\nrocket chip generator"
    },
    "JVNDB-2022-013156": {
        "title": "Linux Foundation の kubeedge におけるリソースの枯渇に関する脆弱性",
        "description": "KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge. Prior to versions 1.11.1, 1.10.2, and 1.9.4, the ServiceBus server on the edge side may be susceptible to a DoS attack if an HTTP request containing a very large Body is sent to it. It is possible for the node to be exhausted of memory. The consequence of the exhaustion is that other services on the node, e.g. other containers, will be unable to allocate memory and thus causing a denial of service. Malicious apps accidentally pulled by users on the host and have the access to send HTTP requests to localhost may make an attack. It will be affected only when users enable the `ServiceBus` module in the config file `edgecore.yaml`. This bug has been fixed in Kubeedge 1.11.1, 1.10.2, and 1.9.4. As a workaround, disable the `ServiceBus` module in the config file `edgecore.yaml`.",
        "technologies": "Linux Foundation\nkubeedge 1.9.4 未満\nkubeedge 1.10.0 以上 1.10.2 未満\nkubeedge 1.11.0 以上 1.11.1 未満"
    },
    "JVNDB-2022-012427": {
        "title": "レッドハットの Red Hat Enterprise Linux における脆弱性",
        "description": "A set of pre-production kernel packages of Red Hat Enterprise Linux for IBM Power architecture can be booted by the grub in Secure Boot mode even though it shouldn't. These kernel builds don't have the secure boot lockdown patches applied to it and can bypass the secure boot validations, allowing the attacker to load another non-trusted code.",
        "technologies": "レッドハット\nRed Hat Enterprise Linux 8.0"
    },
    "JVNDB-2022-013256": {
        "title": "Linux Foundation の argocd における証明書検証に関する脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. Argo CD starting with version 0.4.0 and prior to 2.2.11, 2.3.6, and 2.4.5 is vulnerable to an improper certificate validation bug which could cause Argo CD to trust a malicious (or otherwise untrustworthy) OpenID Connect (OIDC) provider. A patch for this vulnerability has been released in Argo CD versions 2.4.5, 2.3.6, and 2.2.11. There are no complete workarounds, but a partial workaround is available. Those who use an external OIDC provider (not the bundled Dex instance), can mitigate the issue by setting the `oidc.config.rootCA` field in the `argocd-cm` ConfigMap. This mitigation only forces certificate validation when the API server handles login flows. It does not force certificate verification when verifying tokens on API calls.",
        "technologies": "Linux Foundation\nargocd 0.4.0 以上 2.2.11 未満\nargocd 2.3.0 以上 2.3.6 未満\nargocd 2.4.0 以上 2.4.5 未満"
    },
    "JVNDB-2022-012135": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "An incorrect TLB flush issue was found in the Linux kernel’s GPU i915 kernel driver, potentially leading to random memory corruption or data leaks. This flaw could allow a local user to crash the system or escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-015429": {
        "title": "Linux Kernel における情報漏えいに関する脆弱性",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nXen プロジェクト\nXen"
    },
    "JVNDB-2022-015156": {
        "title": "qualys の cloud agent for linux におけるデータの整合性検証不備に関する脆弱性",
        "description": "An issue was discovered in Qualys Cloud Agent 4.8.0-49. It executes programs at various full pathnames without first making ownership and permission checks (e.g., to help ensure that a program was installed by root) and without integrity checks (e.g., a checksum comparison against known legitimate programs). Also, the vendor recommendation is to install this agent software with root privileges. Thus, privilege escalation is possible on systems where any of these pathnames is controlled by a non-root user. An example is /opt/firebird/bin/isql, where the /opt/firebird directory is often owned by the firebird user.",
        "technologies": "qualys\ncloud agent for linux 2.5.548.2 未満"
    },
    "JVNDB-2022-015432": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nXen プロジェクト\nXen"
    },
    "JVNDB-2022-015431": {
        "title": "Linux Kernel における保存または転送前の重要な情報の削除に関する脆弱性",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nXen プロジェクト\nXen"
    },
    "JVNDB-2022-015430": {
        "title": "Linux Kernel における情報漏えいに関する脆弱性",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "technologies": "Debian\nDebian GNU/Linux\nFedora Project\nFedora\nLinux\nLinux Kernel\nXen プロジェクト\nXen"
    },
    "JVNDB-2022-015846": {
        "title": "Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A NULL pointer dereference flaw was found in rxrpc_preparse_s in net/rxrpc/server_key.c in the Linux kernel. This flaw allows a local attacker to crash the system or leak internal kernel information.",
        "technologies": "Linux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-016768": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in KVM. When updating a guest's page table entry, vm_pgoff was improperly used as the offset to get the page's pfn. As vaddr and vm_pgoff are controllable by user-mode processes, this flaw allows unprivileged local users on the host to write outside the userspace region and potentially corrupt the kernel, resulting in a denial of service condition.",
        "technologies": "Fedora Project\nFedora 36\nLinux\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満\nLinux Kernel 5.2 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-015850": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "A memory leak flaw was found in the Linux kernel in acrn_dev_ioctl in the drivers/virt/acrn/hsm.c function in how the ACRN Device Model emulates virtual NICs in VM. This flaw allows a local privileged attacker to leak unauthorized kernel information, causing a denial of service.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-016160": {
        "title": "レッドハットの Red Hat Enterprise Linux Server 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "The version of podman as released for Red Hat Enterprise Linux 7 Extras via RHSA-2022:2190 advisory included an incorrect version of podman missing the fix for CVE-2020-8945, which was previously fixed via RHSA-2020:2117. This issue could possibly be used to crash or cause potential code execution in Go applications that use the Go GPGME wrapper library, under certain conditions, during GPG signature verification.",
        "technologies": "Podman project\npodman 1.6.4-32.el7 9\nレッドハット\nRed Hat Enterprise Linux Server 7.0\nRed Hat Enterprise Linux Workstation 7.0"
    },
    "JVNDB-2022-015887": {
        "title": "Linux Kernel における二重解放に関する脆弱性",
        "description": "io_uring use work_flags to determine which identity need to grab from the calling process to make sure it is consistent with the calling process when executing IORING_OP. Some operations are missing some types, which can lead to incorrect reference counts which can then lead to a double free. We recommend upgrading the kernel past commit df3f3bb5059d20ef094d6b2f0256c4bf4127a859",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-016730": {
        "title": "Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "A memory leak problem was found in the TCP source port generation algorithm in net/ipv4/tcp.c due to the small table perturb size. This flaw may allow an attacker to information leak and may cause a denial of service problem.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-016650": {
        "title": "Linux Foundation の Indy Node における入力確認に関する脆弱性",
        "description": "Indy Node is the server portion of a distributed ledger purpose-built for decentralized identity. In versions 1.12.4 and prior, the `pool-upgrade` request handler in Indy-Node allows an improperly authenticated attacker to remotely execute code on nodes within the network. The `pool-upgrade` request handler in Indy-Node 1.12.5 has been updated to properly authenticate pool-upgrade transactions before any processing is performed by the request handler. The transactions are further sanitized to prevent remote code execution. As a workaround, endorsers should not create DIDs for untrusted users. A vulnerable ledger should configure `auth_rules` to prevent new DIDs from being written to the ledger until the network can be upgraded.",
        "technologies": "Linux Foundation\nIndy Node 1.12.4 およびそれ以前"
    },
    "JVNDB-2022-016766": {
        "title": "Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel in log_replay in fs/ntfs3/fslog.c in the NTFS journal. This flaw allows a local attacker to crash the system and leads to a kernel information leak problem.",
        "technologies": "Fedora Project\nFedora\nLinux\nLinux Kernel\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-016475": {
        "title": "エフ・セキュアの F-Secure Atlant および F-Secure Linux Seculity における脆弱性",
        "description": "A Denial-of-Service (DoS) vulnerability was discovered in the fsicapd component used in WithSecure products whereby the service may crash while parsing the scanning request.",
        "technologies": "エフ・セキュア\nF-Secure Atlant\nF-Secure Linux Seculity"
    },
    "JVNDB-2022-016247": {
        "title": "Linux Kernel における脆弱性",
        "description": "The Linux kernel before 5.18.13 lacks a certain clear operation for the block starting symbol (.bss). This allows Xen PV guest OS users to cause a denial of service or gain privileges.",
        "technologies": "Linux\nLinux Kernel 5.18.13 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-016904": {
        "title": "Buildah project の Buildah 他複数ベンダの製品における誤ったグループへのユーザの配置に関する脆弱性",
        "description": "An incorrect handling of the supplementary groups in the Buildah container engine might lead to the sensitive information disclosure or possible data modification if an attacker has direct access to the affected container where supplementary groups are used to set access permissions and is able to execute a binary code in that container.",
        "technologies": "Buildah project\nBuildah 1.27.1 未満\nレッドハット\nRed Hat OpenShift Container Platform 4.0\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-017035": {
        "title": "syncovery における不十分なランダム値の使用に関する脆弱性",
        "description": "An issue in the component post_applogin.php of Super Flexible Software GmbH & Co. KG Syncovery 9 for Linux v9.47x and below allows attackers to escalate privileges via creating crafted session tokens.",
        "technologies": "syncovery\nsyncovery 8.00 以上 9.48j 未満"
    },
    "JVNDB-2022-016905": {
        "title": "Podman project の podman 他複数ベンダの製品における誤ったグループへのユーザの配置に関する脆弱性",
        "description": "An incorrect handling of the supplementary groups in the Podman container engine might lead to the sensitive information disclosure or possible data modification if an attacker has direct access to the affected container where supplementary groups are used to set access permissions and is able to execute a binary code in that container.",
        "technologies": "Podman project\npodman\nレッドハット\nRed Hat OpenShift Container Platform 3.11\nRed Hat OpenShift Container Platform 4.0\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-017036": {
        "title": "syncovery における脆弱性",
        "description": "Super Flexible Software GmbH & Co. KG Syncovery 9 for Linux v9.47x and below was discovered to contain multiple remote code execution (RCE) vulnerabilities via the Job_ExecuteBefore and Job_ExecuteAfter parameters at post_profilesettings.php.",
        "technologies": "syncovery\nsyncovery 8.00 以上 9.48j 未満"
    },
    "JVNDB-2022-017493": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Linux kernel’s io_uring implementation. This flaw allows an attacker with a local account to corrupt system memory, crash the system or escalate privileges.",
        "technologies": "Linux\nLinux Kernel 5.10.51 以上 5.10.61 未満\nLinux Kernel 5.11 以上 5.13.13 未満"
    },
    "JVNDB-2022-017453": {
        "title": "Kubernetes の CRI-O における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "Incorrect handling of the supplementary groups in the CRI-O container engine might lead to sensitive information disclosure or possible data modification if an attacker has direct access to the affected container where supplementary groups are used to set access permissions and is able to execute a binary code in that container.",
        "technologies": "Kubernetes\nCRI-O 1.25.0"
    },
    "JVNDB-2022-017284": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 5.8.0 未満\nLinux Kernel 5.8.0\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-016902": {
        "title": "Linux Foundation の Indy Node におけるリソースの枯渇に関する脆弱性",
        "description": "indy-node is the server portion of Hyperledger Indy, a distributed ledger purpose-built for decentralized identity. In vulnerable versions of indy-node, an attacker can max out the number of client connections allowed by the ledger, leaving the ledger unable to be used for its intended purpose. However, the ledger content will not be impacted and the ledger will resume functioning after the attack. This attack exploits the trade-off between resilience and availability. Any protection against abusive client connections will also prevent the network being accessed by certain legitimate users. As a result, validator nodes must tune their firewall rules to ensure the right trade-off for their network's expected users. The guidance to network operators for the use of firewall rules in the deployment of Indy networks has been modified to better protect against denial of service attacks by increasing the cost and complexity in mounting such attacks. The mitigation for this vulnerability is not in the Hyperledger Indy code per se, but rather in the individual deployments of Indy. The mitigations should be applied to all deployments of Indy, and are not related to a particular release.",
        "technologies": "Linux Foundation\nIndy Node 1.12.6 およびそれ以前\nIndy Node 1.13.2"
    },
    "JVNDB-2022-017491": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "A vulnerability was found in linux kernel, where an information leak occurs via ext4_extent_header to userspace.",
        "technologies": "Linux\nLinux Kernel 4.4.276 未満\nLinux Kernel 4.5 以上 4.9.276 未満\nLinux Kernel 4.10 以上 4.14.240 未満\nLinux Kernel 4.15 以上 4.19.198 未満\nLinux Kernel 4.20 以上 5.4.132 未満\nLinux Kernel 5.5.0 以上 5.10.50 未満\nLinux Kernel 5.11 以上 5.12.17 未満\nLinux Kernel 5.13 以上 5.13.2 未満"
    },
    "JVNDB-2022-017496": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
        "technologies": "Linux\nLinux Kernel 5.17.14 およびそれ以前\nLinux Kernel 5.18\nNetApp\nActive IQ Unified Manager\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux 6.0"
    },
    "JVNDB-2022-017693": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "There exists a use-after-free in io_uring in the Linux kernel. Signalfd_poll() and binder_poll() use a waitqueue whose lifetime is the current task. It will send a POLLFREE notification to all waiters before the queue is freed. Unfortunately, the io_uring poll doesn't handle POLLFREE. This allows a use-after-free to occur if a signalfd or binder fd is polled with io_uring poll, and the waitqueue gets freed. We recommend upgrading past commit fc78b2fc21f10c4c9c4d5d659a685710ffa63659",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 5.1 以上 5.4.212 未満\nLinux Kernel 5.5 以上 5.10.141 未満\nLinux Kernel 5.11 以上 5.15.65 未満\nLinux Kernel 5.16 以上 5.17 未満"
    },
    "JVNDB-2022-017181": {
        "title": "siderolabs の talos linux における不正な認証に関する脆弱性",
        "description": "Talos Linux is a Linux distribution built for Kubernetes deployments. Talos worker nodes use a join token to get accepted into the Talos cluster. Due to improper validation of the request while signing a worker node CSR (certificate signing request) Talos control plane node might issue Talos API certificate which allows full access to Talos API on a control plane node. Accessing Talos API with full level access on a control plane node might reveal sensitive information which allows full level access to the cluster (Kubernetes and Talos PKI, etc.). Talos API join token is stored in the machine configuration on the worker node. When configured correctly, Kubernetes workloads don't have access to the machine configuration, but due to a misconfiguration workload might access the machine configuration and reveal the join token. This problem has been fixed in Talos 1.2.2. Enabling the Pod Security Standards mitigates the vulnerability by denying hostPath mounts and host networking by default in the baseline policy. Clusters that don't run untrusted workloads are not affected. Clusters with correct Pod Security configurations which don't allow hostPath mounts, and secure access to cloud metadata server (or machine configuration is not supplied via cloud metadata server) are not affected.",
        "technologies": "siderolabs\ntalos linux 1.2.2 未満"
    },
    "JVNDB-2022-017506": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における数値型間の変換の誤りに関する脆弱性",
        "description": "An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 3.18.139 以上 3.19 未満\nLinux Kernel 4.4.179 以上 4.5 未満\nLinux Kernel 4.9.169 以上 4.9.312 未満\nLinux Kernel 4.14.112 以上 4.14.277 未満\nLinux Kernel 4.19.35 以上 4.19.240 未満\nLinux Kernel 5.0.8 以上 5.4.191 未満\nLinux Kernel 5.5 以上 5.10.113 未満\nLinux Kernel 5.11 以上 5.15.36 未満\nLinux Kernel 5.16 以上 5.17.5 未満\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-017512": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A race condition was found the Linux kernel in perf_event_open() which can be exploited by an unprivileged user to gain root privileges. The bug allows to build several exploit primitives such as kernel address information leak, arbitrary execution, etc.",
        "technologies": "Linux\nLinux Kernel 3.2.85 以上 3.3 未満\nLinux Kernel 3.16.40 以上 3.17 未満\nLinux Kernel 3.18.54 以上 3.19 未満\nLinux Kernel 4.0.0 以上 4.9.316 未満\nLinux Kernel 4.10 以上 4.14.281 未満\nLinux Kernel 4.15 以上 4.19.245 未満\nLinux Kernel 4.20 以上 5.4.196 未満\nLinux Kernel 5.5.0 以上 5.10.118 未満\nLinux Kernel 5.11 以上 5.15.42 未満\nLinux Kernel 5.16 以上 5.17.10 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2022-017698": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Linux kernel implementation of proxied virtualized TPM devices. On a system where virtualized TPM devices are configured (this is not the default) a local attacker can create a use-after-free and create a situation where it may be possible to escalate privileges on the system.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.1 未満"
    },
    "JVNDB-2022-017507": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack, causing remote dos.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2022-017688": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh->use to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl(), the rose driver calls rose_del_node() and removes neighbours only if their “count” and “use” are zero.",
        "technologies": "Fedora Project\nFedora 36\nLinux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-017983": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora 36\nLinux\nLinux Kernel 6.0 未満\nLinux Kernel 6.0\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-017917": {
        "title": "Linux Foundation の besu における数値型間の変換の誤りに関する脆弱性",
        "description": "Besu is a Java-based Ethereum client. In versions newer than 22.1.3 and prior to 22.7.1, Besu is subject to an Incorrect Conversion between Numeric Types. An error in 32 bit signed and unsigned types in the calculation of available gas in the CALL operations (including DELEGATECALL) results in incorrect gas being passed into called contracts and incorrect gas being returned after call execution. Where the amount of gas makes a difference in the success or failure, or if the gas is a negative 64 bit value, the execution will result in a different state root than expected, resulting in a consensus failure in networks with multiple EVM implementations. In networks with a single EVM implementation this can be used to execute with significantly more gas than then transaction requested, possibly exceeding gas limitations. This issue is patched in version 22.7.1. As a workaround, reverting to version 22.1.3 or earlier will prevent incorrect execution.",
        "technologies": "Linux Foundation\nbesu 22.4.1 以上 22.7.1 未満\nbesu 22.4.0"
    },
    "JVNDB-2022-017854": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Linux kernel’s implementation of IO-URING. This flaw allows an attacker with local executable permission to create a string of requests that can cause a use-after-free flaw within the kernel. This issue leads to memory corruption and possible privilege escalation.",
        "technologies": "Linux\nLinux Kernel 5.17.3 以上 5.18.6 未満"
    },
    "JVNDB-2022-017856": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.",
        "technologies": "Linux\nLinux Kernel 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5.0 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-017701": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nFedora Project\nFedora 35\nFedora 36\nFedora 37\nLinux\nLinux Kernel 3.14 以上 4.9.327 未満\nLinux Kernel 4.10 以上 4.14.292 未満\nLinux Kernel 4.15 以上 4.19.257 未満\nLinux Kernel 4.20 以上 5.4.212 未満\nLinux Kernel 5.5 以上 5.10.140 未満\nLinux Kernel 5.11 以上 5.15.64 未満\nLinux Kernel 5.16 以上 5.19.6 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-017842": {
        "title": "Linux-Pam の Linux-PAM における認証に関する脆弱性",
        "description": "The Linux-PAM package before 1.5.2-6.1 for openSUSE Tumbleweed allows authentication bypass for SSH logins. The pam_access.so module doesn't correctly restrict login if a user tries to connect from an IP address that is not resolvable via DNS. In such conditions, a user with denied access to a machine can still get access. NOTE: the relevance of this issue is largely limited to openSUSE Tumbleweed and openSUSE Factory; it does not affect Linux-PAM upstream.",
        "technologies": "Linux-Pam\nLinux-PAM 1.5.2-6.1 未満"
    },
    "JVNDB-2022-017703": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 2.6.33 以上 4.9.337 未満\nLinux Kernel 4.10 以上 4.14.303 未満\nLinux Kernel 4.15 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.229 未満\nLinux Kernel 5.5 以上 5.10.163 未満\nLinux Kernel 5.11 以上 5.15.86 未満\nLinux Kernel 5.16 以上 6.0.16 未満\nLinux Kernel 6.1 以上 6.1.2 未満\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-018512": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "A race condition was found in the Linux kernel's watch queue due to a missing lock in pipe_resize_ring(). The specific flaw exists within the handling of pipe buffers. The issue results from the lack of proper locking when performing operations on an object. This flaw allows a local user to crash the system or escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.120 未満\nLinux Kernel 5.11 以上 5.15.45 未満\nLinux Kernel 5.16 以上 5.17.13 未満\nLinux Kernel 5.18 以上 5.18.2 未満"
    },
    "JVNDB-2022-017998": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "A flaw was found in the Linux kernel’s driver for the ASIX AX88179_178A-based USB 2.0/3.0 Gigabit Ethernet Devices. The vulnerability contains multiple out-of-bounds reads and possible out-of-bounds writes.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.180 未満\nLinux Kernel 5.5 以上 5.10.101 未満\nLinux Kernel 5.11 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2022-018246": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds access issue was found in the Linux kernel sound subsystem. It could occur when the 'id->name' provided by the user did not end with '\\0'. A privileged local user could pass a specially crafted name through ioctl() interface and crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 6.0"
    },
    "JVNDB-2022-018085": {
        "title": "サムスンの tizenrt における未チェックの戻り値に関する脆弱性",
        "description": "An issue was discovered in Samsung TizenRT through 3.0_GBM (and 3.1_PRE). l2_packet_receive_timeout in wpa_supplicant/src/l2_packet/l2_packet_pcap.c has a missing check on the return value of pcap_dispatch, leading to a denial of service (malfunction).",
        "technologies": "サムスン\ntizenrt 1.0\ntizenrt 1.1\ntizenrt 2.0\ntizenrt 3.0\ntizenrt 3.1"
    },
    "JVNDB-2022-018507": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the Linux kernel's implementation of Pressure Stall Information. While the feature is disabled by default, it could allow an attacker to crash the system or have other memory-corruption side effects.",
        "technologies": "Fedora Project\nFedora 35\nLinux\nLinux Kernel 5.2 以上 5.4.177 未満\nLinux Kernel 5.5 以上 5.10.97 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux 8.0"
    },
    "JVNDB-2022-018273": {
        "title": "Linux Mint の warpinator におけるリンク解釈に関する脆弱性",
        "description": "Warpinator through 1.2.14 allows access outside of an intended directory, as demonstrated by symbolic directory links.",
        "technologies": "Linux Mint\nwarpinator 1.2.14 およびそれ以前"
    },
    "JVNDB-2022-018424": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "off-by-one in io_uring module.",
        "technologies": "Linux\nLinux Kernel 6.0"
    },
    "JVNDB-2022-018363": {
        "title": "Linux Foundation の dapr dashboard における重要な機能に対する認証の欠如に関する脆弱性",
        "description": "Dapr Dashboard v0.1.0 through v0.10.0 is vulnerable to Incorrect Access Control that allows attackers to obtain sensitive data.",
        "technologies": "Linux Foundation\ndapr dashboard 0.1.0 から 0.10.0"
    },
    "JVNDB-2022-022683": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function follow_page_pte of the file mm/gup.c of the component BPF. The manipulation leads to race condition. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211921 was assigned to this vulnerability.",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 5.1 以上 5.4.228 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.78 未満\nLinux Kernel 5.16 以上 5.19.17 未満\nLinux Kernel 6.0 以上 6.0.3 未満"
    },
    "JVNDB-2022-018263": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw use after free in the Linux kernel video4linux driver was found in the way user triggers em28xx_usb_probe() for the Empia 28xx based TV cards. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 3.15 以上 4.14.295 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-022616": {
        "title": "Linux の Linux Kernel における不適切な同期に関する脆弱性",
        "description": "A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function del_timer of the file drivers/isdn/mISDN/l1oip_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211088.",
        "technologies": "Linux\nLinux Kernel 2.6.27 以上 4.9.331 未満\nLinux Kernel 4.10 以上 4.14.296 未満\nLinux Kernel 4.15 以上 4.19.262 未満\nLinux Kernel 4.20 以上 5.4.220 未満\nLinux Kernel 5.5 以上 5.10.150 未満\nLinux Kernel 5.11 以上 5.15.75 未満\nLinux Kernel 5.16 以上 5.19.17 未満\nLinux Kernel 6.0 以上 6.0.3 未満"
    },
    "JVNDB-2022-022625": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A vulnerability classified as critical was found in Linux Kernel. Affected by this vulnerability is the function l2cap_reassemble_sdu of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211087.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.6 以上 4.9.333 未満\nLinux Kernel 4.10 以上 4.14.299 未満\nLinux Kernel 4.15 以上 4.19.265 未満\nLinux Kernel 4.20 以上 5.4.224 未満\nLinux Kernel 5.5.0 以上 5.10.154 未満\nLinux Kernel 5.11 以上 5.15.78 未満\nLinux Kernel 5.16 以上 6.0.8 未満\nNetApp\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-022618": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "A vulnerability, which was classified as critical, was found in Linux Kernel. Affected is the function l2cap_conn_del of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211944.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nFedora Project\nFedora 35\nFedora 36\nFedora 37\nLinux\nLinux Kernel 4.9.326 以上 4.9.333 未満\nLinux Kernel 4.14.291 以上 4.14.299 未満\nLinux Kernel 4.19.255 以上 4.19.265 未満\nLinux Kernel 5.4.209 以上 5.4.224 未満\nLinux Kernel 5.10.135 以上 5.10.154 未満\nLinux Kernel 5.15.59 以上 5.15.79 未満\nLinux Kernel 5.18.16 以上 6.0.8 未満"
    },
    "JVNDB-2022-022686": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_new_inode of the file fs/nilfs2/inode.c of the component BPF. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211992.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.9.331 未満\nLinux Kernel 4.10 以上 4.14.296 未満\nLinux Kernel 4.15 以上 4.19.262 未満\nLinux Kernel 4.20 以上 5.4.220 未満\nLinux Kernel 5.5 以上 5.10.148 未満\nLinux Kernel 5.11 以上 5.15.74 未満\nLinux Kernel 5.16 以上 5.19.16 未満\nLinux Kernel 6.0 以上 6.0.2 未満\nNetApp\nActive IQ Unified Manager\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-022729": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "A vulnerability was found in Linux Kernel. It has been classified as critical. This affects the function devlink_param_set/devlink_param_get of the file net/core/devlink.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211929 was assigned to this vulnerability.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19 以上 5.4.211 未満\nLinux Kernel 5.5 以上 5.10.138 未満\nLinux Kernel 5.11 以上 5.15.63 未満\nLinux Kernel 5.16 以上 5.19.4 未満"
    },
    "JVNDB-2022-022892": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "A double-free flaw was found in the Linux kernel’s NTFS3 subsystem in how a user triggers remount and umount simultaneously. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 6.1"
    },
    "JVNDB-2022-022999": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 6.0.10. In drivers/media/dvb-core/dvb_ca_en50221.c, a use-after-free can occur is there is a disconnect after an open, because of the lack of a wait_event.",
        "technologies": "Linux\nLinux Kernel 6.0.10 およびそれ以前\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-022624": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品におけるバッファエラーの脆弱性",
        "description": "A vulnerability, which was classified as critical, was found in Linux Kernel. This affects the function __mtk_ppe_check_skb of the file drivers/net/ethernet/mediatek/mtk_ppe.c of the component Ethernet Handler. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211935.",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel"
    },
    "JVNDB-2022-022713": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function tst_timer of the file drivers/atm/idt77252.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. VDB-211934 is the identifier assigned to this vulnerability.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 以上 4.9.326 未満\nLinux Kernel 4.10 以上 4.14.291 未満\nLinux Kernel 4.15 以上 4.19.256 未満\nLinux Kernel 4.20 以上 5.4.211 未満\nLinux Kernel 5.5 以上 5.10.138 未満\nLinux Kernel 5.11 以上 5.15.63 未満\nLinux Kernel 5.16 以上 5.19.4 未満"
    },
    "JVNDB-2022-022869": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における制限またはスロットリング無しのリソースの割り当てに関する脆弱性",
        "description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "technologies": "Linux\nLinux Kernel 5.19.17 未満\nLinux Kernel 6.0 以上 6.0.2 未満\nNetApp\nActive IQ Unified Manager\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-022969": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "Use After Free vulnerability in Linux Kernel allows Privilege Escalation. An improper Update of Reference Count in io_uring leads to Use-After-Free and Local Privilege Escalation. When io_msg_ring was invoked with a fixed file, it called io_fput_file() which improperly decreased its reference count (leading to Use-After-Free and Local Privilege Escalation). Fixed files are permanently registered to the ring, and should not be put separately. We recommend upgrading past commit https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679 https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679",
        "technologies": "Linux\nLinux Kernel 5.18 以上 5.19.11 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-023002": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "There are use-after-free vulnerabilities in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_connect and l2cap_le_connect_req functions which may allow code execution and leaking kernel memory (respectively) remotely via Bluetooth. A remote attacker could execute code leaking kernel memory via Bluetooth if within proximity of the victim. We recommend upgrading past commit  https://www.google.com/url https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4 https://www.google.com/url",
        "technologies": "Linux\nLinux Kernel 4.9.335 未満\nLinux Kernel 4.10 以上 4.14.301 未満\nLinux Kernel 4.15 以上 4.19.268 未満\nLinux Kernel 4.20 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.154 未満\nLinux Kernel 5.11 以上 5.15.78 未満\nLinux Kernel 5.16 以上 6.0.8 未満"
    },
    "JVNDB-2022-022743": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds memory write flaw was found in the Linux kernel’s Kid-friendly Wired Controller driver. This flaw allows a local user to crash or potentially escalate their privileges on the system. It is in bigben_probe of drivers/hid/hid-bigbenff.c. The reason is incorrect assumption - bigben devices all have inputs. However, malicious devices can break this assumption, leaking to out-of-bound write.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-023011": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "An issue was discovered in the Linux kernel through 6.0.10. l2cap_config_req in net/bluetooth/l2cap_core.c has an integer wraparound via L2CAP_CONF_REQ packets.",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nFedora Project\nFedora 37\nLinux\nLinux Kernel 2.6.32 以上 4.9.337 未満\nLinux Kernel 4.10 以上 4.14.303 未満\nLinux Kernel 4.15 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.229 未満\nLinux Kernel 5.5 以上 5.10.161 未満\nLinux Kernel 5.11 以上 5.15.85 未満\nLinux Kernel 5.16 以上 6.0.15 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-024464": {
        "title": "Linux Kernel における型の取り違えに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 5.18.9. A type confusion bug in nft_set_elem_init (leading to a buffer overflow) could be used by a local attacker to escalate privileges, a different vulnerability than CVE-2022-32250. (The attacker can obtain root access, but must start with an unprivileged user namespace to obtain CAP_NET_ADMIN access.) This can be fixed in nft_setelem_parse_data in net/netfilter/nf_tables_api.c.",
        "technologies": "Canonical\nUbuntu\nDebian\nDebian GNU/Linux\nLinux\nLinux Kernel 5.18.9 まで\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-023830": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.2.0 以上 5.10.157 未満\nLinux Kernel 5.11 以上 5.15.81 未満\nLinux Kernel 5.16 以上 6.0.11 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-024472": {
        "title": "Linux 用 VMware Horizon Agent における脆弱性",
        "description": "VMware Horizon Agent for Linux (prior to 22.x) contains a local privilege escalation that allows a user to escalate to root due to a vulnerable configuration file.",
        "technologies": "VMware\nVMware Horizon"
    },
    "JVNDB-2022-023014": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.",
        "technologies": "Linux\nLinux Kernel 6.0.9 およびそれ以前\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-023013": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_net.c has a .disconnect versus dvb_device_open race condition that leads to a use-after-free.",
        "technologies": "Linux\nLinux Kernel 6.0.9 およびそれ以前\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-023831": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.7 以上 5.10.157 未満\nLinux Kernel 5.11 以上 5.15.81 未満\nLinux Kernel 5.16 以上 6.0.11 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-023829": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing the channel list attribute from Wi-Fi management frames.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.2 以上 5.10.157 未満\nLinux Kernel 5.11 以上 5.15.81 未満\nLinux Kernel 5.16 以上 6.0.11 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-023828": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when copying the list of operating channels from Wi-Fi management frames.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.2 以上 5.10.157 未満\nLinux Kernel 5.11 以上 5.15.81 未満\nLinux Kernel 5.16 以上 6.0.11 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-023111": {
        "title": "Linux Foundation の Qubesos 用 mirage firewall における無限ループに関する脆弱性",
        "description": "qubes-mirage-firewall (aka Mirage firewall for QubesOS) 0.8.x through 0.8.3 allows guest OS users to cause a denial of service (CPU consumption and loss of forwarding) via a crafted multicast UDP packet (IP address range of 224.0.0.0 through 239.255.255.255).",
        "technologies": "Linux Foundation\nmirage firewall 0.8.0 以上 0.8.4 未満"
    },
    "JVNDB-2022-023016": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",
        "technologies": "Linux\nLinux Kernel 6.0.9 およびそれ以前\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-024477": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における古典的バッファオーバーフローの脆弱性",
        "description": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.",
        "technologies": "Debian\nDebian GNU/Linux 9.0\nDebian GNU/Linux 10.0\nFedora Project\nFedora 34\nFedora 35\nLinux\nLinux Kernel 5.16.12 およびそれ以前\nNetApp\nH300E ファームウェア\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500E ファームウェア\nH500S ファームウェア\nH700E ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-024581": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における脆弱性",
        "description": "In Wi-Fi, there is a possible low throughput due to misrepresentation of critical information. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: GN20220829014; Issue ID: GN20220829014.",
        "technologies": "Linux Foundation\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nYocto 4.0\nメディアテック\nMT7603 ファームウェア 7.6.6.0\nMT7613 ファームウェア 7.6.6.0\nMT7615 ファームウェア 7.6.6.0\nMT7622 ファームウェア 7.6.6.0\nMT7628 ファームウェア 7.6.6.0\nMT7629 ファームウェア 7.6.6.0\nMT7915 ファームウェア 7.6.6.0\nMT7916 ファームウェア 7.6.6.0\nMT7981 ファームウェア 7.6.6.0\nMT7986 ファームウェア 7.6.6.0"
    },
    "JVNDB-2022-024869": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.2. The ntfs3 subsystem does not properly check for correctness during disk reads, leading to an out-of-bounds read in ntfs_set_ea in fs/ntfs3/xattr.c.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.121 未満\nLinux Kernel 5.16 以上 6.1.40 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2022-024611": {
        "title": "tinylab の cloud lab および linux lab における不適切なデフォルトパーミッションに関する脆弱性",
        "description": "TinyLab linux-lab v1.1-rc1 and cloud-labv0.8-rc2, v1.1-rc1 are vulnerable to insecure permissions. The default configuration could cause Container Escape.",
        "technologies": "tinylab\ncloud lab 0.8\ncloud lab 1.1\nlinux lab 1.1"
    },
    "JVNDB-2022-025027": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における二重解放に関する脆弱性",
        "description": "It was discovered that the cls_route filter implementation in the Linux kernel would not remove an old filter from the hashtable before freeing it if its handle had the value 0.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nLinux\nLinux Kernel 5.19.17 およびそれ以前"
    },
    "JVNDB-2022-024509": {
        "title": "Linux Foundation の nats-server におけるパストラバーサルの脆弱性",
        "description": "NATS nats-server 2.2.0 through 2.7.4 allows directory traversal because of an unintended path to a management action from a management account.",
        "technologies": "Linux Foundation\nnats-server 2.2.0 から 2.7.4"
    },
    "JVNDB-2022-025028": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "io_uring UAF, Unix SCM garbage collection",
        "technologies": "Canonical\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nUbuntu 22.10\nLinux\nLinux Kernel 6.0.19 およびそれ以前"
    },
    "JVNDB-2022-025026": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "It was discovered that a nft object or expression could reference a nft set on a different nft table, leading to a use-after-free once that table was deleted.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nLinux\nLinux Kernel 5.19.17 およびそれ以前"
    },
    "JVNDB-2022-025093": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: slub: fix flush_cpu_slab()/__free_slab() invocations in task context. Commit 5a836bf6b09f (\"mm: slub: move flush_cpu_slab() invocations __free_slab() invocations out of IRQ context\") moved all flush_cpu_slab() invocations to the global workqueue to avoid a problem related with deactivate_slab()/__free_slab() being called from an IRQ context on PREEMPT_RT kernels. When the flush_all_cpu_locked() function is called from a task context it may happen that a workqueue with WQ_MEM_RECLAIM bit set ends up flushing the global workqueue, this will cause a dependency issue. workqueue: WQ_MEM_RECLAIM nvme-delete-wq:nvme_delete_ctrl_work [nvme_core] is flushing !WQ_MEM_RECLAIM events:flush_cpu_slab WARNING: CPU: 37 PID: 410 at kernel/workqueue.c:2637 check_flush_dependency+0x10a/0x120 Workqueue: nvme-delete-wq nvme_delete_ctrl_work [nvme_core] RIP: 0010:check_flush_dependency+0x10a/0x120[ 453.262125] Call Trace: __flush_work.isra.0+0xbf/0x220 ? __queue_work+0x1dc/0x420 flush_all_cpus_locked+0xfb/0x120 __kmem_cache_shutdown+0x2b/0x320 kmem_cache_destroy+0x49/0x100 bioset_exit+0x143/0x190 blk_release_queue+0xb9/0x100 kobject_cleanup+0x37/0x130 nvme_fc_ctrl_free+0xc6/0x150 [nvme_fc] nvme_free_ctrl+0x1ac/0x2b0 [nvme_core] Fix this bug by creating a workqueue for the flush operation with the WQ_MEM_RECLAIM bit set.",
        "technologies": "Linux\nLinux Kernel 5.15 より大きい 5.15.71 未満\nLinux Kernel 5.16 より大きい 5.19.12 未満"
    },
    "JVNDB-2022-025059": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "It was discovered that when exec'ing from a non-leader thread, armed POSIX CPU timers would be left on a list but freed, leading to a use-after-free.",
        "technologies": "Canonical\nUbuntu 20.04\nUbuntu 22.04\nLinux\nLinux Kernel 5.7 以上 6.0 未満"
    },
    "JVNDB-2022-025089": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/gem: Really move i915_gem_context.link under ref protection i915_perf assumes that it can use the i915_gem_context reference to protect its i915->gem.contexts.list iteration. However, this requires that we do not remove the context from the list until after we drop the final reference and release the struct. If, as currently, we remove the context from the list during context_close(), the link.next pointer may be poisoned while we are holding the context reference and cause a GPF: [ 4070.573157] i915 0000:00:02.0: [drm:i915_perf_open_ioctl [i915]] filtering on ctx_id=0x1fffff ctx_id_mask=0x1fffff [ 4070.574881] general protection fault, probably for non-canonical address 0xdead000000000100: 0000 [#1] PREEMPT SMP [ 4070.574897] CPU: 1 PID: 284392 Comm: amd_performance Tainted: G E 5.17.9 #180 [ 4070.574903] Hardware name: Intel Corporation NUC7i5BNK/NUC7i5BNB, BIOS BNKBL357.86A.0052.2017.0918.1346 09/18/2017 [ 4070.574907] RIP: 0010:oa_configure_all_contexts.isra.0+0x222/0x350 [i915] [ 4070.574982] Code: 08 e8 32 6e 10 e1 4d 8b 6d 50 b8 ff ff ff ff 49 83 ed 50 f0 41 0f c1 04 24 83 f8 01 0f 84 e3 00 00 00 85 c0 0f 8e fa 00 00 00 <49> 8b 45 50 48 8d 70 b0 49 8d 45 50 48 39 44 24 10 0f 85 34 fe ff [ 4070.574990] RSP: 0018:ffffc90002077b78 EFLAGS: 00010202 [ 4070.574995] RAX: 0000000000000002 RBX: 0000000000000002 RCX: 0000000000000000 [ 4070.575000] RDX: 0000000000000001 RSI: ffffc90002077b20 RDI: ffff88810ddc7c68 [ 4070.575004] RBP: 0000000000000001 R08: ffff888103242648 R09: fffffffffffffffc [ 4070.575008] R10: ffffffff82c50bc0 R11: 0000000000025c80 R12: ffff888101bf1860 [ 4070.575012] R13: dead0000000000b0 R14: ffffc90002077c04 R15: ffff88810be5cabc [ 4070.575016] FS: 00007f1ed50c0780(0000) GS:ffff88885ec80000(0000) knlGS:0000000000000000 [ 4070.575021] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 4070.575025] CR2: 00007f1ed5590280 CR3: 000000010ef6f005 CR4: 00000000003706e0 [ 4070.575029] Call Trace: [ 4070.575033] <TASK> [ 4070.575037] lrc_configure_all_contexts+0x13e/0x150 [i915] [ 4070.575103] gen8_enable_metric_set+0x4d/0x90 [i915] [ 4070.575164] i915_perf_open_ioctl+0xbc0/0x1500 [i915] [ 4070.575224] ? asm_common_interrupt+0x1e/0x40 [ 4070.575232] ? i915_oa_init_reg_state+0x110/0x110 [i915] [ 4070.575290] drm_ioctl_kernel+0x85/0x110 [ 4070.575296] ? update_load_avg+0x5f/0x5e0 [ 4070.575302] drm_ioctl+0x1d3/0x370 [ 4070.575307] ? i915_oa_init_reg_state+0x110/0x110 [i915] [ 4070.575382] ? gen8_gt_irq_handler+0x46/0x130 [i915] [ 4070.575445] __x64_sys_ioctl+0x3c4/0x8d0 [ 4070.575451] ? __do_softirq+0xaa/0x1d2 [ 4070.575456] do_syscall_64+0x35/0x80 [ 4070.575461] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 4070.575467] RIP: 0033:0x7f1ed5c10397 [ 4070.575471] Code: 3c 1c e8 1c ff ff ff 85 c0 79 87 49 c7 c4 ff ff ff ff 5b 5d 4c 89 e0 41 5c c3 66 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a9 da 0d 00 f7 d8 64 89 01 48 [ 4070.575478] RSP: 002b:00007ffd65c8d7a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 [ 4070.575484] RAX: ffffffffffffffda RBX: 0000000000000006 RCX: 00007f1ed5c10397 [ 4070.575488] RDX: 00007ffd65c8d7c0 RSI: 0000000040106476 RDI: 0000000000000006 [ 4070.575492] RBP: 00005620972f9c60 R08: 000000000000000a R09: 0000000000000005 [ 4070.575496] R10: 000000000000000d R11: 0000000000000246 R12: 000000000000000a [ 4070.575500] R13: 000000000000000d R14: 0000000000000000 R15: 00007ffd65c8d7c0 [ 4070.575505] </TASK> [ 4070.575507] Modules linked in: nls_ascii(E) nls_cp437(E) vfat(E) fat(E) i915(E) x86_pkg_temp_thermal(E) intel_powerclamp(E) crct10dif_pclmul(E) crc32_pclmul(E) crc32c_intel(E) aesni_intel(E) crypto_simd(E) intel_gtt(E) cryptd(E) ttm(E) rapl(E) intel_cstate(E) drm_kms_helper(E) cfbfillrect(E) syscopyarea(E) cfbimgblt(E) intel_uncore(E) sysfillrect(E) mei_me(E) sysimgblt(E) i2c_i801(E) fb_sys_fops(E) mei(E) intel_pch_thermal(E) i2c_smbus ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.71 未満\nLinux Kernel 5.16 以上 5.19.12 未満"
    },
    "JVNDB-2022-025094": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: topology: fix possible overflow in amu_fie_setup() cpufreq_get_hw_max_freq() returns max frequency in kHz as *unsigned int*, while freq_inv_set_max_ratio() gets passed this frequency in Hz as 'u64'. Multiplying max frequency by 1000 can potentially result in overflow -- multiplying by 1000ULL instead should avoid that... Found by Linux Verification Center (linuxtesting.org) with the SVACE static analysis tool.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.150 未満\nLinux Kernel 5.11 以上 5.15.71 未満\nLinux Kernel 5.16 以上 5.19.12 未満"
    },
    "JVNDB-2022-025084": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: moxart: fix potential use-after-free on remove path It was reported that the mmc host structure could be accessed after it was freed in moxart_remove(), so fix this by saving the base register of the device and using it instead of the pointer dereference.",
        "technologies": "Linux\nLinux Kernel 4.9.301 未満\nLinux Kernel 4.10.0 以上 4.14.266 未満\nLinux Kernel 4.15.0 以上 4.19.229 未満\nLinux Kernel 4.20.0 以上 5.4.179 未満\nLinux Kernel 5.5.0 以上 5.10.100 未満\nLinux Kernel 5.11.0 以上 5.15.23 未満\nLinux Kernel 5.16.0 以上 5.16.9 未満"
    },
    "JVNDB-2022-025088": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Harden accesses to the reset domains Accessing reset domains descriptors by the index upon the SCMI drivers requests through the SCMI reset operations interface can potentially lead to out-of-bound violations if the SCMI driver misbehave. Add an internal consistency check before any such domains descriptors accesses.",
        "technologies": "Linux\nLinux Kernel 5.15.71 未満\nLinux Kernel 5.16 より大きい 5.19.12 未満"
    },
    "JVNDB-2022-025096": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/irdma: Fix drain SQ hang with no completion SW generated completions for outstanding WRs posted on SQ after QP is in error target the wrong CQ. This causes the ib_drain_sq to hang with no completion. Fix this to generate completions on the right CQ. [ 863.969340] INFO: task kworker/u52:2:671 blocked for more than 122 seconds. [ 863.979224] Not tainted 5.14.0-130.el9.x86_64 #1 [ 863.986588] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. [ 863.996997] task:kworker/u52:2 state:D stack: 0 pid: 671 ppid: 2 flags:0x00004000 [ 864.007272] Workqueue: xprtiod xprt_autoclose [sunrpc] [ 864.014056] Call Trace: [ 864.017575] __schedule+0x206/0x580 [ 864.022296] schedule+0x43/0xa0 [ 864.026736] schedule_timeout+0x115/0x150 [ 864.032185] __wait_for_common+0x93/0x1d0 [ 864.037717] ? usleep_range_state+0x90/0x90 [ 864.043368] __ib_drain_sq+0xf6/0x170 [ib_core] [ 864.049371] ? __rdma_block_iter_next+0x80/0x80 [ib_core] [ 864.056240] ib_drain_sq+0x66/0x70 [ib_core] [ 864.062003] rpcrdma_xprt_disconnect+0x82/0x3b0 [rpcrdma] [ 864.069365] ? xprt_prepare_transmit+0x5d/0xc0 [sunrpc] [ 864.076386] xprt_rdma_close+0xe/0x30 [rpcrdma] [ 864.082593] xprt_autoclose+0x52/0x100 [sunrpc] [ 864.088718] process_one_work+0x1e8/0x3c0 [ 864.094170] worker_thread+0x50/0x3b0 [ 864.099109] ? rescuer_thread+0x370/0x370 [ 864.104473] kthread+0x149/0x170 [ 864.109022] ? set_kthread_struct+0x40/0x40 [ 864.114713] ret_from_fork+0x22/0x30",
        "technologies": "Linux\nLinux Kernel 5.19 以上 5.19.9 未満"
    },
    "JVNDB-2022-025100": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp: TX zerocopy should not sense pfmemalloc status We got a recent syzbot report [1] showing a possible misuse of pfmemalloc page status in TCP zerocopy paths. Indeed, for pages coming from user space or other layers, using page_is_pfmemalloc() is moot, and possibly could give false positives. There has been attempts to make page_is_pfmemalloc() more robust, but not using it in the first place in this context is probably better, removing cpu cycles. Note to stable teams : You need to backport 84ce071e38a6 (\"net: introduce __skb_fill_page_desc_noacc\") as a prereq. Race is more probable after commit c07aea3ef4d4 (\"mm: add a signature in struct page\") because page_is_pfmemalloc() is now using low order bit from page->lru.next, which can change more often than page->index. Low order bit should never be set for lru.next (when used as an anchor in LRU list), so KCSAN report is mostly a false positive. Backporting to older kernel versions seems not necessary. [1] BUG: KCSAN: data-race in lru_add_fn / tcp_build_frag write to 0xffffea0004a1d2c8 of 8 bytes by task 18600 on cpu 0: __list_add include/linux/list.h:73 [inline] list_add include/linux/list.h:88 [inline] lruvec_add_folio include/linux/mm_inline.h:105 [inline] lru_add_fn+0x440/0x520 mm/swap.c:228 folio_batch_move_lru+0x1e1/0x2a0 mm/swap.c:246 folio_batch_add_and_move mm/swap.c:263 [inline] folio_add_lru+0xf1/0x140 mm/swap.c:490 filemap_add_folio+0xf8/0x150 mm/filemap.c:948 __filemap_get_folio+0x510/0x6d0 mm/filemap.c:1981 pagecache_get_page+0x26/0x190 mm/folio-compat.c:104 grab_cache_page_write_begin+0x2a/0x30 mm/folio-compat.c:116 ext4_da_write_begin+0x2dd/0x5f0 fs/ext4/inode.c:2988 generic_perform_write+0x1d4/0x3f0 mm/filemap.c:3738 ext4_buffered_write_iter+0x235/0x3e0 fs/ext4/file.c:270 ext4_file_write_iter+0x2e3/0x1210 call_write_iter include/linux/fs.h:2187 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x468/0x760 fs/read_write.c:578 ksys_write+0xe8/0x1a0 fs/read_write.c:631 __do_sys_write fs/read_write.c:643 [inline] __se_sys_write fs/read_write.c:640 [inline] __x64_sys_write+0x3e/0x50 fs/read_write.c:640 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd read to 0xffffea0004a1d2c8 of 8 bytes by task 18611 on cpu 1: page_is_pfmemalloc include/linux/mm.h:1740 [inline] __skb_fill_page_desc include/linux/skbuff.h:2422 [inline] skb_fill_page_desc include/linux/skbuff.h:2443 [inline] tcp_build_frag+0x613/0xb20 net/ipv4/tcp.c:1018 do_tcp_sendpages+0x3e8/0xaf0 net/ipv4/tcp.c:1075 tcp_sendpage_locked net/ipv4/tcp.c:1140 [inline] tcp_sendpage+0x89/0xb0 net/ipv4/tcp.c:1150 inet_sendpage+0x7f/0xc0 net/ipv4/af_inet.c:833 kernel_sendpage+0x184/0x300 net/socket.c:3561 sock_sendpage+0x5a/0x70 net/socket.c:1054 pipe_to_sendpage+0x128/0x160 fs/splice.c:361 splice_from_pipe_feed fs/splice.c:415 [inline] __splice_from_pipe+0x222/0x4d0 fs/splice.c:559 splice_from_pipe fs/splice.c:594 [inline] generic_splice_sendpage+0x89/0xc0 fs/splice.c:743 do_splice_from fs/splice.c:764 [inline] direct_splice_actor+0x80/0xa0 fs/splice.c:931 splice_direct_to_actor+0x305/0x620 fs/splice.c:886 do_splice_direct+0xfb/0x180 fs/splice.c:974 do_sendfile+0x3bf/0x910 fs/read_write.c:1249 __do_sys_sendfile64 fs/read_write.c:1317 [inline] __se_sys_sendfile64 fs/read_write.c:1303 [inline] __x64_sys_sendfile64+0x10c/0x150 fs/read_write.c:1303 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd value changed: 0x0000000000000000 -> 0xffffea0004a1d288 Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 18611 Comm: syz-executor.4 Not tainted 6.0.0-rc2-syzkaller-00248-ge022620b5d05-dirty #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/22/2022",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.68 未満\nLinux Kernel 5.16 以上 5.19.9 未満"
    },
    "JVNDB-2022-025109": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: peci: cpu: Fix use-after-free in adev_release() When auxiliary_device_add() returns an error, auxiliary_device_uninit() is called, which causes refcount for device to be decremented and .release callback will be triggered. Because adev_release() re-calls auxiliary_device_uninit(), it will cause use-after-free: [ 1269.455172] WARNING: CPU: 0 PID: 14267 at lib/refcount.c:28 refcount_warn_saturate+0x110/0x15 [ 1269.464007] refcount_t: underflow; use-after-free.",
        "technologies": "Linux\nLinux Kernel 5.19.10 未満"
    },
    "JVNDB-2022-025170": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: rndis: prevent integer overflow in rndis_set_response() If \"BufOffset\" is very large the \"BufOffset + 8\" operation can have an integer overflow.",
        "technologies": "Linux\nLinux Kernel 4.9.302 以上 4.9.308 未満\nLinux Kernel 4.14.267 以上 4.14.273 未満\nLinux Kernel 4.19.230 以上 4.19.236 未満\nLinux Kernel 5.4.180 以上 5.4.187 未満\nLinux Kernel 5.10.101 以上 5.10.108 未満\nLinux Kernel 5.15.24 以上 5.15.31 未満\nLinux Kernel 5.16.10 以上 5.16.17 未満"
    },
    "JVNDB-2022-025105": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: erofs: fix pcluster use-after-free on UP platforms During stress testing with CONFIG_SMP disabled, KASAN reports as below: ================================================================== BUG: KASAN: use-after-free in __mutex_lock+0xe5/0xc30 Read of size 8 at addr ffff8881094223f8 by task stress/7789 CPU: 0 PID: 7789 Comm: stress Not tainted 6.0.0-rc1-00002-g0d53d2e882f9 #3 Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011 Call Trace: <TASK> .. __mutex_lock+0xe5/0xc30 .. z_erofs_do_read_page+0x8ce/0x1560 .. z_erofs_readahead+0x31c/0x580 .. Freed by task 7787 kasan_save_stack+0x1e/0x40 kasan_set_track+0x20/0x30 kasan_set_free_info+0x20/0x40 __kasan_slab_free+0x10c/0x190 kmem_cache_free+0xed/0x380 rcu_core+0x3d5/0xc90 __do_softirq+0x12d/0x389 Last potentially related work creation: kasan_save_stack+0x1e/0x40 __kasan_record_aux_stack+0x97/0xb0 call_rcu+0x3d/0x3f0 erofs_shrink_workstation+0x11f/0x210 erofs_shrink_scan+0xdc/0x170 shrink_slab.constprop.0+0x296/0x530 drop_slab+0x1c/0x70 drop_caches_sysctl_handler+0x70/0x80 proc_sys_call_handler+0x20a/0x2f0 vfs_write+0x555/0x6c0 ksys_write+0xbe/0x160 do_syscall_64+0x3b/0x90 The root cause is that erofs_workgroup_unfreeze() doesn't reset to orig_val thus it causes a race that the pcluster reuses unexpectedly before freeing. Since UP platforms are quite rare now, such path becomes unnecessary. Let's drop such specific-designed path directly instead.",
        "technologies": "Linux\nLinux Kernel 5.0 以上 5.15.68 未満\nLinux Kernel 5.16 以上 5.19.9 未満"
    },
    "JVNDB-2022-025169": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: usbtmc: Fix bug in pipe direction for control transfers The syzbot fuzzer reported a minor bug in the usbtmc driver: usb 5-1: BOGUS control dir, pipe 80001e80 doesn't match bRequestType 0 WARNING: CPU: 0 PID: 3813 at drivers/usb/core/urb.c:412 usb_submit_urb+0x13a5/0x1970 drivers/usb/core/urb.c:410 Modules linked in: CPU: 0 PID: 3813 Comm: syz-executor122 Not tainted 5.17.0-rc5-syzkaller-00306-g2293be58d6a1 #0 ... Call Trace: <TASK> usb_start_wait_urb+0x113/0x530 drivers/usb/core/message.c:58 usb_internal_control_msg drivers/usb/core/message.c:102 [inline] usb_control_msg+0x2a5/0x4b0 drivers/usb/core/message.c:153 usbtmc_ioctl_request drivers/usb/class/usbtmc.c:1947 [inline] The problem is that usbtmc_ioctl_request() uses usb_rcvctrlpipe() for all of its transfers, whether they are in or out. It's easy to fix.",
        "technologies": "Linux\nLinux Kernel 5.4.187 以上 5.10.108 未満\nLinux Kernel 5.11 以上 5.15.31 未満"
    },
    "JVNDB-2022-025107": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: of: fdt: fix off-by-one error in unflatten_dt_nodes() Commit 78c44d910d3e (\"drivers/of: Fix depth when unflattening devicetree\") forgot to fix up the depth check in the loop body in unflatten_dt_nodes() which makes it possible to overflow the nps[] buffer... Found by Linux Verification Center (linuxtesting.org) with the SVACE static analysis tool.",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.14.295 未満\nLinux Kernel 4.15 以上 4.19.260 未満\nLinux Kernel 4.20 以上 5.4.215 未満\nLinux Kernel 5.5 以上 5.10.145 未満\nLinux Kernel 5.11 以上 5.15.70 未満\nLinux Kernel 5.16 以上 5.19.11 未満"
    },
    "JVNDB-2022-025103": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-tcp: fix UAF when detecting digest errors We should also bail from the io_work loop when we set rd_enabled to true, so we don't attempt to read data from the socket when the TCP stream is already out-of-sync or corrupted.",
        "technologies": "Linux\nLinux Kernel 5.0 以上 5.4.213 未満\nLinux Kernel 5.5 以上 5.10.143 未満\nLinux Kernel 5.11 以上 5.15.68 未満\nLinux Kernel 5.16 以上 5.19.9 未満"
    },
    "JVNDB-2022-025173": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing/osnoise: Do not unregister events twice Nicolas reported that using: # trace-cmd record -e all -M 10 -p osnoise --poll Resulted in the following kernel warning: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 1217 at kernel/tracepoint.c:404 tracepoint_probe_unregister+0x280/0x370 [...] CPU: 0 PID: 1217 Comm: trace-cmd Not tainted 5.17.0-rc6-next-20220307-nico+ #19 RIP: 0010:tracepoint_probe_unregister+0x280/0x370 [...] CR2: 00007ff919b29497 CR3: 0000000109da4005 CR4: 0000000000170ef0 Call Trace: <TASK> osnoise_workload_stop+0x36/0x90 tracing_set_tracer+0x108/0x260 tracing_set_trace_write+0x94/0xd0 ? __check_object_size.part.0+0x10a/0x150 ? selinux_file_permission+0x104/0x150 vfs_write+0xb5/0x290 ksys_write+0x5f/0xe0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7ff919a18127 [...] ---[ end trace 0000000000000000 ]--- The warning complains about an attempt to unregister an unregistered tracepoint. This happens on trace-cmd because it first stops tracing, and then switches the tracer to nop. Which is equivalent to: # cd /sys/kernel/tracing/ # echo osnoise > current_tracer # echo 0 > tracing_on # echo nop > current_tracer The osnoise tracer stops the workload when no trace instance is actually collecting data. This can be caused both by disabling tracing or disabling the tracer itself. To avoid unregistering events twice, use the existing trace_osnoise_callback_enabled variable to check if the events (and the workload) are actually active before trying to deactivate them.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025176": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: staging: gdm724x: fix use after free in gdm_lte_rx() The netif_rx_ni() function frees the skb so we can't dereference it to save the skb->len.",
        "technologies": "Linux\nLinux Kernel 3.12 以上 4.9.307 未満\nLinux Kernel 4.10 以上 4.14.272 未満\nLinux Kernel 4.15 以上 4.19.235 未満\nLinux Kernel 4.20 以上 5.4.185 未満\nLinux Kernel 5.5 以上 5.10.106 未満\nLinux Kernel 5.11 以上 5.15.29 未満\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025172": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: watch_queue: Fix filter limit check In watch_queue_set_filter(), there are a couple of places where we check that the filter type value does not exceed what the type_filter bitmap can hold. One place calculates the number of bits by: if (tf[i].type >= sizeof(wfilter->type_filter) * 8) which is fine, but the second does: if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG) which is not. This can lead to a couple of out-of-bounds writes due to a too-large type: (1) __set_bit() on wfilter->type_filter (2) Writing more elements in wfilter->filters[] than we allocated. Fix this by just using the proper WATCH_TYPE__NR instead, which is the number of types we actually know about. The bug may cause an oops looking something like: BUG: KASAN: slab-out-of-bounds in watch_queue_set_filter+0x659/0x740 Write of size 4 at addr ffff88800d2c66bc by task watch_queue_oob/611 ... Call Trace: <TASK> dump_stack_lvl+0x45/0x59 print_address_description.constprop.0+0x1f/0x150 ... kasan_report.cold+0x7f/0x11b ... watch_queue_set_filter+0x659/0x740 ... __x64_sys_ioctl+0x127/0x190 do_syscall_64+0x43/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae Allocated by task 611: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0x81/0xa0 watch_queue_set_filter+0x23a/0x740 __x64_sys_ioctl+0x127/0x190 do_syscall_64+0x43/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae The buggy address belongs to the object at ffff88800d2c66a0 which belongs to the cache kmalloc-32 of size 32 The buggy address is located 28 bytes inside of 32-byte region [ffff88800d2c66a0, ffff88800d2c66c0)",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.106 未満\nLinux Kernel 5.11 以上 5.15.29 未満\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025181": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sctp: fix kernel-infoleak for SCTP sockets syzbot reported a kernel infoleak [1] of 4 bytes. After analysis, it turned out r->idiag_expires is not initialized if inet_sctp_diag_fill() calls inet_diag_msg_common_fill() Make sure to clear idiag_timer/idiag_retrans/idiag_expires and let inet_diag_msg_sctpasoc_fill() fill them again if needed. [1] BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] BUG: KMSAN: kernel-infoleak in copyout lib/iov_iter.c:154 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x6ef/0x25a0 lib/iov_iter.c:668 instrument_copy_to_user include/linux/instrumented.h:121 [inline] copyout lib/iov_iter.c:154 [inline] _copy_to_iter+0x6ef/0x25a0 lib/iov_iter.c:668 copy_to_iter include/linux/uio.h:162 [inline] simple_copy_to_iter+0xf3/0x140 net/core/datagram.c:519 __skb_datagram_iter+0x2d5/0x11b0 net/core/datagram.c:425 skb_copy_datagram_iter+0xdc/0x270 net/core/datagram.c:533 skb_copy_datagram_msg include/linux/skbuff.h:3696 [inline] netlink_recvmsg+0x669/0x1c80 net/netlink/af_netlink.c:1977 sock_recvmsg_nosec net/socket.c:948 [inline] sock_recvmsg net/socket.c:966 [inline] __sys_recvfrom+0x795/0xa10 net/socket.c:2097 __do_sys_recvfrom net/socket.c:2115 [inline] __se_sys_recvfrom net/socket.c:2111 [inline] __x64_sys_recvfrom+0x19d/0x210 net/socket.c:2111 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x44/0xae Uninit was created at: slab_post_alloc_hook mm/slab.h:737 [inline] slab_alloc_node mm/slub.c:3247 [inline] __kmalloc_node_track_caller+0xe0c/0x1510 mm/slub.c:4975 kmalloc_reserve net/core/skbuff.c:354 [inline] __alloc_skb+0x545/0xf90 net/core/skbuff.c:426 alloc_skb include/linux/skbuff.h:1158 [inline] netlink_dump+0x3e5/0x16c0 net/netlink/af_netlink.c:2248 __netlink_dump_start+0xcf8/0xe90 net/netlink/af_netlink.c:2373 netlink_dump_start include/linux/netlink.h:254 [inline] inet_diag_handler_cmd+0x2e7/0x400 net/ipv4/inet_diag.c:1341 sock_diag_rcv_msg+0x24a/0x620 netlink_rcv_skb+0x40c/0x7e0 net/netlink/af_netlink.c:2494 sock_diag_rcv+0x63/0x80 net/core/sock_diag.c:277 netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline] netlink_unicast+0x1093/0x1360 net/netlink/af_netlink.c:1343 netlink_sendmsg+0x14d9/0x1720 net/netlink/af_netlink.c:1919 sock_sendmsg_nosec net/socket.c:705 [inline] sock_sendmsg net/socket.c:725 [inline] sock_write_iter+0x594/0x690 net/socket.c:1061 do_iter_readv_writev+0xa7f/0xc70 do_iter_write+0x52c/0x1500 fs/read_write.c:851 vfs_writev fs/read_write.c:924 [inline] do_writev+0x645/0xe00 fs/read_write.c:967 __do_sys_writev fs/read_write.c:1040 [inline] __se_sys_writev fs/read_write.c:1037 [inline] __x64_sys_writev+0xe5/0x120 fs/read_write.c:1037 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x44/0xae Bytes 68-71 of 2508 are uninitialized Memory access of size 2508 starts at ffff888114f9b000 Data copied to user address 00007f7fe09ff2e0 CPU: 1 PID: 3478 Comm: syz-executor306 Not tainted 5.17.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.9.307 未満\nLinux Kernel 4.10 以上 4.14.272 未満\nLinux Kernel 4.15 以上 4.19.235 未満\nLinux Kernel 4.20 以上 5.4.185 未満\nLinux Kernel 5.5 以上 5.10.106 未満\nLinux Kernel 5.11 以上 5.15.29 未満\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025179": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: arc_emac: Fix use after free in arc_mdio_probe() If bus->state is equal to MDIOBUS_ALLOCATED, mdiobus_free(bus) will free the \"bus\". But bus->name is still used in the next line, which will lead to a use after free. We can fix it by putting the name in a local variable and make the bus->name point to the rodata section \"name\",then use the name in the error message without referring to bus to avoid the uaf.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025184": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix a race on command flush flow Fix a refcount use after free warning due to a race on command entry. Such race occurs when one of the commands releases its last refcount and frees its index and entry while another process running command flush flow takes refcount to this command entry. The process which handles commands flush may see this command as needed to be flushed if the other process released its refcount but didn't release the index yet. Fix it by adding the needed spin lock. It fixes the following warning trace: refcount_t: addition on 0; use-after-free. WARNING: CPU: 11 PID: 540311 at lib/refcount.c:25 refcount_warn_saturate+0x80/0xe0 ... RIP: 0010:refcount_warn_saturate+0x80/0xe0 ... Call Trace: <TASK> mlx5_cmd_trigger_completions+0x293/0x340 [mlx5_core] mlx5_cmd_flush+0x3a/0xf0 [mlx5_core] enter_error_state+0x44/0x80 [mlx5_core] mlx5_fw_fatal_reporter_err_work+0x37/0xe0 [mlx5_core] process_one_work+0x1be/0x390 worker_thread+0x4d/0x3d0 ? rescuer_thread+0x350/0x350 kthread+0x141/0x160 ? set_kthread_struct+0x40/0x40 ret_from_fork+0x1f/0x30 </TASK>",
        "technologies": "Linux\nLinux Kernel 5.4.185 未満\nLinux Kernel 5.5 以上 5.10.106 未満\nLinux Kernel 5.11 以上 5.15.29 未満\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025213": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: pm8001: Fix use-after-free for aborted SSP/STP sas_task Currently a use-after-free may occur if a sas_task is aborted by the upper layer before we handle the I/O completion in mpi_ssp_completion() or mpi_sata_completion(). In this case, the following are the two steps in handling those I/O completions: - Call complete() to inform the upper layer handler of completion of the I/O. - Release driver resources associated with the sas_task in pm8001_ccb_task_free() call. When complete() is called, the upper layer may free the sas_task. As such, we should not touch the associated sas_task afterwards, but we do so in the pm8001_ccb_task_free() call. Fix by swapping the complete() and pm8001_ccb_task_free() calls ordering.",
        "technologies": "Linux\nLinux Kernel 5.10.102 未満\nLinux Kernel 5.11 以上 5.15.25 未満\nLinux Kernel 5.16 以上 5.16.11 未満"
    },
    "JVNDB-2022-025214": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-tcp: fix possible use-after-free in transport error_recovery work While nvme_tcp_submit_async_event_work is checking the ctrl and queue state before preparing the AER command and scheduling io_work, in order to fully prevent a race where this check is not reliable the error recovery work must flush async_event_work before continuing to destroy the admin queue after setting the ctrl state to RESETTING such that there is no race .submit_async_event and the error recovery handler itself changing the ctrl state.",
        "technologies": "Linux\nLinux Kernel 5.4.181 未満\nLinux Kernel 5.5 以上 5.10.102 未満\nLinux Kernel 5.11 以上 5.15.25 未満\nLinux Kernel 5.16 以上 5.16.11 未満"
    },
    "JVNDB-2022-025216": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-rdma: fix possible use-after-free in transport error_recovery work While nvme_rdma_submit_async_event_work is checking the ctrl and queue state before preparing the AER command and scheduling io_work, in order to fully prevent a race where this check is not reliable the error recovery work must flush async_event_work before continuing to destroy the admin queue after setting the ctrl state to RESETTING such that there is no race .submit_async_event and the error recovery handler itself changing the ctrl state.",
        "technologies": "Linux\nLinux Kernel 4.19.231 未満\nLinux Kernel 4.20 以上 5.4.181 未満\nLinux Kernel 5.5 以上 5.10.102 未満\nLinux Kernel 5.11 以上 5.16.11 未満"
    },
    "JVNDB-2022-025215": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iwlwifi: fix use-after-free If no firmware was present at all (or, presumably, all of the firmware files failed to parse), we end up unbinding by calling device_release_driver(), which calls remove(), which then in iwlwifi calls iwl_drv_stop(), freeing the 'drv' struct. However the new code I added will still erroneously access it after it was freed. Set 'failure=false' in this case to avoid the access, all data was already freed anyway.",
        "technologies": "Linux\nLinux Kernel 4.14.263 以上 4.14.268 未満\nLinux Kernel 4.19.226 以上 4.19.231 未満\nLinux Kernel 5.4.174 以上 5.4.181 未満\nLinux Kernel 5.10.94 以上 5.10.102 未満\nLinux Kernel 5.15.17 以上 5.15.25 未満\nLinux Kernel 5.16.3 以上 5.16.11 未満"
    },
    "JVNDB-2022-025210": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme: fix a possible use-after-free in controller reset during load Unlike .queue_rq, in .submit_async_event drivers may not check the ctrl readiness for AER submission. This may lead to a use-after-free condition that was observed with nvme-tcp. The race condition may happen in the following scenario: 1. driver executes its reset_ctrl_work 2. -> nvme_stop_ctrl - flushes ctrl async_event_work 3. ctrl sends AEN which is received by the host, which in turn schedules AEN handling 4. teardown admin queue (which releases the queue socket) 5. AEN processed, submits another AER, calling the driver to submit 6. driver attempts to send the cmd ==> use-after-free In order to fix that, add ctrl state check to validate the ctrl is actually able to accept the AER submission. This addresses the above race in controller resets because the driver during teardown should: 1. change ctrl state to RESETTING 2. flush async_event_work (as well as other async work elements) So after 1,2, any other AER command will find the ctrl state to be RESETTING and bail out without submitting the AER.",
        "technologies": "Linux\nLinux Kernel 4.19.231 未満\nLinux Kernel 4.20 以上 5.4.181 未満\nLinux Kernel 5.5 以上 5.10.102 未満\nLinux Kernel 5.11 以上 5.15.25 未満\nLinux Kernel 5.16 以上 5.16.11 未満"
    },
    "JVNDB-2022-025211": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommu: Fix potential use-after-free during probe Kasan has reported the following use after free on dev->iommu. when a device probe fails and it is in process of freeing dev->iommu in dev_iommu_free function, a deferred_probe_work_func runs in parallel and tries to access dev->iommu->fwspec in of_iommu_configure path thus causing use after free. BUG: KASAN: use-after-free in of_iommu_configure+0xb4/0x4a4 Read of size 8 at addr ffffff87a2f1acb8 by task kworker/u16:2/153 Workqueue: events_unbound deferred_probe_work_func Call trace: dump_backtrace+0x0/0x33c show_stack+0x18/0x24 dump_stack_lvl+0x16c/0x1e0 print_address_description+0x84/0x39c __kasan_report+0x184/0x308 kasan_report+0x50/0x78 __asan_load8+0xc0/0xc4 of_iommu_configure+0xb4/0x4a4 of_dma_configure_id+0x2fc/0x4d4 platform_dma_configure+0x40/0x5c really_probe+0x1b4/0xb74 driver_probe_device+0x11c/0x228 __device_attach_driver+0x14c/0x304 bus_for_each_drv+0x124/0x1b0 __device_attach+0x25c/0x334 device_initial_probe+0x24/0x34 bus_probe_device+0x78/0x134 deferred_probe_work_func+0x130/0x1a8 process_one_work+0x4c8/0x970 worker_thread+0x5c8/0xaec kthread+0x1f8/0x220 ret_from_fork+0x10/0x18 Allocated by task 1: ____kasan_kmalloc+0xd4/0x114 __kasan_kmalloc+0x10/0x1c kmem_cache_alloc_trace+0xe4/0x3d4 __iommu_probe_device+0x90/0x394 probe_iommu_group+0x70/0x9c bus_for_each_dev+0x11c/0x19c bus_iommu_probe+0xb8/0x7d4 bus_set_iommu+0xcc/0x13c arm_smmu_bus_init+0x44/0x130 [arm_smmu] arm_smmu_device_probe+0xb88/0xc54 [arm_smmu] platform_drv_probe+0xe4/0x13c really_probe+0x2c8/0xb74 driver_probe_device+0x11c/0x228 device_driver_attach+0xf0/0x16c __driver_attach+0x80/0x320 bus_for_each_dev+0x11c/0x19c driver_attach+0x38/0x48 bus_add_driver+0x1dc/0x3a4 driver_register+0x18c/0x244 __platform_driver_register+0x88/0x9c init_module+0x64/0xff4 [arm_smmu] do_one_initcall+0x17c/0x2f0 do_init_module+0xe8/0x378 load_module+0x3f80/0x4a40 __se_sys_finit_module+0x1a0/0x1e4 __arm64_sys_finit_module+0x44/0x58 el0_svc_common+0x100/0x264 do_el0_svc+0x38/0xa4 el0_svc+0x20/0x30 el0_sync_handler+0x68/0xac el0_sync+0x160/0x180 Freed by task 1: kasan_set_track+0x4c/0x84 kasan_set_free_info+0x28/0x4c ____kasan_slab_free+0x120/0x15c __kasan_slab_free+0x18/0x28 slab_free_freelist_hook+0x204/0x2fc kfree+0xfc/0x3a4 __iommu_probe_device+0x284/0x394 probe_iommu_group+0x70/0x9c bus_for_each_dev+0x11c/0x19c bus_iommu_probe+0xb8/0x7d4 bus_set_iommu+0xcc/0x13c arm_smmu_bus_init+0x44/0x130 [arm_smmu] arm_smmu_device_probe+0xb88/0xc54 [arm_smmu] platform_drv_probe+0xe4/0x13c really_probe+0x2c8/0xb74 driver_probe_device+0x11c/0x228 device_driver_attach+0xf0/0x16c __driver_attach+0x80/0x320 bus_for_each_dev+0x11c/0x19c driver_attach+0x38/0x48 bus_add_driver+0x1dc/0x3a4 driver_register+0x18c/0x244 __platform_driver_register+0x88/0x9c init_module+0x64/0xff4 [arm_smmu] do_one_initcall+0x17c/0x2f0 do_init_module+0xe8/0x378 load_module+0x3f80/0x4a40 __se_sys_finit_module+0x1a0/0x1e4 __arm64_sys_finit_module+0x44/0x58 el0_svc_common+0x100/0x264 do_el0_svc+0x38/0xa4 el0_svc+0x20/0x30 el0_sync_handler+0x68/0xac el0_sync+0x160/0x180 Fix this by setting dev->iommu to NULL first and then freeing dev_iommu structure in dev_iommu_free function.",
        "technologies": "Linux\nLinux Kernel 5.10.101 未満\nLinux Kernel 5.11 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満"
    },
    "JVNDB-2022-025194": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: hid-thrustmaster: fix OOB read in thrustmaster_interrupts Syzbot reported an slab-out-of-bounds Read in thrustmaster_probe() bug. The root case is in missing validation check of actual number of endpoints. Code should not blindly access usb_host_interface::endpoint array, since it may contain less endpoints than code expects. Fix it by adding missing validaion check and print an error if number of endpoints do not match expected number",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.29 未満\nLinux Kernel 5.16 以上 5.16.15 未満"
    },
    "JVNDB-2022-025209": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: pm8001: Fix use-after-free for aborted TMF sas_task Currently a use-after-free may occur if a TMF sas_task is aborted before we handle the IO completion in mpi_ssp_completion(). The abort occurs due to timeout. When the timeout occurs, the SAS_TASK_STATE_ABORTED flag is set and the sas_task is freed in pm8001_exec_internal_tmf_task(). However, if the I/O completion occurs later, the I/O completion still thinks that the sas_task is available. Fix this by clearing the ccb->task if the TMF times out - the I/O completion handler does nothing if this pointer is cleared.",
        "technologies": "Linux\nLinux Kernel 5.10.102 未満\nLinux Kernel 5.11 以上 5.15.25 未満\nLinux Kernel 5.16 以上 5.16.11 未満"
    },
    "JVNDB-2022-025218": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: f_fs: Fix use-after-free for epfile Consider a case where ffs_func_eps_disable is called from ffs_func_disable as part of composition switch and at the same time ffs_epfile_release get called from userspace. ffs_epfile_release will free up the read buffer and call ffs_data_closed which in turn destroys ffs->epfiles and mark it as NULL. While this was happening the driver has already initialized the local epfile in ffs_func_eps_disable which is now freed and waiting to acquire the spinlock. Once spinlock is acquired the driver proceeds with the stale value of epfile and tries to free the already freed read buffer causing use-after-free. Following is the illustration of the race: CPU1 CPU2 ffs_func_eps_disable epfiles (local copy) ffs_epfile_release ffs_data_closed if (last file closed) ffs_data_reset ffs_data_clear ffs_epfiles_destroy spin_lock dereference epfiles Fix this races by taking epfiles local copy & assigning it under spinlock and if epfiles(local) is null then update it in ffs->epfiles then finally destroy it. Extending the scope further from the race, protecting the ep related structures, and concurrent accesses.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.14.267 未満\nLinux Kernel 4.15 以上 4.19.230 未満\nLinux Kernel 4.20 以上 5.4.180 未満\nLinux Kernel 5.5 以上 5.10.101 未満\nLinux Kernel 5.11 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満"
    },
    "JVNDB-2022-025330": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/nouveau: fix off by one in BIOS boundary checking Bounds checking when parsing init scripts embedded in the BIOS reject access to the last byte. This causes driver initialization to fail on Apple eMac's with GeForce 2 MX GPUs, leaving the system with no working console. This is probably only seen on OpenFirmware machines like PowerPC Macs because the BIOS image provided by OF is only the used parts of the ROM, not a power-of-two blocks read from PCI directly so PCs always have empty bytes at the end that are never accessed.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.9.300 未満\nLinux Kernel 4.10 以上 4.14.265 未満\nLinux Kernel 4.15 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.178 未満\nLinux Kernel 5.5 以上 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満"
    },
    "JVNDB-2022-025434": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/ucma: Protect mc during concurrent multicast leaves Partially revert the commit mentioned in the Fixes line to make sure that allocation and erasing multicast struct are locked. BUG: KASAN: use-after-free in ucma_cleanup_multicast drivers/infiniband/core/ucma.c:491 [inline] BUG: KASAN: use-after-free in ucma_destroy_private_ctx+0x914/0xb70 drivers/infiniband/core/ucma.c:579 Read of size 8 at addr ffff88801bb74b00 by task syz-executor.1/25529 CPU: 0 PID: 25529 Comm: syz-executor.1 Not tainted 5.16.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c:247 __kasan_report mm/kasan/report.c:433 [inline] kasan_report.cold+0x83/0xdf mm/kasan/report.c:450 ucma_cleanup_multicast drivers/infiniband/core/ucma.c:491 [inline] ucma_destroy_private_ctx+0x914/0xb70 drivers/infiniband/core/ucma.c:579 ucma_destroy_id+0x1e6/0x280 drivers/infiniband/core/ucma.c:614 ucma_write+0x25c/0x350 drivers/infiniband/core/ucma.c:1732 vfs_write+0x28e/0xae0 fs/read_write.c:588 ksys_write+0x1ee/0x250 fs/read_write.c:643 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae Currently the xarray search can touch a concurrently freeing mc as the xa_for_each() is not surrounded by any lock. Rather than hold the lock for a full scan hold it only for the effected items, which is usually an empty list.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025325": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: selinux: fix double free of cond_list on error paths On error path from cond_read_list() and duplicate_policydb_cond_list() the cond_list_destroy() gets called a second time in caller functions, resulting in NULL pointer deref. Fix this by resetting the cond_list_len to 0 in cond_list_destroy(), making subsequent calls a noop. Also consistently reset the cond_list pointer to NULL after freeing. [PM: fix line lengths in the description]",
        "technologies": "Linux\nLinux Kernel 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満"
    },
    "JVNDB-2022-025329": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: hda: Fix UAF of leds class devs at unbinding The LED class devices that are created by HD-audio codec drivers are registered via devm_led_classdev_register() and associated with the HD-audio codec device. Unfortunately, it turned out that the devres release doesn't work for this case; namely, since the codec resource release happens before the devm call chain, it triggers a NULL dereference or a UAF for a stale set_brightness_delay callback. For fixing the bug, this patch changes the LED class device register and unregister in a manual manner without devres, keeping the instances in hda_gen_spec.",
        "technologies": "Linux\nLinux Kernel 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満"
    },
    "JVNDB-2022-025327": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rtnetlink: make sure to refresh master_dev/m_ops in __rtnl_newlink() While looking at one unrelated syzbot bug, I found the replay logic in __rtnl_newlink() to potentially trigger use-after-free. It is better to clear master_dev and m_ops inside the loop, in case we have to replay it.",
        "technologies": "Linux\nLinux Kernel 3.14 以上 4.9.300 未満\nLinux Kernel 4.10 以上 4.14.265 未満\nLinux Kernel 4.15 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.177 未満\nLinux Kernel 5.5 以上 5.10.97 未満\nLinux Kernel 5.11 以上 5.15.20 未満\nLinux Kernel 5.16 以上 5.16.6 未満"
    },
    "JVNDB-2022-025340": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mtd: rawnand: gpmi: don't leak PM reference in error path If gpmi_nfc_apply_timings() fails, the PM runtime usage counter must be dropped.",
        "technologies": "Linux\nLinux Kernel 5.4.174 以上 5.4.181 未満\nLinux Kernel 5.10.94 以上 5.10.102 未満\nLinux Kernel 5.15.17 以上 5.15.25 未満\nLinux Kernel 5.16.3 以上 5.16.11 未満"
    },
    "JVNDB-2022-025339": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: mscc: ocelot: fix use-after-free in ocelot_vlan_del() ocelot_vlan_member_del() will free the struct ocelot_bridge_vlan, so if this is the same as the port's pvid_vlan which we access afterwards, what we're accessing is freed memory. Fix the bug by determining whether to clear ocelot_port->pvid_vlan prior to calling ocelot_vlan_member_del().",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.16.11 未満"
    },
    "JVNDB-2022-025399": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tty: serial: qcom-geni-serial: fix slab-out-of-bounds on RX FIFO buffer Driver's probe allocates memory for RX FIFO (port->rx_fifo) based on default RX FIFO depth, e.g. 16. Later during serial startup the qcom_geni_serial_port_setup() updates the RX FIFO depth (port->rx_fifo_depth) to match real device capabilities, e.g. to 32. The RX UART handle code will read \"port->rx_fifo_depth\" number of words into \"port->rx_fifo\" buffer, thus exceeding the bounds. This can be observed in certain configurations with Qualcomm Bluetooth HCI UART device and KASAN: Bluetooth: hci0: QCA Product ID :0x00000010 Bluetooth: hci0: QCA SOC Version :0x400a0200 Bluetooth: hci0: QCA ROM Version :0x00000200 Bluetooth: hci0: QCA Patch Version:0x00000d2b Bluetooth: hci0: QCA controller version 0x02000200 Bluetooth: hci0: QCA Downloading qca/htbtfw20.tlv bluetooth hci0: Direct firmware load for qca/htbtfw20.tlv failed with error -2 Bluetooth: hci0: QCA Failed to request file: qca/htbtfw20.tlv (-2) Bluetooth: hci0: QCA Failed to download patch (-2) ================================================================== BUG: KASAN: slab-out-of-bounds in handle_rx_uart+0xa8/0x18c Write of size 4 at addr ffff279347d578c0 by task swapper/0/0 CPU: 0 PID: 0 Comm: swapper/0 Not tainted 6.1.0-rt5-00350-gb2450b7e00be-dirty #26 Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT) Call trace: dump_backtrace.part.0+0xe0/0xf0 show_stack+0x18/0x40 dump_stack_lvl+0x8c/0xb8 print_report+0x188/0x488 kasan_report+0xb4/0x100 __asan_store4+0x80/0xa4 handle_rx_uart+0xa8/0x18c qcom_geni_serial_handle_rx+0x84/0x9c qcom_geni_serial_isr+0x24c/0x760 __handle_irq_event_percpu+0x108/0x500 handle_irq_event+0x6c/0x110 handle_fasteoi_irq+0x138/0x2cc generic_handle_domain_irq+0x48/0x64 If the RX FIFO depth changes after probe, be sure to resize the buffer.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.165 未満\nLinux Kernel 5.11 以上 5.15.90 未満\nLinux Kernel 5.16 以上 6.1.8 未満"
    },
    "JVNDB-2022-025395": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: fastrpc: Don't remove map on creater_process and device_release Do not remove the map from the list on error path in fastrpc_init_create_process, instead call fastrpc_map_put, to avoid use-after-free. Do not remove it on fastrpc_device_release either, call fastrpc_map_put instead. The fastrpc_free_map is the only proper place to remove the map. This is called only after the reference count is 0.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.230 未満\nLinux Kernel 5.5 以上 5.10.165 未満\nLinux Kernel 5.11 以上 5.15.90 未満\nLinux Kernel 5.16 以上 6.1.8 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-025331": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free after failure to create a snapshot At ioctl.c:create_snapshot(), we allocate a pending snapshot structure and then attach it to the transaction's list of pending snapshots. After that we call btrfs_commit_transaction(), and if that returns an error we jump to 'fail' label, where we kfree() the pending snapshot structure. This can result in a later use-after-free of the pending snapshot: 1) We allocated the pending snapshot and added it to the transaction's list of pending snapshots; 2) We call btrfs_commit_transaction(), and it fails either at the first call to btrfs_run_delayed_refs() or btrfs_start_dirty_block_groups(). In both cases, we don't abort the transaction and we release our transaction handle. We jump to the 'fail' label and free the pending snapshot structure. We return with the pending snapshot still in the transaction's list; 3) Another task commits the transaction. This time there's no error at all, and then during the transaction commit it accesses a pointer to the pending snapshot structure that the snapshot creation task has already freed, resulting in a user-after-free. This issue could actually be detected by smatch, which produced the following warning: fs/btrfs/ioctl.c:843 create_snapshot() warn: '&pending_snapshot->list' not removed from list So fix this by not having the snapshot creation ioctl directly add the pending snapshot to the transaction's list. Instead add the pending snapshot to the transaction handle, and then at btrfs_commit_transaction() we add the snapshot to the list only when we can guarantee that any error returned after that point will result in a transaction abort, in which case the ioctl code can safely free the pending snapshot and no one can access it anymore.",
        "technologies": "Linux\nLinux Kernel 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満"
    },
    "JVNDB-2022-025338": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mctp: fix use after free Clang static analysis reports this problem route.c:425:4: warning: Use of memory after it is freed trace_mctp_key_acquire(key); ^~~~~~~~~~~~~~~~~~~~~~~~~~~ When mctp_key_add() fails, key is freed but then is later used in trace_mctp_key_acquire(). Add an else statement to use the key only when mctp_key_add() is successful.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.16.11 未満"
    },
    "JVNDB-2022-025472": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: libbpf: Handle size overflow for ringbuf mmap The maximum size of ringbuf is 2GB on x86-64 host, so 2 * max_entries will overflow u32 when mapping producer page and data pages. Only casting max_entries to size_t is not enough, because for 32-bits application on 64-bits kernel the size of read-only mmap region also could overflow size_t. So fixing it by casting the size of read-only mmap region into a __u64 and checking whether or not there will be overflow during mmap.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025488": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/shmem-helper: Remove errant put in error path drm_gem_shmem_mmap() doesn't own this reference, resulting in the GEM object getting prematurely freed leading to a later use-after-free.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025479": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (ibmpex) Fix possible UAF when ibmpex_register_bmc() fails Smatch report warning as follows: drivers/hwmon/ibmpex.c:509 ibmpex_register_bmc() warn: '&data->list' not removed from list If ibmpex_find_sensors() fails in ibmpex_register_bmc(), data will be freed, but data->list will not be removed from driver_data.bmc_data, then list traversal may cause UAF. Fix by removeing it from driver_data.bmc_data before free().",
        "technologies": "Linux\nLinux Kernel 2.6.24 以上 4.9.335 未満\nLinux Kernel 4.10 以上 4.14.301 未満\nLinux Kernel 4.15 以上 4.19.268 未満\nLinux Kernel 4.20 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025484": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFC: nci: Bounds check struct nfc_target arrays While running under CONFIG_FORTIFY_SOURCE=y, syzkaller reported: memcpy: detected field-spanning write (size 129) of single field \"target->sensf_res\" at net/nfc/nci/ntf.c:260 (size 18) This appears to be a legitimate lack of bounds checking in nci_add_new_protocol(). Add the missing checks.",
        "technologies": "Linux\nLinux Kernel 3.4 以上 4.9.336 未満\nLinux Kernel 4.10 以上 4.14.302 未満\nLinux Kernel 4.15 以上 4.19.269 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025503": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/qeth: fix use-after-free in hsci KASAN found that addr was dereferenced after br2dev_event_work was freed. ================================================================== BUG: KASAN: use-after-free in qeth_l2_br2dev_worker+0x5ba/0x6b0 Read of size 1 at addr 00000000fdcea440 by task kworker/u760:4/540 CPU: 17 PID: 540 Comm: kworker/u760:4 Tainted: G E 6.1.0-20221128.rc7.git1.5aa3bed4ce83.300.fc36.s390x+kasan #1 Hardware name: IBM 8561 T01 703 (LPAR) Workqueue: 0.0.8000_event qeth_l2_br2dev_worker Call Trace: [<000000016944d4ce>] dump_stack_lvl+0xc6/0xf8 [<000000016942cd9c>] print_address_description.constprop.0+0x34/0x2a0 [<000000016942d118>] print_report+0x110/0x1f8 [<0000000167a7bd04>] kasan_report+0xfc/0x128 [<000000016938d79a>] qeth_l2_br2dev_worker+0x5ba/0x6b0 [<00000001673edd1e>] process_one_work+0x76e/0x1128 [<00000001673ee85c>] worker_thread+0x184/0x1098 [<000000016740718a>] kthread+0x26a/0x310 [<00000001672c606a>] __ret_from_fork+0x8a/0xe8 [<00000001694711da>] ret_from_fork+0xa/0x40 Allocated by task 108338: kasan_save_stack+0x40/0x68 kasan_set_track+0x36/0x48 __kasan_kmalloc+0xa0/0xc0 qeth_l2_switchdev_event+0x25a/0x738 atomic_notifier_call_chain+0x9c/0xf8 br_switchdev_fdb_notify+0xf4/0x110 fdb_notify+0x122/0x180 fdb_add_entry.constprop.0.isra.0+0x312/0x558 br_fdb_add+0x59e/0x858 rtnl_fdb_add+0x58a/0x928 rtnetlink_rcv_msg+0x5f8/0x8d8 netlink_rcv_skb+0x1f2/0x408 netlink_unicast+0x570/0x790 netlink_sendmsg+0x752/0xbe0 sock_sendmsg+0xca/0x110 ____sys_sendmsg+0x510/0x6a8 ___sys_sendmsg+0x12a/0x180 __sys_sendmsg+0xe6/0x168 __do_sys_socketcall+0x3c8/0x468 do_syscall+0x22c/0x328 __do_syscall+0x94/0xf0 system_call+0x82/0xb0 Freed by task 540: kasan_save_stack+0x40/0x68 kasan_set_track+0x36/0x48 kasan_save_free_info+0x4c/0x68 ____kasan_slab_free+0x14e/0x1a8 __kasan_slab_free+0x24/0x30 __kmem_cache_free+0x168/0x338 qeth_l2_br2dev_worker+0x154/0x6b0 process_one_work+0x76e/0x1128 worker_thread+0x184/0x1098 kthread+0x26a/0x310 __ret_from_fork+0x8a/0xe8 ret_from_fork+0xa/0x40 Last potentially related work creation: kasan_save_stack+0x40/0x68 __kasan_record_aux_stack+0xbe/0xd0 insert_work+0x56/0x2e8 __queue_work+0x4ce/0xd10 queue_work_on+0xf4/0x100 qeth_l2_switchdev_event+0x520/0x738 atomic_notifier_call_chain+0x9c/0xf8 br_switchdev_fdb_notify+0xf4/0x110 fdb_notify+0x122/0x180 fdb_add_entry.constprop.0.isra.0+0x312/0x558 br_fdb_add+0x59e/0x858 rtnl_fdb_add+0x58a/0x928 rtnetlink_rcv_msg+0x5f8/0x8d8 netlink_rcv_skb+0x1f2/0x408 netlink_unicast+0x570/0x790 netlink_sendmsg+0x752/0xbe0 sock_sendmsg+0xca/0x110 ____sys_sendmsg+0x510/0x6a8 ___sys_sendmsg+0x12a/0x180 __sys_sendmsg+0xe6/0x168 __do_sys_socketcall+0x3c8/0x468 do_syscall+0x22c/0x328 __do_syscall+0x94/0xf0 system_call+0x82/0xb0 Second to last potentially related work creation: kasan_save_stack+0x40/0x68 __kasan_record_aux_stack+0xbe/0xd0 kvfree_call_rcu+0xb2/0x760 kernfs_unlink_open_file+0x348/0x430 kernfs_fop_release+0xc2/0x320 __fput+0x1ae/0x768 task_work_run+0x1bc/0x298 exit_to_user_mode_prepare+0x1a0/0x1a8 __do_syscall+0x94/0xf0 system_call+0x82/0xb0 The buggy address belongs to the object at 00000000fdcea400 which belongs to the cache kmalloc-96 of size 96 The buggy address is located 64 bytes inside of 96-byte region [00000000fdcea400, 00000000fdcea460) The buggy address belongs to the physical page: page:000000005a9c26e8 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xfdcea flags: 0x3ffff00000000200(slab|node=0|zone=1|lastcpupid=0x1ffff) raw: 3ffff00000000200 0000000000000000 0000000100000122 000000008008cc00 raw: 0000000000000000 0020004100000000 ffffffff00000001 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: 00000000fdcea300: fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc 00000000fdcea380: fb fb fb fb fb fb f ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025481": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: mvneta: Prevent out of bounds read in mvneta_config_rss() The pp->indir[0] value comes from the user. It is passed to: if (cpu_online(pp->rxq_def)) inside the mvneta_percpu_elect() function. It needs bounds checkeding to ensure that it is not beyond the end of the cpu bitmap.",
        "technologies": "Linux\nLinux Kernel 4.5 以上 4.9.336 未満\nLinux Kernel 4.10 以上 4.14.302 未満\nLinux Kernel 4.15 以上 4.19.269 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025500": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix use-after-free during gpu recovery [Why] [ 754.862560] refcount_t: underflow; use-after-free. [ 754.862898] Call Trace: [ 754.862903] <TASK> [ 754.862913] amdgpu_job_free_cb+0xc2/0xe1 [amdgpu] [ 754.863543] drm_sched_main.cold+0x34/0x39 [amd_sched] [How] The fw_fence may be not init, check whether dma_fence_init is performed before job free",
        "technologies": "Linux\nLinux Kernel 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025492": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: perf: Fix perf_pending_task() UaF Per syzbot it is possible for perf_pending_task() to run after the event is free()'d. There are two related but distinct cases: - the task_work was already queued before destroying the event; - destroying the event itself queues the task_work. The first cannot be solved using task_work_cancel() since perf_release() itself might be called from a task_work (____fput), which means the current->task_works list is already empty and task_work_cancel() won't be able to find the perf_pending_task() entry. The simplest alternative is extending the perf_event lifetime to cover the task_work. The second is just silly, queueing a task_work while you know the event is going away makes no sense and is easily avoided by re-arranging how the event is marked STATE_DEAD and ensuring it goes through STATE_OFF on the way down.",
        "technologies": "Linux\nLinux Kernel 5.15.84 未満\nLinux Kernel 5.16 以上 6.0.14 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025478": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: health: afe4403: Fix oob read in afe4403_read_raw KASAN report out-of-bounds read as follows: BUG: KASAN: global-out-of-bounds in afe4403_read_raw+0x42e/0x4c0 Read of size 4 at addr ffffffffc02ac638 by task cat/279 Call Trace: afe4403_read_raw iio_read_channel_info dev_attr_show The buggy address belongs to the variable: afe4403_channel_leds+0x18/0xffffffffffffe9e0 This issue can be reproduced by singe command: $ cat /sys/bus/spi/devices/spi0.0/iio\\:device0/in_intensity6_raw The array size of afe4403_channel_leds is less than channels, so access with chan->address cause OOB read in afe4403_read_raw. Fix it by moving access before use it.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.9.335 未満\nLinux Kernel 4.10 以上 4.14.301 未満\nLinux Kernel 4.15 以上 4.19.268 未満\nLinux Kernel 4.20 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025504": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hisilicon: Fix potential use-after-free in hisi_femac_rx() The skb is delivered to napi_gro_receive() which may free it, after calling this, dereferencing skb may trigger use-after-free.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.9.336 未満\nLinux Kernel 4.10 以上 4.14.302 未満\nLinux Kernel 4.15 以上 4.19.269 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025517": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hisilicon: Fix potential use-after-free in hix5hd2_rx() The skb is delivered to napi_gro_receive() which may free it, after calling this, dereferencing skb may trigger use-after-free.",
        "technologies": "Linux\nLinux Kernel 3.16 以上 4.9.336 未満\nLinux Kernel 4.10 以上 4.14.302 未満\nLinux Kernel 4.15 以上 4.19.269 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025506": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: ops: Check bounds for second channel in snd_soc_put_volsw_sx() The bounds checks in snd_soc_put_volsw_sx() are only being applied to the first channel, meaning it is possible to write out of bounds values to the second channel in stereo controls. Add appropriate checks.",
        "technologies": "Linux\nLinux Kernel 4.9.337 未満\nLinux Kernel 4.10 以上 4.14.303 未満\nLinux Kernel 4.15 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.228 未満\nLinux Kernel 5.5 以上 5.10.160 未満\nLinux Kernel 5.11 以上 5.15.84 未満\nLinux Kernel 5.16 以上 6.0.14 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025523": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: tun: Fix use-after-free in tun_detach() syzbot reported use-after-free in tun_detach() [1]. This causes call trace like below: ================================================================== BUG: KASAN: use-after-free in notifier_call_chain+0x1ee/0x200 kernel/notifier.c:75 Read of size 8 at addr ffff88807324e2a8 by task syz-executor.0/3673 CPU: 0 PID: 3673 Comm: syz-executor.0 Not tainted 6.1.0-rc5-syzkaller-00044-gcc675d22e422 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:284 [inline] print_report+0x15e/0x461 mm/kasan/report.c:395 kasan_report+0xbf/0x1f0 mm/kasan/report.c:495 notifier_call_chain+0x1ee/0x200 kernel/notifier.c:75 call_netdevice_notifiers_info+0x86/0x130 net/core/dev.c:1942 call_netdevice_notifiers_extack net/core/dev.c:1983 [inline] call_netdevice_notifiers net/core/dev.c:1997 [inline] netdev_wait_allrefs_any net/core/dev.c:10237 [inline] netdev_run_todo+0xbc6/0x1100 net/core/dev.c:10351 tun_detach drivers/net/tun.c:704 [inline] tun_chr_close+0xe4/0x190 drivers/net/tun.c:3467 __fput+0x27c/0xa90 fs/file_table.c:320 task_work_run+0x16f/0x270 kernel/task_work.c:179 exit_task_work include/linux/task_work.h:38 [inline] do_exit+0xb3d/0x2a30 kernel/exit.c:820 do_group_exit+0xd4/0x2a0 kernel/exit.c:950 get_signal+0x21b1/0x2440 kernel/signal.c:2858 arch_do_signal_or_restart+0x86/0x2300 arch/x86/kernel/signal.c:869 exit_to_user_mode_loop kernel/entry/common.c:168 [inline] exit_to_user_mode_prepare+0x15f/0x250 kernel/entry/common.c:203 __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline] syscall_exit_to_user_mode+0x1d/0x50 kernel/entry/common.c:296 do_syscall_64+0x46/0xb0 arch/x86/entry/common.c:86 entry_SYSCALL_64_after_hwframe+0x63/0xcd The cause of the issue is that sock_put() from __tun_detach() drops last reference count for struct net, and then notifier_call_chain() from netdev_state_change() accesses that struct net. This patch fixes the issue by calling sock_put() from tun_detach() after all necessary accesses for the struct net has done.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.268 未満\nLinux Kernel 4.20 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025526": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix use-after-free when reverting termination table When having multiple dests with termination tables and second one or afterwards fails the driver reverts usage of term tables but doesn't reset the assignment in attr->dests[num_vport_dests].termtbl which case a use-after-free when releasing the rule. Fix by resetting the assignment of termtbl to null.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025520": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: e100: Fix possible use after free in e100_xmit_prepare In e100_xmit_prepare(), if we can't map the skb, then return -ENOMEM, so e100_xmit_frame() will return NETDEV_TX_BUSY and the upper layer will resend the skb. But the skb is already freed, which will cause UAF bug when the upper layer resends the skb. Remove the harmful free.",
        "technologies": "Linux\nLinux Kernel 4.3 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025518": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ravb: Fix potential use-after-free in ravb_rx_gbeth() The skb is delivered to napi_gro_receive() which may free it, after calling this, dereferencing skb may trigger use-after-free.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025524": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tipc: re-fetch skb cb after tipc_msg_validate As the call trace shows, the original skb was freed in tipc_msg_validate(), and dereferencing the old skb cb would cause an use-after-free crash. BUG: KASAN: use-after-free in tipc_crypto_rcv_complete+0x1835/0x2240 [tipc] Call Trace: <IRQ> tipc_crypto_rcv_complete+0x1835/0x2240 [tipc] tipc_crypto_rcv+0xd32/0x1ec0 [tipc] tipc_rcv+0x744/0x1150 [tipc] ... Allocated by task 47078: kmem_cache_alloc_node+0x158/0x4d0 __alloc_skb+0x1c1/0x270 tipc_buf_acquire+0x1e/0xe0 [tipc] tipc_msg_create+0x33/0x1c0 [tipc] tipc_link_build_proto_msg+0x38a/0x2100 [tipc] tipc_link_timeout+0x8b8/0xef0 [tipc] tipc_node_timeout+0x2a1/0x960 [tipc] call_timer_fn+0x2d/0x1c0 ... Freed by task 47078: tipc_msg_validate+0x7b/0x440 [tipc] tipc_crypto_rcv_complete+0x4b5/0x2240 [tipc] tipc_crypto_rcv+0xd32/0x1ec0 [tipc] tipc_rcv+0x744/0x1150 [tipc] This patch fixes it by re-fetching the skb cb from the new allocated skb after calling tipc_msg_validate().",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025529": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: uvc: Prevent buffer overflow in setup handler Setup function uvc_function_setup permits control transfer requests with up to 64 bytes of payload (UVC_MAX_REQUEST_SIZE), data stage handler for OUT transfer uses memcpy to copy req->actual bytes to uvc_event->data.data array of size 60. This may result in an overflow of 4 bytes.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.9.337 未満\nLinux Kernel 4.10 以上 4.14.303 未満\nLinux Kernel 4.15 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.229 未満\nLinux Kernel 5.5 以上 5.10.161 未満\nLinux Kernel 5.11 以上 5.15.85 未満\nLinux Kernel 5.16 以上 6.0.15 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025536": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv: fix race when vmap stack overflow Currently, when detecting vmap stack overflow, riscv firstly switches to the so called shadow stack, then use this shadow stack to call the get_overflow_stack() to get the overflow stack. However, there's a race here if two or more harts use the same shadow stack at the same time. To solve this race, we introduce spin_shadow_stack atomic var, which will be swap between its own address and 0 in atomic way, when the var is set, it means the shadow_stack is being used; when the var is cleared, it means the shadow_stack isn't being used. [Palmer: Add AQ to the swap, and also some comments.]",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025528": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: health: afe4404: Fix oob read in afe4404_[read|write]_raw KASAN report out-of-bounds read as follows: BUG: KASAN: global-out-of-bounds in afe4404_read_raw+0x2ce/0x380 Read of size 4 at addr ffffffffc00e4658 by task cat/278 Call Trace: afe4404_read_raw iio_read_channel_info dev_attr_show The buggy address belongs to the variable: afe4404_channel_leds+0x18/0xffffffffffffe9c0 This issue can be reproduce by singe command: $ cat /sys/bus/i2c/devices/0-0058/iio\\:device0/in_intensity6_raw The array size of afe4404_channel_leds and afe4404_channel_offdacs are less than channels, so access with chan->address cause OOB read in afe4404_[read|write]_raw. Fix it by moving access before use them.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.9.335 未満\nLinux Kernel 4.10 以上 4.14.301 未満\nLinux Kernel 4.15 以上 4.19.268 未満\nLinux Kernel 4.20 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025553": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/khugepaged: invoke MMU notifiers in shmem/file collapse paths Any codepath that zaps page table entries must invoke MMU notifiers to ensure that secondary MMUs (like KVM) don't keep accessing pages which aren't mapped anymore. Secondary MMUs don't hold their own references to pages that are mirrored over, so failing to notify them can lead to page use-after-free. I'm marking this as addressing an issue introduced in commit f3f0e1d2150b (\"khugepaged: add support of collapse for tmpfs/shmem pages\"), but most of the security impact of this only came in commit 27e1f8273113 (\"khugepaged: enable collapse pmd for pte-mapped THP\"), which actually omitted flushes for the removal of present PTEs, not just for the removal of empty page tables.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.9.337 未満\nLinux Kernel 4.10 以上 4.14.303 未満\nLinux Kernel 4.15 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025534": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing: Free buffers when a used dynamic event is removed After 65536 dynamic events have been added and removed, the \"type\" field of the event then uses the first type number that is available (not currently used by other events). A type number is the identifier of the binary blobs in the tracing ring buffer (known as events) to map them to logic that can parse the binary blob. The issue is that if a dynamic event (like a kprobe event) is traced and is in the ring buffer, and then that event is removed (because it is dynamic, which means it can be created and destroyed), if another dynamic event is created that has the same number that new event's logic on parsing the binary blob will be used. To show how this can be an issue, the following can crash the kernel: # cd /sys/kernel/tracing # for i in `seq 65536`; do echo 'p:kprobes/foo do_sys_openat2 $arg1:u32' > kprobe_events # done For every iteration of the above, the writing to the kprobe_events will remove the old event and create a new one (with the same format) and increase the type number to the next available on until the type number reaches over 65535 which is the max number for the 16 bit type. After it reaches that number, the logic to allocate a new number simply looks for the next available number. When an dynamic event is removed, that number is then available to be reused by the next dynamic event created. That is, once the above reaches the max number, the number assigned to the event in that loop will remain the same. Now that means deleting one dynamic event and created another will reuse the previous events type number. This is where bad things can happen. After the above loop finishes, the kprobes/foo event which reads the do_sys_openat2 function call's first parameter as an integer. # echo 1 > kprobes/foo/enable # cat /etc/passwd > /dev/null # cat trace cat-2211 [005] .... 2007.849603: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 cat-2211 [005] .... 2007.849620: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 cat-2211 [005] .... 2007.849838: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 cat-2211 [005] .... 2007.849880: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 # echo 0 > kprobes/foo/enable Now if we delete the kprobe and create a new one that reads a string: # echo 'p:kprobes/foo do_sys_openat2 +0($arg2):string' > kprobe_events And now we can the trace: # cat trace sendmail-1942 [002] ..... 530.136320: foo: (do_sys_openat2+0x0/0x240) arg1= cat-2046 [004] ..... 530.930817: foo: (do_sys_openat2+0x0/0x240) arg1=\"������������������������������������������������������������������������������������������������\" cat-2046 [004] ..... 530.930961: foo: (do_sys_openat2+0x0/0x240) arg1=\"������������������������������������������������������������������������������������������������\" cat-2046 [004] ..... 530.934278: foo: (do_sys_openat2+0x0/0x240) arg1=\"������������������������������������������������������������������������������������������������\" cat-2046 [004] ..... 530.934563: foo: (do_sys_openat2+0x0/0x240) arg1=\"��������������������������������������� ---truncated---",
        "technologies": "Linux\nLinux Kernel 2.6.33 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025549": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: memcg: fix possible use-after-free in memcg_write_event_control() memcg_write_event_control() accesses the dentry->d_name of the specified control fd to route the write call. As a cgroup interface file can't be renamed, it's safe to access d_name as long as the specified file is a regular cgroup file. Also, as these cgroup interface files can't be removed before the directory, it's safe to access the parent too. Prior to 347c4a874710 (\"memcg: remove cgroup_event->cft\"), there was a call to __file_cft() which verified that the specified file is a regular cgroupfs file before further accesses. The cftype pointer returned from __file_cft() was no longer necessary and the commit inadvertently dropped the file type check with it allowing any file to slip through. With the invarients broken, the d_name and parent accesses can now race against renames and removals of arbitrary files and cause use-after-free's. Fix the bug by resurrecting the file type check in __file_cft(). Now that cgroupfs is implemented through kernfs, checking the file operations needs to go through a layer of indirection. Instead, let's check the superblock and dentry type.",
        "technologies": "Linux\nLinux Kernel 3.14 以上 4.14.302 未満\nLinux Kernel 4.15 以上 4.19.269 未満\nLinux Kernel 4.20 以上 5.4.227 未満\nLinux Kernel 5.5 以上 5.10.159 未満\nLinux Kernel 5.11 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025542": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv4: Handle attempt to delete multipath route when fib_info contains an nh reference Gwangun Jung reported a slab-out-of-bounds access in fib_nh_match: fib_nh_match+0xf98/0x1130 linux-6.0-rc7/net/ipv4/fib_semantics.c:961 fib_table_delete+0x5f3/0xa40 linux-6.0-rc7/net/ipv4/fib_trie.c:1753 inet_rtm_delroute+0x2b3/0x380 linux-6.0-rc7/net/ipv4/fib_frontend.c:874 Separate nexthop objects are mutually exclusive with the legacy multipath spec. Fix fib_nh_match to return if the config for the to be deleted route contains a multipath spec while the fib_info is using a nexthop object.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.226 未満\nLinux Kernel 5.5 以上 5.10.158 未満\nLinux Kernel 5.11 以上 5.15.82 未満\nLinux Kernel 5.16 以上 6.0.12 未満"
    },
    "JVNDB-2022-025532": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dsa: sja1105: avoid out of bounds access in sja1105_init_l2_policing() The SJA1105 family has 45 L2 policing table entries (SJA1105_MAX_L2_POLICING_COUNT) and SJA1110 has 110 (SJA1110_MAX_L2_POLICING_COUNT). Keeping the table structure but accounting for the difference in port count (5 in SJA1105 vs 10 in SJA1110) does not fully explain the difference. Rather, the SJA1110 also has L2 ingress policers for multicast traffic. If a packet is classified as multicast, it will be processed by the policer index 99 + SRCPORT. The sja1105_init_l2_policing() function initializes all L2 policers such that they don't interfere with normal packet reception by default. To have a common code between SJA1105 and SJA1110, the index of the multicast policer for the port is calculated because it's an index that is out of bounds for SJA1105 but in bounds for SJA1110, and a bounds check is performed. The code fails to do the proper thing when determining what to do with the multicast policer of port 0 on SJA1105 (ds->num_ports = 5). The \"mcast\" index will be equal to 45, which is also equal to table->ops->max_entry_count (SJA1105_MAX_L2_POLICING_COUNT). So it passes through the check. But at the same time, SJA1105 doesn't have multicast policers. So the code programs the SHARINDX field of an out-of-bounds element in the L2 Policing table of the static config. The comparison between index 45 and 45 entries should have determined the code to not access this policer index on SJA1105, since its memory wasn't even allocated. With enough bad luck, the out-of-bounds write could even overwrite other valid kernel data, but in this case, the issue was detected using KASAN. Kernel log: sja1105 spi5.0: Probed switch chip: SJA1105Q ================================================================== BUG: KASAN: slab-out-of-bounds in sja1105_setup+0x1cbc/0x2340 Write of size 8 at addr ffffff880bd57708 by task kworker/u8:0/8 ... Workqueue: events_unbound deferred_probe_work_func Call trace: ... sja1105_setup+0x1cbc/0x2340 dsa_register_switch+0x1284/0x18d0 sja1105_probe+0x748/0x840 ... Allocated by task 8: ... sja1105_setup+0x1bcc/0x2340 dsa_register_switch+0x1284/0x18d0 sja1105_probe+0x748/0x840 ...",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.83 未満\nLinux Kernel 5.16 以上 6.0.13 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025558": {
        "title": "Linux Foundation の Harbor における不正な認証に関する脆弱性",
        "description": "Harbor fails to validate the user permissions when updating tag immutability policies.  By sending a request to update a tag immutability policy with an id that belongs to a project that the currently authenticated user doesn’t have access to, the attacker could modify tag immutability policies configured in other projects.",
        "technologies": "Linux Foundation\nHarbor 2.0.0 以上 2.4.3 未満\nHarbor 2.5.0 以上 2.5.2 未満"
    },
    "JVNDB-2022-025557": {
        "title": "Linux Foundation の Harbor における不正な認証に関する脆弱性",
        "description": "Harbor fails to validate user permissions when reading and updating job execution logs through the P2P preheat execution logs. By sending a request that attempts to read/update P2P preheat execution logs and specifying different job IDs, malicious authenticated users could read all the job logs stored in the Harbor database.",
        "technologies": "Linux Foundation\nHarbor 2.0.0 以上 2.4.3 未満\nHarbor 2.5.0 以上 2.5.2 未満"
    },
    "JVNDB-2022-025584": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: hdmi-codec: Fix OOB memory accesses Correct size of iec_status array by changing it to the size of status array of the struct snd_aes_iec958. This fixes out-of-bounds slab read accesses made by memcpy() of the hdmi-codec driver. This problem is reported by KASAN.",
        "technologies": "Linux\nLinux Kernel 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025555": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/bpf/32: Fix Oops on tail call tests test_bpf tail call tests end up as: test_bpf: #0 Tail call leaf jited:1 85 PASS test_bpf: #1 Tail call 2 jited:1 111 PASS test_bpf: #2 Tail call 3 jited:1 145 PASS test_bpf: #3 Tail call 4 jited:1 170 PASS test_bpf: #4 Tail call load/store leaf jited:1 190 PASS test_bpf: #5 Tail call load/store jited:1 BUG: Unable to handle kernel data access on write at 0xf1b4e000 Faulting instruction address: 0xbe86b710 Oops: Kernel access of bad area, sig: 11 [#1] BE PAGE_SIZE=4K MMU=Hash PowerMac Modules linked in: test_bpf(+) CPU: 0 PID: 97 Comm: insmod Not tainted 6.1.0-rc4+ #195 Hardware name: PowerMac3,1 750CL 0x87210 PowerMac NIP: be86b710 LR: be857e88 CTR: be86b704 REGS: f1b4df20 TRAP: 0300 Not tainted (6.1.0-rc4+) MSR: 00009032 <EE,ME,IR,DR,RI> CR: 28008242 XER: 00000000 DAR: f1b4e000 DSISR: 42000000 GPR00: 00000001 f1b4dfe0 c11d2280 00000000 00000000 00000000 00000002 00000000 GPR08: f1b4e000 be86b704 f1b4e000 00000000 00000000 100d816a f2440000 fe73baa8 GPR16: f2458000 00000000 c1941ae4 f1fe2248 00000045 c0de0000 f2458030 00000000 GPR24: 000003e8 0000000f f2458000 f1b4dc90 3e584b46 00000000 f24466a0 c1941a00 NIP [be86b710] 0xbe86b710 LR [be857e88] __run_one+0xec/0x264 [test_bpf] Call Trace: [f1b4dfe0] [00000002] 0x2 (unreliable) Instruction dump: XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX ---[ end trace 0000000000000000 ]--- This is a tentative to write above the stack. The problem is encoutered with tests added by commit 38608ee7b690 (\"bpf, tests: Add load store test case for tail call\") This happens because tail call is done to a BPF prog with a different stack_depth. At the time being, the stack is kept as is when the caller tail calls its callee. But at exit, the callee restores the stack based on its own properties. Therefore here, at each run, r1 is erroneously increased by 32 - 16 = 16 bytes. This was done that way in order to pass the tail call count from caller to callee through the stack. As powerpc32 doesn't have a red zone in the stack, it was necessary the maintain the stack as is for the tail call. But it was not anticipated that the BPF frame size could be different. Let's take a new approach. Use register r4 to carry the tail call count during the tail call, and save it into the stack at function entry if required. This means the input parameter must be in r3, which is more correct as it is a 32 bits parameter, then tail call better match with normal BPF function entry, the down side being that we move that input parameter back and forth between r3 and r4. That can be optimised later. Doing that also has the advantage of maximising the common parts between tail calls and a normal function exit. With the fix, tail call tests are now successfull: test_bpf: #0 Tail call leaf jited:1 53 PASS test_bpf: #1 Tail call 2 jited:1 115 PASS test_bpf: #2 Tail call 3 jited:1 154 PASS test_bpf: #3 Tail call 4 jited:1 165 PASS test_bpf: #4 Tail call load/store leaf jited:1 101 PASS test_bpf: #5 Tail call load/store jited:1 141 PASS test_bpf: #6 Tail call error path, max count reached jited:1 994 PASS test_bpf: #7 Tail call count preserved across function calls jited:1 140975 PASS test_bpf: #8 Tail call error path, NULL target jited:1 110 PASS test_bpf: #9 Tail call error path, index out of range jited:1 69 PASS test_bpf: test_tail_calls: Summary: 10 PASSED, 0 FAILED, [10/10 JIT'ed]",
        "technologies": "Linux\nLinux Kernel 5.13 以上 6.0.12 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-025559": {
        "title": "Linux Foundation の Harbor における不正な認証に関する脆弱性",
        "description": "Harbor fails to validate the user permissions when updating tag retention policies.  By sending a request to update a tag retention policy with an id that belongs to a project that the currently authenticated user doesn’t have access to, the attacker could modify tag retention policies configured in other projects.",
        "technologies": "Linux Foundation\nHarbor 1.0.0 以上 1.10.13 未満\nHarbor 2.0.0 以上 2.4.3 未満\nHarbor 2.5.0 以上 2.5.2 未満"
    },
    "JVNDB-2022-025646": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: max9759: fix underflow in speaker_gain_control_put() Check for negative values of \"priv->gain\" to prevent an out of bounds access. The concern is that these might come from the user via: -> snd_ctl_elem_write_user() -> snd_ctl_elem_write() -> kctl->put()",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.178 未満\nLinux Kernel 5.5 以上 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025570": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: mpt3sas: Fix use-after-free warning Fix the following use-after-free warning which is observed during controller reset: refcount_t: underflow; use-after-free. WARNING: CPU: 23 PID: 5399 at lib/refcount.c:28 refcount_warn_saturate+0xa6/0xf0",
        "technologies": "Linux\nLinux Kernel 4.9.328 未満\nLinux Kernel 4.10 以上 4.14.293 未満\nLinux Kernel 4.15 以上 4.19.258 未満\nLinux Kernel 4.20 以上 5.4.213 未満\nLinux Kernel 5.5 以上 5.10.143 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 5.19.9 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025675": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/xive/spapr: correct bitmap allocation size kasan detects access beyond the end of the xibm->bitmap allocation: BUG: KASAN: slab-out-of-bounds in _find_first_zero_bit+0x40/0x140 Read of size 8 at addr c00000001d1d0118 by task swapper/0/1 CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-rc2-00001-g90df023b36dd #28 Call Trace: [c00000001d98f770] [c0000000012baab8] dump_stack_lvl+0xac/0x108 (unreliable) [c00000001d98f7b0] [c00000000068faac] print_report+0x37c/0x710 [c00000001d98f880] [c0000000006902c0] kasan_report+0x110/0x354 [c00000001d98f950] [c000000000692324] __asan_load8+0xa4/0xe0 [c00000001d98f970] [c0000000011c6ed0] _find_first_zero_bit+0x40/0x140 [c00000001d98f9b0] [c0000000000dbfbc] xive_spapr_get_ipi+0xcc/0x260 [c00000001d98fa70] [c0000000000d6d28] xive_setup_cpu_ipi+0x1e8/0x450 [c00000001d98fb30] [c000000004032a20] pSeries_smp_probe+0x5c/0x118 [c00000001d98fb60] [c000000004018b44] smp_prepare_cpus+0x944/0x9ac [c00000001d98fc90] [c000000004009f9c] kernel_init_freeable+0x2d4/0x640 [c00000001d98fd90] [c0000000000131e8] kernel_init+0x28/0x1d0 [c00000001d98fe10] [c00000000000cd54] ret_from_kernel_thread+0x5c/0x64 Allocated by task 0: kasan_save_stack+0x34/0x70 __kasan_kmalloc+0xb4/0xf0 __kmalloc+0x268/0x540 xive_spapr_init+0x4d0/0x77c pseries_init_irq+0x40/0x27c init_IRQ+0x44/0x84 start_kernel+0x2a4/0x538 start_here_common+0x1c/0x20 The buggy address belongs to the object at c00000001d1d0118 which belongs to the cache kmalloc-8 of size 8 The buggy address is located 0 bytes inside of 8-byte region [c00000001d1d0118, c00000001d1d0120) The buggy address belongs to the physical page: page:c00c000000074740 refcount:1 mapcount:0 mapping:0000000000000000 index:0xc00000001d1d0558 pfn:0x1d1d flags: 0x7ffff000000200(slab|node=0|zone=0|lastcpupid=0x7ffff) raw: 007ffff000000200 c00000001d0003c8 c00000001d0003c8 c00000001d010480 raw: c00000001d1d0558 0000000001e1000a 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: c00000001d1d0000: fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc c00000001d1d0080: fc fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc >c00000001d1d0100: fc fc fc 02 fc fc fc fc fc fc fc fc fc fc fc fc ^ c00000001d1d0180: fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc fc c00000001d1d0200: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc This happens because the allocation uses the wrong unit (bits) when it should pass (BITS_TO_LONGS(count) * sizeof(long)) or equivalent. With small numbers of bits, the allocated object can be smaller than sizeof(long), which results in invalid accesses. Use bitmap_zalloc() to allocate and initialize the irq bitmap, paired with bitmap_free() for consistency.",
        "technologies": "Linux\nLinux Kernel 5.15.56 未満\nLinux Kernel 5.16 以上 5.18.13 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025590": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vmwgfx: Fix stale file descriptors on failed usercopy A failing usercopy of the fence_rep object will lead to a stale entry in the file descriptor table as put_unused_fd() won't release it. This enables userland to refer to a dangling 'file' object through that still valid file descriptor, leading to all kinds of use-after-free exploitation scenarios. Fix this by deferring the call to fd_install() until after the usercopy has succeeded.",
        "technologies": "Linux\nLinux Kernel 4.14 以上 4.14.264 未満\nLinux Kernel 4.15 以上 4.19.227 未満\nLinux Kernel 4.20 以上 5.4.175 未満\nLinux Kernel 5.5 以上 5.10.95 未満\nLinux Kernel 5.11 以上 5.15.18 未満\nLinux Kernel 5.16 以上 5.16.4 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025597": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/slab_common: fix possible double free of kmem_cache When doing slub_debug test, kfence's 'test_memcache_typesafe_by_rcu' kunit test case cause a use-after-free error: BUG: KASAN: use-after-free in kobject_del+0x14/0x30 Read of size 8 at addr ffff888007679090 by task kunit_try_catch/261 CPU: 1 PID: 261 Comm: kunit_try_catch Tainted: G B N 6.0.0-rc5-next-20220916 #17 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x34/0x48 print_address_description.constprop.0+0x87/0x2a5 print_report+0x103/0x1ed kasan_report+0xb7/0x140 kobject_del+0x14/0x30 kmem_cache_destroy+0x130/0x170 test_exit+0x1a/0x30 kunit_try_run_case+0xad/0xc0 kunit_generic_run_threadfn_adapter+0x26/0x50 kthread+0x17b/0x1b0 </TASK> The cause is inside kmem_cache_destroy(): kmem_cache_destroy acquire lock/mutex shutdown_cache schedule_work(kmem_cache_release) (if RCU flag set) release lock/mutex kmem_cache_release (if RCU flag not set) In some certain timing, the scheduled work could be run before the next RCU flag checking, which can then get a wrong value and lead to double kmem_cache_release(). Fix it by caching the RCU flag inside protected area, just like 'refcnt'",
        "technologies": "Linux\nLinux Kernel 5.19.8 以上 5.19.12 未満"
    },
    "JVNDB-2022-025562": {
        "title": "Linux Foundation の Harbor における不正な認証に関する脆弱性",
        "description": "Harbor fails to validate the user permissions when updating p2p preheat policies. By sending a request to update a p2p preheat policy with an id that belongs to a project that the currently authenticated user doesn't have access to, the attacker could modify p2p preheat policies configured in other projects.",
        "technologies": "Linux Foundation\nHarbor 2.0.0 以上 2.4.3 未満\nHarbor 2.5.0 以上 2.5.2 未満"
    },
    "JVNDB-2022-025690": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: fix double free in si_parse_power_table() In function si_parse_power_table(), array adev->pm.dpm.ps and its member is allocated. If the allocation of each member fails, the array itself is freed and returned with an error code. However, the array is later freed again in si_dpm_fini() function which is called when the function returns an error. This leads to potential double free of the array adev->pm.dpm.ps, as well as leak of its array members, since the members are not freed in the allocation function and the array is not nulled when freed. In addition adev->pm.dpm.num_ps, which keeps track of the allocated array member, is not updated until the member allocation is successfully finished, this could also lead to either use after free, or uninitialized variable access in si_dpm_fini(). Fix this by postponing the free of the array until si_dpm_fini() and increment adev->pm.dpm.num_ps everytime the array member is allocated.",
        "technologies": "Linux\nLinux Kernel 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025669": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: usb: ax88179_178a: Fix out-of-bounds accesses in RX fixup ax88179_rx_fixup() contains several out-of-bounds accesses that can be triggered by a malicious (or defective) USB device, in particular: - The metadata array (hdr_off..hdr_off+2*pkt_cnt) can be out of bounds, causing OOB reads and (on big-endian systems) OOB endianness flips. - A packet can overlap the metadata array, causing a later OOB endianness flip to corrupt data used by a cloned SKB that has already been handed off into the network stack. - A packet SKB can be constructed whose tail is far beyond its end, causing out-of-bounds heap data to be considered part of the SKB's data. I have tested that this can be used by a malicious USB device to send a bogus ICMPv6 Echo Request and receive an ICMPv6 Echo Reply in response that contains random kernel heap data. It's probably also possible to get OOB writes from this on a little-endian system somehow - maybe by triggering skb_cow() via IP options processing -, but I haven't tested that.",
        "technologies": "Linux\nLinux Kernel 3.9 以上 4.9.303 未満\nLinux Kernel 4.10 以上 4.14.268 未満\nLinux Kernel 4.15 以上 4.19.231 未満\nLinux Kernel 4.20 以上 5.4.180 未満\nLinux Kernel 5.5 以上 5.10.101 未満\nLinux Kernel 5.11 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025671": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: exfat: check if cluster num is valid Syzbot reported slab-out-of-bounds read in exfat_clear_bitmap. This was triggered by reproducer calling truncute with size 0, which causes the following trace: BUG: KASAN: slab-out-of-bounds in exfat_clear_bitmap+0x147/0x490 fs/exfat/balloc.c:174 Read of size 8 at addr ffff888115aa9508 by task syz-executor251/365 Call Trace: __dump_stack lib/dump_stack.c:77 [inline] dump_stack_lvl+0x1e2/0x24b lib/dump_stack.c:118 print_address_description+0x81/0x3c0 mm/kasan/report.c:233 __kasan_report mm/kasan/report.c:419 [inline] kasan_report+0x1a4/0x1f0 mm/kasan/report.c:436 __asan_report_load8_noabort+0x14/0x20 mm/kasan/report_generic.c:309 exfat_clear_bitmap+0x147/0x490 fs/exfat/balloc.c:174 exfat_free_cluster+0x25a/0x4a0 fs/exfat/fatent.c:181 __exfat_truncate+0x99e/0xe00 fs/exfat/file.c:217 exfat_truncate+0x11b/0x4f0 fs/exfat/file.c:243 exfat_setattr+0xa03/0xd40 fs/exfat/file.c:339 notify_change+0xb76/0xe10 fs/attr.c:336 do_truncate+0x1ea/0x2d0 fs/open.c:65 Move the is_valid_cluster() helper from fatent.c to a common header to make it reusable in other *.c files. And add is_valid_cluster() to validate if cluster number is within valid range in exfat_clear_bitmap() and exfat_set_bitmap().",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.120 未満\nLinux Kernel 5.11 以上 5.15.45 未満\nLinux Kernel 5.16 以上 5.17.13 未満\nLinux Kernel 5.18 以上 5.18.2 未満"
    },
    "JVNDB-2022-025651": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Fix an out-of-bounds bug in __snd_usb_parse_audio_interface() There may be a bad USB audio device with a USB ID of (0x04fa, 0x4201) and the number of it's interfaces less than 4, an out-of-bounds read bug occurs when parsing the interface descriptor for this device. Fix this by checking the number of interfaces.",
        "technologies": "Linux\nLinux Kernel 4.9.328 未満\nLinux Kernel 4.10 以上 4.14.293 未満\nLinux Kernel 4.15 以上 4.19.258 未満\nLinux Kernel 4.20 以上 5.4.213 未満\nLinux Kernel 5.5 以上 5.10.143 未満\nLinux Kernel 5.11 以上 5.15.68 未満\nLinux Kernel 5.16 以上 5.19.9 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025650": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: emu10k1: Fix out of bounds access in snd_emu10k1_pcm_channel_alloc() The voice allocator sometimes begins allocating from near the end of the array and then wraps around, however snd_emu10k1_pcm_channel_alloc() accesses the newly allocated voices as if it never wrapped around. This results in out of bounds access if the first voice has a high enough index so that first_voice + requested_voice_count > NUM_G (64). The more voices are requested, the more likely it is for this to occur. This was initially discovered using PipeWire, however it can be reproduced by calling aplay multiple times with 16 channels: aplay -r 48000 -D plughw:CARD=Live,DEV=3 -c 16 /dev/zero UBSAN: array-index-out-of-bounds in sound/pci/emu10k1/emupcm.c:127:40 index 65 is out of range for type 'snd_emu10k1_voice [64]' CPU: 1 PID: 31977 Comm: aplay Tainted: G W IOE 6.0.0-rc2-emu10k1+ #7 Hardware name: ASUSTEK COMPUTER INC P5W DH Deluxe/P5W DH Deluxe, BIOS 3002 07/22/2010 Call Trace: <TASK> dump_stack_lvl+0x49/0x63 dump_stack+0x10/0x16 ubsan_epilogue+0x9/0x3f __ubsan_handle_out_of_bounds.cold+0x44/0x49 snd_emu10k1_playback_hw_params+0x3bc/0x420 [snd_emu10k1] snd_pcm_hw_params+0x29f/0x600 [snd_pcm] snd_pcm_common_ioctl+0x188/0x1410 [snd_pcm] ? exit_to_user_mode_prepare+0x35/0x170 ? do_syscall_64+0x69/0x90 ? syscall_exit_to_user_mode+0x26/0x50 ? do_syscall_64+0x69/0x90 ? exit_to_user_mode_prepare+0x35/0x170 snd_pcm_ioctl+0x27/0x40 [snd_pcm] __x64_sys_ioctl+0x95/0xd0 do_syscall_64+0x5c/0x90 ? do_syscall_64+0x69/0x90 ? do_syscall_64+0x69/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd",
        "technologies": "Linux\nLinux Kernel 4.9.328 未満\nLinux Kernel 4.10 以上 4.14.293 未満\nLinux Kernel 4.15 以上 4.19.258 未満\nLinux Kernel 4.20 以上 5.4.213 未満\nLinux Kernel 5.5 以上 5.10.143 未満\nLinux Kernel 5.11 以上 5.15.68 未満\nLinux Kernel 5.17 以上 5.19.9 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025713": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix potential array overflow in bpf_trampoline_get_progs() The cnt value in the 'cnt >= BPF_MAX_TRAMP_PROGS' check does not include BPF_TRAMP_MODIFY_RETURN bpf programs, so the number of the attached BPF_TRAMP_MODIFY_RETURN bpf programs in a trampoline can exceed BPF_MAX_TRAMP_PROGS. When this happens, the assignment '*progs++ = aux->prog' in bpf_trampoline_get_progs() will cause progs array overflow as the progs field in the bpf_tramp_progs struct can only hold at most BPF_MAX_TRAMP_PROGS bpf programs.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.120 未満\nLinux Kernel 5.11 以上 5.15.45 未満\nLinux Kernel 5.16 以上 5.17.13 未満\nLinux Kernel 5.18 以上 5.18.2 未満"
    },
    "JVNDB-2022-025872": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/dp: Fix OOB read when handling Post Cursor2 register The link_status array was not large enough to read the Adjust Request Post Cursor2 register, so remove the common helper function to avoid an OOB read, found with a -Warray-bounds build: drivers/gpu/drm/drm_dp_helper.c: In function 'drm_dp_get_adjust_request_post_cursor': drivers/gpu/drm/drm_dp_helper.c:59:27: error: array subscript 10 is outside array bounds of 'const u8[6]' {aka 'const unsigned char[6]'} [-Werror=array-bounds] 59 | return link_status[r - DP_LANE0_1_STATUS]; | ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~ drivers/gpu/drm/drm_dp_helper.c:147:51: note: while referencing 'link_status' 147 | u8 drm_dp_get_adjust_request_post_cursor(const u8 link_status[DP_LINK_STATUS_SIZE], | ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Replace the only user of the helper with an open-coded fetch and decode, similar to drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c.",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.17.2 未満"
    },
    "JVNDB-2022-025879": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rtw89: cfo: check mac_id to avoid out-of-bounds Somehow, hardware reports incorrect mac_id and pollute memory. Check index before we access the array. UBSAN: array-index-out-of-bounds in rtw89/phy.c:2517:23 index 188 is out of range for type 's32 [64]' CPU: 1 PID: 51550 Comm: irq/35-rtw89_pc Tainted: G OE Call Trace: <IRQ> show_stack+0x52/0x58 dump_stack_lvl+0x4c/0x63 dump_stack+0x10/0x12 ubsan_epilogue+0x9/0x45 __ubsan_handle_out_of_bounds.cold+0x44/0x49 ? __alloc_skb+0x92/0x1d0 rtw89_phy_cfo_parse+0x44/0x7f [rtw89_core] rtw89_core_rx+0x261/0x871 [rtw89_core] ? __alloc_skb+0xee/0x1d0 rtw89_pci_napi_poll+0x3fa/0x4ea [rtw89_pci] __napi_poll+0x33/0x1a0 net_rx_action+0x126/0x260 ? __queue_work+0x217/0x4c0 __do_softirq+0xd9/0x315 ? disable_irq_nosync+0x10/0x10 do_softirq.part.0+0x6d/0x90 </IRQ> <TASK> __local_bh_enable_ip+0x62/0x70 rtw89_pci_interrupt_threadfn+0x182/0x1a6 [rtw89_pci] irq_thread_fn+0x28/0x60 irq_thread+0xc8/0x190 ? irq_thread_fn+0x60/0x60 kthread+0x16b/0x190 ? irq_thread_check_affinity+0xe0/0xe0 ? set_kthread_struct+0x50/0x50 ret_from_fork+0x22/0x30 </TASK>",
        "technologies": "Linux\nLinux Kernel 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025746": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block: Fix handling of offline queues in blk_mq_alloc_request_hctx() This patch prevents that test nvme/004 triggers the following: UBSAN: array-index-out-of-bounds in block/blk-mq.h:135:9 index 512 is out of range for type 'long unsigned int [512]' Call Trace: show_stack+0x52/0x58 dump_stack_lvl+0x49/0x5e dump_stack+0x10/0x12 ubsan_epilogue+0x9/0x3b __ubsan_handle_out_of_bounds.cold+0x44/0x49 blk_mq_alloc_request_hctx+0x304/0x310 __nvme_submit_sync_cmd+0x70/0x200 [nvme_core] nvmf_connect_io_queue+0x23e/0x2a0 [nvme_fabrics] nvme_loop_connect_io_queues+0x8d/0xb0 [nvme_loop] nvme_loop_create_ctrl+0x58e/0x7d0 [nvme_loop] nvmf_create_ctrl+0x1d7/0x4d0 [nvme_fabrics] nvmf_dev_write+0xae/0x111 [nvme_fabrics] vfs_write+0x144/0x560 ksys_write+0xb7/0x140 __x64_sys_write+0x42/0x50 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 4.16 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.49 未満\nLinux Kernel 5.16 以上 5.18.6 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025848": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: ocxl: fix possible double free in ocxl_file_register_afu info_release() will be called in device_unregister() when info->dev's reference count is 0. So there is no need to call ocxl_afu_put() and kfree() again. Fix this by adding free_minor() and return to err_unregister error path.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025748": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i2c: mlxbf: prevent stack overflow in mlxbf_i2c_smbus_start_transaction() memcpy() is called in a loop while 'operation->length' upper bound is not checked and 'data_idx' also increments.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.146 未満\nLinux Kernel 5.11 以上 5.15.71 未満\nLinux Kernel 5.16 以上 5.19.12 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025714": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: isp1760: Fix out-of-bounds array access Running the driver through kasan gives an interesting splat: BUG: KASAN: global-out-of-bounds in isp1760_register+0x180/0x70c Read of size 20 at addr f1db2e64 by task swapper/0/1 (...) isp1760_register from isp1760_plat_probe+0x1d8/0x220 (...) This happens because the loop reading the regmap fields for the different ISP1760 variants look like this: for (i = 0; i < HC_FIELD_MAX; i++) { ... } Meaning it expects the arrays to be at least HC_FIELD_MAX - 1 long. However the arrays isp1760_hc_reg_fields[], isp1763_hc_reg_fields[], isp1763_hc_volatile_ranges[] and isp1763_dc_volatile_ranges[] are dynamically sized during compilation. Fix this by putting an empty assignment to the [HC_FIELD_MAX] and [DC_FIELD_MAX] array member at the end of each array. This will make the array one member longer than it needs to be, but avoids the risk of overwriting whatever is inside [HC_FIELD_MAX - 1] and is simple and intuitive to read. Also add comments explaining what is going on.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025865": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: clk: visconti: prevent array overflow in visconti_clk_register_gates() This code was using -1 to represent that there was no reset function. Unfortunately, the -1 was stored in u8 so the if (clks[i].rs_id >= 0) condition was always true. This lead to an out of bounds access in visconti_clk_register_gates().",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025756": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: fix potential double free during failed mount RHBZ: https://bugzilla.redhat.com/show_bug.cgi?id=2088799",
        "technologies": "Linux\nLinux Kernel 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025854": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: pvrusb2: fix array-index-out-of-bounds in pvr2_i2c_core_init Syzbot reported that -1 is used as array index. The problem was in missing validation check. hdw->unit_number is initialized with -1 and then if init table walk fails this value remains unchanged. Since code blindly uses this member for array indexing adding sanity check is the easiest fix for that. hdw->workpoll initialization moved upper to prevent warning in __flush_work.",
        "technologies": "Linux\nLinux Kernel 2.6.18 以上 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025912": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: elan: Fix potential double free in elan_input_configured 'input' is a managed resource allocated with devm_input_allocate_device(), so there is no need to call input_free_device() explicitly or there will be a double free. According to the doc of devm_input_allocate_device(): * Managed input devices do not need to be explicitly unregistered or * freed as it will be done automatically when owner device unbinds from * its driver (or binding fails).",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025914": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: potential buffer overflow in handling symlinks Smatch printed a warning: arch/x86/crypto/poly1305_glue.c:198 poly1305_update_arch() error: __memcpy() 'dctx->buf' too small (16 vs u32max) It's caused because Smatch marks 'link_len' as untrusted since it comes from sscanf(). Add a check to ensure that 'link_len' is not larger than the size of the 'link_str' buffer.",
        "technologies": "Linux\nLinux Kernel 2.6.37 以上 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.239 未満\nLinux Kernel 4.20 以上 5.4.190 未満\nLinux Kernel 5.5 以上 5.10.112 未満\nLinux Kernel 5.11 以上 5.15.35 未満\nLinux Kernel 5.16 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025935": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: srcu: Tighten cleanup_srcu_struct() GP checks Currently, cleanup_srcu_struct() checks for a grace period in progress, but it does not check for a grace period that has not yet started but which might start at any time. Such a situation could result in a use-after-free bug, so this commit adds a check for a grace period that is needed but not yet started to cleanup_srcu_struct().",
        "technologies": "Linux\nLinux Kernel 5.18.11 未満"
    },
    "JVNDB-2022-025933": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sfc: fix use after free when disabling sriov Use after free is detected by kfence when disabling sriov. What was read after being freed was vf->pci_dev: it was freed from pci_disable_sriov and later read in efx_ef10_sriov_free_vf_vports, called from efx_ef10_sriov_free_vf_vswitching. Set the pointer to NULL at release time to not trying to read it later. Reproducer and dmesg log (note that kfence doesn't detect it every time): $ echo 1 > /sys/class/net/enp65s0f0np0/device/sriov_numvfs $ echo 0 > /sys/class/net/enp65s0f0np0/device/sriov_numvfs BUG: KFENCE: use-after-free read in efx_ef10_sriov_free_vf_vswitching+0x82/0x170 [sfc] Use-after-free read at 0x00000000ff3c1ba5 (in kfence-#224): efx_ef10_sriov_free_vf_vswitching+0x82/0x170 [sfc] efx_ef10_pci_sriov_disable+0x38/0x70 [sfc] efx_pci_sriov_configure+0x24/0x40 [sfc] sriov_numvfs_store+0xfe/0x140 kernfs_fop_write_iter+0x11c/0x1b0 new_sync_write+0x11f/0x1b0 vfs_write+0x1eb/0x280 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae kfence-#224: 0x00000000edb8ef95-0x00000000671f5ce1, size=2792, cache=kmalloc-4k allocated by task 6771 on cpu 10 at 3137.860196s: pci_alloc_dev+0x21/0x60 pci_iov_add_virtfn+0x2a2/0x320 sriov_enable+0x212/0x3e0 efx_ef10_sriov_configure+0x67/0x80 [sfc] efx_pci_sriov_configure+0x24/0x40 [sfc] sriov_numvfs_store+0xba/0x140 kernfs_fop_write_iter+0x11c/0x1b0 new_sync_write+0x11f/0x1b0 vfs_write+0x1eb/0x280 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae freed by task 6771 on cpu 12 at 3170.991309s: device_release+0x34/0x90 kobject_cleanup+0x3a/0x130 pci_iov_remove_virtfn+0xd9/0x120 sriov_disable+0x30/0xe0 efx_ef10_pci_sriov_disable+0x57/0x70 [sfc] efx_pci_sriov_configure+0x24/0x40 [sfc] sriov_numvfs_store+0xfe/0x140 kernfs_fop_write_iter+0x11c/0x1b0 new_sync_write+0x11f/0x1b0 vfs_write+0x1eb/0x280 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 4.2 以上 4.9.324 未満\nLinux Kernel 4.10 以上 4.14.289 未満\nLinux Kernel 4.15 以上 4.19.253 未満\nLinux Kernel 4.20 以上 5.4.207 未満\nLinux Kernel 5.5 以上 5.10.132 未満\nLinux Kernel 5.11 以上 5.15.56 未満\nLinux Kernel 5.16 以上 5.18.13 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025932": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: blk-throttle: Set BIO_THROTTLED when bio has been throttled 1.In current process, all bio will set the BIO_THROTTLED flag after __blk_throtl_bio(). 2.If bio needs to be throttled, it will start the timer and stop submit bio directly. Bio will submit in blk_throtl_dispatch_work_fn() when the timer expires.But in the current process, if bio is throttled. The BIO_THROTTLED will be set to bio after timer start. If the bio has been completed, it may cause use-after-free blow. BUG: KASAN: use-after-free in blk_throtl_bio+0x12f0/0x2c70 Read of size 2 at addr ffff88801b8902d4 by task fio/26380 dump_stack+0x9b/0xce print_address_description.constprop.6+0x3e/0x60 kasan_report.cold.9+0x22/0x3a blk_throtl_bio+0x12f0/0x2c70 submit_bio_checks+0x701/0x1550 submit_bio_noacct+0x83/0xc80 submit_bio+0xa7/0x330 mpage_readahead+0x380/0x500 read_pages+0x1c1/0xbf0 page_cache_ra_unbounded+0x471/0x6f0 do_page_cache_ra+0xda/0x110 ondemand_readahead+0x442/0xae0 page_cache_async_ra+0x210/0x300 generic_file_buffered_read+0x4d9/0x2130 generic_file_read_iter+0x315/0x490 blkdev_read_iter+0x113/0x1b0 aio_read+0x2ad/0x450 io_submit_one+0xc8e/0x1d60 __se_sys_io_submit+0x125/0x350 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Allocated by task 26380: kasan_save_stack+0x19/0x40 __kasan_kmalloc.constprop.2+0xc1/0xd0 kmem_cache_alloc+0x146/0x440 mempool_alloc+0x125/0x2f0 bio_alloc_bioset+0x353/0x590 mpage_alloc+0x3b/0x240 do_mpage_readpage+0xddf/0x1ef0 mpage_readahead+0x264/0x500 read_pages+0x1c1/0xbf0 page_cache_ra_unbounded+0x471/0x6f0 do_page_cache_ra+0xda/0x110 ondemand_readahead+0x442/0xae0 page_cache_async_ra+0x210/0x300 generic_file_buffered_read+0x4d9/0x2130 generic_file_read_iter+0x315/0x490 blkdev_read_iter+0x113/0x1b0 aio_read+0x2ad/0x450 io_submit_one+0xc8e/0x1d60 __se_sys_io_submit+0x125/0x350 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Freed by task 0: kasan_save_stack+0x19/0x40 kasan_set_track+0x1c/0x30 kasan_set_free_info+0x1b/0x30 __kasan_slab_free+0x111/0x160 kmem_cache_free+0x94/0x460 mempool_free+0xd6/0x320 bio_free+0xe0/0x130 bio_put+0xab/0xe0 bio_endio+0x3a6/0x5d0 blk_update_request+0x590/0x1370 scsi_end_request+0x7d/0x400 scsi_io_completion+0x1aa/0xe50 scsi_softirq_done+0x11b/0x240 blk_mq_complete_request+0xd4/0x120 scsi_mq_done+0xf0/0x200 virtscsi_vq_done+0xbc/0x150 vring_interrupt+0x179/0x390 __handle_irq_event_percpu+0xf7/0x490 handle_irq_event_percpu+0x7b/0x160 handle_irq_event+0xcc/0x170 handle_edge_irq+0x215/0xb20 common_interrupt+0x60/0x120 asm_common_interrupt+0x1e/0x40 Fix this by move BIO_THROTTLED set into the queue_lock.",
        "technologies": "Linux\nLinux Kernel 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025937": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipvlan: Fix out-of-bound bugs caused by unset skb->mac_header If an AF_PACKET socket is used to send packets through ipvlan and the default xmit function of the AF_PACKET socket is changed from dev_queue_xmit() to packet_direct_xmit() via setsockopt() with the option name of PACKET_QDISC_BYPASS, the skb->mac_header may not be reset and remains as the initial value of 65535, this may trigger slab-out-of-bounds bugs as following: ================================================================= UG: KASAN: slab-out-of-bounds in ipvlan_xmit_mode_l2+0xdb/0x330 [ipvlan] PU: 2 PID: 1768 Comm: raw_send Kdump: loaded Not tainted 6.0.0-rc4+ #6 ardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 all Trace: print_address_description.constprop.0+0x1d/0x160 print_report.cold+0x4f/0x112 kasan_report+0xa3/0x130 ipvlan_xmit_mode_l2+0xdb/0x330 [ipvlan] ipvlan_start_xmit+0x29/0xa0 [ipvlan] __dev_direct_xmit+0x2e2/0x380 packet_direct_xmit+0x22/0x60 packet_snd+0x7c9/0xc40 sock_sendmsg+0x9a/0xa0 __sys_sendto+0x18a/0x230 __x64_sys_sendto+0x74/0x90 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd The root cause is: 1. packet_snd() only reset skb->mac_header when sock->type is SOCK_RAW and skb->protocol is not specified as in packet_parse_headers() 2. packet_direct_xmit() doesn't reset skb->mac_header as dev_queue_xmit() In this case, skb->mac_header is 65535 when ipvlan_xmit_mode_l2() is called. So when ipvlan_xmit_mode_l2() gets mac header with eth_hdr() which use \"skb->head + skb->mac_header\", out-of-bound access occurs. This patch replaces eth_hdr() with skb_eth_hdr() in ipvlan_xmit_mode_l2() and reset mac header in multicast to solve this out-of-bound bug.",
        "technologies": "Linux\nLinux Kernel 3.19 以上 4.9.330 未満\nLinux Kernel 4.10 以上 4.14.295 未満\nLinux Kernel 4.15 以上 4.19.260 未満\nLinux Kernel 4.20 以上 5.4.215 未満\nLinux Kernel 5.5 以上 5.10.146 未満\nLinux Kernel 5.11 以上 5.15.71 未満\nLinux Kernel 5.16 以上 5.19.12 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025936": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: igb: fix a use-after-free issue in igb_clean_tx_ring Fix the following use-after-free bug in igb_clean_tx_ring routine when the NIC is running in XDP mode. The issue can be triggered redirecting traffic into the igb NIC and then closing the device while the traffic is flowing. [ 73.322719] CPU: 1 PID: 487 Comm: xdp_redirect Not tainted 5.18.3-apu2 #9 [ 73.330639] Hardware name: PC Engines APU2/APU2, BIOS 4.0.7 02/28/2017 [ 73.337434] RIP: 0010:refcount_warn_saturate+0xa7/0xf0 [ 73.362283] RSP: 0018:ffffc9000081f798 EFLAGS: 00010282 [ 73.367761] RAX: 0000000000000000 RBX: ffffc90000420f80 RCX: 0000000000000000 [ 73.375200] RDX: ffff88811ad22d00 RSI: ffff88811ad171e0 RDI: ffff88811ad171e0 [ 73.382590] RBP: 0000000000000900 R08: ffffffff82298f28 R09: 0000000000000058 [ 73.390008] R10: 0000000000000219 R11: ffffffff82280f40 R12: 0000000000000090 [ 73.397356] R13: ffff888102343a40 R14: ffff88810359e0e4 R15: 0000000000000000 [ 73.404806] FS: 00007ff38d31d740(0000) GS:ffff88811ad00000(0000) knlGS:0000000000000000 [ 73.413129] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 73.419096] CR2: 000055cff35f13f8 CR3: 0000000106391000 CR4: 00000000000406e0 [ 73.426565] Call Trace: [ 73.429087] <TASK> [ 73.431314] igb_clean_tx_ring+0x43/0x140 [igb] [ 73.436002] igb_down+0x1d7/0x220 [igb] [ 73.439974] __igb_close+0x3c/0x120 [igb] [ 73.444118] igb_xdp+0x10c/0x150 [igb] [ 73.447983] ? igb_pci_sriov_configure+0x70/0x70 [igb] [ 73.453362] dev_xdp_install+0xda/0x110 [ 73.457371] dev_xdp_attach+0x1da/0x550 [ 73.461369] do_setlink+0xfd0/0x10f0 [ 73.465166] ? __nla_validate_parse+0x89/0xc70 [ 73.469714] rtnl_setlink+0x11a/0x1e0 [ 73.473547] rtnetlink_rcv_msg+0x145/0x3d0 [ 73.477709] ? rtnl_calcit.isra.0+0x130/0x130 [ 73.482258] netlink_rcv_skb+0x8d/0x110 [ 73.486229] netlink_unicast+0x230/0x340 [ 73.490317] netlink_sendmsg+0x215/0x470 [ 73.494395] __sys_sendto+0x179/0x190 [ 73.498268] ? move_addr_to_user+0x37/0x70 [ 73.502547] ? __sys_getsockname+0x84/0xe0 [ 73.506853] ? netlink_setsockopt+0x1c1/0x4a0 [ 73.511349] ? __sys_setsockopt+0xc8/0x1d0 [ 73.515636] __x64_sys_sendto+0x20/0x30 [ 73.519603] do_syscall_64+0x3b/0x80 [ 73.523399] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 73.528712] RIP: 0033:0x7ff38d41f20c [ 73.551866] RSP: 002b:00007fff3b945a68 EFLAGS: 00000246 ORIG_RAX: 000000000000002c [ 73.559640] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ff38d41f20c [ 73.567066] RDX: 0000000000000034 RSI: 00007fff3b945b30 RDI: 0000000000000003 [ 73.574457] RBP: 0000000000000003 R08: 0000000000000000 R09: 0000000000000000 [ 73.581852] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff3b945ab0 [ 73.589179] R13: 0000000000000000 R14: 0000000000000003 R15: 00007fff3b945b30 [ 73.596545] </TASK> [ 73.598842] ---[ end trace 0000000000000000 ]---",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.127 未満\nLinux Kernel 5.11 以上 5.15.51 未満\nLinux Kernel 5.16 以上 5.18.8 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025931": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bfq: Update cgroup information before merging bio When the process is migrated to a different cgroup (or in case of writeback just starts submitting bios associated with a different cgroup) bfq_merge_bio() can operate with stale cgroup information in bic. Thus the bio can be merged to a request from a different cgroup or it can result in merging of bfqqs for different cgroups or bfqqs of already dead cgroups and causing possible use-after-free issues. Fix the problem by updating cgroup information in bfq_merge_bio().",
        "technologies": "Linux\nLinux Kernel 4.12 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025941": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ep93xx: clock: Fix UAF in ep93xx_clk_register_gate() arch/arm/mach-ep93xx/clock.c:154:2: warning: Use of memory after it is freed [clang-analyzer-unix.Malloc] arch/arm/mach-ep93xx/clock.c:151:2: note: Taking true branch if (IS_ERR(clk)) ^ arch/arm/mach-ep93xx/clock.c:152:3: note: Memory is released kfree(psc); ^~~~~~~~~~ arch/arm/mach-ep93xx/clock.c:154:2: note: Use of memory after it is freed return &psc->hw; ^ ~~~~~~~~",
        "technologies": "Linux\nLinux Kernel 5.16 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025924": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bnxt: prevent skb UAF after handing over to PTP worker When reading the timestamp is required bnxt_tx_int() hands over the ownership of the completed skb to the PTP worker. The skb should not be used afterwards, as the worker may run before the rest of our code and free the skb, leading to a use-after-free. Since dev_kfree_skb_any() accepts NULL make the loss of ownership more obvious and set skb to NULL.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.71 未満\nLinux Kernel 5.16 以上 5.19.12 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025934": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cgroup: Use separate src/dst nodes when preloading css_sets for migration Each cset (css_set) is pinned by its tasks. When we're moving tasks around across csets for a migration, we need to hold the source and destination csets to ensure that they don't go away while we're moving tasks about. This is done by linking cset->mg_preload_node on either the mgctx->preloaded_src_csets or mgctx->preloaded_dst_csets list. Using the same cset->mg_preload_node for both the src and dst lists was deemed okay as a cset can't be both the source and destination at the same time. Unfortunately, this overloading becomes problematic when multiple tasks are involved in a migration and some of them are identity noop migrations while others are actually moving across cgroups. For example, this can happen with the following sequence on cgroup1: #1> mkdir -p /sys/fs/cgroup/misc/a/b #2> echo $$ > /sys/fs/cgroup/misc/a/cgroup.procs #3> RUN_A_COMMAND_WHICH_CREATES_MULTIPLE_THREADS & #4> PID=$! #5> echo $PID > /sys/fs/cgroup/misc/a/b/tasks #6> echo $PID > /sys/fs/cgroup/misc/a/cgroup.procs the process including the group leader back into a. In this final migration, non-leader threads would be doing identity migration while the group leader is doing an actual one. After #3, let's say the whole process was in cset A, and that after #4, the leader moves to cset B. Then, during #6, the following happens: 1. cgroup_migrate_add_src() is called on B for the leader. 2. cgroup_migrate_add_src() is called on A for the other threads. 3. cgroup_migrate_prepare_dst() is called. It scans the src list. 4. It notices that B wants to migrate to A, so it tries to A to the dst list but realizes that its ->mg_preload_node is already busy. 5. and then it notices A wants to migrate to A as it's an identity migration, it culls it by list_del_init()'ing its ->mg_preload_node and putting references accordingly. 6. The rest of migration takes place with B on the src list but nothing on the dst list. This means that A isn't held while migration is in progress. If all tasks leave A before the migration finishes and the incoming task pins it, the cset will be destroyed leading to use-after-free. This is caused by overloading cset->mg_preload_node for both src and dst preload lists. We wanted to exclude the cset from the src list but ended up inadvertently excluding it from the dst list too. This patch fixes the issue by separating out cset->mg_preload_node into ->mg_src_preload_node and ->mg_dst_preload_node, so that the src and dst preloadings don't interfere with each other.",
        "technologies": "Linux\nLinux Kernel 3.16 以上 4.14.289 未満\nLinux Kernel 4.15 以上 4.19.253 未満\nLinux Kernel 4.20 以上 5.4.207 未満\nLinux Kernel 5.5 以上 5.10.132 未満\nLinux Kernel 5.11 以上 5.15.56 未満\nLinux Kernel 5.16 以上 5.18.13 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025915": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: Fix KASAN slab-out-of-bounds in cachefiles_set_volume_xattr Use the actual length of volume coherency data when setting the xattr to avoid the following KASAN report. BUG: KASAN: slab-out-of-bounds in cachefiles_set_volume_xattr+0xa0/0x350 [cachefiles] Write of size 4 at addr ffff888101e02af4 by task kworker/6:0/1347 CPU: 6 PID: 1347 Comm: kworker/6:0 Kdump: loaded Not tainted 5.18.0-rc1-nfs-fscache-netfs+ #13 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-4.fc34 04/01/2014 Workqueue: events fscache_create_volume_work [fscache] Call Trace: <TASK> dump_stack_lvl+0x45/0x5a print_report.cold+0x5e/0x5db ? __lock_text_start+0x8/0x8 ? cachefiles_set_volume_xattr+0xa0/0x350 [cachefiles] kasan_report+0xab/0x120 ? cachefiles_set_volume_xattr+0xa0/0x350 [cachefiles] kasan_check_range+0xf5/0x1d0 memcpy+0x39/0x60 cachefiles_set_volume_xattr+0xa0/0x350 [cachefiles] cachefiles_acquire_volume+0x2be/0x500 [cachefiles] ? __cachefiles_free_volume+0x90/0x90 [cachefiles] fscache_create_volume_work+0x68/0x160 [fscache] process_one_work+0x3b7/0x6a0 worker_thread+0x2c4/0x650 ? process_one_work+0x6a0/0x6a0 kthread+0x16c/0x1a0 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x22/0x30 </TASK> Allocated by task 1347: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0x81/0xa0 cachefiles_set_volume_xattr+0x76/0x350 [cachefiles] cachefiles_acquire_volume+0x2be/0x500 [cachefiles] fscache_create_volume_work+0x68/0x160 [fscache] process_one_work+0x3b7/0x6a0 worker_thread+0x2c4/0x650 kthread+0x16c/0x1a0 ret_from_fork+0x22/0x30 The buggy address belongs to the object at ffff888101e02af0 which belongs to the cache kmalloc-8 of size 8 The buggy address is located 4 bytes inside of 8-byte region [ffff888101e02af0, ffff888101e02af8) The buggy address belongs to the physical page: page:00000000a2292d70 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x101e02 flags: 0x17ffffc0000200(slab|node=0|zone=2|lastcpupid=0x1fffff) raw: 0017ffffc0000200 0000000000000000 dead000000000001 ffff888100042280 raw: 0000000000000000 0000000080660066 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888101e02980: fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc ffff888101e02a00: 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00 >ffff888101e02a80: fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 04 fc ^ ffff888101e02b00: fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc ffff888101e02b80: fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc ==================================================================",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025942": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hfi1: Fix use-after-free bug for mm struct Under certain conditions, such as MPI_Abort, the hfi1 cleanup code may represent the last reference held on the task mm. hfi1_mmu_rb_unregister() then drops the last reference and the mm is freed before the final use in hfi1_release_user_pages(). A new task may allocate the mm structure while it is still being used, resulting in problems. One manifestation is corruption of the mmap_sem counter leading to a hang in down_write(). Another is corruption of an mm struct that is in use by another task.",
        "technologies": "Linux\nLinux Kernel 5.9.12 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025927": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: core: Fix a use-after-free There are two .exit_cmd_priv implementations. Both implementations use resources associated with the SCSI host. Make sure that these resources are still available when .exit_cmd_priv is called by waiting inside scsi_remove_host() until the tag set has been freed. This commit fixes the following use-after-free: ================================================================== BUG: KASAN: use-after-free in srp_exit_cmd_priv+0x27/0xd0 [ib_srp] Read of size 8 at addr ffff888100337000 by task multipathd/16727 Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_report.cold+0x5e/0x5db kasan_report+0xab/0x120 srp_exit_cmd_priv+0x27/0xd0 [ib_srp] scsi_mq_exit_request+0x4d/0x70 blk_mq_free_rqs+0x143/0x410 __blk_mq_free_map_and_rqs+0x6e/0x100 blk_mq_free_tag_set+0x2b/0x160 scsi_host_dev_release+0xf3/0x1a0 device_release+0x54/0xe0 kobject_put+0xa5/0x120 device_release+0x54/0xe0 kobject_put+0xa5/0x120 scsi_device_dev_release_usercontext+0x4c1/0x4e0 execute_in_process_context+0x23/0x90 device_release+0x54/0xe0 kobject_put+0xa5/0x120 scsi_disk_release+0x3f/0x50 device_release+0x54/0xe0 kobject_put+0xa5/0x120 disk_release+0x17f/0x1b0 device_release+0x54/0xe0 kobject_put+0xa5/0x120 dm_put_table_device+0xa3/0x160 [dm_mod] dm_put_device+0xd0/0x140 [dm_mod] free_priority_group+0xd8/0x110 [dm_multipath] free_multipath+0x94/0xe0 [dm_multipath] dm_table_destroy+0xa2/0x1e0 [dm_mod] __dm_destroy+0x196/0x350 [dm_mod] dev_remove+0x10c/0x160 [dm_mod] ctl_ioctl+0x2c2/0x590 [dm_mod] dm_ctl_ioctl+0x5/0x10 [dm_mod] __x64_sys_ioctl+0xb4/0xf0 dm_ctl_ioctl+0x5/0x10 [dm_mod] __x64_sys_ioctl+0xb4/0xf0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x46/0xb0",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.19.12 未満\nLinux Kernel 6.0"
    },
    "JVNDB-2022-025944": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bfq: fix use-after-free in bfq_dispatch_request KASAN reports a use-after-free report when doing normal scsi-mq test [69832.239032] ================================================================== [69832.241810] BUG: KASAN: use-after-free in bfq_dispatch_request+0x1045/0x44b0 [69832.243267] Read of size 8 at addr ffff88802622ba88 by task kworker/3:1H/155 [69832.244656] [69832.245007] CPU: 3 PID: 155 Comm: kworker/3:1H Not tainted 5.10.0-10295-g576c6382529e #8 [69832.246626] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [69832.249069] Workqueue: kblockd blk_mq_run_work_fn [69832.250022] Call Trace: [69832.250541] dump_stack+0x9b/0xce [69832.251232] ? bfq_dispatch_request+0x1045/0x44b0 [69832.252243] print_address_description.constprop.6+0x3e/0x60 [69832.253381] ? __cpuidle_text_end+0x5/0x5 [69832.254211] ? vprintk_func+0x6b/0x120 [69832.254994] ? bfq_dispatch_request+0x1045/0x44b0 [69832.255952] ? bfq_dispatch_request+0x1045/0x44b0 [69832.256914] kasan_report.cold.9+0x22/0x3a [69832.257753] ? bfq_dispatch_request+0x1045/0x44b0 [69832.258755] check_memory_region+0x1c1/0x1e0 [69832.260248] bfq_dispatch_request+0x1045/0x44b0 [69832.261181] ? bfq_bfqq_expire+0x2440/0x2440 [69832.262032] ? blk_mq_delay_run_hw_queues+0xf9/0x170 [69832.263022] __blk_mq_do_dispatch_sched+0x52f/0x830 [69832.264011] ? blk_mq_sched_request_inserted+0x100/0x100 [69832.265101] __blk_mq_sched_dispatch_requests+0x398/0x4f0 [69832.266206] ? blk_mq_do_dispatch_ctx+0x570/0x570 [69832.267147] ? __switch_to+0x5f4/0xee0 [69832.267898] blk_mq_sched_dispatch_requests+0xdf/0x140 [69832.268946] __blk_mq_run_hw_queue+0xc0/0x270 [69832.269840] blk_mq_run_work_fn+0x51/0x60 [69832.278170] process_one_work+0x6d4/0xfe0 [69832.278984] worker_thread+0x91/0xc80 [69832.279726] ? __kthread_parkme+0xb0/0x110 [69832.280554] ? process_one_work+0xfe0/0xfe0 [69832.281414] kthread+0x32d/0x3f0 [69832.282082] ? kthread_park+0x170/0x170 [69832.282849] ret_from_fork+0x1f/0x30 [69832.283573] [69832.283886] Allocated by task 7725: [69832.284599] kasan_save_stack+0x19/0x40 [69832.285385] __kasan_kmalloc.constprop.2+0xc1/0xd0 [69832.286350] kmem_cache_alloc_node+0x13f/0x460 [69832.287237] bfq_get_queue+0x3d4/0x1140 [69832.287993] bfq_get_bfqq_handle_split+0x103/0x510 [69832.289015] bfq_init_rq+0x337/0x2d50 [69832.289749] bfq_insert_requests+0x304/0x4e10 [69832.290634] blk_mq_sched_insert_requests+0x13e/0x390 [69832.291629] blk_mq_flush_plug_list+0x4b4/0x760 [69832.292538] blk_flush_plug_list+0x2c5/0x480 [69832.293392] io_schedule_prepare+0xb2/0xd0 [69832.294209] io_schedule_timeout+0x13/0x80 [69832.295014] wait_for_common_io.constprop.1+0x13c/0x270 [69832.296137] submit_bio_wait+0x103/0x1a0 [69832.296932] blkdev_issue_discard+0xe6/0x160 [69832.297794] blk_ioctl_discard+0x219/0x290 [69832.298614] blkdev_common_ioctl+0x50a/0x1750 [69832.304715] blkdev_ioctl+0x470/0x600 [69832.305474] block_ioctl+0xde/0x120 [69832.306232] vfs_ioctl+0x6c/0xc0 [69832.306877] __se_sys_ioctl+0x90/0xa0 [69832.307629] do_syscall_64+0x2d/0x40 [69832.308362] entry_SYSCALL_64_after_hwframe+0x44/0xa9 [69832.309382] [69832.309701] Freed by task 155: [69832.310328] kasan_save_stack+0x19/0x40 [69832.311121] kasan_set_track+0x1c/0x30 [69832.311868] kasan_set_free_info+0x1b/0x30 [69832.312699] __kasan_slab_free+0x111/0x160 [69832.313524] kmem_cache_free+0x94/0x460 [69832.314367] bfq_put_queue+0x582/0x940 [69832.315112] __bfq_bfqd_reset_in_service+0x166/0x1d0 [69832.317275] bfq_bfqq_expire+0xb27/0x2440 [69832.318084] bfq_dispatch_request+0x697/0x44b0 [69832.318991] __blk_mq_do_dispatch_sched+0x52f/0x830 [69832.319984] __blk_mq_sched_dispatch_requests+0x398/0x4f0 [69832.321087] blk_mq_sched_dispatch_requests+0xdf/0x140 [69832.322225] __blk_mq_run_hw_queue+0xc0/0x270 [69832.323114] blk_mq_run_work_fn+0x51/0x6 ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025948": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: macsec: fix UAF bug for real_dev Create a new macsec device but not get reference to real_dev. That can not ensure that real_dev is freed after macsec. That will trigger the UAF bug for real_dev as following: ================================================================== BUG: KASAN: use-after-free in macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662 Call Trace: ... macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662 dev_get_iflink+0x73/0xe0 net/core/dev.c:637 default_operstate net/core/link_watch.c:42 [inline] rfc2863_policy+0x233/0x2d0 net/core/link_watch.c:54 linkwatch_do_dev+0x2a/0x150 net/core/link_watch.c:161 Allocated by task 22209: ... alloc_netdev_mqs+0x98/0x1100 net/core/dev.c:10549 rtnl_create_link+0x9d7/0xc00 net/core/rtnetlink.c:3235 veth_newlink+0x20e/0xa90 drivers/net/veth.c:1748 Freed by task 8: ... kfree+0xd6/0x4d0 mm/slub.c:4552 kvfree+0x42/0x50 mm/util.c:615 device_release+0x9f/0x240 drivers/base/core.c:2229 kobject_cleanup lib/kobject.c:673 [inline] kobject_release lib/kobject.c:704 [inline] kref_put include/linux/kref.h:65 [inline] kobject_put+0x1c8/0x540 lib/kobject.c:721 netdev_run_todo+0x72e/0x10b0 net/core/dev.c:10327 After commit faab39f63c1f (\"net: allow out-of-order netdev unregistration\") and commit e5f80fcf869a (\"ipv6: give an IPv6 dev to blackhole_netdev\"), we can add dev_hold_track() in macsec_dev_init() and dev_put_track() in macsec_free_netdev() to fix the problem.",
        "technologies": "Linux\nLinux Kernel 4.14.154 以上 4.15 未満\nLinux Kernel 4.19.84 以上 4.20 未満\nLinux Kernel 5.3.11 以上 5.17.15 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025947": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ref_tracker: implement use-after-free detection Whenever ref_tracker_dir_init() is called, mark the struct ref_tracker_dir as dead. Test the dead status from ref_tracker_alloc() and ref_tracker_free() This should detect buggy dev_put()/dev_hold() happening too late in netdevice dismantle process.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-025949": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ubi: ubi_create_volume: Fix use-after-free when volume creation failed There is an use-after-free problem for 'eba_tbl' in ubi_create_volume()'s error handling path: ubi_eba_replace_table(vol, eba_tbl) vol->eba_tbl = tbl out_mapping: ubi_eba_destroy_table(eba_tbl) // Free 'eba_tbl' out_unlock: put_device(&vol->dev) vol_release kfree(tbl->entries) // UAF Fix it by removing redundant 'eba_tbl' releasing. Fetch a reproducer in [Link].",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.122 未満\nLinux Kernel 5.11 以上 5.15.47 未満\nLinux Kernel 5.16 以上 5.17.15 未満\nLinux Kernel 5.18 以上 5.18.4 未満"
    },
    "JVNDB-2022-025943": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommu/arm-smmu-v3-sva: Fix mm use-after-free We currently call arm64_mm_context_put() without holding a reference to the mm, which can result in use-after-free. Call mmgrab()/mmdrop() to ensure the mm only gets freed after we unpinned the ASID.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025945": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: do not clean up repair bio if submit fails The submit helper will always run bio_endio() on the bio if it fails to submit, so cleaning up the bio just leads to a variety of use-after-free and NULL pointer dereference bugs because we race with the endio function that is cleaning up the bio. Instead just return BLK_STS_OK as the repair function has to continue to process the rest of the pages, and the endio for the repair bio will do the appropriate cleanup for the page that it was given.",
        "technologies": "Linux\nLinux Kernel 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025967": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bonding: fix use-after-free after 802.3ad slave unbind commit 0622cab0341c (\"bonding: fix 802.3ad aggregator reselection\"), resolve case, when there is several aggregation groups in the same bond. bond_3ad_unbind_slave will invalidate (clear) aggregator when __agg_active_ports return zero. So, ad_clear_agg can be executed even, when num_of_ports!=0. Than bond_3ad_unbind_slave can be executed again for, previously cleared aggregator. NOTE: at this time bond_3ad_unbind_slave will not update slave ports list, because lag_ports==NULL. So, here we got slave ports, pointing to freed aggregator memory. Fix with checking actual number of ports in group (as was before commit 0622cab0341c (\"bonding: fix 802.3ad aggregator reselection\") ), before ad_clear_agg(). The KASAN logs are as follows: [ 767.617392] ================================================================== [ 767.630776] BUG: KASAN: use-after-free in bond_3ad_state_machine_handler+0x13dc/0x1470 [ 767.638764] Read of size 2 at addr ffff00011ba9d430 by task kworker/u8:7/767 [ 767.647361] CPU: 3 PID: 767 Comm: kworker/u8:7 Tainted: G O 5.15.11 #15 [ 767.655329] Hardware name: DNI AmazonGo1 A7040 board (DT) [ 767.660760] Workqueue: lacp_1 bond_3ad_state_machine_handler [ 767.666468] Call trace: [ 767.668930] dump_backtrace+0x0/0x2d0 [ 767.672625] show_stack+0x24/0x30 [ 767.675965] dump_stack_lvl+0x68/0x84 [ 767.679659] print_address_description.constprop.0+0x74/0x2b8 [ 767.685451] kasan_report+0x1f0/0x260 [ 767.689148] __asan_load2+0x94/0xd0 [ 767.692667] bond_3ad_state_machine_handler+0x13dc/0x1470",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.9.322 未満\nLinux Kernel 4.10 以上 4.14.287 未満\nLinux Kernel 4.15 以上 4.19.251 未満\nLinux Kernel 4.20 以上 5.4.204 未満\nLinux Kernel 5.5 以上 5.10.129 未満\nLinux Kernel 5.11 以上 5.15.53 未満\nLinux Kernel 5.16 以上 5.18.10 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025946": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_sync: Fix queuing commands when HCI_UNREGISTER is set hci_cmd_sync_queue shall return an error if HCI_UNREGISTER flag has been set as that means hci_unregister_dev has been called so it will likely cause a uaf after the timeout as the hdev will be freed.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-025950": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: driver: base: fix UAF when driver_attach failed When driver_attach(drv); failed, the driver_private will be freed. But it has been added to the bus, which caused a UAF. To fix it, we need to delete it from the bus when failed.",
        "technologies": "Linux\nLinux Kernel 3.9 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.122 未満\nLinux Kernel 5.11 以上 5.15.47 未満\nLinux Kernel 5.16 以上 5.17.15 未満\nLinux Kernel 5.18 以上 5.18.4 未満"
    },
    "JVNDB-2022-025953": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: target: tcmu: Fix possible page UAF tcmu_try_get_data_page() looks up pages under cmdr_lock, but it does not take refcount properly and just returns page pointer. When tcmu_try_get_data_page() returns, the returned page may have been freed by tcmu_blocks_release(). We need to get_page() under cmdr_lock to avoid concurrent tcmu_blocks_release().",
        "technologies": "Linux\nLinux Kernel 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.239 未満\nLinux Kernel 4.20 以上 5.4.190 未満\nLinux Kernel 5.5 以上 5.10.112 未満\nLinux Kernel 5.11 以上 5.15.35 未満\nLinux Kernel 5.16 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025956": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: erofs: fix buffer copy overflow of ztailpacking feature I got some KASAN report as below: [ 46.959738] ================================================================== [ 46.960430] BUG: KASAN: use-after-free in z_erofs_shifted_transform+0x2bd/0x370 [ 46.960430] Read of size 4074 at addr ffff8880300c2f8e by task fssum/188 ... [ 46.960430] Call Trace: [ 46.960430] <TASK> [ 46.960430] dump_stack_lvl+0x41/0x5e [ 46.960430] print_report.cold+0xb2/0x6b7 [ 46.960430] ? z_erofs_shifted_transform+0x2bd/0x370 [ 46.960430] kasan_report+0x8a/0x140 [ 46.960430] ? z_erofs_shifted_transform+0x2bd/0x370 [ 46.960430] kasan_check_range+0x14d/0x1d0 [ 46.960430] memcpy+0x20/0x60 [ 46.960430] z_erofs_shifted_transform+0x2bd/0x370 [ 46.960430] z_erofs_decompress_pcluster+0xaae/0x1080 The root cause is that the tail pcluster won't be a complete filesystem block anymore. So if ztailpacking is used, the second part of an uncompressed tail pcluster may not be ``rq->pageofs_out``.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025951": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ath11k: free peer for station when disconnect from AP for QCA6390/WCN6855 Commit b4a0f54156ac (\"ath11k: move peer delete after vdev stop of station for QCA6390 and WCN6855\") is to fix firmware crash by changing the WMI command sequence, but actually skip all the peer delete operation, then it lead commit 58595c9874c6 (\"ath11k: Fixing dangling pointer issue upon peer delete failure\") not take effect, and then happened a use-after-free warning from KASAN. because the peer->sta is not set to NULL and then used later. Change to only skip the WMI_PEER_DELETE_CMDID for QCA6390/WCN6855. log of user-after-free: [ 534.888665] BUG: KASAN: use-after-free in ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k] [ 534.888696] Read of size 8 at addr ffff8881396bb1b8 by task rtcwake/2860 [ 534.888705] CPU: 4 PID: 2860 Comm: rtcwake Kdump: loaded Tainted: G W 5.15.0-wt-ath+ #523 [ 534.888712] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021 [ 534.888716] Call Trace: [ 534.888720] <IRQ> [ 534.888726] dump_stack_lvl+0x57/0x7d [ 534.888736] print_address_description.constprop.0+0x1f/0x170 [ 534.888745] ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k] [ 534.888771] kasan_report.cold+0x83/0xdf [ 534.888783] ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k] [ 534.888810] ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k] [ 534.888840] ath11k_dp_rx_process_mon_status+0x529/0xa70 [ath11k] [ 534.888874] ? ath11k_dp_rx_mon_status_bufs_replenish+0x3f0/0x3f0 [ath11k] [ 534.888897] ? check_prev_add+0x20f0/0x20f0 [ 534.888922] ? __lock_acquire+0xb72/0x1870 [ 534.888937] ? find_held_lock+0x33/0x110 [ 534.888954] ath11k_dp_rx_process_mon_rings+0x297/0x520 [ath11k] [ 534.888981] ? rcu_read_unlock+0x40/0x40 [ 534.888990] ? ath11k_dp_rx_pdev_alloc+0xd90/0xd90 [ath11k] [ 534.889026] ath11k_dp_service_mon_ring+0x67/0xe0 [ath11k] [ 534.889053] ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k] [ 534.889075] call_timer_fn+0x167/0x4a0 [ 534.889084] ? add_timer_on+0x3b0/0x3b0 [ 534.889103] ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370 [ 534.889117] __run_timers.part.0+0x539/0x8b0 [ 534.889123] ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k] [ 534.889157] ? call_timer_fn+0x4a0/0x4a0 [ 534.889164] ? mark_lock_irq+0x1c30/0x1c30 [ 534.889173] ? clockevents_program_event+0xdd/0x280 [ 534.889189] ? mark_held_locks+0xa5/0xe0 [ 534.889203] run_timer_softirq+0x97/0x180 [ 534.889213] __do_softirq+0x276/0x86a [ 534.889230] __irq_exit_rcu+0x11c/0x180 [ 534.889238] irq_exit_rcu+0x5/0x20 [ 534.889244] sysvec_apic_timer_interrupt+0x8e/0xc0 [ 534.889251] </IRQ> [ 534.889254] <TASK> [ 534.889259] asm_sysvec_apic_timer_interrupt+0x12/0x20 [ 534.889265] RIP: 0010:_raw_spin_unlock_irqrestore+0x38/0x70 [ 534.889271] Code: 74 24 10 e8 ea c2 bf fd 48 89 ef e8 12 53 c0 fd 81 e3 00 02 00 00 75 25 9c 58 f6 c4 02 75 2d 48 85 db 74 01 fb bf 01 00 00 00 <e8> 13 a7 b5 fd 65 8b 05 cc d9 9c 5e 85 c0 74 0a 5b 5d c3 e8 a0 ee [ 534.889276] RSP: 0018:ffffc90002e5f880 EFLAGS: 00000206 [ 534.889284] RAX: 0000000000000006 RBX: 0000000000000200 RCX: ffffffff9f256f10 [ 534.889289] RDX: 0000000000000000 RSI: ffffffffa1c6e420 RDI: 0000000000000001 [ 534.889293] RBP: ffff8881095e6200 R08: 0000000000000001 R09: ffffffffa40d2b8f [ 534.889298] R10: fffffbfff481a571 R11: 0000000000000001 R12: ffff8881095e6e68 [ 534.889302] R13: ffffc90002e5f908 R14: 0000000000000246 R15: 0000000000000000 [ 534.889316] ? mark_lock+0xd0/0x14a0 [ 534.889332] klist_next+0x1d4/0x450 [ 534.889340] ? dpm_wait_for_subordinate+0x2d0/0x2d0 [ 534.889350] device_for_each_child+0xa8/0x140 [ 534.889360] ? device_remove_class_symlinks+0x1b0/0x1b0 [ 534.889370] ? __lock_release+0x4bd/0x9f0 [ 534.889378] ? dpm_suspend+0x26b/0x3f0 [ 534.889390] dpm_wait_for_subordinate+ ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025952": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: phylib: fix potential use-after-free Commit bafbdd527d56 (\"phylib: Add device reset GPIO support\") added call to phy_device_reset(phydev) after the put_device() call in phy_detach(). The comment before the put_device() call says that the phydev might go away with put_device(). Fix potential use-after-free by calling phy_device_reset() before put_device().",
        "technologies": "Linux\nLinux Kernel 4.16 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.176 未満\nLinux Kernel 5.5 以上 5.10.96 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-025954": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bfq: Avoid merging queues with different parents It can happen that the parent of a bfqq changes between the moment we decide two queues are worth to merge (and set bic->stable_merge_bfqq) and the moment bfq_setup_merge() is called. This can happen e.g. because the process submitted IO for a different cgroup and thus bfqq got reparented. It can even happen that the bfqq we are merging with has parent cgroup that is already offline and going to be destroyed in which case the merge can lead to use-after-free issues such as: BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50 Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544 CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G E 5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014 Call Trace: <IRQ> dump_stack_lvl+0x46/0x5a print_address_description.constprop.0+0x1f/0x140 ? __bfq_deactivate_entity+0x9cb/0xa50 kasan_report.cold+0x7f/0x11b ? __bfq_deactivate_entity+0x9cb/0xa50 __bfq_deactivate_entity+0x9cb/0xa50 ? update_curr+0x32f/0x5d0 bfq_deactivate_entity+0xa0/0x1d0 bfq_del_bfqq_busy+0x28a/0x420 ? resched_curr+0x116/0x1d0 ? bfq_requeue_bfqq+0x70/0x70 ? check_preempt_wakeup+0x52b/0xbc0 __bfq_bfqq_expire+0x1a2/0x270 bfq_bfqq_expire+0xd16/0x2160 ? try_to_wake_up+0x4ee/0x1260 ? bfq_end_wr_async_queues+0xe0/0xe0 ? _raw_write_unlock_bh+0x60/0x60 ? _raw_spin_lock_irq+0x81/0xe0 bfq_idle_slice_timer+0x109/0x280 ? bfq_dispatch_request+0x4870/0x4870 __hrtimer_run_queues+0x37d/0x700 ? enqueue_hrtimer+0x1b0/0x1b0 ? kvm_clock_get_cycles+0xd/0x10 ? ktime_get_update_offsets_now+0x6f/0x280 hrtimer_interrupt+0x2c8/0x740 Fix the problem by checking that the parent of the two bfqqs we are merging in bfq_setup_merge() is the same.",
        "technologies": "Linux\nLinux Kernel 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.13 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025955": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix use-after-free in chanctx code In ieee80211_vif_use_reserved_context(), when we have an old context and the new context's replace_state is set to IEEE80211_CHANCTX_REPLACE_NONE, we free the old context in ieee80211_vif_use_reserved_reassign(). Therefore, we cannot check the old_ctx anymore, so we should set it to NULL after this point. However, since the new_ctx replace state is clearly not IEEE80211_CHANCTX_REPLACES_OTHER, we're not going to do anything else in this function and can just return to avoid accessing the freed old_ctx.",
        "technologies": "Linux\nLinux Kernel 3.17 以上 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025979": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix use after free in hci_send_acl This fixes the following trace caused by receiving HCI_EV_DISCONN_PHY_LINK_COMPLETE which does call hci_conn_del without first checking if conn->type is in fact AMP_LINK and in case it is do properly cleanup upper layers with hci_disconn_cfm: ================================================================== BUG: KASAN: use-after-free in hci_send_acl+0xaba/0xc50 Read of size 8 at addr ffff88800e404818 by task bluetoothd/142 CPU: 0 PID: 142 Comm: bluetoothd Not tainted 5.17.0-rc5-00006-gda4022eeac1a #7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x45/0x59 print_address_description.constprop.0+0x1f/0x150 kasan_report.cold+0x7f/0x11b hci_send_acl+0xaba/0xc50 l2cap_do_send+0x23f/0x3d0 l2cap_chan_send+0xc06/0x2cc0 l2cap_sock_sendmsg+0x201/0x2b0 sock_sendmsg+0xdc/0x110 sock_write_iter+0x20f/0x370 do_iter_readv_writev+0x343/0x690 do_iter_write+0x132/0x640 vfs_writev+0x198/0x570 do_writev+0x202/0x280 do_syscall_64+0x38/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae RSP: 002b:00007ffce8a099b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000014 Code: 0f 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 14 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 89 74 24 10 RDX: 0000000000000001 RSI: 00007ffce8a099e0 RDI: 0000000000000015 RAX: ffffffffffffffda RBX: 00007ffce8a099e0 RCX: 00007f788fc3cf77 R10: 00007ffce8af7080 R11: 0000000000000246 R12: 000055e4ccf75580 RBP: 0000000000000015 R08: 0000000000000002 R09: 0000000000000001 </TASK> R13: 000055e4ccf754a0 R14: 000055e4ccf75cd0 R15: 000055e4ccf4a6b0 Allocated by task 45: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0x81/0xa0 hci_chan_create+0x9a/0x2f0 l2cap_conn_add.part.0+0x1a/0xdc0 l2cap_connect_cfm+0x236/0x1000 le_conn_complete_evt+0x15a7/0x1db0 hci_le_conn_complete_evt+0x226/0x2c0 hci_le_meta_evt+0x247/0x450 hci_event_packet+0x61b/0xe90 hci_rx_work+0x4d5/0xc50 process_one_work+0x8fb/0x15a0 worker_thread+0x576/0x1240 kthread+0x29d/0x340 ret_from_fork+0x1f/0x30 Freed by task 45: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_set_free_info+0x20/0x30 __kasan_slab_free+0xfb/0x130 kfree+0xac/0x350 hci_conn_cleanup+0x101/0x6a0 hci_conn_del+0x27e/0x6c0 hci_disconn_phylink_complete_evt+0xe0/0x120 hci_event_packet+0x812/0xe90 hci_rx_work+0x4d5/0xc50 process_one_work+0x8fb/0x15a0 worker_thread+0x576/0x1240 kthread+0x29d/0x340 ret_from_fork+0x1f/0x30 The buggy address belongs to the object at ffff88800c0f0500 The buggy address is located 24 bytes inside of which belongs to the cache kmalloc-128 of size 128 The buggy address belongs to the page: 128-byte region [ffff88800c0f0500, ffff88800c0f0580) flags: 0x100000000000200(slab|node=0|zone=1) page:00000000fe45cd86 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xc0f0 raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000 raw: 0100000000000200 ffffea00003a2c80 dead000000000004 ffff8880078418c0 page dumped because: kasan: bad access detected ffff88800c0f0400: 00 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc Memory state around the buggy address: >ffff88800c0f0500: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff88800c0f0480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffff88800c0f0580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-025978": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: fix race on unaccepted mptcp sockets When the listener socket owning the relevant request is closed, it frees the unaccepted subflows and that causes later deletion of the paired MPTCP sockets. The mptcp socket's worker can run in the time interval between such delete operations. When that happens, any access to msk->first will cause an UaF access, as the subflow cleanup did not cleared such field in the mptcp socket. Address the issue explicitly traversing the listener socket accept queue at close time and performing the needed cleanup on the pending msk. Note that the locking is a bit tricky, as we need to acquire the msk socket lock, while still owning the subflow socket one.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 5.18.10 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025966": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usbnet: Run unregister_netdev() before unbind() again Commit 2c9d6c2b871d (\"usbnet: run unbind() before unregister_netdev()\") sought to fix a use-after-free on disconnect of USB Ethernet adapters. It turns out that a different fix is necessary to address the issue: https://lore.kernel.org/netdev/18b3541e5372bc9b9fc733d422f4e698c089077c.1650177997.git.lukas@wunner.de/ So the commit was not necessary. The commit made binding and unbinding of USB Ethernet asymmetrical: Before, usbnet_probe() first invoked the ->bind() callback and then register_netdev(). usbnet_disconnect() mirrored that by first invoking unregister_netdev() and then ->unbind(). Since the commit, the order in usbnet_disconnect() is reversed and no longer mirrors usbnet_probe(). One consequence is that a PHY disconnected (and stopped) in ->unbind() is afterwards stopped once more by unregister_netdev() as it closes the netdev before unregistering. That necessitates a contortion in ->stop() because the PHY may only be stopped if it hasn't already been disconnected. Reverting the commit allows making the call to phy_stop() unconditional in ->stop().",
        "technologies": "Linux\nLinux Kernel 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025985": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: lz4: fix LZ4_decompress_safe_partial read out of bound When partialDecoding, it is EOF if we've either filled the output buffer or can't proceed with reading an offset for following match. In some extreme corner cases when compressed data is suitably corrupted, UAF will occur. As reported by KASAN [1], LZ4_decompress_safe_partial may lead to read out of bound problem during decoding. lz4 upstream has fixed it [2] and this issue has been disscussed here [3] before. current decompression routine was ported from lz4 v1.8.3, bumping lib/lz4 to v1.9.+ is certainly a huge work to be done later, so, we'd better fix it first. [1] https://lore.kernel.org/all/000000000000830d1205cf7f0477@google.com/ [2] https://github.com/lz4/lz4/commit/c5d6f8a8be3927c0bec91bcc58667a6cfad244ad# [3] https://lore.kernel.org/all/CC666AE8-4CA4-4951-B6FB-A2EFDE3AC03B@fb.com/",
        "technologies": "Linux\nLinux Kernel 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-025987": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: skbuff: fix coalescing for page_pool fragment recycling Fix a use-after-free when using page_pool with page fragments. We encountered this problem during normal RX in the hns3 driver: (1) Initially we have three descriptors in the RX queue. The first one allocates PAGE1 through page_pool, and the other two allocate one half of PAGE2 each. Page references look like this: RX_BD1 _______ PAGE1 RX_BD2 _______ PAGE2 RX_BD3 _________/ (2) Handle RX on the first descriptor. Allocate SKB1, eventually added to the receive queue by tcp_queue_rcv(). (3) Handle RX on the second descriptor. Allocate SKB2 and pass it to netif_receive_skb(): netif_receive_skb(SKB2) ip_rcv(SKB2) SKB3 = skb_clone(SKB2) SKB2 and SKB3 share a reference to PAGE2 through skb_shinfo()->dataref. The other ref to PAGE2 is still held by RX_BD3: SKB2 ---+- PAGE2 SKB3 __/ / RX_BD3 _________/ (3b) Now while handling TCP, coalesce SKB3 with SKB1: tcp_v4_rcv(SKB3) tcp_try_coalesce(to=SKB1, from=SKB3) // succeeds kfree_skb_partial(SKB3) skb_release_data(SKB3) // drops one dataref SKB1 _____ PAGE1 \\____ SKB2 _____ PAGE2 / RX_BD3 _________/ In skb_try_coalesce(), __skb_frag_ref() takes a page reference to PAGE2, where it should instead have increased the page_pool frag reference, pp_frag_count. Without coalescing, when releasing both SKB2 and SKB3, a single reference to PAGE2 would be dropped. Now when releasing SKB1 and SKB2, two references to PAGE2 will be dropped, resulting in underflow. (3c) Drop SKB2: af_packet_rcv(SKB2) consume_skb(SKB2) skb_release_data(SKB2) // drops second dataref page_pool_return_skb_page(PAGE2) // drops one pp_frag_count SKB1 _____ PAGE1 \\____ PAGE2 / RX_BD3 _________/ (4) Userspace calls recvmsg() Copies SKB1 and releases it. Since SKB3 was coalesced with SKB1, we release the SKB3 page as well: tcp_eat_recv_skb(SKB1) skb_release_data(SKB1) page_pool_return_skb_page(PAGE1) page_pool_return_skb_page(PAGE2) // drops second pp_frag_count (5) PAGE2 is freed, but the third RX descriptor was still using it! In our case this causes IOMMU faults, but it would silently corrupt memory if the IOMMU was disabled. Change the logic that checks whether pp_recycle SKBs can be coalesced. We still reject differing pp_recycle between 'from' and 'to' SKBs, but in order to avoid the situation described above, we also reject coalescing when both 'from' and 'to' are pp_recycled and 'from' is cloned. The new logic allows coalescing a cloned pp_recycle SKB into a page refcounted one, because in this case the release (4) will drop the right reference, the one taken by skb_try_coalesce().",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025986": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rxrpc: fix a race in rxrpc_exit_net() Current code can lead to the following race: CPU0 CPU1 rxrpc_exit_net() rxrpc_peer_keepalive_worker() if (rxnet->live) rxnet->live = false; del_timer_sync(&rxnet->peer_keepalive_timer); timer_reduce(&rxnet->peer_keepalive_timer, jiffies + delay); cancel_work_sync(&rxnet->peer_keepalive_work); rxrpc_exit_net() exits while peer_keepalive_timer is still armed, leading to use-after-free. syzbot report was: ODEBUG: free active (active state 0) object type: timer_list hint: rxrpc_peer_keepalive_timeout+0x0/0xb0 WARNING: CPU: 0 PID: 3660 at lib/debugobjects.c:505 debug_print_object+0x16e/0x250 lib/debugobjects.c:505 Modules linked in: CPU: 0 PID: 3660 Comm: kworker/u4:6 Not tainted 5.17.0-syzkaller-13993-g88e6c0207623 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: netns cleanup_net RIP: 0010:debug_print_object+0x16e/0x250 lib/debugobjects.c:505 Code: ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 af 00 00 00 48 8b 14 dd 00 1c 26 8a 4c 89 ee 48 c7 c7 00 10 26 8a e8 b1 e7 28 05 <0f> 0b 83 05 15 eb c5 09 01 48 83 c4 18 5b 5d 41 5c 41 5d 41 5e c3 RSP: 0018:ffffc9000353fb00 EFLAGS: 00010082 RAX: 0000000000000000 RBX: 0000000000000003 RCX: 0000000000000000 RDX: ffff888029196140 RSI: ffffffff815efad8 RDI: fffff520006a7f52 RBP: 0000000000000001 R08: 0000000000000000 R09: 0000000000000000 R10: ffffffff815ea4ae R11: 0000000000000000 R12: ffffffff89ce23e0 R13: ffffffff8a2614e0 R14: ffffffff816628c0 R15: dffffc0000000000 FS: 0000000000000000(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fe1f2908924 CR3: 0000000043720000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> __debug_check_no_obj_freed lib/debugobjects.c:992 [inline] debug_check_no_obj_freed+0x301/0x420 lib/debugobjects.c:1023 kfree+0xd6/0x310 mm/slab.c:3809 ops_free_list.part.0+0x119/0x370 net/core/net_namespace.c:176 ops_free_list net/core/net_namespace.c:174 [inline] cleanup_net+0x591/0xb00 net/core/net_namespace.c:598 process_one_work+0x996/0x1610 kernel/workqueue.c:2289 worker_thread+0x665/0x1080 kernel/workqueue.c:2436 kthread+0x2e9/0x3a0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:298 </TASK>",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025988": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm: fix use-after-free in dm_cleanup_zoned_dev() dm_cleanup_zoned_dev() uses queue, so it must be called before blk_cleanup_disk() starts its killing: blk_cleanup_disk->blk_cleanup_queue()->kobject_put()->blk_release_queue()-> ->...RCU...->blk_free_queue_rcu()->kmem_cache_free() Otherwise, RCU callback may be executed first and dm_cleanup_zoned_dev() will touch free'd memory: BUG: KASAN: use-after-free in dm_cleanup_zoned_dev+0x33/0xd0 Read of size 8 at addr ffff88805ac6e430 by task dmsetup/681 CPU: 4 PID: 681 Comm: dmsetup Not tainted 5.17.0-rc2+ #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x57/0x7d print_address_description.constprop.0+0x1f/0x150 ? dm_cleanup_zoned_dev+0x33/0xd0 kasan_report.cold+0x7f/0x11b ? dm_cleanup_zoned_dev+0x33/0xd0 dm_cleanup_zoned_dev+0x33/0xd0 __dm_destroy+0x26a/0x400 ? dm_blk_ioctl+0x230/0x230 ? up_write+0xd8/0x270 dev_remove+0x156/0x1d0 ctl_ioctl+0x269/0x530 ? table_clear+0x140/0x140 ? lock_release+0xb2/0x750 ? remove_all+0x40/0x40 ? rcu_read_lock_sched_held+0x12/0x70 ? lock_downgrade+0x3c0/0x3c0 ? rcu_read_lock_sched_held+0x12/0x70 dm_ctl_ioctl+0xa/0x10 __x64_sys_ioctl+0xb9/0xf0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7fb6dfa95c27",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025990": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: pci: cx23885: Fix the error handling in cx23885_initdev() When the driver fails to call the dma_set_mask(), the driver will get the following splat: [ 55.853884] BUG: KASAN: use-after-free in __process_removed_driver+0x3c/0x240 [ 55.854486] Read of size 8 at addr ffff88810de60408 by task modprobe/590 [ 55.856822] Call Trace: [ 55.860327] __process_removed_driver+0x3c/0x240 [ 55.861347] bus_for_each_dev+0x102/0x160 [ 55.861681] i2c_del_driver+0x2f/0x50 This is because the driver has initialized the i2c related resources in cx23885_dev_setup() but not released them in error handling, fix this bug by modifying the error path that jumps after failing to call the dma_set_mask().",
        "technologies": "Linux\nLinux Kernel 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025989": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix use-after-free in ext4_rename_dir_prepare We got issue as follows: EXT4-fs (loop0): mounted filesystem without journal. Opts: ,errors=continue ext4_get_first_dir_block: bh->b_data=0xffff88810bee6000 len=34478 ext4_get_first_dir_block: *parent_de=0xffff88810beee6ae bh->b_data=0xffff88810bee6000 ext4_rename_dir_prepare: [1] parent_de=0xffff88810beee6ae ================================================================== BUG: KASAN: use-after-free in ext4_rename_dir_prepare+0x152/0x220 Read of size 4 at addr ffff88810beee6ae by task rep/1895 CPU: 13 PID: 1895 Comm: rep Not tainted 5.10.0+ #241 Call Trace: dump_stack+0xbe/0xf9 print_address_description.constprop.0+0x1e/0x220 kasan_report.cold+0x37/0x7f ext4_rename_dir_prepare+0x152/0x220 ext4_rename+0xf44/0x1ad0 ext4_rename2+0x11c/0x170 vfs_rename+0xa84/0x1440 do_renameat2+0x683/0x8f0 __x64_sys_renameat+0x53/0x60 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 RIP: 0033:0x7f45a6fc41c9 RSP: 002b:00007ffc5a470218 EFLAGS: 00000246 ORIG_RAX: 0000000000000108 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f45a6fc41c9 RDX: 0000000000000005 RSI: 0000000020000180 RDI: 0000000000000005 RBP: 00007ffc5a470240 R08: 00007ffc5a470160 R09: 0000000020000080 R10: 00000000200001c0 R11: 0000000000000246 R12: 0000000000400bb0 R13: 00007ffc5a470320 R14: 0000000000000000 R15: 0000000000000000 The buggy address belongs to the page: page:00000000440015ce refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x10beee flags: 0x200000000000000() raw: 0200000000000000 ffffea00043ff4c8 ffffea0004325608 0000000000000000 raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff88810beee580: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff88810beee600: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff >ffff88810beee680: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ^ ffff88810beee700: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff88810beee780: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ================================================================== Disabling lock debugging due to kernel taint ext4_rename_dir_prepare: [2] parent_de->inode=3537895424 ext4_rename_dir_prepare: [3] dir=0xffff888124170140 ext4_rename_dir_prepare: [4] ino=2 ext4_rename_dir_prepare: ent->dir->i_ino=2 parent=-757071872 Reason is first directory entry which 'rec_len' is 34478, then will get illegal parent entry. Now, we do not check directory entry after read directory block in 'ext4_get_first_dir_block'. To solve this issue, check directory entry in 'ext4_get_first_dir_block'. [ Trigger an ext4_error() instead of just warning if the directory is missing a '.' or '..' entry. Also make sure we return an error code if the file system is corrupted. -TYT ]",
        "technologies": "Linux\nLinux Kernel 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025984": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bfq: Make sure bfqg for which we are queueing requests is online Bios queued into BFQ IO scheduler can be associated with a cgroup that was already offlined. This may then cause insertion of this bfq_group into a service tree. But this bfq_group will get freed as soon as last bio associated with it is completed leading to use after free issues for service tree users. Fix the problem by making sure we always operate on online bfq_group. If the bfq_group associated with the bio is not online, we pick the first online parent.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-025981": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: add vlan list lock to protect vlan list When adding port base VLAN, vf VLAN need to remove from HW and modify the vlan state in vf VLAN list as false. If the periodicity task is freeing the same node, it may cause \"use after free\" error. This patch adds a vlan list lock to protect the vlan list.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025983": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFSD: Fix potential use-after-free in nfsd_file_put() nfsd_file_put_noref() can free @nf, so don't dereference @nf immediately upon return from nfsd_file_put_noref().",
        "technologies": "Linux\nLinux Kernel 5.18 以上 5.18.4 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025991": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tipc: fix use-after-free Read in tipc_named_reinit syzbot found the following issue on: ================================================================== BUG: KASAN: use-after-free in tipc_named_reinit+0x94f/0x9b0 net/tipc/name_distr.c:413 Read of size 8 at addr ffff88805299a000 by task kworker/1:9/23764 CPU: 1 PID: 23764 Comm: kworker/1:9 Not tainted 5.18.0-rc4-syzkaller-00878-g17d49e6e8012 #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events tipc_net_finalize_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0xeb/0x495 mm/kasan/report.c:313 print_report mm/kasan/report.c:429 [inline] kasan_report.cold+0xf4/0x1c6 mm/kasan/report.c:491 tipc_named_reinit+0x94f/0x9b0 net/tipc/name_distr.c:413 tipc_net_finalize+0x234/0x3d0 net/tipc/net.c:138 process_one_work+0x996/0x1610 kernel/workqueue.c:2289 worker_thread+0x665/0x1080 kernel/workqueue.c:2436 kthread+0x2e9/0x3a0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:298 </TASK> [...] ================================================================== In the commit d966ddcc3821 (\"tipc: fix a deadlock when flushing scheduled work\"), the cancel_work_sync() function just to make sure ONLY the work tipc_net_finalize_work() is executing/pending on any CPU completed before tipc namespace is destroyed through tipc_exit_net(). But this function is not guaranteed the work is the last queued. So, the destroyed instance may be accessed in the work which will try to enqueue later. In order to completely fix, we re-order the calling of cancel_work_sync() to make sure the work tipc_net_finalize_work() was last queued and it must be completed by calling cancel_work_sync().",
        "technologies": "Linux\nLinux Kernel 5.4.83 以上 5.5 未満\nLinux Kernel 5.9.14 以上 5.10.127 未満\nLinux Kernel 5.11 以上 5.15.51 未満\nLinux Kernel 5.16 以上 5.18.8 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025980": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: mt7921: fix crash when startup fails. If the nic fails to start, it is possible that the reset_work has already been scheduled. Ensure the work item is canceled so we do not have use-after-free crash in case cleanup is called before the work item is executed. This fixes crash on my x86_64 apu2 when mt7921k radio fails to work. Radio still fails, but OS does not crash.",
        "technologies": "Linux\nLinux Kernel 4.16 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-025982": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: pcm: Fix races among concurrent hw_params and hw_free calls Currently we have neither proper check nor protection against the concurrent calls of PCM hw_params and hw_free ioctls, which may result in a UAF. Since the existing PCM stream lock can't be used for protecting the whole ioctl operations, we need a new mutex to protect those racy calls. This patch introduced a new mutex, runtime->buffer_mutex, and applies it to both hw_params and hw_free ioctl code paths. Along with it, the both functions are slightly modified (the mmap_count check is moved into the state-check block) for code simplicity.",
        "technologies": "Linux\nLinux Kernel 4.14.279 未満\nLinux Kernel 4.15 以上 4.19.243 未満\nLinux Kernel 4.20 以上 5.4.193 未満\nLinux Kernel 5.5 以上 5.10.109 未満\nLinux Kernel 5.11 以上 5.15.32 未満\nLinux Kernel 5.16 以上 5.16.18 未満\nLinux Kernel 5.17 以上 5.17.1 未満"
    },
    "JVNDB-2022-025992": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: libfc: Fix use after free in fc_exch_abts_resp() fc_exch_release(ep) will decrease the ep's reference count. When the reference count reaches zero, it is freed. But ep is still used in the following code, which will lead to a use after free. Return after the fc_exch_release() call to avoid use after free.",
        "technologies": "Linux\nLinux Kernel 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満"
    },
    "JVNDB-2022-025997": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/slub: add missing TID updates on slab deactivation The fastpath in slab_alloc_node() assumes that c->slab is stable as long as the TID stays the same. However, two places in __slab_alloc() currently don't update the TID when deactivating the CPU slab. If multiple operations race the right way, this could lead to an object getting lost; or, in an even more unlikely situation, it could even lead to an object being freed onto the wrong slab's freelist, messing up the `inuse` counter and eventually causing a page to be freed to the page allocator while it still contains slab objects. (I haven't actually tested these cases though, this is just based on looking at the code. Writing testcases for this stuff seems like it'd be a pain...) The race leading to state inconsistency is (all operations on the same CPU and kmem_cache): - task A: begin do_slab_free(): - read TID - read pcpu freelist (==NULL) - check `slab == c->slab` (true) - [PREEMPT A->B] - task B: begin slab_alloc_node(): - fastpath fails (`c->freelist` is NULL) - enter __slab_alloc() - slub_get_cpu_ptr() (disables preemption) - enter ___slab_alloc() - take local_lock_irqsave() - read c->freelist as NULL - get_freelist() returns NULL - write `c->slab = NULL` - drop local_unlock_irqrestore() - goto new_slab - slub_percpu_partial() is NULL - get_partial() returns NULL - slub_put_cpu_ptr() (enables preemption) - [PREEMPT B->A] - task A: finish do_slab_free(): - this_cpu_cmpxchg_double() succeeds() - [CORRUPT STATE: c->slab==NULL, c->freelist!=NULL] From there, the object on c->freelist will get lost if task B is allowed to continue from here: It will proceed to the retry_load_slab label, set c->slab, then jump to load_freelist, which clobbers c->freelist. But if we instead continue as follows, we get worse corruption: - task A: run __slab_free() on object from other struct slab: - CPU_PARTIAL_FREE case (slab was on no list, is now on pcpu partial) - task A: run slab_alloc_node() with NUMA node constraint: - fastpath fails (c->slab is NULL) - call __slab_alloc() - slub_get_cpu_ptr() (disables preemption) - enter ___slab_alloc() - c->slab is NULL: goto new_slab - slub_percpu_partial() is non-NULL - set c->slab to slub_percpu_partial(c) - [CORRUPT STATE: c->slab points to slab-1, c->freelist has objects from slab-2] - goto redo - node_match() fails - goto deactivate_slab - existing c->freelist is passed into deactivate_slab() - inuse count of slab-1 is decremented to account for object from slab-2 At this point, the inuse count of slab-1 is 1 lower than it should be. This means that if we free all allocated objects in slab-1 except for one, SLUB will think that slab-1 is completely unused, and may free its page, leading to use-after-free.",
        "technologies": "Linux\nLinux Kernel 3.1 以上 4.9.323 未満\nLinux Kernel 4.10 以上 4.14.288 未満\nLinux Kernel 4.15 以上 4.19.252 未満\nLinux Kernel 4.20 以上 5.4.205 未満\nLinux Kernel 5.5 以上 5.10.130 未満\nLinux Kernel 5.11 以上 5.15.54 未満\nLinux Kernel 5.16 以上 5.18.8 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-025994": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix UAF due to race between btf_try_get_module and load_module While working on code to populate kfunc BTF ID sets for module BTF from its initcall, I noticed that by the time the initcall is invoked, the module BTF can already be seen by userspace (and the BPF verifier). The existing btf_try_get_module calls try_module_get which only fails if mod->state == MODULE_STATE_GOING, i.e. it can increment module reference when module initcall is happening in parallel. Currently, BTF parsing happens from MODULE_STATE_COMING notifier callback. At this point, the module initcalls have not been invoked. The notifier callback parses and prepares the module BTF, allocates an ID, which publishes it to userspace, and then adds it to the btf_modules list allowing the kernel to invoke btf_try_get_module for the BTF. However, at this point, the module has not been fully initialized (i.e. its initcalls have not finished). The code in module.c can still fail and free the module, without caring for other users. However, nothing stops btf_try_get_module from succeeding between the state transition from MODULE_STATE_COMING to MODULE_STATE_LIVE. This leads to a use-after-free issue when BPF program loads successfully in the state transition, load_module's do_init_module call fails and frees the module, and BPF program fd on close calls module_put for the freed module. Future patch has test case to verify we don't regress in this area in future. There are multiple points after prepare_coming_module (in load_module) where failure can occur and module loading can return error. We illustrate and test for the race using the last point where it can practically occur (in module __init function). An illustration of the race: CPU 0 CPU 1 load_module notifier_call(MODULE_STATE_COMING) btf_parse_module btf_alloc_id // Published to userspace list_add(&btf_mod->list, btf_modules) mod->init(...) ... ^ bpf_check | check_pseudo_btf_id | btf_try_get_module | returns true | ... ... | module __init in progress return prog_fd | ... ... V if (ret < 0) free_module(mod) ... close(prog_fd) ... bpf_prog_free_deferred module_put(used_btf.mod) // use-after-free We fix this issue by setting a flag BTF_MODULE_F_LIVE, from the notifier callback when MODULE_STATE_LIVE state is reached for the module, so that we return NULL from btf_try_get_module for modules that are not fully formed. Since try_module_get already checks that module is not in MODULE_STATE_GOING state, and that is the only transition a live module can make before being removed from btf_modules list, this is enough to close the race and prevent the bug. A later selftest patch crafts the race condition artifically to verify that it has been fixed, and that verifier fails to load program (with ENXIO). Lastly, a couple of comments: 1. Even if this race didn't exist, it seems more appropriate to only access resources (ksyms and kfuncs) of a fully formed module which has been initialized completely. 2. This patch was born out of need for synchronization against module initcall for the next patch, so it is needed for correctness even without the aforementioned race condition. The BTF resources initialized by module initcall are set up once and then only looked up, so just waiting until the initcall has finished ensures correct behavior.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025999": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drbd: Fix five use after free bugs in get_initial_state In get_initial_state, it calls notify_initial_state_done(skb,..) if cb->args[5]==1. If genlmsg_put() failed in notify_initial_state_done(), the skb will be freed by nlmsg_free(skb). Then get_initial_state will goto out and the freed skb will be used by return value skb->len, which is a uaf bug. What's worse, the same problem goes even further: skb can also be freed in the notify_*_state_change -> notify_*_state calls below. Thus 4 additional uaf bugs happened. My patch lets the problem callee functions: notify_initial_state_done and notify_*_state_change return an error code if errors happen. So that the error codes could be propagated and the uaf bugs can be avoid. v2 reports a compilation warning. This v3 fixed this warning and built successfully in my local environment with no additional warnings. v2: https://lore.kernel.org/patchwork/patch/1435218/",
        "technologies": "Linux\nLinux Kernel 4.5 以上 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-025998": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: mpt3sas: Fix use after free in _scsih_expander_node_remove() The function mpt3sas_transport_port_remove() called in _scsih_expander_node_remove() frees the port field of the sas_expander structure, leading to the following use-after-free splat from KASAN when the ioc_info() call following that function is executed (e.g. when doing rmmod of the driver module): [ 3479.371167] ================================================================== [ 3479.378496] BUG: KASAN: use-after-free in _scsih_expander_node_remove+0x710/0x750 [mpt3sas] [ 3479.386936] Read of size 1 at addr ffff8881c037691c by task rmmod/1531 [ 3479.393524] [ 3479.395035] CPU: 18 PID: 1531 Comm: rmmod Not tainted 5.17.0-rc8+ #1436 [ 3479.401712] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.1 06/02/2021 [ 3479.409263] Call Trace: [ 3479.411743] <TASK> [ 3479.413875] dump_stack_lvl+0x45/0x59 [ 3479.417582] print_address_description.constprop.0+0x1f/0x120 [ 3479.423389] ? _scsih_expander_node_remove+0x710/0x750 [mpt3sas] [ 3479.429469] kasan_report.cold+0x83/0xdf [ 3479.433438] ? _scsih_expander_node_remove+0x710/0x750 [mpt3sas] [ 3479.439514] _scsih_expander_node_remove+0x710/0x750 [mpt3sas] [ 3479.445411] ? _raw_spin_unlock_irqrestore+0x2d/0x40 [ 3479.452032] scsih_remove+0x525/0xc90 [mpt3sas] [ 3479.458212] ? mpt3sas_expander_remove+0x1d0/0x1d0 [mpt3sas] [ 3479.465529] ? down_write+0xde/0x150 [ 3479.470746] ? up_write+0x14d/0x460 [ 3479.475840] ? kernfs_find_ns+0x137/0x310 [ 3479.481438] pci_device_remove+0x65/0x110 [ 3479.487013] __device_release_driver+0x316/0x680 [ 3479.493180] driver_detach+0x1ec/0x2d0 [ 3479.498499] bus_remove_driver+0xe7/0x2d0 [ 3479.504081] pci_unregister_driver+0x26/0x250 [ 3479.510033] _mpt3sas_exit+0x2b/0x6cf [mpt3sas] [ 3479.516144] __x64_sys_delete_module+0x2fd/0x510 [ 3479.522315] ? free_module+0xaa0/0xaa0 [ 3479.527593] ? __cond_resched+0x1c/0x90 [ 3479.532951] ? lockdep_hardirqs_on_prepare+0x273/0x3e0 [ 3479.539607] ? syscall_enter_from_user_mode+0x21/0x70 [ 3479.546161] ? trace_hardirqs_on+0x1c/0x110 [ 3479.551828] do_syscall_64+0x35/0x80 [ 3479.556884] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 3479.563402] RIP: 0033:0x7f1fc482483b ... [ 3479.943087] ================================================================== Fix this by introducing the local variable port_id to store the port ID value before executing mpt3sas_transport_port_remove(). This local variable is then used in the call to ioc_info() instead of dereferencing the freed port structure.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-026000": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block, bfq: don't move oom_bfqq Our test report a UAF: [ 2073.019181] ================================================================== [ 2073.019188] BUG: KASAN: use-after-free in __bfq_put_async_bfqq+0xa0/0x168 [ 2073.019191] Write of size 8 at addr ffff8000ccf64128 by task rmmod/72584 [ 2073.019192] [ 2073.019196] CPU: 0 PID: 72584 Comm: rmmod Kdump: loaded Not tainted 4.19.90-yk #5 [ 2073.019198] Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015 [ 2073.019200] Call trace: [ 2073.019203] dump_backtrace+0x0/0x310 [ 2073.019206] show_stack+0x28/0x38 [ 2073.019210] dump_stack+0xec/0x15c [ 2073.019216] print_address_description+0x68/0x2d0 [ 2073.019220] kasan_report+0x238/0x2f0 [ 2073.019224] __asan_store8+0x88/0xb0 [ 2073.019229] __bfq_put_async_bfqq+0xa0/0x168 [ 2073.019233] bfq_put_async_queues+0xbc/0x208 [ 2073.019236] bfq_pd_offline+0x178/0x238 [ 2073.019240] blkcg_deactivate_policy+0x1f0/0x420 [ 2073.019244] bfq_exit_queue+0x128/0x178 [ 2073.019249] blk_mq_exit_sched+0x12c/0x160 [ 2073.019252] elevator_exit+0xc8/0xd0 [ 2073.019256] blk_exit_queue+0x50/0x88 [ 2073.019259] blk_cleanup_queue+0x228/0x3d8 [ 2073.019267] null_del_dev+0xfc/0x1e0 [null_blk] [ 2073.019274] null_exit+0x90/0x114 [null_blk] [ 2073.019278] __arm64_sys_delete_module+0x358/0x5a0 [ 2073.019282] el0_svc_common+0xc8/0x320 [ 2073.019287] el0_svc_handler+0xf8/0x160 [ 2073.019290] el0_svc+0x10/0x218 [ 2073.019291] [ 2073.019294] Allocated by task 14163: [ 2073.019301] kasan_kmalloc+0xe0/0x190 [ 2073.019305] kmem_cache_alloc_node_trace+0x1cc/0x418 [ 2073.019308] bfq_pd_alloc+0x54/0x118 [ 2073.019313] blkcg_activate_policy+0x250/0x460 [ 2073.019317] bfq_create_group_hierarchy+0x38/0x110 [ 2073.019321] bfq_init_queue+0x6d0/0x948 [ 2073.019325] blk_mq_init_sched+0x1d8/0x390 [ 2073.019330] elevator_switch_mq+0x88/0x170 [ 2073.019334] elevator_switch+0x140/0x270 [ 2073.019338] elv_iosched_store+0x1a4/0x2a0 [ 2073.019342] queue_attr_store+0x90/0xe0 [ 2073.019348] sysfs_kf_write+0xa8/0xe8 [ 2073.019351] kernfs_fop_write+0x1f8/0x378 [ 2073.019359] __vfs_write+0xe0/0x360 [ 2073.019363] vfs_write+0xf0/0x270 [ 2073.019367] ksys_write+0xdc/0x1b8 [ 2073.019371] __arm64_sys_write+0x50/0x60 [ 2073.019375] el0_svc_common+0xc8/0x320 [ 2073.019380] el0_svc_handler+0xf8/0x160 [ 2073.019383] el0_svc+0x10/0x218 [ 2073.019385] [ 2073.019387] Freed by task 72584: [ 2073.019391] __kasan_slab_free+0x120/0x228 [ 2073.019394] kasan_slab_free+0x10/0x18 [ 2073.019397] kfree+0x94/0x368 [ 2073.019400] bfqg_put+0x64/0xb0 [ 2073.019404] bfqg_and_blkg_put+0x90/0xb0 [ 2073.019408] bfq_put_queue+0x220/0x228 [ 2073.019413] __bfq_put_async_bfqq+0x98/0x168 [ 2073.019416] bfq_put_async_queues+0xbc/0x208 [ 2073.019420] bfq_pd_offline+0x178/0x238 [ 2073.019424] blkcg_deactivate_policy+0x1f0/0x420 [ 2073.019429] bfq_exit_queue+0x128/0x178 [ 2073.019433] blk_mq_exit_sched+0x12c/0x160 [ 2073.019437] elevator_exit+0xc8/0xd0 [ 2073.019440] blk_exit_queue+0x50/0x88 [ 2073.019443] blk_cleanup_queue+0x228/0x3d8 [ 2073.019451] null_del_dev+0xfc/0x1e0 [null_blk] [ 2073.019459] null_exit+0x90/0x114 [null_blk] [ 2073.019462] __arm64_sys_delete_module+0x358/0x5a0 [ 2073.019467] el0_svc_common+0xc8/0x320 [ 2073.019471] el0_svc_handler+0xf8/0x160 [ 2073.019474] el0_svc+0x10/0x218 [ 2073.019475] [ 2073.019479] The buggy address belongs to the object at ffff8000ccf63f00 which belongs to the cache kmalloc-1024 of size 1024 [ 2073.019484] The buggy address is located 552 bytes inside of 1024-byte region [ffff8000ccf63f00, ffff8000ccf64300) [ 2073.019486] The buggy address belongs to the page: [ 2073.019492] page:ffff7e000333d800 count:1 mapcount:0 mapping:ffff8000c0003a00 index:0x0 compound_mapcount: 0 [ 2073.020123] flags: 0x7ffff0000008100(slab|head) [ 2073.020403] raw: 07ffff0000008100 ffff7e0003334c08 ffff7e00001f5a08 ffff8000c0003a00 [ 2073.020409] ra ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-025996": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: blk-mq: don't touch ->tagset in blk_mq_get_sq_hctx blk_mq_run_hw_queues() could be run when there isn't queued request and after queue is cleaned up, at that time tagset is freed, because tagset lifetime is covered by driver, and often freed after blk_cleanup_queue() returns. So don't touch ->tagset for figuring out current default hctx by the mapping built in request queue, so use-after-free on tagset can be avoided. Meantime this way should be fast than retrieving mapping from tagset.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.47 未満\nLinux Kernel 5.16 以上 5.17.15 未満\nLinux Kernel 5.18 以上 5.18.4 未満"
    },
    "JVNDB-2022-025995": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: pcm: Fix races among concurrent prealloc proc writes We have no protection against concurrent PCM buffer preallocation changes via proc files, and it may potentially lead to UAF or some weird problem. This patch applies the PCM open_mutex to the proc write operation for avoiding the racy proc writes and the PCM stream open (and further operations).",
        "technologies": "Linux\nLinux Kernel 4.14.279 未満\nLinux Kernel 4.15 以上 4.19.243 未満\nLinux Kernel 4.20 以上 5.4.193 未満\nLinux Kernel 5.5 以上 5.10.109 未満\nLinux Kernel 5.11 以上 5.15.32 未満\nLinux Kernel 5.16 以上 5.16.18 未満\nLinux Kernel 5.17 以上 5.17.1 未満"
    },
    "JVNDB-2022-025993": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/pseries: Fix use after free in remove_phb_dynamic() In remove_phb_dynamic() we use &phb->io_resource, after we've called device_unregister(&host_bridge->dev). But the unregister may have freed phb, because pcibios_free_controller_deferred() is the release function for the host_bridge. If there are no outstanding references when we call device_unregister() then phb will be freed out from under us. This has gone mainly unnoticed, but with slub_debug and page_poison enabled it can lead to a crash: PID: 7574 TASK: c0000000d492cb80 CPU: 13 COMMAND: \"drmgr\" #0 [c0000000e4f075a0] crash_kexec at c00000000027d7dc #1 [c0000000e4f075d0] oops_end at c000000000029608 #2 [c0000000e4f07650] __bad_page_fault at c0000000000904b4 #3 [c0000000e4f076c0] do_bad_slb_fault at c00000000009a5a8 #4 [c0000000e4f076f0] data_access_slb_common_virt at c000000000008b30 Data SLB Access [380] exception frame: R0: c000000000167250 R1: c0000000e4f07a00 R2: c000000002a46100 R3: c000000002b39ce8 R4: 00000000000000c0 R5: 00000000000000a9 R6: 3894674d000000c0 R7: 0000000000000000 R8: 00000000000000ff R9: 0000000000000100 R10: 6b6b6b6b6b6b6b6b R11: 0000000000008000 R12: c00000000023da80 R13: c0000009ffd38b00 R14: 0000000000000000 R15: 000000011c87f0f0 R16: 0000000000000006 R17: 0000000000000003 R18: 0000000000000002 R19: 0000000000000004 R20: 0000000000000005 R21: 000000011c87ede8 R22: 000000011c87c5a8 R23: 000000011c87d3a0 R24: 0000000000000000 R25: 0000000000000001 R26: c0000000e4f07cc8 R27: c00000004d1cc400 R28: c0080000031d00e8 R29: c00000004d23d800 R30: c00000004d1d2400 R31: c00000004d1d2540 NIP: c000000000167258 MSR: 8000000000009033 OR3: c000000000e9f474 CTR: 0000000000000000 LR: c000000000167250 XER: 0000000020040003 CCR: 0000000024088420 MQ: 0000000000000000 DAR: 6b6b6b6b6b6b6ba3 DSISR: c0000000e4f07920 Syscall Result: fffffffffffffff2 [NIP : release_resource+56] [LR : release_resource+48] #5 [c0000000e4f07a00] release_resource at c000000000167258 (unreliable) #6 [c0000000e4f07a30] remove_phb_dynamic at c000000000105648 #7 [c0000000e4f07ab0] dlpar_remove_slot at c0080000031a09e8 [rpadlpar_io] #8 [c0000000e4f07b50] remove_slot_store at c0080000031a0b9c [rpadlpar_io] #9 [c0000000e4f07be0] kobj_attr_store at c000000000817d8c #10 [c0000000e4f07c00] sysfs_kf_write at c00000000063e504 #11 [c0000000e4f07c20] kernfs_fop_write_iter at c00000000063d868 #12 [c0000000e4f07c70] new_sync_write at c00000000054339c #13 [c0000000e4f07d10] vfs_write at c000000000546624 #14 [c0000000e4f07d60] ksys_write at c0000000005469f4 #15 [c0000000e4f07db0] system_call_exception at c000000000030840 #16 [c0000000e4f07e10] system_call_vectored_common at c00000000000c168 To avoid it, we can take a reference to the host_bridge->dev until we're done using phb. Then when we drop the reference the phb will be freed.",
        "technologies": "Linux\nLinux Kernel 3.16.39 以上 3.17 未満\nLinux Kernel 4.7.8 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026001": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cxl/port: Hold port reference until decoder release KASAN + DEBUG_KOBJECT_RELEASE reports a potential use-after-free in cxl_decoder_release() where it goes to reference its parent, a cxl_port, to free its id back to port->decoder_ida. BUG: KASAN: use-after-free in to_cxl_port+0x18/0x90 [cxl_core] Read of size 8 at addr ffff888119270908 by task kworker/35:2/379 CPU: 35 PID: 379 Comm: kworker/35:2 Tainted: G OE 5.17.0-rc2+ #198 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 Workqueue: events kobject_delayed_cleanup Call Trace: <TASK> dump_stack_lvl+0x59/0x73 print_address_description.constprop.0+0x1f/0x150 ? to_cxl_port+0x18/0x90 [cxl_core] kasan_report.cold+0x83/0xdf ? to_cxl_port+0x18/0x90 [cxl_core] to_cxl_port+0x18/0x90 [cxl_core] cxl_decoder_release+0x2a/0x60 [cxl_core] device_release+0x5f/0x100 kobject_cleanup+0x80/0x1c0 The device core only guarantees parent lifetime until all children are unregistered. If a child needs a parent to complete its ->release() callback that child needs to hold a reference to extend the lifetime of the parent.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.54 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026002": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: ccree - Fix use after free in cc_cipher_exit() kfree_sensitive(ctx_p->user.key) will free the ctx_p->user.key. But ctx_p->user.key is still used in the next line, which will lead to a use after free. We can call kfree_sensitive() after dev_dbg() to avoid the uaf.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026004": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tpm: fix reference counting for struct tpm_chip The following sequence of operations results in a refcount warning: 1. Open device /dev/tpmrm. 2. Remove module tpm_tis_spi. 3. Write a TPM command to the file descriptor opened at step 1. ------------[ cut here ]------------ WARNING: CPU: 3 PID: 1161 at lib/refcount.c:25 kobject_get+0xa0/0xa4 refcount_t: addition on 0; use-after-free. Modules linked in: tpm_tis_spi tpm_tis_core tpm mdio_bcm_unimac brcmfmac sha256_generic libsha256 sha256_arm hci_uart btbcm bluetooth cfg80211 vc4 brcmutil ecdh_generic ecc snd_soc_core crc32_arm_ce libaes raspberrypi_hwmon ac97_bus snd_pcm_dmaengine bcm2711_thermal snd_pcm snd_timer genet snd phy_generic soundcore [last unloaded: spi_bcm2835] CPU: 3 PID: 1161 Comm: hold_open Not tainted 5.10.0ls-main-dirty #2 Hardware name: BCM2711 [<c0410c3c>] (unwind_backtrace) from [<c040b580>] (show_stack+0x10/0x14) [<c040b580>] (show_stack) from [<c1092174>] (dump_stack+0xc4/0xd8) [<c1092174>] (dump_stack) from [<c0445a30>] (__warn+0x104/0x108) [<c0445a30>] (__warn) from [<c0445aa8>] (warn_slowpath_fmt+0x74/0xb8) [<c0445aa8>] (warn_slowpath_fmt) from [<c08435d0>] (kobject_get+0xa0/0xa4) [<c08435d0>] (kobject_get) from [<bf0a715c>] (tpm_try_get_ops+0x14/0x54 [tpm]) [<bf0a715c>] (tpm_try_get_ops [tpm]) from [<bf0a7d6c>] (tpm_common_write+0x38/0x60 [tpm]) [<bf0a7d6c>] (tpm_common_write [tpm]) from [<c05a7ac0>] (vfs_write+0xc4/0x3c0) [<c05a7ac0>] (vfs_write) from [<c05a7ee4>] (ksys_write+0x58/0xcc) [<c05a7ee4>] (ksys_write) from [<c04001a0>] (ret_fast_syscall+0x0/0x4c) Exception stack(0xc226bfa8 to 0xc226bff0) bfa0: 00000000 000105b4 00000003 beafe664 00000014 00000000 bfc0: 00000000 000105b4 000103f8 00000004 00000000 00000000 b6f9c000 beafe684 bfe0: 0000006c beafe648 0001056c b6eb6944 ---[ end trace d4b8409def9b8b1f ]--- The reason for this warning is the attempt to get the chip->dev reference in tpm_common_write() although the reference counter is already zero. Since commit 8979b02aaf1d (\"tpm: Fix reference count to main device\") the extra reference used to prevent a premature zero counter is never taken, because the required TPM_CHIP_FLAG_TPM2 flag is never set. Fix this by moving the TPM 2 character device handling from tpm_chip_alloc() to tpm_add_char_device() which is called at a later point in time when the flag has been set in case of TPM2. Commit fdc915f7f719 (\"tpm: expose spaces via a device link /dev/tpmrm<n>\") already introduced function tpm_devs_release() to release the extra reference but did not implement the required put on chip->devs that results in the call of this function. Fix this by putting chip->devs in tpm_chip_unregister(). Finally move the new implementation for the TPM 2 handling into a new function to avoid multiple checks for the TPM_CHIP_FLAG_TPM2 flag in the good case and error cases.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.1 未満"
    },
    "JVNDB-2022-026012": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: f_fs: Prevent race during ffs_ep0_queue_wait While performing fast composition switch, there is a possibility that the process of ffs_ep0_write/ffs_ep0_read get into a race condition due to ep0req being freed up from functionfs_unbind. Consider the scenario that the ffs_ep0_write calls the ffs_ep0_queue_wait by taking a lock &ffs->ev.waitq.lock. However, the functionfs_unbind isn't bounded so it can go ahead and mark the ep0req to NULL, and since there is no NULL check in ffs_ep0_queue_wait we will end up in use-after-free. Fix this by making a serialized execution between the two functions using a mutex_lock(ffs->mutex).",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.14.305 未満\nLinux Kernel 4.15 以上 4.19.272 未満\nLinux Kernel 4.20 以上 5.4.231 未満\nLinux Kernel 5.5 以上 5.10.166 未満\nLinux Kernel 5.11 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-026013": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: always report error in run_one_delayed_ref() Currently we have a btrfs_debug() for run_one_delayed_ref() failure, but if end users hit such problem, there will be no chance that btrfs_debug() is enabled. This can lead to very little useful info for debugging. This patch will: - Add extra info for error reporting Including: * logical bytenr * num_bytes * type * action * ref_mod - Replace the btrfs_debug() with btrfs_err() - Move the error reporting into run_one_delayed_ref() This is to avoid use-after-free, the @node can be freed in the caller. This error should only be triggered at most once. As if run_one_delayed_ref() failed, we trigger the error message, then causing the call chain to error out: btrfs_run_delayed_refs() `- btrfs_run_delayed_refs() `- btrfs_run_delayed_refs_for_head() `- run_one_delayed_ref() And we will abort the current transaction in btrfs_run_delayed_refs(). If we have to run delayed refs for the abort transaction, run_one_delayed_ref() will just cleanup the refs and do nothing, thus no new error messages would be output.",
        "technologies": "Linux\nLinux Kernel 5.10.165 未満\nLinux Kernel 5.11 以上 5.15.90 未満\nLinux Kernel 5.16 以上 6.1.8 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-026003": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: m_can: m_can_tx_handler(): fix use after free of skb can_put_echo_skb() will clone skb then free the skb. Move the can_put_echo_skb() for the m_can version 3.0.x directly before the start of the xmit in hardware, similar to the 3.1.x branch.",
        "technologies": "Linux\nLinux Kernel 3.18 以上 4.9.324 未満\nLinux Kernel 4.10 以上 4.14.289 未満\nLinux Kernel 4.15 以上 4.19.253 未満\nLinux Kernel 4.20 以上 5.4.207 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026006": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/panfrost: Job should reference MMU not file_priv For a while now it's been allowed for a MMU context to outlive it's corresponding panfrost_priv, however the job structure still references panfrost_priv to get hold of the MMU context. If panfrost_priv has been freed this is a use-after-free which I've been able to trigger resulting in a splat. To fix this, drop the reference to panfrost_priv in the job structure and add a direct reference to the MMU structure which is what's actually needed.",
        "technologies": "Linux\nLinux Kernel 5.10.67 以上 5.11 未満\nLinux Kernel 5.13.19 以上 5.14 未満\nLinux Kernel 5.14.6 以上 5.17.15 未満\nLinux Kernel 5.18 以上 5.18.4 未満\nLinux Kernel 5.19"
    },
    "JVNDB-2022-026005": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: fix use-after-free by removing a non-RCU wcid pointer Fixes an issue caught by KASAN about use-after-free in mt76_txq_schedule by protecting mtxq->wcid with rcu_lock between mt76_txq_schedule and sta_info_[alloc, free]. [18853.876689] ================================================================== [18853.876751] BUG: KASAN: use-after-free in mt76_txq_schedule+0x204/0xaf8 [mt76] [18853.876773] Read of size 8 at addr ffffffaf989a2138 by task mt76-tx phy0/883 [18853.876786] [18853.876810] CPU: 5 PID: 883 Comm: mt76-tx phy0 Not tainted 5.10.100-fix-510-56778d365941-kasan #5 0b01fbbcf41a530f52043508fec2e31a4215 [18853.876840] Call trace: [18853.876861] dump_backtrace+0x0/0x3ec [18853.876878] show_stack+0x20/0x2c [18853.876899] dump_stack+0x11c/0x1ac [18853.876918] print_address_description+0x74/0x514 [18853.876934] kasan_report+0x134/0x174 [18853.876948] __asan_report_load8_noabort+0x44/0x50 [18853.876976] mt76_txq_schedule+0x204/0xaf8 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2] [18853.877002] mt76_txq_schedule_all+0x2c/0x48 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2] [18853.877030] mt7921_tx_worker+0xa0/0x1cc [mt7921_common f0875ebac9d7b4754e1010549e7db50fbd90a047] [18853.877054] __mt76_worker_fn+0x190/0x22c [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2] [18853.877071] kthread+0x2f8/0x3b8 [18853.877087] ret_from_fork+0x10/0x30 [18853.877098] [18853.877112] Allocated by task 941: [18853.877131] kasan_save_stack+0x38/0x68 [18853.877147] __kasan_kmalloc+0xd4/0xfc [18853.877163] kasan_kmalloc+0x10/0x1c [18853.877177] __kmalloc+0x264/0x3c4 [18853.877294] sta_info_alloc+0x460/0xf88 [mac80211] [18853.877410] ieee80211_prep_connection+0x204/0x1ee0 [mac80211] [18853.877523] ieee80211_mgd_auth+0x6c4/0xa4c [mac80211] [18853.877635] ieee80211_auth+0x20/0x2c [mac80211] [18853.877733] rdev_auth+0x7c/0x438 [cfg80211] [18853.877826] cfg80211_mlme_auth+0x26c/0x390 [cfg80211] [18853.877919] nl80211_authenticate+0x6d4/0x904 [cfg80211] [18853.877938] genl_rcv_msg+0x748/0x93c [18853.877954] netlink_rcv_skb+0x160/0x2a8 [18853.877969] genl_rcv+0x3c/0x54 [18853.877985] netlink_unicast_kernel+0x104/0x1ec [18853.877999] netlink_unicast+0x178/0x268 [18853.878015] netlink_sendmsg+0x3cc/0x5f0 [18853.878030] sock_sendmsg+0xb4/0xd8 [18853.878043] ____sys_sendmsg+0x2f8/0x53c [18853.878058] ___sys_sendmsg+0xe8/0x150 [18853.878071] __sys_sendmsg+0xc4/0x1f4 [18853.878087] __arm64_compat_sys_sendmsg+0x88/0x9c [18853.878101] el0_svc_common+0x1b4/0x390 [18853.878115] do_el0_svc_compat+0x8c/0xdc [18853.878131] el0_svc_compat+0x10/0x1c [18853.878146] el0_sync_compat_handler+0xa8/0xcc [18853.878161] el0_sync_compat+0x188/0x1c0 [18853.878171] [18853.878183] Freed by task 10927: [18853.878200] kasan_save_stack+0x38/0x68 [18853.878215] kasan_set_track+0x28/0x3c [18853.878228] kasan_set_free_info+0x24/0x48 [18853.878244] __kasan_slab_free+0x11c/0x154 [18853.878259] kasan_slab_free+0x14/0x24 [18853.878273] slab_free_freelist_hook+0xac/0x1b0 [18853.878287] kfree+0x104/0x390 [18853.878402] sta_info_free+0x198/0x210 [mac80211] [18853.878515] __sta_info_destroy_part2+0x230/0x2d4 [mac80211] [18853.878628] __sta_info_flush+0x300/0x37c [mac80211] [18853.878740] ieee80211_set_disassoc+0x2cc/0xa7c [mac80211] [18853.878851] ieee80211_mgd_deauth+0x4a4/0x10a0 [mac80211] [18853.878962] ieee80211_deauth+0x20/0x2c [mac80211] [18853.879057] rdev_deauth+0x7c/0x438 [cfg80211] [18853.879150] cfg80211_mlme_deauth+0x274/0x414 [cfg80211] [18853.879243] cfg80211_mlme_down+0xe4/0x118 [cfg80211] [18853.879335] cfg80211_disconnect+0x218/0x2d8 [cfg80211] [18853.879427] __cfg80211_leave+0x17c/0x240 [cfg80211] [18853.879519] cfg80211_leave+0x3c/0x58 [cfg80211] [18853.879611] wiphy_suspend+0xdc/0x200 [cfg80211] [18853.879628] dpm_run_callback+0x58/0x408 [18853.879642] __device_suspend+0x4cc/0x864 [18853.879658] async_suspend+0x34/0xf4 [18 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15.58 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-026015": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dmaengine: Fix double increment of client_count in dma_chan_get() The first time dma_chan_get() is called for a channel the channel client_count is incorrectly incremented twice for public channels, first in balance_ref_count(), and again prior to returning. This results in an incorrect client count which will lead to the channel resources not being freed when they should be. A simple test of repeated module load and unload of async_tx on a Dell Power Edge R7425 also shows this resulting in a kref underflow warning. [ 124.329662] async_tx: api initialized (async) [ 129.000627] async_tx: api initialized (async) [ 130.047839] ------------[ cut here ]------------ [ 130.052472] refcount_t: underflow; use-after-free. [ 130.057279] WARNING: CPU: 3 PID: 19364 at lib/refcount.c:28 refcount_warn_saturate+0xba/0x110 [ 130.065811] Modules linked in: async_tx(-) rfkill intel_rapl_msr intel_rapl_common amd64_edac edac_mce_amd ipmi_ssif kvm_amd dcdbas kvm mgag200 drm_shmem_helper acpi_ipmi irqbypass drm_kms_helper ipmi_si syscopyarea sysfillrect rapl pcspkr ipmi_devintf sysimgblt fb_sys_fops k10temp i2c_piix4 ipmi_msghandler acpi_power_meter acpi_cpufreq vfat fat drm fuse xfs libcrc32c sd_mod t10_pi sg ahci crct10dif_pclmul libahci crc32_pclmul crc32c_intel ghash_clmulni_intel igb megaraid_sas i40e libata i2c_algo_bit ccp sp5100_tco dca dm_mirror dm_region_hash dm_log dm_mod [last unloaded: async_tx] [ 130.117361] CPU: 3 PID: 19364 Comm: modprobe Kdump: loaded Not tainted 5.14.0-185.el9.x86_64 #1 [ 130.126091] Hardware name: Dell Inc. PowerEdge R7425/02MJ3T, BIOS 1.18.0 01/17/2022 [ 130.133806] RIP: 0010:refcount_warn_saturate+0xba/0x110 [ 130.139041] Code: 01 01 e8 6d bd 55 00 0f 0b e9 72 9d 8a 00 80 3d 26 18 9c 01 00 75 85 48 c7 c7 f8 a3 03 9d c6 05 16 18 9c 01 01 e8 4a bd 55 00 <0f> 0b e9 4f 9d 8a 00 80 3d 01 18 9c 01 00 0f 85 5e ff ff ff 48 c7 [ 130.157807] RSP: 0018:ffffbf98898afe68 EFLAGS: 00010286 [ 130.163036] RAX: 0000000000000000 RBX: ffff9da06028e598 RCX: 0000000000000000 [ 130.170172] RDX: ffff9daf9de26480 RSI: ffff9daf9de198a0 RDI: ffff9daf9de198a0 [ 130.177316] RBP: ffff9da7cddf3970 R08: 0000000000000000 R09: 00000000ffff7fff [ 130.184459] R10: ffffbf98898afd00 R11: ffffffff9d9e8c28 R12: ffff9da7cddf1970 [ 130.191596] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [ 130.198739] FS: 00007f646435c740(0000) GS:ffff9daf9de00000(0000) knlGS:0000000000000000 [ 130.206832] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 130.212586] CR2: 00007f6463b214f0 CR3: 00000008ab98c000 CR4: 00000000003506e0 [ 130.219729] Call Trace: [ 130.222192] <TASK> [ 130.224305] dma_chan_put+0x10d/0x110 [ 130.227988] dmaengine_put+0x7a/0xa0 [ 130.231575] __do_sys_delete_module.constprop.0+0x178/0x280 [ 130.237157] ? syscall_trace_enter.constprop.0+0x145/0x1d0 [ 130.242652] do_syscall_64+0x5c/0x90 [ 130.246240] ? exc_page_fault+0x62/0x150 [ 130.250178] entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 130.255243] RIP: 0033:0x7f6463a3f5ab [ 130.258830] Code: 73 01 c3 48 8b 0d 75 a8 1b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 b0 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 45 a8 1b 00 f7 d8 64 89 01 48 [ 130.277591] RSP: 002b:00007fff22f972c8 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0 [ 130.285164] RAX: ffffffffffffffda RBX: 000055b6786edd40 RCX: 00007f6463a3f5ab [ 130.292303] RDX: 0000000000000000 RSI: 0000000000000800 RDI: 000055b6786edda8 [ 130.299443] RBP: 000055b6786edd40 R08: 0000000000000000 R09: 0000000000000000 [ 130.306584] R10: 00007f6463b9eac0 R11: 0000000000000206 R12: 000055b6786edda8 [ 130.313731] R13: 0000000000000000 R14: 000055b6786edda8 R15: 00007fff22f995f8 [ 130.320875] </TASK> [ 130.323081] ---[ end trace eff7156d56b5cf25 ]--- cat /sys/class/dma/dma0chan*/in_use would get the wrong result. 2 2 2 Test-by: Jie Hai <haijie1@huawei.com>",
        "technologies": "Linux\nLinux Kernel 4.0 以上 4.14.305 未満\nLinux Kernel 4.15 以上 4.19.272 未満\nLinux Kernel 4.20 以上 5.4.231 未満\nLinux Kernel 5.5 以上 5.10.166 未満\nLinux Kernel 5.11 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-026070": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: brcmfmac: Check the count value of channel spec to prevent out-of-bounds reads This patch fixes slab-out-of-bounds reads in brcmfmac that occur in brcmf_construct_chaninfo() and brcmf_enable_bw40_2g() when the count value of channel specifications provided by the device is greater than the length of 'list->element[]', decided by the size of the 'list' allocated with kzalloc(). The patch adds checks that make the functions free the buffer and return -EINVAL if that is the case. Note that the negative return is handled by the caller, brcmf_setup_wiphybands() or brcmf_cfg80211_attach(). Found by a modified version of syzkaller. Crash Report from brcmf_construct_chaninfo(): ================================================================== BUG: KASAN: slab-out-of-bounds in brcmf_setup_wiphybands+0x1238/0x1430 Read of size 4 at addr ffff888115f24600 by task kworker/0:2/1896 CPU: 0 PID: 1896 Comm: kworker/0:2 Tainted: G W O 5.14.0+ #132 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014 Workqueue: usb_hub_wq hub_event Call Trace: dump_stack_lvl+0x57/0x7d print_address_description.constprop.0.cold+0x93/0x334 kasan_report.cold+0x83/0xdf brcmf_setup_wiphybands+0x1238/0x1430 brcmf_cfg80211_attach+0x2118/0x3fd0 brcmf_attach+0x389/0xd40 brcmf_usb_probe+0x12de/0x1690 usb_probe_interface+0x25f/0x710 really_probe+0x1be/0xa90 __driver_probe_device+0x2ab/0x460 driver_probe_device+0x49/0x120 __device_attach_driver+0x18a/0x250 bus_for_each_drv+0x123/0x1a0 __device_attach+0x207/0x330 bus_probe_device+0x1a2/0x260 device_add+0xa61/0x1ce0 usb_set_configuration+0x984/0x1770 usb_generic_driver_probe+0x69/0x90 usb_probe_device+0x9c/0x220 really_probe+0x1be/0xa90 __driver_probe_device+0x2ab/0x460 driver_probe_device+0x49/0x120 __device_attach_driver+0x18a/0x250 bus_for_each_drv+0x123/0x1a0 __device_attach+0x207/0x330 bus_probe_device+0x1a2/0x260 device_add+0xa61/0x1ce0 usb_new_device.cold+0x463/0xf66 hub_event+0x10d5/0x3330 process_one_work+0x873/0x13e0 worker_thread+0x8b/0xd10 kthread+0x379/0x450 ret_from_fork+0x1f/0x30 Allocated by task 1896: kasan_save_stack+0x1b/0x40 __kasan_kmalloc+0x7c/0x90 kmem_cache_alloc_trace+0x19e/0x330 brcmf_setup_wiphybands+0x290/0x1430 brcmf_cfg80211_attach+0x2118/0x3fd0 brcmf_attach+0x389/0xd40 brcmf_usb_probe+0x12de/0x1690 usb_probe_interface+0x25f/0x710 really_probe+0x1be/0xa90 __driver_probe_device+0x2ab/0x460 driver_probe_device+0x49/0x120 __device_attach_driver+0x18a/0x250 bus_for_each_drv+0x123/0x1a0 __device_attach+0x207/0x330 bus_probe_device+0x1a2/0x260 device_add+0xa61/0x1ce0 usb_set_configuration+0x984/0x1770 usb_generic_driver_probe+0x69/0x90 usb_probe_device+0x9c/0x220 really_probe+0x1be/0xa90 __driver_probe_device+0x2ab/0x460 driver_probe_device+0x49/0x120 __device_attach_driver+0x18a/0x250 bus_for_each_drv+0x123/0x1a0 __device_attach+0x207/0x330 bus_probe_device+0x1a2/0x260 device_add+0xa61/0x1ce0 usb_new_device.cold+0x463/0xf66 hub_event+0x10d5/0x3330 process_one_work+0x873/0x13e0 worker_thread+0x8b/0xd10 kthread+0x379/0x450 ret_from_fork+0x1f/0x30 The buggy address belongs to the object at ffff888115f24000 which belongs to the cache kmalloc-2k of size 2048 The buggy address is located 1536 bytes inside of 2048-byte region [ffff888115f24000, ffff888115f24800) Memory state around the buggy address: ffff888115f24500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888115f24580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff888115f24600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ^ ffff888115f24680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffff888115f24700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ================================================================== Crash Report from brcmf_enable_bw40_2g(): ========== ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満"
    },
    "JVNDB-2022-026066": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix a buffer overflow in mgmt_mesh_add() Smatch Warning: net/bluetooth/mgmt_util.c:375 mgmt_mesh_add() error: __memcpy() 'mesh_tx->param' too small (48 vs 50) Analysis: 'mesh_tx->param' is array of size 48. This is the destination. u8 param[sizeof(struct mgmt_cp_mesh_send) + 29]; // 19 + 29 = 48. But in the caller 'mesh_send' we reject only when len > 50. len > (MGMT_MESH_SEND_SIZE + 31) // 19 + 31 = 50.",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-026048": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ethernet: mtk_eth_soc: out of bounds read in mtk_hwlro_get_fdir_entry() The \"fsp->location\" variable comes from user via ethtool_get_rxnfc(). Check that it is valid to prevent an out of bounds read.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.122 未満\nLinux Kernel 5.11 以上 5.15.47 未満\nLinux Kernel 5.16 以上 5.17.15 未満\nLinux Kernel 5.18 以上 5.18.4 未満"
    },
    "JVNDB-2022-026071": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: md: fix double free of io_acct_set bioset Now io_acct_set is alloc and free in personality. Remove the codes that free io_acct_set in md_free and md_stop.",
        "technologies": "Linux\nLinux Kernel 5.15.17 以上 5.15.46 未満\nLinux Kernel 5.16.3 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-026083": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing: Fix potential double free in create_var_ref() In create_var_ref(), init_var_ref() is called to initialize the fields of variable ref_field, which is allocated in the previous function call to create_hist_field(). Function init_var_ref() allocates the corresponding fields such as ref_field->system, but frees these fields when the function encounters an error. The caller later calls destroy_hist_field() to conduct error handling, which frees the fields and the variable itself. This results in double free of the fields which are already freed in the previous function. Fix this by storing NULL to the corresponding fields when they are freed in init_var_ref().",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-026016": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: wcd938x: fix incorrect used of portid Mixer controls have the channel id in mixer->reg, which is not same as port id. port id should be derived from chan_info array. So fix this. Without this, its possible that we could corrupt struct wcd938x_sdw_priv by accessing port_map array out of range with channel id instead of port id.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026094": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mac80211: fix potential double free on mesh join While commit 6a01afcf8468 (\"mac80211: mesh: Free ie data when leaving mesh\") fixed a memory leak on mesh leave / teardown it introduced a potential memory corruption caused by a double free when rejoining the mesh: ieee80211_leave_mesh() -> kfree(sdata->u.mesh.ie); ... ieee80211_join_mesh() -> copy_mesh_setup() -> old_ie = ifmsh->ie; -> kfree(old_ie); This double free / kernel panics can be reproduced by using wpa_supplicant with an encrypted mesh (if set up without encryption via \"iw\" then ifmsh->ie is always NULL, which avoids this issue). And then calling: $ iw dev mesh0 mesh leave $ iw dev mesh0 mesh join my-mesh Note that typically these commands are not used / working when using wpa_supplicant. And it seems that wpa_supplicant or wpa_cli are going through a NETDEV_DOWN/NETDEV_UP cycle between a mesh leave and mesh join where the NETDEV_UP resets the mesh.ie to NULL via a memcpy of default_mesh_setup in cfg80211_netdev_notifier_call, which then avoids the memory corruption, too. The issue was first observed in an application which was not using wpa_supplicant but \"Senf\" instead, which implements its own calls to nl80211. Fixing the issue by removing the kfree()'ing of the mesh IE in the mesh join function and leaving it solely up to the mesh leave to free the mesh IE.",
        "technologies": "Linux\nLinux Kernel 4.4.233 以上 4.5 未満\nLinux Kernel 4.9.233 以上 4.9.309 未満\nLinux Kernel 4.14.192 以上 4.14.274 未満\nLinux Kernel 4.19.137 以上 4.19.237 未満\nLinux Kernel 5.4.56 以上 5.4.188 未満\nLinux Kernel 5.7.13 以上 5.10.109 未満\nLinux Kernel 5.11 以上 5.15.32 未満\nLinux Kernel 5.16 以上 5.16.18 未満\nLinux Kernel 5.17 以上 5.17.1 未満"
    },
    "JVNDB-2022-026140": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: entry: avoid kprobe recursion The cortex_a76_erratum_1463225_debug_handler() function is called when handling debug exceptions (and synchronous exceptions from BRK instructions), and so is called when a probed function executes. If the compiler does not inline cortex_a76_erratum_1463225_debug_handler(), it can be probed. If cortex_a76_erratum_1463225_debug_handler() is probed, any debug exception or software breakpoint exception will result in recursive exceptions leading to a stack overflow. This can be triggered with the ftrace multiple_probes selftest, and as per the example splat below. This is a regression caused by commit: 6459b8469753e9fe (\"arm64: entry: consolidate Cortex-A76 erratum 1463225 workaround\") ... which removed the NOKPROBE_SYMBOL() annotation associated with the function. My intent was that cortex_a76_erratum_1463225_debug_handler() would be inlined into its caller, el1_dbg(), which is marked noinstr and cannot be probed. Mark cortex_a76_erratum_1463225_debug_handler() as __always_inline to ensure this. Example splat prior to this patch (with recursive entries elided): | # echo p cortex_a76_erratum_1463225_debug_handler > /sys/kernel/debug/tracing/kprobe_events | # echo p do_el0_svc >> /sys/kernel/debug/tracing/kprobe_events | # echo 1 > /sys/kernel/debug/tracing/events/kprobes/enable | Insufficient stack space to handle exception! | ESR: 0x0000000096000047 -- DABT (current EL) | FAR: 0xffff800009cefff0 | Task stack: [0xffff800009cf0000..0xffff800009cf4000] | IRQ stack: [0xffff800008000000..0xffff800008004000] | Overflow stack: [0xffff00007fbc00f0..0xffff00007fbc10f0] | CPU: 0 PID: 145 Comm: sh Not tainted 6.0.0 #2 | Hardware name: linux,dummy-virt (DT) | pstate: 604003c5 (nZCv DAIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) | pc : arm64_enter_el1_dbg+0x4/0x20 | lr : el1_dbg+0x24/0x5c | sp : ffff800009cf0000 | x29: ffff800009cf0000 x28: ffff000002c74740 x27: 0000000000000000 | x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000 | x23: 00000000604003c5 x22: ffff80000801745c x21: 0000aaaac95ac068 | x20: 00000000f2000004 x19: ffff800009cf0040 x18: 0000000000000000 | x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 | x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000 | x11: 0000000000000010 x10: ffff800008c87190 x9 : ffff800008ca00d0 | x8 : 000000000000003c x7 : 0000000000000000 x6 : 0000000000000000 | x5 : 0000000000000000 x4 : 0000000000000000 x3 : 00000000000043a4 | x2 : 00000000f2000004 x1 : 00000000f2000004 x0 : ffff800009cf0040 | Kernel panic - not syncing: kernel stack overflow | CPU: 0 PID: 145 Comm: sh Not tainted 6.0.0 #2 | Hardware name: linux,dummy-virt (DT) | Call trace: | dump_backtrace+0xe4/0x104 | show_stack+0x18/0x4c | dump_stack_lvl+0x64/0x7c | dump_stack+0x18/0x38 | panic+0x14c/0x338 | test_taint+0x0/0x2c | panic_bad_stack+0x104/0x118 | handle_bad_stack+0x34/0x48 | __bad_stack+0x78/0x7c | arm64_enter_el1_dbg+0x4/0x20 | el1h_64_sync_handler+0x40/0x98 | el1h_64_sync+0x64/0x68 | cortex_a76_erratum_1463225_debug_handler+0x0/0x34 ... | el1h_64_sync_handler+0x40/0x98 | el1h_64_sync+0x64/0x68 | cortex_a76_erratum_1463225_debug_handler+0x0/0x34 ... | el1h_64_sync_handler+0x40/0x98 | el1h_64_sync+0x64/0x68 | cortex_a76_erratum_1463225_debug_handler+0x0/0x34 | el1h_64_sync_handler+0x40/0x98 | el1h_64_sync+0x64/0x68 | do_el0_svc+0x0/0x28 | el0t_64_sync_handler+0x84/0xf0 | el0t_64_sync+0x18c/0x190 | Kernel Offset: disabled | CPU features: 0x0080,00005021,19001080 | Memory Limit: none | ---[ end Kernel panic - not syncing: kernel stack overflow ]--- With this patch, cortex_a76_erratum_1463225_debug_handler() is inlined into el1_dbg(), and el1_dbg() cannot be probed: | # echo p cortex_a76_erratum_1463225_debug_handler > /sys/kernel/debug/tracing/kprobe_events | sh: write error: No such file or directory | # grep -w cortex_a76_errat ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.78 未満\nLinux Kernel 5.16 以上 6.0.8 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026104": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on i_extra_isize in is_alive() syzbot found a f2fs bug: BUG: KASAN: slab-out-of-bounds in data_blkaddr fs/f2fs/f2fs.h:2891 [inline] BUG: KASAN: slab-out-of-bounds in is_alive fs/f2fs/gc.c:1117 [inline] BUG: KASAN: slab-out-of-bounds in gc_data_segment fs/f2fs/gc.c:1520 [inline] BUG: KASAN: slab-out-of-bounds in do_garbage_collect+0x386a/0x3df0 fs/f2fs/gc.c:1734 Read of size 4 at addr ffff888076557568 by task kworker/u4:3/52 CPU: 1 PID: 52 Comm: kworker/u4:3 Not tainted 6.1.0-rc4-syzkaller-00362-gfef7fd48922d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 Workqueue: writeback wb_workfn (flush-7:0) Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:284 [inline] print_report+0x15e/0x45d mm/kasan/report.c:395 kasan_report+0xbb/0x1f0 mm/kasan/report.c:495 data_blkaddr fs/f2fs/f2fs.h:2891 [inline] is_alive fs/f2fs/gc.c:1117 [inline] gc_data_segment fs/f2fs/gc.c:1520 [inline] do_garbage_collect+0x386a/0x3df0 fs/f2fs/gc.c:1734 f2fs_gc+0x88c/0x20a0 fs/f2fs/gc.c:1831 f2fs_balance_fs+0x544/0x6b0 fs/f2fs/segment.c:410 f2fs_write_inode+0x57e/0xe20 fs/f2fs/inode.c:753 write_inode fs/fs-writeback.c:1440 [inline] __writeback_single_inode+0xcfc/0x1440 fs/fs-writeback.c:1652 writeback_sb_inodes+0x54d/0xf90 fs/fs-writeback.c:1870 wb_writeback+0x2c5/0xd70 fs/fs-writeback.c:2044 wb_do_writeback fs/fs-writeback.c:2187 [inline] wb_workfn+0x2dc/0x12f0 fs/fs-writeback.c:2227 process_one_work+0x9bf/0x1710 kernel/workqueue.c:2289 worker_thread+0x665/0x1080 kernel/workqueue.c:2436 kthread+0x2e4/0x3a0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306 The root cause is that we forgot to do sanity check on .i_extra_isize in below path, result in accessing invalid address later, fix it. - gc_data_segment - is_alive - data_blkaddr - offset_in_addr",
        "technologies": "Linux\nLinux Kernel 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満"
    },
    "JVNDB-2022-026136": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: udf: Fix a slab-out-of-bounds write bug in udf_find_entry() Syzbot reported a slab-out-of-bounds Write bug: loop0: detected capacity change from 0 to 2048 ================================================================== BUG: KASAN: slab-out-of-bounds in udf_find_entry+0x8a5/0x14f0 fs/udf/namei.c:253 Write of size 105 at addr ffff8880123ff896 by task syz-executor323/3610 CPU: 0 PID: 3610 Comm: syz-executor323 Not tainted 6.1.0-rc2-syzkaller-00105-gb229b6ca5abb #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 10/11/2022 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106 print_address_description+0x74/0x340 mm/kasan/report.c:284 print_report+0x107/0x1f0 mm/kasan/report.c:395 kasan_report+0xcd/0x100 mm/kasan/report.c:495 kasan_check_range+0x2a7/0x2e0 mm/kasan/generic.c:189 memcpy+0x3c/0x60 mm/kasan/shadow.c:66 udf_find_entry+0x8a5/0x14f0 fs/udf/namei.c:253 udf_lookup+0xef/0x340 fs/udf/namei.c:309 lookup_open fs/namei.c:3391 [inline] open_last_lookups fs/namei.c:3481 [inline] path_openat+0x10e6/0x2df0 fs/namei.c:3710 do_filp_open+0x264/0x4f0 fs/namei.c:3740 do_sys_openat2+0x124/0x4e0 fs/open.c:1310 do_sys_open fs/open.c:1326 [inline] __do_sys_creat fs/open.c:1402 [inline] __se_sys_creat fs/open.c:1396 [inline] __x64_sys_creat+0x11f/0x160 fs/open.c:1396 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7ffab0d164d9 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffe1a7e6bb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000055 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffab0d164d9 RDX: 00007ffab0d164d9 RSI: 0000000000000000 RDI: 0000000020000180 RBP: 00007ffab0cd5a10 R08: 0000000000000000 R09: 0000000000000000 R10: 00005555573552c0 R11: 0000000000000246 R12: 00007ffab0cd5aa0 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 </TASK> Allocated by task 3610: kasan_save_stack mm/kasan/common.c:45 [inline] kasan_set_track+0x3d/0x60 mm/kasan/common.c:52 ____kasan_kmalloc mm/kasan/common.c:371 [inline] __kasan_kmalloc+0x97/0xb0 mm/kasan/common.c:380 kmalloc include/linux/slab.h:576 [inline] udf_find_entry+0x7b6/0x14f0 fs/udf/namei.c:243 udf_lookup+0xef/0x340 fs/udf/namei.c:309 lookup_open fs/namei.c:3391 [inline] open_last_lookups fs/namei.c:3481 [inline] path_openat+0x10e6/0x2df0 fs/namei.c:3710 do_filp_open+0x264/0x4f0 fs/namei.c:3740 do_sys_openat2+0x124/0x4e0 fs/open.c:1310 do_sys_open fs/open.c:1326 [inline] __do_sys_creat fs/open.c:1402 [inline] __se_sys_creat fs/open.c:1396 [inline] __x64_sys_creat+0x11f/0x160 fs/open.c:1396 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd The buggy address belongs to the object at ffff8880123ff800 which belongs to the cache kmalloc-256 of size 256 The buggy address is located 150 bytes inside of 256-byte region [ffff8880123ff800, ffff8880123ff900) The buggy address belongs to the physical page: page:ffffea000048ff80 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x123fe head:ffffea000048ff80 order:1 compound_mapcount:0 compound_pincount:0 flags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff) raw: 00fff00000010200 ffffea00004b8500 dead000000000003 ffff888012041b40 raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected page_owner tracks the page as allocated page last allocated via order 0, migratetype Unmovable, gfp_mask 0x0(), pid 1, tgid 1 (swapper/0), ts 1841222404, free_ts 0 create_dummy_stack mm/page_owner.c: ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.6 以上 4.9.334 未満\nLinux Kernel 4.10 以上 4.14.300 未満\nLinux Kernel 4.15 以上 4.19.267 未満\nLinux Kernel 4.20 以上 5.4.225 未満\nLinux Kernel 5.5 以上 5.10.155 未満\nLinux Kernel 5.11 以上 5.15.79 未満\nLinux Kernel 5.16 以上 6.0.9 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026146": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: Fix use after free in red_enqueue() We can't use \"skb\" again after passing it to qdisc_enqueue(). This is basically identical to commit 2f09707d0c97 (\"sch_sfb: Also store skb len before calling child enqueue\").",
        "technologies": "Linux\nLinux Kernel 4.4.163 以上 4.5 未満\nLinux Kernel 4.7 以上 4.9.333 未満\nLinux Kernel 4.10 以上 4.14.299 未満\nLinux Kernel 4.15 以上 4.19.265 未満\nLinux Kernel 4.20 以上 5.4.224 未満\nLinux Kernel 5.5 以上 5.10.154 未満\nLinux Kernel 5.11 以上 5.15.78 未満\nLinux Kernel 5.16 以上 6.0.8 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026135": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: core: Fix use-after-free in snd_soc_exit() KASAN reports a use-after-free: BUG: KASAN: use-after-free in device_del+0xb5b/0xc60 Read of size 8 at addr ffff888008655050 by task rmmod/387 CPU: 2 PID: 387 Comm: rmmod Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) Call Trace: <TASK> dump_stack_lvl+0x79/0x9a print_report+0x17f/0x47b kasan_report+0xbb/0xf0 device_del+0xb5b/0xc60 platform_device_del.part.0+0x24/0x200 platform_device_unregister+0x2e/0x40 snd_soc_exit+0xa/0x22 [snd_soc_core] __do_sys_delete_module.constprop.0+0x34f/0x5b0 do_syscall_64+0x3a/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd ... </TASK> It's bacause in snd_soc_init(), snd_soc_util_init() is possble to fail, but its ret is ignored, which makes soc_dummy_dev unregistered twice. snd_soc_init() snd_soc_util_init() platform_device_register_simple(soc_dummy_dev) platform_driver_register() # fail platform_device_unregister(soc_dummy_dev) platform_driver_register() # success ... snd_soc_exit() snd_soc_util_exit() # soc_dummy_dev will be unregistered for second time To fix it, handle error and stop snd_soc_init() when util_init() fail. Also clean debugfs when util_init() or driver_register() fail.",
        "technologies": "Linux\nLinux Kernel 3.0 以上 4.9.334 未満\nLinux Kernel 4.10 以上 4.14.300 未満\nLinux Kernel 4.15 以上 4.19.267 未満\nLinux Kernel 4.20 以上 5.4.225 未満\nLinux Kernel 5.5 以上 5.10.156 未満\nLinux Kernel 5.11 以上 5.15.80 未満\nLinux Kernel 5.16 以上 6.0.10 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026134": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, test_run: Fix alignment problem in bpf_prog_test_run_skb() We got a syzkaller problem because of aarch64 alignment fault if KFENCE enabled. When the size from user bpf program is an odd number, like 399, 407, etc, it will cause the struct skb_shared_info's unaligned access. As seen below: BUG: KFENCE: use-after-free read in __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032 Use-after-free read at 0xffff6254fffac077 (in kfence-#213): __lse_atomic_add arch/arm64/include/asm/atomic_lse.h:26 [inline] arch_atomic_add arch/arm64/include/asm/atomic.h:28 [inline] arch_atomic_inc include/linux/atomic-arch-fallback.h:270 [inline] atomic_inc include/asm-generic/atomic-instrumented.h:241 [inline] __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032 skb_clone+0xf4/0x214 net/core/skbuff.c:1481 ____bpf_clone_redirect net/core/filter.c:2433 [inline] bpf_clone_redirect+0x78/0x1c0 net/core/filter.c:2420 bpf_prog_d3839dd9068ceb51+0x80/0x330 bpf_dispatcher_nop_func include/linux/bpf.h:728 [inline] bpf_test_run+0x3c0/0x6c0 net/bpf/test_run.c:53 bpf_prog_test_run_skb+0x638/0xa7c net/bpf/test_run.c:594 bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline] __do_sys_bpf kernel/bpf/syscall.c:4441 [inline] __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381 kfence-#213: 0xffff6254fffac000-0xffff6254fffac196, size=407, cache=kmalloc-512 allocated by task 15074 on cpu 0 at 1342.585390s: kmalloc include/linux/slab.h:568 [inline] kzalloc include/linux/slab.h:675 [inline] bpf_test_init.isra.0+0xac/0x290 net/bpf/test_run.c:191 bpf_prog_test_run_skb+0x11c/0xa7c net/bpf/test_run.c:512 bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline] __do_sys_bpf kernel/bpf/syscall.c:4441 [inline] __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381 __arm64_sys_bpf+0x50/0x60 kernel/bpf/syscall.c:4381 To fix the problem, we adjust @size so that (@size + @hearoom) is a multiple of SMP_CACHE_BYTES. So we make sure the struct skb_shared_info is aligned to a cache line.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.14.300 未満\nLinux Kernel 4.15 以上 4.19.267 未満\nLinux Kernel 4.20 以上 5.4.225 未満\nLinux Kernel 5.5 以上 5.10.156 未満\nLinux Kernel 5.11 以上 5.15.80 未満\nLinux Kernel 5.16 以上 6.0.10 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026106": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: um: Fix out-of-bounds read in LDT setup syscall_stub_data() expects the data_count parameter to be the number of longs, not bytes. ================================================================== BUG: KASAN: stack-out-of-bounds in syscall_stub_data+0x70/0xe0 Read of size 128 at addr 000000006411f6f0 by task swapper/1 CPU: 0 PID: 1 Comm: swapper Not tainted 5.18.0+ #18 Call Trace: show_stack.cold+0x166/0x2a7 __dump_stack+0x3a/0x43 dump_stack_lvl+0x1f/0x27 print_report.cold+0xdb/0xf81 kasan_report+0x119/0x1f0 kasan_check_range+0x3a3/0x440 memcpy+0x52/0x140 syscall_stub_data+0x70/0xe0 write_ldt_entry+0xac/0x190 init_new_ldt+0x515/0x960 init_new_context+0x2c4/0x4d0 mm_init.constprop.0+0x5ed/0x760 mm_alloc+0x118/0x170 0x60033f48 do_one_initcall+0x1d7/0x860 0x60003e7b kernel_init+0x6e/0x3d4 new_thread_handler+0x1e7/0x2c0 The buggy address belongs to stack of task swapper/1 and is located at offset 64 in frame: init_new_ldt+0x0/0x960 This frame has 2 objects: [32, 40) 'addr' [64, 80) 'desc' ==================================================================",
        "technologies": "Linux\nLinux Kernel 2.6.15 以上 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-026077": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: remoteproc: mtk_scp: Fix a potential double free 'scp->rproc' is allocated using devm_rproc_alloc(), so there is no need to free it explicitly in the remove function.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 5.18.4 未満"
    },
    "JVNDB-2022-026148": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: fix use-after-free in l2cap_conn_del() When l2cap_recv_frame() is invoked to receive data, and the cid is L2CAP_CID_A2MP, if the channel does not exist, it will create a channel. However, after a channel is created, the hold operation of the channel is not performed. In this case, the value of channel reference counting is 1. As a result, after hci_error_reset() is triggered, l2cap_conn_del() invokes the close hook function of A2MP to release the channel. Then l2cap_chan_unlock(chan) will trigger UAF issue. The process is as follows: Receive data: l2cap_data_channel() a2mp_channel_create() --->channel ref is 2 l2cap_chan_put() --->channel ref is 1 Triger event: hci_error_reset() hci_dev_do_close() ... l2cap_disconn_cfm() l2cap_conn_del() l2cap_chan_hold() --->channel ref is 2 l2cap_chan_del() --->channel ref is 1 a2mp_chan_close_cb() --->channel ref is 0, release channel l2cap_chan_unlock() --->UAF of channel The detailed Call Trace is as follows: BUG: KASAN: use-after-free in __mutex_unlock_slowpath+0xa6/0x5e0 Read of size 8 at addr ffff8880160664b8 by task kworker/u11:1/7593 Workqueue: hci0 hci_error_reset Call Trace: <TASK> dump_stack_lvl+0xcd/0x134 print_report.cold+0x2ba/0x719 kasan_report+0xb1/0x1e0 kasan_check_range+0x140/0x190 __mutex_unlock_slowpath+0xa6/0x5e0 l2cap_conn_del+0x404/0x7b0 l2cap_disconn_cfm+0x8c/0xc0 hci_conn_hash_flush+0x11f/0x260 hci_dev_close_sync+0x5f5/0x11f0 hci_dev_do_close+0x2d/0x70 hci_error_reset+0x9e/0x140 process_one_work+0x98a/0x1620 worker_thread+0x665/0x1080 kthread+0x2e4/0x3a0 ret_from_fork+0x1f/0x30 </TASK> Allocated by task 7593: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0xa9/0xd0 l2cap_chan_create+0x40/0x930 amp_mgr_create+0x96/0x990 a2mp_channel_create+0x7d/0x150 l2cap_recv_frame+0x51b8/0x9a70 l2cap_recv_acldata+0xaa3/0xc00 hci_rx_work+0x702/0x1220 process_one_work+0x98a/0x1620 worker_thread+0x665/0x1080 kthread+0x2e4/0x3a0 ret_from_fork+0x1f/0x30 Freed by task 7593: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_set_free_info+0x20/0x30 ____kasan_slab_free+0x167/0x1c0 slab_free_freelist_hook+0x89/0x1c0 kfree+0xe2/0x580 l2cap_chan_put+0x22a/0x2d0 l2cap_conn_del+0x3fc/0x7b0 l2cap_disconn_cfm+0x8c/0xc0 hci_conn_hash_flush+0x11f/0x260 hci_dev_close_sync+0x5f5/0x11f0 hci_dev_do_close+0x2d/0x70 hci_error_reset+0x9e/0x140 process_one_work+0x98a/0x1620 worker_thread+0x665/0x1080 kthread+0x2e4/0x3a0 ret_from_fork+0x1f/0x30 Last potentially related work creation: kasan_save_stack+0x1e/0x40 __kasan_record_aux_stack+0xbe/0xd0 call_rcu+0x99/0x740 netlink_release+0xe6a/0x1cf0 __sock_release+0xcd/0x280 sock_close+0x18/0x20 __fput+0x27c/0xa90 task_work_run+0xdd/0x1a0 exit_to_user_mode_prepare+0x23c/0x250 syscall_exit_to_user_mode+0x19/0x50 do_syscall_64+0x42/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd Second to last potentially related work creation: kasan_save_stack+0x1e/0x40 __kasan_record_aux_stack+0xbe/0xd0 call_rcu+0x99/0x740 netlink_release+0xe6a/0x1cf0 __sock_release+0xcd/0x280 sock_close+0x18/0x20 __fput+0x27c/0xa90 task_work_run+0xdd/0x1a0 exit_to_user_mode_prepare+0x23c/0x250 syscall_exit_to_user_mode+0x19/0x50 do_syscall_64+0x42/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd",
        "technologies": "Linux\nLinux Kernel 4.9.326 以上 4.9.333 未満\nLinux Kernel 4.14.291 以上 4.14.299 未満\nLinux Kernel 4.19.255 以上 4.19.265 未満\nLinux Kernel 5.4.209 以上 5.4.224 未満\nLinux Kernel 5.10.135 以上 5.10.154 未満\nLinux Kernel 5.15.59 以上 5.15.78 未満\nLinux Kernel 5.18.16 以上 6.0.8 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026162": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: release flow rule object from commit path No need to postpone this to the commit release path, since no packets are walking over this object, this is accessed from control plane only. This helped uncovered UAF triggered by races with the netlink notifier.",
        "technologies": "Linux\nLinux Kernel 5.4.198 以上 5.4.224 未満\nLinux Kernel 5.10.122 以上 5.10.154 未満\nLinux Kernel 5.15.47 以上 5.15.78 未満\nLinux Kernel 5.17.15 以上 5.18 未満\nLinux Kernel 5.18.4 以上 6.0.8 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026156": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix use-after-free for dynamic ftrace_ops KASAN reported a use-after-free with ftrace ops [1]. It was found from vmcore that perf had registered two ops with the same content successively, both dynamic. After unregistering the second ops, a use-after-free occurred. In ftrace_shutdown(), when the second ops is unregistered, the FTRACE_UPDATE_CALLS command is not set because there is another enabled ops with the same content. Also, both ops are dynamic and the ftrace callback function is ftrace_ops_list_func, so the FTRACE_UPDATE_TRACE_FUNC command will not be set. Eventually the value of 'command' will be 0 and ftrace_shutdown() will skip the rcu synchronization. However, ftrace may be activated. When the ops is released, another CPU may be accessing the ops. Add the missing synchronization to fix this problem. [1] BUG: KASAN: use-after-free in __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline] BUG: KASAN: use-after-free in ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049 Read of size 8 at addr ffff56551965bbc8 by task syz-executor.2/14468 CPU: 1 PID: 14468 Comm: syz-executor.2 Not tainted 5.10.0 #7 Hardware name: linux,dummy-virt (DT) Call trace: dump_backtrace+0x0/0x40c arch/arm64/kernel/stacktrace.c:132 show_stack+0x30/0x40 arch/arm64/kernel/stacktrace.c:196 __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x1b4/0x248 lib/dump_stack.c:118 print_address_description.constprop.0+0x28/0x48c mm/kasan/report.c:387 __kasan_report mm/kasan/report.c:547 [inline] kasan_report+0x118/0x210 mm/kasan/report.c:564 check_memory_region_inline mm/kasan/generic.c:187 [inline] __asan_load8+0x98/0xc0 mm/kasan/generic.c:253 __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline] ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049 ftrace_graph_call+0x0/0x4 __might_sleep+0x8/0x100 include/linux/perf_event.h:1170 __might_fault mm/memory.c:5183 [inline] __might_fault+0x58/0x70 mm/memory.c:5171 do_strncpy_from_user lib/strncpy_from_user.c:41 [inline] strncpy_from_user+0x1f4/0x4b0 lib/strncpy_from_user.c:139 getname_flags+0xb0/0x31c fs/namei.c:149 getname+0x2c/0x40 fs/namei.c:209 [...] Allocated by task 14445: kasan_save_stack+0x24/0x50 mm/kasan/common.c:48 kasan_set_track mm/kasan/common.c:56 [inline] __kasan_kmalloc mm/kasan/common.c:479 [inline] __kasan_kmalloc.constprop.0+0x110/0x13c mm/kasan/common.c:449 kasan_kmalloc+0xc/0x14 mm/kasan/common.c:493 kmem_cache_alloc_trace+0x440/0x924 mm/slub.c:2950 kmalloc include/linux/slab.h:563 [inline] kzalloc include/linux/slab.h:675 [inline] perf_event_alloc.part.0+0xb4/0x1350 kernel/events/core.c:11230 perf_event_alloc kernel/events/core.c:11733 [inline] __do_sys_perf_event_open kernel/events/core.c:11831 [inline] __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723 __arm64_sys_perf_event_open+0x6c/0x80 kernel/events/core.c:11723 [...] Freed by task 14445: kasan_save_stack+0x24/0x50 mm/kasan/common.c:48 kasan_set_track+0x24/0x34 mm/kasan/common.c:56 kasan_set_free_info+0x20/0x40 mm/kasan/generic.c:358 __kasan_slab_free.part.0+0x11c/0x1b0 mm/kasan/common.c:437 __kasan_slab_free mm/kasan/common.c:445 [inline] kasan_slab_free+0x2c/0x40 mm/kasan/common.c:446 slab_free_hook mm/slub.c:1569 [inline] slab_free_freelist_hook mm/slub.c:1608 [inline] slab_free mm/slub.c:3179 [inline] kfree+0x12c/0xc10 mm/slub.c:4176 perf_event_alloc.part.0+0xa0c/0x1350 kernel/events/core.c:11434 perf_event_alloc kernel/events/core.c:11733 [inline] __do_sys_perf_event_open kernel/events/core.c:11831 [inline] __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723 [...]",
        "technologies": "Linux\nLinux Kernel 4.1.45 以上 4.2 未満\nLinux Kernel 4.4.89 以上 4.5 未満\nLinux Kernel 4.9.52 以上 4.10 未満\nLinux Kernel 4.13.4 以上 5.10.154 未満\nLinux Kernel 5.11 以上 5.15.78 未満\nLinux Kernel 5.16 以上 6.0.8 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026268": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm integrity: fix memory corruption when tag_size is less than digest size It is possible to set up dm-integrity in such a way that the \"tag_size\" parameter is less than the actual digest size. In this situation, a part of the digest beyond tag_size is ignored. In this case, dm-integrity would write beyond the end of the ic->recalc_tags array and corrupt memory. The corruption happened in integrity_recalc->integrity_sector_checksum->crypto_shash_final. Fix this corruption by increasing the tags array so that it has enough padding at the end to accomodate the loop in integrity_recalc() being able to write a full digest size for the last member of the tags array.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.19.240 未満\nLinux Kernel 4.20 以上 5.4.190 未満\nLinux Kernel 5.5 以上 5.10.112 未満\nLinux Kernel 5.11 以上 5.15.35 未満\nLinux Kernel 5.16 以上 5.17.4 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-026155": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: dev: fix skb drop check In commit a6d190f8c767 (\"can: skb: drop tx skb if in listen only mode\") the priv->ctrlmode element is read even on virtual CAN interfaces that do not create the struct can_priv at startup. This out-of-bounds read may lead to CAN frame drops for virtual CAN interfaces like vcan and vxcan. This patch mainly reverts the original commit and adds a new helper for CAN interface drivers that provide the required information in struct can_priv. [mkl: patch pch_can, too]",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.0.9 未満\nLinux Kernel 6.1"
    },
    "JVNDB-2022-026270": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/tls: fix slab-out-of-bounds bug in decrypt_internal The memory size of tls_ctx->rx.iv for AES128-CCM is 12 setting in tls_set_sw_offload(). The return value of crypto_aead_ivsize() for \"ccm(aes)\" is 16. So memcpy() require 16 bytes from 12 bytes memory space will trigger slab-out-of-bounds bug as following: ================================================================== BUG: KASAN: slab-out-of-bounds in decrypt_internal+0x385/0xc40 [tls] Read of size 16 at addr ffff888114e84e60 by task tls/10911 Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_report.cold+0x5e/0x5db ? decrypt_internal+0x385/0xc40 [tls] kasan_report+0xab/0x120 ? decrypt_internal+0x385/0xc40 [tls] kasan_check_range+0xf9/0x1e0 memcpy+0x20/0x60 decrypt_internal+0x385/0xc40 [tls] ? tls_get_rec+0x2e0/0x2e0 [tls] ? process_rx_list+0x1a5/0x420 [tls] ? tls_setup_from_iter.constprop.0+0x2e0/0x2e0 [tls] decrypt_skb_update+0x9d/0x400 [tls] tls_sw_recvmsg+0x3c8/0xb50 [tls] Allocated by task 10911: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0x81/0xa0 tls_set_sw_offload+0x2eb/0xa20 [tls] tls_setsockopt+0x68c/0x700 [tls] __sys_setsockopt+0xfe/0x1b0 Replace the crypto_aead_ivsize() with prot->iv_size + prot->salt_size when memcpy() iv value in TLS_1_3_VERSION scenario.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-026255": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Use VM_MAP instead of VM_ALLOC for ringbuf After commit 2fd3fb0be1d1 (\"kasan, vmalloc: unpoison VM_ALLOC pages after mapping\"), non-VM_ALLOC mappings will be marked as accessible in __get_vm_area_node() when KASAN is enabled. But now the flag for ringbuf area is VM_ALLOC, so KASAN will complain out-of-bound access after vmap() returns. Because the ringbuf area is created by mapping allocated pages, so use VM_MAP instead. After the change, info in /proc/vmallocinfo also changes from [start]-[end] 24576 ringbuf_map_alloc+0x171/0x290 vmalloc user to [start]-[end] 24576 ringbuf_map_alloc+0x171/0x290 vmap user",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026257": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix error handling in ext4_fc_record_modified_inode() Current code does not fully takes care of krealloc() error case, which could lead to silent memory corruption or a kernel bug. This patch fixes that. Also it cleans up some duplicated error handling logic from various functions in fast_commit.c file.",
        "technologies": "Linux\nLinux Kernel 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026259": {
        "title": "Linux の Linux Kernel における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: fix information leakage in /proc/net/ptype In one net namespace, after creating a packet socket without binding it to a device, users in other net namespaces can observe the new `packet_type` added by this packet socket by reading `/proc/net/ptype` file. This is minor information leakage as packet socket is namespace aware. Add a net pointer in `packet_type` to keep the net namespace of of corresponding packet socket. In `ptype_seq_show`, this net pointer must be checked when it is not NULL.",
        "technologies": "Linux\nLinux Kernel 2.6.26 以上 4.4.302 未満\nLinux Kernel 4.5 以上 4.9.300 未満\nLinux Kernel 4.10 以上 4.14.265 未満\nLinux Kernel 4.15 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.176 未満\nLinux Kernel 5.5 以上 5.10.96 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026253": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rpmsg: char: Fix race between the release of rpmsg_ctrldev and cdev struct rpmsg_ctrldev contains a struct cdev. The current code frees the rpmsg_ctrldev struct in rpmsg_ctrldev_release_device(), but the cdev is a managed object, therefore its release is not predictable and the rpmsg_ctrldev could be freed before the cdev is entirely released, as in the backtrace below. [ 93.625603] ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x7c [ 93.636115] WARNING: CPU: 0 PID: 12 at lib/debugobjects.c:488 debug_print_object+0x13c/0x1b0 [ 93.644799] Modules linked in: veth xt_cgroup xt_MASQUERADE rfcomm algif_hash algif_skcipher af_alg uinput ip6table_nat fuse uvcvideo videobuf2_vmalloc venus_enc venus_dec videobuf2_dma_contig hci_uart btandroid btqca snd_soc_rt5682_i2c bluetooth qcom_spmi_temp_alarm snd_soc_rt5682v [ 93.715175] CPU: 0 PID: 12 Comm: kworker/0:1 Tainted: G B 5.4.163-lockdep #26 [ 93.723855] Hardware name: Google Lazor (rev3 - 8) with LTE (DT) [ 93.730055] Workqueue: events kobject_delayed_cleanup [ 93.735271] pstate: 60c00009 (nZCv daif +PAN +UAO) [ 93.740216] pc : debug_print_object+0x13c/0x1b0 [ 93.744890] lr : debug_print_object+0x13c/0x1b0 [ 93.749555] sp : ffffffacf5bc7940 [ 93.752978] x29: ffffffacf5bc7940 x28: dfffffd000000000 [ 93.758448] x27: ffffffacdb11a800 x26: dfffffd000000000 [ 93.763916] x25: ffffffd0734f856c x24: dfffffd000000000 [ 93.769389] x23: 0000000000000000 x22: ffffffd0733c35b0 [ 93.774860] x21: ffffffd0751994a0 x20: ffffffd075ec27c0 [ 93.780338] x19: ffffffd075199100 x18: 00000000000276e0 [ 93.785814] x17: 0000000000000000 x16: dfffffd000000000 [ 93.791291] x15: ffffffffffffffff x14: 6e6968207473696c [ 93.796768] x13: 0000000000000000 x12: ffffffd075e2b000 [ 93.802244] x11: 0000000000000001 x10: 0000000000000000 [ 93.807723] x9 : d13400dff1921900 x8 : d13400dff1921900 [ 93.813200] x7 : 0000000000000000 x6 : 0000000000000000 [ 93.818676] x5 : 0000000000000080 x4 : 0000000000000000 [ 93.824152] x3 : ffffffd0732a0fa4 x2 : 0000000000000001 [ 93.829628] x1 : ffffffacf5bc7580 x0 : 0000000000000061 [ 93.835104] Call trace: [ 93.837644] debug_print_object+0x13c/0x1b0 [ 93.841963] __debug_check_no_obj_freed+0x25c/0x3c0 [ 93.846987] debug_check_no_obj_freed+0x18/0x20 [ 93.851669] slab_free_freelist_hook+0xbc/0x1e4 [ 93.856346] kfree+0xfc/0x2f4 [ 93.859416] rpmsg_ctrldev_release_device+0x78/0xb8 [ 93.864445] device_release+0x84/0x168 [ 93.868310] kobject_cleanup+0x12c/0x298 [ 93.872356] kobject_delayed_cleanup+0x10/0x18 [ 93.876948] process_one_work+0x578/0x92c [ 93.881086] worker_thread+0x804/0xcf8 [ 93.884963] kthread+0x2a8/0x314 [ 93.888303] ret_from_fork+0x10/0x18 The cdev_device_add/del() API was created to address this issue (see commit '233ed09d7fda (\"chardev: add helper function to register char devs with a struct device\")'), use it instead of cdev add/del().",
        "technologies": "Linux\nLinux Kernel 4.11 以上 4.14.265 未満\nLinux Kernel 4.15 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.176 未満\nLinux Kernel 5.5 以上 5.10.96 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026276": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: parisc: Fix non-access data TLB cache flush faults When a page is not present, we get non-access data TLB faults from the fdc and fic instructions in flush_user_dcache_range_asm and flush_user_icache_range_asm. When these occur, the cache line is not invalidated and potentially we get memory corruption. The problem was hidden by the nullification of the flush instructions. These faults also affect performance. With pa8800/pa8900 processors, there will be 32 faults per 4 KB page since the cache line is 128 bytes. There will be more faults with earlier processors. The problem is fixed by using flush_cache_pages(). It does the flush using a tmp alias mapping. The flush_cache_pages() call in flush_cache_range() flushed too large a range. V2: Remove unnecessary preempt_disable() and preempt_enable() calls.",
        "technologies": "Linux\nLinux Kernel 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026302": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ata: sata_dwc_460ex: Fix crash due to OOB write the driver uses libata's \"tag\" values from in various arrays. Since the mentioned patch bumped the ATA_TAG_INTERNAL to 32, the value of the SATA_DWC_QCMD_MAX needs to account for that. Otherwise ATA_TAG_INTERNAL usage cause similar crashes like this as reported by Tice Rex on the OpenWrt Forum and reproduced (with symbols) here: | BUG: Kernel NULL pointer dereference at 0x00000000 | Faulting instruction address: 0xc03ed4b8 | Oops: Kernel access of bad area, sig: 11 [#1] | BE PAGE_SIZE=4K PowerPC 44x Platform | CPU: 0 PID: 362 Comm: scsi_eh_1 Not tainted 5.4.163 #0 | NIP: c03ed4b8 LR: c03d27e8 CTR: c03ed36c | REGS: cfa59950 TRAP: 0300 Not tainted (5.4.163) | MSR: 00021000 <CE,ME> CR: 42000222 XER: 00000000 | DEAR: 00000000 ESR: 00000000 | GPR00: c03d27e8 cfa59a08 cfa55fe0 00000000 0fa46bc0 [...] | [..] | NIP [c03ed4b8] sata_dwc_qc_issue+0x14c/0x254 | LR [c03d27e8] ata_qc_issue+0x1c8/0x2dc | Call Trace: | [cfa59a08] [c003f4e0] __cancel_work_timer+0x124/0x194 (unreliable) | [cfa59a78] [c03d27e8] ata_qc_issue+0x1c8/0x2dc | [cfa59a98] [c03d2b3c] ata_exec_internal_sg+0x240/0x524 | [cfa59b08] [c03d2e98] ata_exec_internal+0x78/0xe0 | [cfa59b58] [c03d30fc] ata_read_log_page.part.38+0x1dc/0x204 | [cfa59bc8] [c03d324c] ata_identify_page_supported+0x68/0x130 | [...] This is because sata_dwc_dma_xfer_complete() NULLs the dma_pending's next neighbour \"chan\" (a *dma_chan struct) in this '32' case right here (line ~735): > hsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_NONE; Then the next time, a dma gets issued; dma_dwc_xfer_setup() passes the NULL'd hsdevp->chan to the dmaengine_slave_config() which then causes the crash. With this patch, SATA_DWC_QCMD_MAX is now set to ATA_MAX_QUEUE + 1. This avoids the OOB. But please note, there was a worthwhile discussion on what ATA_TAG_INTERNAL and ATA_MAX_QUEUE is. And why there should not be a \"fake\" 33 command-long queue size. Ideally, the dw driver should account for the ATA_TAG_INTERNAL. In Damien Le Moal's words: \"... having looked at the driver, it is a bigger change than just faking a 33rd \"tag\" that is in fact not a command tag at all.\" BugLink: https://github.com/openwrt/openwrt/issues/9505",
        "technologies": "Linux\nLinux Kernel 4.18 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.111 未満\nLinux Kernel 5.11 以上 5.15.34 未満\nLinux Kernel 5.16 以上 5.16.20 未満\nLinux Kernel 5.17 以上 5.17.3 未満\nLinux Kernel 5.18"
    },
    "JVNDB-2022-026296": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: USB: core: Fix hang in usb_kill_urb by adding memory barriers The syzbot fuzzer has identified a bug in which processes hang waiting for usb_kill_urb() to return. It turns out the issue is not unlinking the URB; that works just fine. Rather, the problem arises when the wakeup notification that the URB has completed is not received. The reason is memory-access ordering on SMP systems. In outline form, usb_kill_urb() and __usb_hcd_giveback_urb() operating concurrently on different CPUs perform the following actions: CPU 0 CPU 1 ---------------------------- --------------------------------- usb_kill_urb(): __usb_hcd_giveback_urb(): ... ... atomic_inc(&urb->reject); atomic_dec(&urb->use_count); ... ... wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0); if (atomic_read(&urb->reject)) wake_up(&usb_kill_urb_queue); Confining your attention to urb->reject and urb->use_count, you can see that the overall pattern of accesses on CPU 0 is: write urb->reject, then read urb->use_count; whereas the overall pattern of accesses on CPU 1 is: write urb->use_count, then read urb->reject. This pattern is referred to in memory-model circles as SB (for \"Store Buffering\"), and it is well known that without suitable enforcement of the desired order of accesses -- in the form of memory barriers -- it is entirely possible for one or both CPUs to execute their reads ahead of their writes. The end result will be that sometimes CPU 0 sees the old un-decremented value of urb->use_count while CPU 1 sees the old un-incremented value of urb->reject. Consequently CPU 0 ends up on the wait queue and never gets woken up, leading to the observed hang in usb_kill_urb(). The same pattern of accesses occurs in usb_poison_urb() and the failure pathway of usb_hcd_submit_urb(). The problem is fixed by adding suitable memory barriers. To provide proper memory-access ordering in the SB pattern, a full barrier is required on both CPUs. The atomic_inc() and atomic_dec() accesses themselves don't provide any memory ordering, but since they are present, we can use the optimized smp_mb__after_atomic() memory barrier in the various routines to obtain the desired effect. This patch adds the necessary memory barriers.",
        "technologies": "Linux\nLinux Kernel 4.4.302 未満\nLinux Kernel 4.5 以上 4.9.300 未満\nLinux Kernel 4.10 以上 4.14.265 未満\nLinux Kernel 4.15 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.176 未満\nLinux Kernel 5.5 以上 5.10.96 未満\nLinux Kernel 5.11 以上 5.15.19 未満\nLinux Kernel 5.16 以上 5.16.5 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026310": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: rx-macro: fix accessing array out of bounds for enum type Accessing enums using integer would result in array out of bounds access on platforms like aarch64 where sizeof(long) is 8 compared to enum size which is 4 bytes.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026311": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: rx-macro: fix accessing compander for aux AUX interpolator does not have compander, so check before accessing compander data for this. Without this checkan array of out bounds access will be made in comp_enabled[] array.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026332": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/gem: add missing boundary check in vm_access A missing bounds check in vm_access() can lead to an out-of-bounds read or write in the adjacent memory area, since the len attribute is not validated before the memcpy later in the function, potentially hitting: [ 183.637831] BUG: unable to handle page fault for address: ffffc90000c86000 [ 183.637934] #PF: supervisor read access in kernel mode [ 183.637997] #PF: error_code(0x0000) - not-present page [ 183.638059] PGD 100000067 P4D 100000067 PUD 100258067 PMD 106341067 PTE 0 [ 183.638144] Oops: 0000 [#2] PREEMPT SMP NOPTI [ 183.638201] CPU: 3 PID: 1790 Comm: poc Tainted: G D 5.17.0-rc6-ci-drm-11296+ #1 [ 183.638298] Hardware name: Intel Corporation CoffeeLake Client Platform/CoffeeLake H DDR4 RVP, BIOS CNLSFWR1.R00.X208.B00.1905301319 05/30/2019 [ 183.638430] RIP: 0010:memcpy_erms+0x6/0x10 [ 183.640213] RSP: 0018:ffffc90001763d48 EFLAGS: 00010246 [ 183.641117] RAX: ffff888109c14000 RBX: ffff888111bece40 RCX: 0000000000000ffc [ 183.642029] RDX: 0000000000001000 RSI: ffffc90000c86000 RDI: ffff888109c14004 [ 183.642946] RBP: 0000000000000ffc R08: 800000000000016b R09: 0000000000000000 [ 183.643848] R10: ffffc90000c85000 R11: 0000000000000048 R12: 0000000000001000 [ 183.644742] R13: ffff888111bed190 R14: ffff888109c14000 R15: 0000000000001000 [ 183.645653] FS: 00007fe5ef807540(0000) GS:ffff88845b380000(0000) knlGS:0000000000000000 [ 183.646570] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 183.647481] CR2: ffffc90000c86000 CR3: 000000010ff02006 CR4: 00000000003706e0 [ 183.648384] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 183.649271] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 183.650142] Call Trace: [ 183.650988] <TASK> [ 183.651793] vm_access+0x1f0/0x2a0 [i915] [ 183.652726] __access_remote_vm+0x224/0x380 [ 183.653561] mem_rw.isra.0+0xf9/0x190 [ 183.654402] vfs_read+0x9d/0x1b0 [ 183.655238] ksys_read+0x63/0xe0 [ 183.656065] do_syscall_64+0x38/0xc0 [ 183.656882] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 183.657663] RIP: 0033:0x7fe5ef725142 [ 183.659351] RSP: 002b:00007ffe1e81c7e8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000 [ 183.660227] RAX: ffffffffffffffda RBX: 0000557055dfb780 RCX: 00007fe5ef725142 [ 183.661104] RDX: 0000000000001000 RSI: 00007ffe1e81d880 RDI: 0000000000000005 [ 183.661972] RBP: 00007ffe1e81e890 R08: 0000000000000030 R09: 0000000000000046 [ 183.662832] R10: 0000557055dfc2e0 R11: 0000000000000246 R12: 0000557055dfb1c0 [ 183.663691] R13: 00007ffe1e81e980 R14: 0000000000000000 R15: 0000000000000000 Changes since v1: - Updated if condition with range_overflows_t [Chris Wilson] [mauld: tidy up the commit message and add Cc: stable] (cherry picked from commit 661412e301e2ca86799aa4f400d1cf0bd38c57c6)",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026292": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dlm: fix plock invalid read This patch fixes an invalid read showed by KASAN. A unlock will allocate a \"struct plock_op\" and a followed send_op() will append it to a global send_list data structure. In some cases a followed dev_read() moves it to recv_list and dev_write() will cast it to \"struct plock_xop\" and access fields which are only available in those structures. At this point an invalid read happens by accessing those fields. To fix this issue the \"callback\" field is moved to \"struct plock_op\" to indicate that a cast to \"plock_xop\" is allowed and does the additional \"plock_xop\" handling if set. Example of the KASAN output which showed the invalid read: [ 2064.296453] ================================================================== [ 2064.304852] BUG: KASAN: slab-out-of-bounds in dev_write+0x52b/0x5a0 [dlm] [ 2064.306491] Read of size 8 at addr ffff88800ef227d8 by task dlm_controld/7484 [ 2064.308168] [ 2064.308575] CPU: 0 PID: 7484 Comm: dlm_controld Kdump: loaded Not tainted 5.14.0+ #9 [ 2064.310292] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011 [ 2064.311618] Call Trace: [ 2064.312218] dump_stack_lvl+0x56/0x7b [ 2064.313150] print_address_description.constprop.8+0x21/0x150 [ 2064.314578] ? dev_write+0x52b/0x5a0 [dlm] [ 2064.315610] ? dev_write+0x52b/0x5a0 [dlm] [ 2064.316595] kasan_report.cold.14+0x7f/0x11b [ 2064.317674] ? dev_write+0x52b/0x5a0 [dlm] [ 2064.318687] dev_write+0x52b/0x5a0 [dlm] [ 2064.319629] ? dev_read+0x4a0/0x4a0 [dlm] [ 2064.320713] ? bpf_lsm_kernfs_init_security+0x10/0x10 [ 2064.321926] vfs_write+0x17e/0x930 [ 2064.322769] ? __fget_light+0x1aa/0x220 [ 2064.323753] ksys_write+0xf1/0x1c0 [ 2064.324548] ? __ia32_sys_read+0xb0/0xb0 [ 2064.325464] do_syscall_64+0x3a/0x80 [ 2064.326387] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 2064.327606] RIP: 0033:0x7f807e4ba96f [ 2064.328470] Code: 89 54 24 18 48 89 74 24 10 89 7c 24 08 e8 39 87 f8 ff 48 8b 54 24 18 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 31 44 89 c7 48 89 44 24 08 e8 7c 87 f8 ff 48 [ 2064.332902] RSP: 002b:00007ffd50cfe6e0 EFLAGS: 00000293 ORIG_RAX: 0000000000000001 [ 2064.334658] RAX: ffffffffffffffda RBX: 000055cc3886eb30 RCX: 00007f807e4ba96f [ 2064.336275] RDX: 0000000000000040 RSI: 00007ffd50cfe7e0 RDI: 0000000000000010 [ 2064.337980] RBP: 00007ffd50cfe7e0 R08: 0000000000000000 R09: 0000000000000001 [ 2064.339560] R10: 000055cc3886eb30 R11: 0000000000000293 R12: 000055cc3886eb80 [ 2064.341237] R13: 000055cc3886eb00 R14: 000055cc3886f590 R15: 0000000000000001 [ 2064.342857] [ 2064.343226] Allocated by task 12438: [ 2064.344057] kasan_save_stack+0x1c/0x40 [ 2064.345079] __kasan_kmalloc+0x84/0xa0 [ 2064.345933] kmem_cache_alloc_trace+0x13b/0x220 [ 2064.346953] dlm_posix_unlock+0xec/0x720 [dlm] [ 2064.348811] do_lock_file_wait.part.32+0xca/0x1d0 [ 2064.351070] fcntl_setlk+0x281/0xbc0 [ 2064.352879] do_fcntl+0x5e4/0xfe0 [ 2064.354657] __x64_sys_fcntl+0x11f/0x170 [ 2064.356550] do_syscall_64+0x3a/0x80 [ 2064.358259] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 2064.360745] [ 2064.361511] Last potentially related work creation: [ 2064.363957] kasan_save_stack+0x1c/0x40 [ 2064.365811] __kasan_record_aux_stack+0xaf/0xc0 [ 2064.368100] call_rcu+0x11b/0xf70 [ 2064.369785] dlm_process_incoming_buffer+0x47d/0xfd0 [dlm] [ 2064.372404] receive_from_sock+0x290/0x770 [dlm] [ 2064.374607] process_recv_sockets+0x32/0x40 [dlm] [ 2064.377290] process_one_work+0x9a8/0x16e0 [ 2064.379357] worker_thread+0x87/0xbf0 [ 2064.381188] kthread+0x3ac/0x490 [ 2064.383460] ret_from_fork+0x22/0x30 [ 2064.385588] [ 2064.386518] Second to last potentially related work creation: [ 2064.389219] kasan_save_stack+0x1c/0x40 [ 2064.391043] __kasan_record_aux_stack+0xaf/0xc0 [ 2064.393303] call_rcu+0x11b/0xf70 [ 2064.394885] dlm_process_incoming_buffer+0x47d/0xfd0 [dlm] [ 2064.397694] receive_from_sock+0x290/0x770 ---truncated---",
        "technologies": "Linux\nLinux Kernel 2.6.22 以上 4.9.318 未満\nLinux Kernel 4.10 以上 4.14.283 未満\nLinux Kernel 4.15 以上 4.19.247 未満\nLinux Kernel 4.20 以上 5.4.198 未満\nLinux Kernel 5.5 以上 5.10.121 未満\nLinux Kernel 5.11 以上 5.15.46 未満\nLinux Kernel 5.16 以上 5.17.14 未満\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-026329": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: uaccess: fix integer overflow on access_ok() Three architectures check the end of a user access against the address limit without taking a possible overflow into account. Passing a negative length or another overflow in here returns success when it should not. Use the most common correct implementation here, which optimizes for a constant 'size' argument, and turns the common case into a single comparison.",
        "technologies": "Linux\nLinux Kernel 3.2 以上 5.15.32 未満\nLinux Kernel 5.16 以上 5.16.18 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026325": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/page_owner: use strscpy() instead of strlcpy() current->comm[] is not a string (no guarantee for a zero byte in it). strlcpy(s1, s2, l) is calling strlen(s2), potentially causing out-of-bound access, as reported by syzbot: detected buffer overflow in __fortify_strlen ------------[ cut here ]------------ kernel BUG at lib/string_helpers.c:980! invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 4087 Comm: dhcpcd-run-hooks Not tainted 5.18.0-rc3-syzkaller-01537-g20b87e7c29df #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP: 0010:fortify_panic+0x18/0x1a lib/string_helpers.c:980 Code: 8c e8 c5 ba e1 fa e9 23 0f bf fa e8 0b 5d 8c f8 eb db 55 48 89 fd e8 e0 49 40 f8 48 89 ee 48 c7 c7 80 f5 26 8a e8 99 09 f1 ff <0f> 0b e8 ca 49 40 f8 48 8b 54 24 18 4c 89 f1 48 c7 c7 00 00 27 8a RSP: 0018:ffffc900000074a8 EFLAGS: 00010286 RAX: 000000000000002c RBX: ffff88801226b728 RCX: 0000000000000000 RDX: ffff8880198e0000 RSI: ffffffff81600458 RDI: fffff52000000e87 RBP: ffffffff89da2aa0 R08: 000000000000002c R09: 0000000000000000 R10: ffffffff815fae2e R11: 0000000000000000 R12: ffff88801226b700 R13: ffff8880198e0830 R14: 0000000000000000 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f5876ad6ff8 CR3: 000000001a48c000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600 Call Trace: <IRQ> __fortify_strlen include/linux/fortify-string.h:128 [inline] strlcpy include/linux/fortify-string.h:143 [inline] __set_page_owner_handle+0x2b1/0x3e0 mm/page_owner.c:171 __set_page_owner+0x3e/0x50 mm/page_owner.c:190 prep_new_page mm/page_alloc.c:2441 [inline] get_page_from_freelist+0xba2/0x3e00 mm/page_alloc.c:4182 __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5408 alloc_pages+0x1aa/0x310 mm/mempolicy.c:2272 alloc_slab_page mm/slub.c:1799 [inline] allocate_slab+0x26c/0x3c0 mm/slub.c:1944 new_slab mm/slub.c:2004 [inline] ___slab_alloc+0x8df/0xf20 mm/slub.c:3005 __slab_alloc.constprop.0+0x4d/0xa0 mm/slub.c:3092 slab_alloc_node mm/slub.c:3183 [inline] slab_alloc mm/slub.c:3225 [inline] __kmem_cache_alloc_lru mm/slub.c:3232 [inline] kmem_cache_alloc+0x360/0x3b0 mm/slub.c:3242 dst_alloc+0x146/0x1f0 net/core/dst.c:92",
        "technologies": "Linux\nLinux Kernel 5.18 以上 5.18.3 未満"
    },
    "JVNDB-2022-026328": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: oss: Fix PCM OSS buffer allocation overflow We've got syzbot reports hitting INT_MAX overflow at vmalloc() allocation that is called from snd_pcm_plug_alloc(). Although we apply the restrictions to input parameters, it's based only on the hw_params of the underlying PCM device. Since the PCM OSS layer allocates a temporary buffer for the data conversion, the size may become unexpectedly large when more channels or higher rates is given; in the reported case, it went over INT_MAX, hence it hits WARN_ON(). This patch is an attempt to avoid such an overflow and an allocation for too large buffers. First off, it adds the limit of 1MB as the upper bound for period bytes. This must be large enough for all use cases, and we really don't want to handle a larger temporary buffer than this size. The size check is performed at two places, where the original period bytes is calculated and where the plugin buffer size is calculated. In addition, the driver uses array_size() and array3_size() for multiplications to catch overflows for the converted period size and buffer bytes.",
        "technologies": "Linux\nLinux Kernel 4.19.237 未満\nLinux Kernel 4.20 以上 5.4.188 未満\nLinux Kernel 5.5 以上 5.10.109 未満\nLinux Kernel 5.11 以上 5.15.32 未満\nLinux Kernel 5.16 以上 5.16.18 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026312": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dsa: Avoid cross-chip syncing of VLAN filtering Changes to VLAN filtering are not applicable to cross-chip notifications. On a system like this: .-----. .-----. .-----. | sw1 +---+ sw2 +---+ sw3 | '-1-2-' '-1-2-' '-1-2-' Before this change, upon sw1p1 leaving a bridge, a call to dsa_port_vlan_filtering would also be made to sw2p1 and sw3p1. In this scenario: .---------. .-----. .-----. | sw1 +---+ sw2 +---+ sw3 | '-1-2-3-4-' '-1-2-' '-1-2-' When sw1p4 would leave a bridge, dsa_port_vlan_filtering would be called for sw2 and sw3 with a non-existing port - leading to array out-of-bounds accesses and crashes on mv88e6xxx.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.17.2 未満"
    },
    "JVNDB-2022-026318": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: imx-jpeg: fix a bug of accessing array out of bounds When error occurs in parsing jpeg, the slot isn't acquired yet, it may be the default value MXC_MAX_SLOTS. If the driver access the slot using the incorrect slot number, it will access array out of bounds. The result is the driver will change num_domains, which follows slot_data in struct mxc_jpeg_dev. Then the driver won't detach the pm domain at rmmod, which will lead to kernel panic when trying to insmod again.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026315": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Fix double uncharge the mem of sk_msg If tcp_bpf_sendmsg is running during a tear down operation, psock may be freed. tcp_bpf_sendmsg() tcp_bpf_send_verdict() sk_msg_return() tcp_bpf_sendmsg_redir() unlikely(!psock)) sk_msg_free() The mem of msg has been uncharged in tcp_bpf_send_verdict() by sk_msg_return(), and would be uncharged by sk_msg_free() again. When psock is null, we can simply returning an error code, this would then trigger the sk_msg_free_nocharge in the error path of __SK_REDIRECT and would have the side effect of throwing an error up to user space. This would be a slight change in behavior from user side but would look the same as an error if the redirect on the socket threw an error. This issue can cause the following info: WARNING: CPU: 0 PID: 2136 at net/ipv4/af_inet.c:155 inet_sock_destruct+0x13c/0x260 Call Trace: <TASK> __sk_destruct+0x24/0x1f0 sk_psock_destroy+0x19b/0x1c0 process_one_work+0x1b3/0x3c0 worker_thread+0x30/0x350 ? process_one_work+0x3c0/0x3c0 kthread+0xe6/0x110 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x22/0x30 </TASK>",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026347": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: va-macro: fix accessing array out of bounds for enum type Accessing enums using integer would result in array out of bounds access on platforms like aarch64 where sizeof(long) is 8 compared to enum size which is 4 bytes.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026348": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: wc938x: fix accessing array out of bounds for enum type Accessing enums using integer would result in array out of bounds access on platforms like aarch64 where sizeof(long) is 8 compared to enum size which is 4 bytes. Fix this by using enumerated items instead of integers.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026340": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ACPI: CPPC: Avoid out of bounds access when parsing _CPC data If the NumEntries field in the _CPC return package is less than 2, do not attempt to access the \"Revision\" element of that package, because it may not be present then. BugLink: https://lore.kernel.org/lkml/20220322143534.GC32582@xsang-OptiPlex-9020/",
        "technologies": "Linux\nLinux Kernel 4.4 以上 4.9.311 未満\nLinux Kernel 4.10 以上 4.14.276 未満\nLinux Kernel 4.15 以上 4.19.238 未満\nLinux Kernel 4.20 以上 5.4.189 未満\nLinux Kernel 5.5 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026370": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: remoteproc: Fix count check in rproc_coredump_write() Check count for 0, to avoid a potential underflow. Make the check the same as the one in rproc_recovery_write().",
        "technologies": "Linux\nLinux Kernel 5.9 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026359": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFSD: Fix the behavior of READ near OFFSET_MAX Dan Aloni reports: > Due to commit 8cfb9015280d (\"NFS: Always provide aligned buffers to > the RPC read layers\") on the client, a read of 0xfff is aligned up > to server rsize of 0x1000. > > As a result, in a test where the server has a file of size > 0x7fffffffffffffff, and the client tries to read from the offset > 0x7ffffffffffff000, the read causes loff_t overflow in the server > and it returns an NFS code of EINVAL to the client. The client as > a result indefinitely retries the request. The Linux NFS client does not handle NFS?ERR_INVAL, even though all NFS specifications permit servers to return that status code for a READ. Instead of NFS?ERR_INVAL, have out-of-range READ requests succeed and return a short result. Set the EOF flag in the result to prevent the client from retrying the READ request. This behavior appears to be consistent with Solaris NFS servers. Note that NFSv3 and NFSv4 use u64 offset values on the wire. These must be converted to loff_t internally before use -- an implicit type cast is not adequate for this purpose. Otherwise VFS checks against sb->s_maxbytes do not work properly.",
        "technologies": "Linux\nLinux Kernel 5.10.220 未満\nLinux Kernel 5.11 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026363": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on curseg->alloc_type As Wenqing Liu reported in bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215657 - Overview UBSAN: array-index-out-of-bounds in fs/f2fs/segment.c:3460:2 when mount and operate a corrupted image - Reproduce tested on kernel 5.17-rc4, 5.17-rc6 1. mkdir test_crash 2. cd test_crash 3. unzip tmp2.zip 4. mkdir mnt 5. ./single_test.sh f2fs 2 - Kernel dump [ 46.434454] loop0: detected capacity change from 0 to 131072 [ 46.529839] F2FS-fs (loop0): Mounted with checkpoint version = 7548c2d9 [ 46.738319] ================================================================================ [ 46.738412] UBSAN: array-index-out-of-bounds in fs/f2fs/segment.c:3460:2 [ 46.738475] index 231 is out of range for type 'unsigned int [2]' [ 46.738539] CPU: 2 PID: 939 Comm: umount Not tainted 5.17.0-rc6 #1 [ 46.738547] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-1ubuntu1.1 04/01/2014 [ 46.738551] Call Trace: [ 46.738556] <TASK> [ 46.738563] dump_stack_lvl+0x47/0x5c [ 46.738581] ubsan_epilogue+0x5/0x50 [ 46.738592] __ubsan_handle_out_of_bounds+0x68/0x80 [ 46.738604] f2fs_allocate_data_block+0xdff/0xe60 [f2fs] [ 46.738819] do_write_page+0xef/0x210 [f2fs] [ 46.738934] f2fs_do_write_node_page+0x3f/0x80 [f2fs] [ 46.739038] __write_node_page+0x2b7/0x920 [f2fs] [ 46.739162] f2fs_sync_node_pages+0x943/0xb00 [f2fs] [ 46.739293] f2fs_write_checkpoint+0x7bb/0x1030 [f2fs] [ 46.739405] kill_f2fs_super+0x125/0x150 [f2fs] [ 46.739507] deactivate_locked_super+0x60/0xc0 [ 46.739517] deactivate_super+0x70/0xb0 [ 46.739524] cleanup_mnt+0x11a/0x200 [ 46.739532] __cleanup_mnt+0x16/0x20 [ 46.739538] task_work_run+0x67/0xa0 [ 46.739547] exit_to_user_mode_prepare+0x18c/0x1a0 [ 46.739559] syscall_exit_to_user_mode+0x26/0x40 [ 46.739568] do_syscall_64+0x46/0xb0 [ 46.739584] entry_SYSCALL_64_after_hwframe+0x44/0xae The root cause is we missed to do sanity check on curseg->alloc_type, result in out-of-bound accessing on sbi->block_count[] array, fix it.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 5.10.110 未満\nLinux Kernel 5.11 以上 5.15.33 未満\nLinux Kernel 5.16 以上 5.16.19 未満\nLinux Kernel 5.17 以上 5.17.2 未満"
    },
    "JVNDB-2022-026376": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: IPoIB, Block PKEY interfaces with less rx queues than parent A user is able to configure an arbitrary number of rx queues when creating an interface via netlink. This doesn't work for child PKEY interfaces because the child interface uses the parent receive channels. Although the child shares the parent's receive channels, the number of rx queues is important for the channel_stats array: the parent's rx channel index is used to access the child's channel_stats. So the array has to be at least as large as the parent's rx queue size for the counting to work correctly and to prevent out of bound accesses. This patch checks for the mentioned scenario and returns an error when trying to create the interface. The error is propagated to the user.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.7 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2022-026392": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Avoid field-overflowing memcpy() In preparation for FORTIFY_SOURCE performing compile-time and run-time field bounds checking for memcpy(), memmove(), and memset(), avoid intentionally writing across neighboring fields. Use flexible arrays instead of zero-element arrays (which look like they are always overflowing) and split the cross-field memcpy() into two halves that can be appropriately bounds-checked by the compiler. We were doing: #define ETH_HLEN 14 #define VLAN_HLEN 4 ... #define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN) ... struct mlx5e_tx_wqe *wqe = mlx5_wq_cyc_get_wqe(wq, pi); ... struct mlx5_wqe_eth_seg *eseg = &wqe->eth; struct mlx5_wqe_data_seg *dseg = wqe->data; ... memcpy(eseg->inline_hdr.start, xdptxd->data, MLX5E_XDP_MIN_INLINE); target is wqe->eth.inline_hdr.start (which the compiler sees as being 2 bytes in size), but copying 18, intending to write across start (really vlan_tci, 2 bytes). The remaining 16 bytes get written into wqe->data[0], covering byte_count (4 bytes), lkey (4 bytes), and addr (8 bytes). struct mlx5e_tx_wqe { struct mlx5_wqe_ctrl_seg ctrl; /* 0 16 */ struct mlx5_wqe_eth_seg eth; /* 16 16 */ struct mlx5_wqe_data_seg data[]; /* 32 0 */ /* size: 32, cachelines: 1, members: 3 */ /* last cacheline: 32 bytes */ }; struct mlx5_wqe_eth_seg { u8 swp_outer_l4_offset; /* 0 1 */ u8 swp_outer_l3_offset; /* 1 1 */ u8 swp_inner_l4_offset; /* 2 1 */ u8 swp_inner_l3_offset; /* 3 1 */ u8 cs_flags; /* 4 1 */ u8 swp_flags; /* 5 1 */ __be16 mss; /* 6 2 */ __be32 flow_table_metadata; /* 8 4 */ union { struct { __be16 sz; /* 12 2 */ u8 start[2]; /* 14 2 */ } inline_hdr; /* 12 4 */ struct { __be16 type; /* 12 2 */ __be16 vlan_tci; /* 14 2 */ } insert; /* 12 4 */ __be32 trailer; /* 12 4 */ }; /* 12 4 */ /* size: 16, cachelines: 1, members: 9 */ /* last cacheline: 16 bytes */ }; struct mlx5_wqe_data_seg { __be32 byte_count; /* 0 4 */ __be32 lkey; /* 4 4 */ __be64 addr; /* 8 8 */ /* size: 16, cachelines: 1, members: 3 */ /* last cacheline: 16 bytes */ }; So, split the memcpy() so the compiler can reason about the buffer sizes. \"pahole\" shows no size nor member offset changes to struct mlx5e_tx_wqe nor struct mlx5e_umr_wqe. \"objdump -d\" shows no meaningful object code changes (i.e. only source line number induced differences and optimizations).",
        "technologies": "Linux\nLinux Kernel 4.9 以上 5.16.6 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026378": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: fastrpc: avoid double fput() on failed usercopy If the copy back to userland fails for the FASTRPC_IOCTL_ALLOC_DMA_BUFF ioctl(), we shouldn't assume that 'buf->dmabuf' is still valid. In fact, dma_buf_fd() called fd_install() before, i.e. \"consumed\" one reference, leaving us with none. Calling dma_buf_put() will therefore put a reference we no longer own, leading to a valid file descritor table entry for an already released 'file' object which is a straight use-after-free. Simply avoid calling dma_buf_put() and rely on the process exit code to do the necessary cleanup, if needed, i.e. if the file descriptor is still valid.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.180 未満\nLinux Kernel 5.5 以上 5.10.101 未満\nLinux Kernel 5.11 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2022-026393": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: ops: Reject out of bounds values in snd_soc_put_volsw() We don't currently validate that the values being set are within the range we advertised to userspace as being valid, do so and reject any values that are out of range.",
        "technologies": "Linux\nLinux Kernel 4.9.300 未満\nLinux Kernel 4.10 以上 4.14.265 未満\nLinux Kernel 4.15 以上 4.19.228 未満\nLinux Kernel 4.20 以上 5.4.178 未満\nLinux Kernel 5.5 以上 5.10.99 未満\nLinux Kernel 5.11 以上 5.15.22 未満\nLinux Kernel 5.16 以上 5.16.8 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2023-006551": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における二重解放に関する脆弱性",
        "description": "hci_conn_cleanup in net/bluetooth/hci_conn.c in the Linux kernel through 6.2.9 has a use-after-free (observed in hci_conn_hash_flush) because of calls to hci_dev_put and hci_conn_put. There is a double free that may lead to privilege escalation.",
        "technologies": "Linux\nLinux Kernel 6.1.25\nLinux Kernel 6.2.12\nLinux Kernel 6.3\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-006586": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw use after free in the Linux kernel Xircom 16-bit PCMCIA (PC-card) Ethernet driver was found.A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 2.6.18 以上 4.14.312 未満\nLinux Kernel 4.15 以上 4.19.280 未満\nLinux Kernel 4.20 以上 5.4.240 未満\nLinux Kernel 5.5 以上 5.10.177 未満\nLinux Kernel 5.11 以上 5.15.105 未満\nLinux Kernel 5.16 以上 6.1.22 未満\nLinux Kernel 6.2 以上 6.2.9 未満"
    },
    "JVNDB-2022-026403": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: buffer: Fix file related error handling in IIO_BUFFER_GET_FD_IOCTL If we fail to copy the just created file descriptor to userland, we try to clean up by putting back 'fd' and freeing 'ib'. The code uses put_unused_fd() for the former which is wrong, as the file descriptor was already published by fd_install() which gets called internally by anon_inode_getfd(). This makes the error handling code leaving a half cleaned up file descriptor table around and a partially destructed 'file' object, allowing userland to play use-after-free tricks on us, by abusing the still usable fd and making the code operate on a dangling 'file->private_data' pointer. Instead of leaving the kernel in a partially corrupted state, don't attempt to explicitly clean up and leave this to the process exit path that'll release any still valid fds, including the one created by the previous call to anon_inode_getfd(). Simply return -EFAULT to indicate the error.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.24 未満\nLinux Kernel 5.16 以上 5.16.10 未満\nLinux Kernel 5.17"
    },
    "JVNDB-2023-009362": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "A vulnerability was found in compare_netdev_and_ip in drivers/infiniband/core/cma.c in RDMA in the Linux Kernel. The improper cleanup results in out-of-boundary read, where a local user can utilize this problem to crash the system or escalation of privilege.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.3 未満"
    },
    "JVNDB-2023-008711": {
        "title": "Linux Foundation の Kubernetes 用 openfeature における脆弱性",
        "description": "The OpenFeature Operator allows users to expose feature flags to applications. Assuming the pre-existence of a vulnerability that allows for arbitrary code execution, an attacker could leverage the lax permissions configured on `open-feature-operator-controller-manager` to escalate the privileges of any SA in the cluster. The increased privileges could be used to modify cluster state, leading to DoS, or read sensitive data, including secrets. Version 0.2.32 mitigates this issue by restricting the resources the `open-feature-operator-controller-manager` can modify.",
        "technologies": "Linux Foundation\nopenfeature 0.2.32 未満"
    },
    "JVNDB-2023-009253": {
        "title": "Sangoma の freepbx linux 7 における認証情報の不十分な保護に関する脆弱性",
        "description": "Sangoma FreePBX 1805 through 2302 (when obtained as a ,.ISO file) places AMPDBUSER, AMPDBPASS, AMPMGRUSER, and AMPMGRPASS in the list of global variables. This exposes cleartext authentication credentials for the Asterisk Database (MariaDB/MySQL) and Asterisk Manager Interface. For example, an attacker can make a /ari/asterisk/variable?variable=AMPDBPASS API call.",
        "technologies": "Sangoma\nfreepbx linux 7 1805\nfreepbx linux 7 1904\nfreepbx linux 7 1910\nfreepbx linux 7 2002\nfreepbx linux 7 2008\nfreepbx linux 7 2011\nfreepbx linux 7 2104\nfreepbx linux 7 2105\nfreepbx linux 7 2109\nfreepbx linux 7 2112\nfreepbx linux 7 2201\nfreepbx linux 7 2202\nfreepbx linux 7 2203\nfreepbx linux 7 2302"
    },
    "JVNDB-2023-008885": {
        "title": "Linux Foundation の kubewarden-controller における権限管理に関する脆弱性",
        "description": "An Improper Privilege Management vulnerability in SUSE kubewarden allows attackers to read arbitrary secrets if they get access to the ServiceAccount kubewarden-controller This issue affects: SUSE kubewarden kubewarden-controller versions prior to 1.6.0.",
        "technologies": "Linux Foundation\nkubewarden-controller 1.6.0 未満"
    },
    "JVNDB-2023-009381": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における別領域リソースに対する外部からの制御可能な参照に関する脆弱性",
        "description": "The current implementation of the prctl syscall does not issue an IBPB immediately during the syscall. The ib_prctl_set  function updates the Thread Information Flags (TIFs) for the task and updates the SPEC_CTRL MSR on the function __speculation_ctrl_update, but the IBPB is only issued on the next schedule, when the TIF bits are checked. This leaves the victim vulnerable to values already injected on the BTB, prior to the prctl syscall.  The patch that added the support for the conditional mitigation via prctl (ib_prctl_set) dates back to the kernel 4.9.176. We recommend upgrading past commit a664ec9158eeddd75121d39c9a0758016097fa96",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.16.68 以上 3.17 未満\nLinux Kernel 4.4.180 以上 4.5 未満\nLinux Kernel 4.9.176 以上 4.10 未満\nLinux Kernel 4.14.86 以上 4.14.303 未満\nLinux Kernel 4.19.7 以上 4.19.270 未満\nLinux Kernel 4.20 以上 5.4.229 未満\nLinux Kernel 5.5.0 以上 5.10.163 未満\nLinux Kernel 5.11 以上 5.15.87 未満\nLinux Kernel 5.16 以上 6.0.19 未満\nLinux Kernel 6.1 以上 6.1.5 未満\nNetApp\nActive IQ Unified Manager\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-009382": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux Kernel io_uring subsystem can be exploited to achieve local privilege escalation. Both io_install_fixed_file and its callers call fput in a file in case of an error, causing a reference underflow which leads to a use-after-free vulnerability. We recommend upgrading past commit 9d94c04c0db024922e886c9fd429659f22f48ea4.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.0.11 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2023-009383": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux Kernel Performance Events system can be exploited to achieve local privilege escalation. The perf_group_detach function did not check the event's siblings' attach_state before calling add_event_to_groups(), but remove_on_exec made it possible to call list_del_event() on before detaching from their group, making it possible to use a dangling pointer causing a use-after-free vulnerability. We recommend upgrading past commit fd0815f632c24878e325821943edccc7fde947a2.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.104 未満\nLinux Kernel 5.16 以上 6.1.21 未満\nLinux Kernel 6.2 以上 6.2.8 未満"
    },
    "JVNDB-2023-009556": {
        "title": "cyberpower の複数の OS 用 powerpanel における認証に関する脆弱性",
        "description": "Use of default password vulnerability in PowerPanel Business Local/Remote for Windows v4.8.6 and earlier, PowerPanel Business Management for Windows v4.8.6 and earlier, PowerPanel Business Local/Remote for Linux 32bit v4.8.6 and earlier, PowerPanel Business Local/Remote for Linux 64bit v4.8.6 and earlier, PowerPanel Business Management for Linux 32bit v4.8.6 and earlier, PowerPanel Business Management for Linux 64bit v4.8.6 and earlier, PowerPanel Business Local/Remote for MacOS v4.8.6 and earlier, and PowerPanel Business Management for MacOS v4.8.6 and earlier allows remote attackers to log in to the server directly to perform administrative functions. Upon installation or upon first login, the application does not ask the user to change the 'admin' password.",
        "technologies": "cyberpower\npowerpanel 4.8.6 およびそれ以前"
    },
    "JVNDB-2023-009387": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "The specific flaw exists within the DPT I2O Controller driver. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this in conjunction with other vulnerabilities to escalate privileges and execute arbitrary code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 6.0 未満"
    },
    "JVNDB-2023-009552": {
        "title": "cyberpower の複数の OS 用 powerpanel における権限管理に関する脆弱性",
        "description": "Improper privilege management vulnerability in default.cmd file in PowerPanel Business Local/Remote for Windows v4.8.6 and earlier, PowerPanel Business Management for Windows v4.8.6 and earlier, PowerPanel Business Local/Remote for Linux 32bit v4.8.6 and earlier, PowerPanel Business Local/Remote for Linux 64bit v4.8.6 and earlier, PowerPanel Business Management for Linux 32bit v4.8.6 and earlier, PowerPanel Business Management for Linux 64bit v4.8.6 and earlier, PowerPanel Business Local/Remote for MacOS v4.8.6 and earlier, and PowerPanel Business Management for MacOS v4.8.6 and earlier allows remote attackers to execute operation system commands via unspecified vectors.",
        "technologies": "cyberpower\npowerpanel 4.8.6 およびそれ以前"
    },
    "JVNDB-2023-009555": {
        "title": "cyberpower の複数の OS 用 powerpanel における危険なタイプのファイルの無制限アップロードに関する脆弱性",
        "description": "Unrestricted upload of file with dangerous type vulnerability in default.cmd file in PowerPanel Business Local/Remote for Windows v4.8.6 and earlier, PowerPanel Business Management for Windows v4.8.6 and earlier, PowerPanel Business Local/Remote for Linux 32bit v4.8.6 and earlier, PowerPanel Business Local/Remote for Linux 64bit v4.8.6 and earlier, PowerPanel Business Management for Linux 32bit v4.8.6 and earlier, PowerPanel Business Management for Linux 64bit v4.8.6 and earlier, PowerPanel Business Local/Remote for MacOS v4.8.6 and earlier, and PowerPanel Business Management for MacOS v4.8.6 and earlier allows remote attackers to execute operation system commands via unspecified vectors.",
        "technologies": "cyberpower\npowerpanel 4.8.6 およびそれ以前"
    },
    "JVNDB-2023-009385": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A race condition was found in the Linux kernel's RxRPC network protocol, within the processing of RxRPC bundles. This issue results from the lack of proper locking when performing operations on an object. This may allow an attacker to escalate privileges and execute arbitrary code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.157 未満\nLinux Kernel 5.11 以上 5.15.81 未満\nLinux Kernel 5.16 以上 6.0.11 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2023-009384": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13 allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.",
        "technologies": "Linux\nLinux Kernel 3.7 以上 4.14.314 未満\nLinux Kernel 4.15 以上 4.19.282 未満\nLinux Kernel 4.20 以上 5.4.242 未満\nLinux Kernel 5.5.0 以上 5.10.179 未満\nLinux Kernel 5.11 以上 5.15.109 未満\nLinux Kernel 5.16 以上 6.1.26 未満\nLinux Kernel 6.2 以上 6.2.13 未満"
    },
    "JVNDB-2023-010048": {
        "title": "Linux Foundation の rekor における制限またはスロットリング無しのリソースの割り当てに関する脆弱性",
        "description": "Rekor is an open source software supply chain transparency log. Rekor prior to version 1.1.1 may crash due to out of memory (OOM) conditions caused by reading archive metadata files into memory without checking their sizes first. Verification of a JAR file submitted to Rekor can cause an out of memory crash if files within the META-INF directory of the JAR are sufficiently large. Parsing of an APK file submitted to Rekor can cause an out of memory crash if the .SIGN or .PKGINFO files within the APK are sufficiently large. The OOM crash has been patched in Rekor version 1.1.1. There are no known workarounds.",
        "technologies": "Linux Foundation\nrekor 1.1.1 未満"
    },
    "JVNDB-2023-010055": {
        "title": "Linux Foundation の Fluid における不正な認証に関する脆弱性",
        "description": "Fluid is an open source Kubernetes-native distributed dataset orchestrator and accelerator for data-intensive applications. Starting in version 0.7.0 and prior to version 0.8.6, if a malicious user gains control of a Kubernetes node running fluid csi pod (controlled by the `csi-nodeplugin-fluid` node-daemonset), they can leverage the fluid-csi service account to modify specs of all the nodes in the cluster. However, since this service account lacks `list node` permissions, the attacker may need to use other techniques to identify vulnerable nodes. Once the attacker identifies and modifies the node specs, they can manipulate system-level-privileged components to access all secrets in the cluster or execute pods on other nodes. This allows them to elevate privileges beyond the compromised node and potentially gain full privileged access to the whole cluster. To exploit this vulnerability, the attacker can make all other nodes unschedulable (for example, patch node with taints) and wait for system-critical components with high privilege to appear on the compromised node. However, this attack requires two prerequisites: a compromised node and identifying all vulnerable nodes through other means. Version 0.8.6 contains a patch for this issue. As a workaround, delete the `csi-nodeplugin-fluid` daemonset in `fluid-system` namespace and avoid using CSI mode to mount FUSE file systems. Alternatively, using sidecar mode to mount FUSE file systems is recommended.",
        "technologies": "Linux Foundation\nFluid 0.7.0 以上 0.8.6 未満"
    },
    "JVNDB-2023-010080": {
        "title": "複数の CODESYS Control 製品における OS コマンドインジェクションの脆弱性",
        "description": "A low-privileged remote attacker could exploit the vulnerability and inject additional system commands via file system libraries which could give the attacker full control of the device.",
        "technologies": "CODESYS GmbH\nCODESYS Control for BeagleBone SL 4.11.0.0 より前のバージョン\nCODESYS Control for emPC-A/iMX6 SL 4.11.0.0 より前のバージョン\nCODESYS Control for IOT2000 SL 4.11.0.0 より前のバージョン\nCODESYS Control for Linux ARM SL 4.11.0.0 より前のバージョン\nCODESYS Control for Linux SL 4.11.0.0 より前のバージョン\nCODESYS Control for PFC100 SL 4.11.0.0 より前のバージョン\nCODESYS Control for PFC200 SL 4.11.0.0 より前のバージョン\nCODESYS Control for PLCnext SL 4.11.0.0 より前のバージョン\nCODESYS Control for Raspberry Pi SL 4.11.0.0 より前のバージョン\nCODESYS Control for WAGO Touch Panels 600 SL 4.11.0.0 より前のバージョン\nCODESYS Runtime Toolkit for Linux or QNX 3.5.19.50 より前のバージョン"
    },
    "JVNDB-2023-010418": {
        "title": "インテルの Linux 用 i915 graphics における境界外書き込みに関する脆弱性",
        "description": "Improper restriction of operations within the bounds of a memory buffer in some Intel(R) i915 Graphics drivers for linux before kernel version 6.2.10 may allow an authenticated user to potentially enable escalation of privilege via local access.",
        "technologies": "インテル\ni915 graphics 6.2.10 未満"
    },
    "JVNDB-2023-010689": {
        "title": "Linux Foundation の Backstage におけるコードインジェクションの脆弱性",
        "description": "Backstage is an open platform for building developer portals. The Backstage scaffolder-backend plugin uses a templating library that requires sandbox, as it by design allows for code injection. The library used for this sandbox so far has been `vm2`, but in light of several past vulnerabilities and existing vulnerabilities that may not have a fix, the plugin has switched to using a different sandbox library. A malicious actor with write access to a registered scaffolder template could manipulate the template in a way that allows for remote code execution on the scaffolder-backend instance. This was only exploitable in the template YAML definition itself and not by user input data. This is vulnerability is fixed in version 1.15.0 of `@backstage/plugin-scaffolder-backend`.",
        "technologies": "Linux Foundation\nBackstage 1.15.0 未満"
    },
    "JVNDB-2023-010276": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables when processing batch requests can be abused to perform arbitrary read and write operations on kernel memory. Unprivileged local users can obtain root privileges. This occurs because anonymous sets are mishandled.",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.14.315 未満\nLinux Kernel 4.15 以上 4.19.283 未満\nLinux Kernel 4.20 以上 5.4.243 未満\nLinux Kernel 5.5 以上 5.10.180 未満\nLinux Kernel 5.11 以上 5.15.111 未満\nLinux Kernel 5.16 以上 6.1.28 未満\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s\nレッドハット\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-010904": {
        "title": "Linux Foundation の cups-filters 他複数ベンダの製品における OS コマンドインジェクションの脆弱性",
        "description": "cups-filters contains backends, filters, and other software required to get the cups printing service working on operating systems other than macos. If you use the Backend Error Handler (beh) to create an accessible network printer, this security vulnerability can cause remote code execution. `beh.c` contains the line `retval = system(cmdline) >> 8;` which calls the `system` command with the operand `cmdline`. `cmdline` contains multiple user controlled, unsanitized values. As a result an attacker with network access to the hosted print server can exploit this vulnerability to inject system commands which are executed in the context of the running server. This issue has been addressed in commit `8f2740357` and is expected to be bundled in the next release. Users are advised to upgrade when possible and to restrict access to network printers in the meantime.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nFedora Project\nFedora 37\nFedora 38\nLinux Foundation\ncups-filters 2.0 未満\ncups-filters 2.0"
    },
    "JVNDB-2023-011223": {
        "title": "ノキアの service router linux および service router operating system における脆弱性",
        "description": "Nokia Service Router Operating System (SR OS) 22.10 and SR Linux, when error-handling update-fault-tolerance is not enabled, mishandle BGP path attributes.",
        "technologies": "ノキア\nservice router linux\nservice router operating system 22.10"
    },
    "JVNDB-2023-012033": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation. When fw_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free. We recommend upgrading past commit 76e42ae831991c828cffa8c37736ebfb831ad5ec.",
        "technologies": "Debian\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 6.5 未満"
    },
    "JVNDB-2023-012032": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation. When u32_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free. We recommend upgrading past commit 3044b16e7c6fe5d24b1cdbcf1bd0a9d92d1ebd81.",
        "technologies": "Debian\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 6.5 未満"
    },
    "JVNDB-2023-012026": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's af_unix component can be exploited to achieve local privilege escalation. The unix_stream_sendpage() function tries to add data to the last skb in the peer's recv queue without locking the queue. Thus there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free. We recommend upgrading past commit 790c2f9d15b594350ae9bca7b236f2b1859de02c.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 4.2 以上 6.1.47 未満"
    },
    "JVNDB-2023-012027": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. Due to a race condition between nf_tables netlink control plane transaction and nft_set element garbage collection, it is possible to underflow the reference counter causing a use-after-free vulnerability. We recommend upgrading past commit 3e91b0ebd994635df2346353322ac51ce84ce6d8.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 6.5 未満"
    },
    "JVNDB-2023-011238": {
        "title": "Linux の Linux Kernel 他複数ベンダの製品における到達可能なアサーションに関する脆弱性",
        "description": "A flaw was found in the networking subsystem of the Linux kernel within the handling of the RPL protocol. This issue results from the lack of proper handling of user-supplied data, which can lead to an assertion failure. This may allow an unauthenticated remote attacker to create a denial of service condition on the system.",
        "technologies": "Fedora Project\nFedora 38\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-011450": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds memory access flaw was found in the Linux kernel’s XFS file system in how a user restores an XFS image after failure (with a dirty log journal). This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 6.3 およびそれ以前"
    },
    "JVNDB-2023-012034": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_route component can be exploited to achieve local privilege escalation. When route4_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free. We recommend upgrading past commit b80b829e9e2c1b3f7aae34855e04d8f6ecaf13c8.",
        "technologies": "Debian\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 6.5 未満"
    },
    "JVNDB-2023-012025": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: sch_hfsc (HFSC qdisc traffic control) component can be exploited to achieve local privilege escalation. If a class with a link-sharing curve (i.e. with the HFSC_FSC flag set) has a parent without a link-sharing curve, then init_vf() will call vttree_insert() on the parent, but vttree_remove() will be skipped in update_vf(). This leaves a dangling pointer that can cause a use-after-free. We recommend upgrading past commit b3d26c5702c7d6c45456326e56d2ccf3f103e60f.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 以上 6.6 未満"
    },
    "JVNDB-2023-012036": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. On an error when building a nftables rule, deactivating immediate expressions in nft_immediate_deactivate() can lead unbinding the chain and objects be deactivated but later used. We recommend upgrading past commit 0a771f7b266b02d262900c75f1e175c7fe76fec2.",
        "technologies": "Debian\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 5.9 以上 5.10.190 未満\nLinux Kernel 5.11 以上 5.15.124 未満\nLinux Kernel 5.16 以上 6.1.43 未満\nLinux Kernel 6.2 以上 6.4.8 未満"
    },
    "JVNDB-2023-012080": {
        "title": "Linux Foundation の Kubernetes 用 Argo Continuous Delivery におけるログファイルからの情報漏えいに関する脆弱性",
        "description": "Argo CD is a declarative continuous deployment for Kubernetes. Argo CD Cluster secrets might be managed declaratively using Argo CD / kubectl apply. As a result, the full secret body is stored in`kubectl.kubernetes.io/last-applied-configuration` annotation. pull request #7139 introduced the ability to manage cluster labels and annotations. Since clusters are stored as secrets it also exposes the `kubectl.kubernetes.io/last-applied-configuration` annotation which includes full secret body. In order to view the cluster annotations via the Argo CD API, the user must have `clusters, get` RBAC access. **Note:** In many cases, cluster secrets do not contain any actually-secret information. But sometimes, as in bearer-token auth, the contents might be very sensitive. The bug has been patched in versions 2.8.3, 2.7.14, and 2.6.15. Users are advised to upgrade. Users unable to upgrade should update/deploy cluster secret with `server-side-apply` flag which does not use or rely on `kubectl.kubernetes.io/last-applied-configuration` annotation. Note: annotation for existing secrets will require manual removal.",
        "technologies": "Linux Foundation\nArgo Continuous Delivery 2.2.0 以上 2.6.15 未満\nArgo Continuous Delivery 2.7.0 以上 2.7.14 未満\nArgo Continuous Delivery 2.8.0 以上 2.8.3 未満"
    },
    "JVNDB-2023-012807": {
        "title": "NVIDIA の cumulus linux における脆弱性",
        "description": "NVIDIA Cumulus Linux contains a vulnerability in forwarding where a VxLAN-encapsulated IPv6 packet received on an SVI interface with DMAC/DIPv6 set to the link-local address of the SVI interface may be incorrectly forwarded. A successful exploit may lead to information disclosure.",
        "technologies": "NVIDIA\ncumulus linux 5.6.0 未満"
    },
    "JVNDB-2023-012719": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation. When the plug qdisc is used as a class of the qfq qdisc, sending network packets triggers use-after-free in qfq_dequeue() due to the incorrect .peek handler of sch_plug and lack of error checking in agg_dequeue(). We recommend upgrading past commit 8fc134fee27f2263988ae38920bc03da416b03d8.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.8 以上 6.6 未満"
    },
    "JVNDB-2023-012878": {
        "title": "Linux Foundation の edge virtualization engine におけるデータの信頼性についての不十分な検証に関する脆弱性",
        "description": "In EVE OS, the “measured boot” mechanism prevents a compromised device from accessing the encrypted data located in the vault. As per the “measured boot” design, the PCR values calculated at different stages of the boot process will change if any of their respective parts are changed. This includes, among other things, the configuration of the bios, grub, the kernel cmdline, initrd, and more. However, this mechanism does not validate the entire rootfs, so an attacker can edit the filesystem and gain control over the system. As the default filesystem used by EVE OS is squashfs, this is somewhat harder than an ext4, which is easily changeable. This will not stop an attacker, as an attacker can repackage the squashfs with their changes in it and replace the partition altogether. This can also be done directly on the device, as the “003-storage-init” container contains the “mksquashfs” and “unsquashfs” binaries (with the corresponding libs). An attacker can gain full control over the device without changing the PCR values, thus not triggering the “measured boot” mechanism, and having full access to the vault. Note: This issue was partially fixed in these commits (after disclosure to Zededa), where the config partition measurement was added to PCR13: • aa3501d6c57206ced222c33aea15a9169d629141 • 5fef4d92e75838cc78010edaed5247dfbdae1889. This issue was made viable in version 9.0.0 when the calculation was moved to PCR14 but it was not included in the measured boot.",
        "technologies": "Linux Foundation\nedge virtualization engine 8.6.0 未満\nedge virtualization engine 9.0.0 以上 9.5.0 未満"
    },
    "JVNDB-2023-013214": {
        "title": "複数のエフ・セキュア製品における無限ループに関する脆弱性",
        "description": "Certain WithSecure products allow Denial of Service (infinite loop). This affects WithSecure Client Security 15, WithSecure Server Security 15, WithSecure Email and Server Security 15, WithSecure Elements Endpoint Protection 17 and later, WithSecure Client Security for Mac 15, WithSecure Elements Endpoint Protection for Mac 17 and later, Linux Security 64 12.0 , Linux Protection 12.0, and WithSecure Atlant (formerly F-Secure Atlant) 1.0.35-1.",
        "technologies": "エフ・セキュア\nclient security 15.00\nclient security 15.00\nF-Secure Atlant 1.0.35-1\nF-Secure E-mail and Server Security 15.00\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Linux Seculity 64 12.0\nF-Secure Server Security 15.00\nlinux protection 12.0"
    },
    "JVNDB-2023-012882": {
        "title": "Linux Foundation の edge virtualization engine における認証情報の不十分な保護に関する脆弱性",
        "description": "PCR14 is not in the list of PCRs that seal/unseal the “vault” key, but due to the change that was implemented in commit “7638364bc0acf8b5c481b5ce5fea11ad44ad7fd4”, fixing this issue alone would not solve the problem of the config partition not being measured correctly. Also, the “vault” key is sealed/unsealed with SHA1 PCRs instead of SHA256. This issue was somewhat mitigated due to all of the PCR extend functions updating both the values of SHA256 and SHA1 for a given PCR ID. However, due to the change that was implemented in commit “7638364bc0acf8b5c481b5ce5fea11ad44ad7fd4”, this is no longer the case for PCR14, as the code in “measurefs.go” explicitly updates only the SHA256 instance of PCR14, which means that even if PCR14 were to be added to the list of PCRs sealing/unsealing the “vault” key, changes to the config partition would still not be measured. An attacker could modify the config partition without triggering the measured boot, this could result in the attacker gaining full control over the device with full access to the contents of the encrypted “vault”",
        "technologies": "Linux Foundation\nedge virtualization engine 9.0.0 以上 9.5.0 未満"
    },
    "JVNDB-2023-012881": {
        "title": "Linux Foundation の edge virtualization engine における認証情報の不十分な保護に関する脆弱性",
        "description": "On boot, the Pillar eve container checks for the existence and content of “/config/authorized_keys”. If the file is present, and contains a supported public key, the container will go on to open port 22 and enable sshd with the given keys as the authorized keys for root login. An attacker could easily add their own keys and gain full control over the system without triggering the “measured boot” mechanism implemented by EVE OS, and without marking the device as “UUD” (“Unknown Update Detected”). This is because the “/config” partition is not protected by “measured boot”, it is mutable, and it is not encrypted in any way. An attacker can gain full control over the device without changing the PCR values, thus not triggering the “measured boot” mechanism, and having full access to the vault. Note: This issue was partially fixed in these commits (after disclosure to Zededa), where the config partition measurement was added to PCR13: • aa3501d6c57206ced222c33aea15a9169d629141 • 5fef4d92e75838cc78010edaed5247dfbdae1889. This issue was made viable in version 9.0.0 when the calculation was moved to PCR14 but it was not included in the measured boot.",
        "technologies": "Linux Foundation\nedge virtualization engine 8.6.0 未満\nedge virtualization engine 9.0.0 以上 9.5.0 未満"
    },
    "JVNDB-2023-012879": {
        "title": "Linux Foundation の edge virtualization engine における暗号アルゴリズムの使用に関する脆弱性",
        "description": "Vault Key Sealed With SHA1 PCRs The measured boot solution implemented in EVE OS leans on a PCR locking mechanism. Different parts of the system update different PCR values in the TPM, resulting in a unique value for each PCR entry. These PCRs are then used in order to seal/unseal a key from the TPM which is used to encrypt/decrypt the “vault” directory. This “vault” directory is the most sensitive point in the system and as such, its content should be protected. This mechanism is noted in Zededa’s documentation as the “measured boot” mechanism, designed to protect said “vault”. The code that’s responsible for generating and fetching the key from the TPM assumes that SHA256 PCRs are used in order to seal/unseal the key, and as such their presence is being checked. The issue here is that the key is not sealed using SHA256 PCRs, but using SHA1 PCRs. This leads to several issues: • Machines that have their SHA256 PCRs enabled but SHA1 PCRs disabled, as well as not sealing their keys at all, meaning the “vault” is not protected from an attacker. • SHA1 is considered insecure and reduces the complexity level required to unseal the key in machines which have their SHA1 PCRs enabled. An attacker can very easily retrieve the contents of the “vault”, which will effectively render the “measured boot” mechanism meaningless.",
        "technologies": "Linux Foundation\nedge virtualization engine 9.5.0 未満"
    },
    "JVNDB-2023-012880": {
        "title": "Linux Foundation の edge virtualization engine における制限またはスロットリング無しのリソースの割り当てに関する脆弱性",
        "description": "As noted in the “VTPM.md” file in the eve documentation, “VTPM is a server listening on port 8877 in EVE, exposing limited functionality of the TPM to the clients. VTPM allows clients to execute tpm2-tools binaries from a list of hardcoded options” The communication with this server is done using protobuf, and the data is comprised of 2 parts: 1. Header 2. Data When a connection is made, the server is waiting for 4 bytes of data, which will be the header, and these 4 bytes would be parsed as uint32 size of the actual data to come. Then, in the function “handleRequest” this size is then used in order to allocate a payload on the stack for the incoming data. As this payload is allocated on the stack, this will allow overflowing the stack size allocated for the relevant process with freely controlled data. * An attacker can crash the system. * An attacker can gain control over the system, specifically on the “vtpm_server” process which has very high privileges.",
        "technologies": "Linux Foundation\nedge virtualization engine 3.0.0 以上 9.5.0 未満"
    },
    "JVNDB-2023-012041": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. When nf_tables_delrule() is flushing table rules, it is not checked whether the chain is bound and the chain's owner rule can also release the objects in certain circumstances. We recommend upgrading past commit 6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nDebian\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 5.9.0 未満\nLinux Kernel 6.0 以上 6.5 未満"
    },
    "JVNDB-2023-013200": {
        "title": "複数のエフ・セキュア製品における脆弱性",
        "description": "Certain WithSecure products allow Denial of Service in the aeelf component. This affects WithSecure Client Security 15, WithSecure Server Security 15, WithSecure Email and Server Security 15, WithSecure Elements Endpoint Protection 17 and later, WithSecure Client Security for Mac 15, WithSecure Elements Endpoint Protection for Mac 17 and later, Linux Security 64 12.0 , Linux Protection 12.0, and WithSecure Atlant (formerly F-Secure Atlant) 1.0.35-1.",
        "technologies": "エフ・セキュア\nclient security 15.00\nclient security 15.00\nF-Secure Atlant 1.0.35-1\nF-Secure E-mail and Server Security 15.00\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Linux Seculity 64 12.0\nF-Secure Server Security 15.00\nlinux protection 12.0"
    },
    "JVNDB-2023-013218": {
        "title": "複数のエフ・セキュア製品における脆弱性",
        "description": "Certain WithSecure products allow Denial of Service via the aepack archive unpack handler. This affects WithSecure Client Security 15, WithSecure Server Security 15, WithSecure Email and Server Security 15, WithSecure Elements Endpoint Protection 17 and later, WithSecure Client Security for Mac 15, WithSecure Elements Endpoint Protection for Mac 17 and later, Linux Security 64 12.0 , Linux Protection 12.0, and WithSecure Atlant (formerly F-Secure Atlant) 1.0.35-1.",
        "technologies": "エフ・セキュア\nclient security 15.00\nclient security 15.00\nF-Secure Atlant 1.0.35-1\nF-Secure E-mail and Server Security 15.00\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Linux Seculity 64 12.0\nF-Secure Server Security 15.00\nlinux protection 12.0"
    },
    "JVNDB-2023-013217": {
        "title": "複数のエフ・セキュア製品における脆弱性",
        "description": "Certain WithSecure products allow Local privilege escalation via the lhz archive unpack handler. This affects WithSecure Client Security 15, WithSecure Server Security 15, WithSecure Email and Server Security 15, WithSecure Elements Endpoint Protection 17 and later, WithSecure Client Security for Mac 15, WithSecure Elements Endpoint Protection for Mac 17 and later, Linux Security 64 12.0 , Linux Protection 12.0, and WithSecure Atlant (formerly F-Secure Atlant) 1.0.35-1.",
        "technologies": "エフ・セキュア\nclient security 15.00\nclient security 15.00\nF-Secure Atlant 1.0.35-1\nF-Secure E-mail and Server Security 15.00\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Linux Seculity 64 12.0\nF-Secure Server Security 15.00\nlinux protection 12.0"
    },
    "JVNDB-2023-013491": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "An issue was discovered in net/ceph/messenger_v2.c in the Linux kernel before 6.4.5. There is an integer signedness error, leading to a buffer overflow and remote code execution via HELLO or one of the AUTH frames. This occurs because of an untrusted length taken from a TCP packet in ceph_decode_32.",
        "technologies": "Linux\nLinux Kernel 6.4.5 未満"
    },
    "JVNDB-2023-013374": {
        "title": "Linux の Linux Kernel における計算の誤りに関する脆弱性",
        "description": "Incorrect verifier pruning in BPF in Linux Kernel >=5.4 leads to unsafe code paths being incorrectly marked as safe, resulting in arbitrary read/write in kernel memory, lateral privilege escalation, and container escape.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.242 未満\nLinux Kernel 5.5 以上 5.10.179 未満\nLinux Kernel 5.11 以上 5.15.109 未満\nLinux Kernel 5.16 以上 6.1.26 未満\nLinux Kernel 6.2 以上 6.2.13 未満"
    },
    "JVNDB-2023-014105": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における脆弱性",
        "description": "An improper input validation flaw was found in the eBPF subsystem in the Linux kernel. The issue occurs due to a lack of proper validation of dynamic pointers within user-supplied eBPF programs prior to executing them. This may allow an attacker with CAP_BPF privileges to escalate privileges and execute arbitrary code in the context of the kernel.",
        "technologies": "Fedora Project\nFedora 38\nLinux\nLinux Kernel 6.3 未満\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-013709": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における到達可能なアサーションに関する脆弱性",
        "description": "In wlan firmware, there is a possible firmware assertion due to improper input handling. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07932637; Issue ID: ALPS07932637.",
        "technologies": "Google\nAndroid 11.0\nAndroid 12.0\nAndroid 13.0\nLinux\nLinux Kernel 4.19\nLinux Foundation\nYocto 3.1\nYocto 3.3\nメディアテック\niot yocto 23.0"
    },
    "JVNDB-2023-013431": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An array indexing vulnerability was found in the netfilter subsystem of the Linux kernel. A missing macro could lead to a miscalculation of the `h->nets` array offset, providing attackers with the primitive to arbitrarily increment/decrement a memory buffer out-of-bound. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 6.6 未満\nレッドハット\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-013707": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's fs/smb/client component can be exploited to achieve local privilege escalation. In case of an error in smb3_fs_context_parse_param, ctx->password was freed but the field was not set to NULL which could lead to double free. We recommend upgrading past commit e6e43b8aa7cd3c3af686caf0c2e11819a886d705.",
        "technologies": "Fedora Project\nFedora 37\nFedora 38\nFedora 39\nLinux\nLinux Kernel 6.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-013313": {
        "title": "Zoom Video Communications, Inc. の Linux 用 Zoom Client における入力確認に関する脆弱性",
        "description": "Improper input validation in Zoom Desktop Client for Linux before version 5.15.10 may allow an unauthenticated user to conduct a denial of service via network access.",
        "technologies": "Zoom Video Communications, Inc.\nZoom Client 5.15.10 未満"
    },
    "JVNDB-2023-017542": {
        "title": "インテルの Linux 用 Intel QuickAssist Technology における脆弱性",
        "description": "Improper input validation in firmware for Intel(R) QAT before version QAT20.L.1.0.40-00004 may allow escalation of privilege and denial of service via adjacent access.",
        "technologies": "インテル\nIntel QuickAssist Technology 1.0.40-00004 未満"
    },
    "JVNDB-2023-017833": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. The function nft_trans_gc_catchall did not remove the catchall set element from the catchall_list when the argument sync is true, making it possible to free a catchall set element many times. We recommend upgrading past commit 93995bf4af2c5a99e2a87f0cd5ce547d31eb7630.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.7 未満"
    },
    "JVNDB-2023-020882": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. Flaw in the error handling of bound chains causes a use-after-free in the abort path of NFT_MSG_NEWRULE. The vulnerability requires CAP_NET_ADMIN to be triggered. We recommend upgrading past commit 4bedf9eee016286c835e3d8fa981ddece5338795.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 5.9 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.15.119 未満\nLinux Kernel 5.16 以上 6.1.36 未満\nLinux Kernel 6.2 以上 6.3.10 未満"
    },
    "JVNDB-2023-018409": {
        "title": "複数のエフ・セキュア製品における脆弱性",
        "description": "Certain WithSecure products allow a Denial of Service because there is an unpack handler crash that can lead to a scanning engine crash. This affects WithSecure Client Security 15, WithSecure Server Security 15, WithSecure Email and Server Security 15, WithSecure Elements Endpoint Protection 17 and later, WithSecure Client Security for Mac 15, WithSecure Elements Endpoint Protection for Mac 17 and later, WithSecure Linux Security 64 12.0, WithSecure Linux Protection 12.0, and WithSecure Atlant 1.0.35-1.",
        "technologies": "エフ・セキュア\nclient security 15.00\nclient security 15.00\nF-Secure Atlant 1.0.35-1\nF-Secure E-mail and Server Security 15.00\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Elements Endpoint Protection 17.0 以上\nF-Secure Linux Seculity 64 12.0\nF-Secure Server Security 15.00\nlinux protection 12.0"
    },
    "JVNDB-2023-019226": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-020373": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. The function nft_pipapo_walk did not skip inactive elements during set walk which could lead double deactivations of PIPAPO (Pile Packet Policies) elements, leading to use-after-free. We recommend upgrading past commit 317eb9685095678f2c9f5a8189de698c5354316a.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.204 未満\nLinux Kernel 5.11 以上 5.15.143 未満\nLinux Kernel 5.16 以上 6.1.68 未満\nLinux Kernel 6.2 以上 6.6.7 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2023-014356": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "In wlan firmware, there is possible system crash due to an uncaught exception. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07664711; Issue ID: ALPS07664711.",
        "technologies": "Google\nAndroid 11.0\nAndroid 12.0\nLinux Foundation\nYocto 4.0"
    },
    "JVNDB-2023-014358": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "In wlan firmware, there is possible system crash due to an integer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07664731; Issue ID: ALPS07664731.",
        "technologies": "Google\nAndroid 11.0\nAndroid 12.0\nLinux Foundation\nYocto 4.0"
    },
    "JVNDB-2023-014357": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における例外的な状態の処理に関する脆弱性",
        "description": "In wlan firmware, there is possible system crash due to an uncaught exception. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07664720; Issue ID: ALPS07664720.",
        "technologies": "Google\nAndroid 11.0\nLinux Foundation\nYocto 4.0"
    },
    "JVNDB-2023-018527": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A null pointer dereference flaw was found in the nft_inner.c functionality of netfilter in the Linux kernel. This issue could allow a local user to crash the system or escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora 39\nLinux\nLinux Kernel 6.2.1 から 6.5.10\nLinux Kernel 6.2\nLinux Kernel 6.2.0\nLinux Kernel 6.6"
    },
    "JVNDB-2023-020400": {
        "title": "Linux Foundation の dapr における認証に関する脆弱性",
        "description": "Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge. A vulnerability has been found in Dapr that allows bypassing API token authentication, which is used by the Dapr sidecar to authenticate calls coming from the application, with a well-crafted HTTP request. Users who leverage API token authentication are encouraged to upgrade Dapr to 1.10.9 or to 1.11.2. This vulnerability impacts Dapr users who have configured API token authentication. An attacker could craft a request that is always allowed by the Dapr sidecar over HTTP, even if the `dapr-api-token` in the request is invalid or missing. The issue has been fixed in Dapr 1.10.9 or to 1.11.2. There are no known workarounds for this vulnerability.",
        "technologies": "Linux Foundation\ndapr 1.10.9 未満\ndapr 1.11.0 以上 1.11.2 未満"
    },
    "JVNDB-2023-020880": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds write vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation. The qfq_change_agg() function in net/sched/sch_qfq.c allows an out-of-bounds write because lmax is updated according to packet sizes without bounds checks. We recommend upgrading past commit 3e337087c3b5805fe0b8a46ba622a962880b5d64.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 3.8 以上 6.5 未満\nLinux Kernel 6.5"
    },
    "JVNDB-2023-020870": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation. If tcf_change_indev() fails, fw_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability. We recommend upgrading past commit 0323bce598eea038714f941ce2b22541c46d488f.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 2.6 以上 6.5 未満\nLinux Kernel 6.5"
    },
    "JVNDB-2023-020540": {
        "title": "レッドハットの Red Hat Enterprise Linux EUS 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "A flaw was found in xorg-server. Querying or changing XKB button actions such as moving from a touchpad to a mouse can result in out-of-bounds memory reads and writes. This may allow local privilege escalation or possible remote code execution in cases where X11 forwarding is involved.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nTigerVNC\nTigerVNC\nX.Org Foundation\nX.Org X Server 21.1.10 未満\nxwayland 23.2.3 未満\nレッドハット\nRed Hat Enterprise Linux EUS 9.2"
    },
    "JVNDB-2023-019227": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds read vulnerability was found in smbCalcSize in fs/smb/client/netmisc.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-020930": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the handling of SMB2_TREE_CONNECT and SMB2_QUERY_INFO commands. The issue results from the lack of proper validation of a pointer prior to accessing it. An attacker can leverage this vulnerability to create a denial-of-service condition on the system.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.111 未満\nLinux Kernel 5.16 以上 6.1.28 未満\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-020929": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the handling of SMB2_LOGOFF commands. The issue results from the lack of proper validation of a pointer prior to accessing it. An attacker can leverage this vulnerability to create a denial-of-service condition on the system.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.29 未満\nLinux Kernel 6.2 以上 6.2.16 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-020978": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における観測可能な不一致に関する脆弱性",
        "description": "A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory, where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-020942": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品におけるリソースのロックに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the processing of SMB2_SESSION_SETUP and SMB2_LOGOFF commands. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this vulnerability to execute code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.29 未満\nLinux Kernel 6.2 以上 6.2.16 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nNetApp SolidFire & HCI Storage Node\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-020931": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the handling of SMB2_SESSION_SETUP commands. The issue results from the lack of control of resource consumption. An attacker can leverage this vulnerability to create a denial-of-service condition on the system.",
        "technologies": "Linux\nLinux Kernel 5.15 から 6.1.29\nLinux Kernel 6.2 以上 6.2.16 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-020975": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品におけるリソースのロックに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the processing of SMB2_LOGOFF and SMB2_CLOSE commands. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this vulnerability to execute code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.29 未満\nLinux Kernel 6.2 以上 6.2.16 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-020928": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel's netfilter in the way a user triggers the nft_pipapo_remove function with the element, without a NFT_SET_EXT_KEY_END. This issue could allow a local user to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nFedora Project\nFedora 38\nLinux\nLinux Kernel 5.6 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.15.123 未満\nLinux Kernel 5.16 以上 6.1.42 未満\nLinux Kernel 6.2 以上 6.4.7 未満\nNetApp\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-022317": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nDebian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 6.4.10 未満"
    },
    "JVNDB-2023-022324": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "A flaw was found in btrfs_get_root_ref in fs/btrfs/disk-io.c in the btrfs filesystem in the Linux Kernel due to a double decrement of the reference count. This issue may allow a local attacker with user privilege to crash the system or may lead to leaked internal kernel information.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.112 未満\nLinux Kernel 5.11 以上 5.15.35 未満\nLinux Kernel 5.16 以上 5.17.4 未満"
    },
    "JVNDB-2023-020897": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation. If tcf_change_indev() fails, u32_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability. We recommend upgrading past commit 04c55383fa5689357bcdd2c8036725a55ed632bc.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 4.14 以上 6.4 未満\nLinux Kernel 6.4"
    },
    "JVNDB-2023-022325": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in vmxnet3_rq_alloc_rx_buf in drivers/net/vmxnet3/vmxnet3_drv.c in VMware's vmxnet3 ethernet NIC driver in the Linux Kernel. This issue could allow a local attacker to crash the system due to a double-free while cleaning up vmxnet3_rq_cleanup_all, which could also lead to a kernel information leak problem.",
        "technologies": "Linux\nLinux Kernel 3.16.60 以上 3.17 未満\nLinux Kernel 4.4 以上 4.9.316 未満\nLinux Kernel 4.10 以上 4.14.281 未満\nLinux Kernel 4.15 以上 4.19.245 未満\nLinux Kernel 4.20 以上 5.4.196 未満\nLinux Kernel 5.5 以上 5.10.118 未満\nLinux Kernel 5.11 以上 5.15.42 未満\nLinux Kernel 5.16 以上 5.17.10 未満\nレッドハット\nRed Hat Enterprise Linux 6.0\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-020983": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "An out-of-bounds memory access flaw was found in the Linux kernel’s TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 4.19.265 未満\nLinux Kernel 4.20 以上 5.4.224 未満\nLinux Kernel 5.5 以上 5.10.154 未満\nLinux Kernel 5.11 以上 5.15.78 未満\nLinux Kernel 5.16 以上 6.0.8 未満\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-022054": {
        "title": "インテルの ethernet controller rdma driver for linux における脆弱性",
        "description": "Improper access control in the Intel(R) Ethernet Controller RDMA driver for linux before version 1.9.30 may allow an unauthenticated user to potentially enable escalation of privilege via network access.",
        "technologies": "インテル\nethernet controller rdma driver for linux 1.9.30 未満"
    },
    "JVNDB-2023-021249": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nLinux\nLinux Kernel 6.2.0 未満\nLinux Kernel 6.2.0\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-022438": {
        "title": "escanav の Linux 用 escan anti-virus における重要なリソースに対する不適切なパーミッションの割り当てに関する脆弱性",
        "description": "A vulnerability, which was classified as critical, was found in MicroWorld eScan Anti-Virus 7.0.32 on Linux. This affects an unknown part of the file runasroot. The manipulation leads to incorrect execution-assigned permissions. The attack needs to be approached locally. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-237315. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
        "technologies": "escanav\nescan anti-virus 7.0.32"
    },
    "JVNDB-2023-022478": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "A flaw was found in the fixed buffer registration code for io_uring (io_sqe_buffer_register in io_uring/rsrc.c) in the Linux kernel that allows out-of-bounds access to physical memory beyond the end of the buffer. This flaw enables full local privilege escalation.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2023-022402": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux kernel’s Netfilter functionality when adding a rule with NFTA_RULE_CHAIN_ID. This flaw allows a local user to crash or escalate their privileges on the system.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nFedora Project\nFedora 38\nLinux\nLinux Kernel 6.5 未満\nLinux Kernel 6.5\nレッドハット\nRed Hat Enterprise Linux 9.0\nRed Hat Enterprise Linux EUS 9.2\nRed Hat Enterprise Linux for Real Time 9.0\nRed Hat Enterprise Linux for Real Time for NFV 9.0\nRed Hat Enterprise Linux Server AUS 9.2"
    },
    "JVNDB-2023-022766": {
        "title": "Linux Foundation の argocd におけるセッション期限に関する脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All versions of Argo CD starting from version 2.6.0 have a bug where open web terminal sessions do not expire. This bug allows users to send any websocket messages even if the token has already expired. The most straightforward scenario is when a user opens the terminal view and leaves it open for an extended period. This allows the user to view sensitive information even when they should have been logged out already. A patch for this vulnerability has been released in the following Argo CD versions: 2.6.14, 2.7.12 and 2.8.1.",
        "technologies": "Linux Foundation\nargocd 2.6.0 から 2.6.13\nargocd 2.7.11\nargocd 2.8.0"
    },
    "JVNDB-2023-022518": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use after free vulnerability was found in prepare_to_relocate in fs/btrfs/relocation.c in btrfs in the Linux Kernel. This possible flaw can be triggered by calling btrfs_ioctl_balance() before calling btrfs_ioctl_defrag().",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 2.6.31 以上 4.14.318 未満\nLinux Kernel 4.15 以上 4.19.286 未満\nLinux Kernel 4.20 以上 5.4.247 未満\nLinux Kernel 5.5 以上 5.10.184 未満\nLinux Kernel 5.11 以上 5.15.63 未満\nLinux Kernel 5.16 以上 5.19.4 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023088": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in rkvdec_remove in drivers/staging/media/rkvdec/rkvdec.c.",
        "technologies": "Linux\nLinux Kernel 6.3.2 未満"
    },
    "JVNDB-2023-022785": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in r592_remove in drivers/memstick/host/r592.c in media access in the Linux Kernel. This flaw allows a local attacker to crash the system at device disconnect, possibly leading to a kernel information leak.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.39 以上 4.14.316 未満\nLinux Kernel 4.15 以上 4.19.284 未満\nLinux Kernel 4.20 以上 5.4.244 未満\nLinux Kernel 5.5 以上 5.10.181 未満\nLinux Kernel 5.11 以上 5.15.113 未満\nLinux Kernel 5.16 以上 6.1.30 未満\nLinux Kernel 6.2 以上 6.3.4 未満\nNetApp\nNetApp HCI Baseboard Management Controller h300s\nNetApp HCI Baseboard Management Controller h410c\nNetApp HCI Baseboard Management Controller h410s\nNetApp HCI Baseboard Management Controller h500s\nNetApp HCI Baseboard Management Controller h700s"
    },
    "JVNDB-2023-023114": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An issue was discovered in fl_set_geneve_opt in net/sched/cls_flower.c in the Linux kernel before 6.3.7. It allows an out-of-bounds write in the flower classifier code via TCA_FLOWER_KEY_ENC_OPTS_GENEVE packets. This may result in denial of service or privilege escalation.",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nDebian\nDebian GNU/Linux 12.0\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 6.3.7 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023133": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in dm1105_remove in drivers/media/pci/dm1105/dm1105.c.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 6.3.2 未満"
    },
    "JVNDB-2023-023134": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 6.3.2 未満"
    },
    "JVNDB-2023-023102": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.",
        "technologies": "Linux\nLinux Kernel 6.3.8 未満"
    },
    "JVNDB-2023-023096": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in renesas_usb3_remove in drivers/usb/gadget/udc/renesas_usb3.c.",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.283 未満\nLinux Kernel 4.20 以上 5.4.243 未満\nLinux Kernel 5.5 以上 5.10.180 未満\nLinux Kernel 5.11 以上 5.15.111 未満\nLinux Kernel 5.16 以上 6.1.28 未満\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023113": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in cedrus_remove in drivers/staging/media/sunxi/cedrus/cedrus.c.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.28 未満\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023366": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "A vulnerability was found in drivers/cpufreq/qcom-cpufreq-hw.c in cpufreq subsystem in the Linux Kernel. This flaw, during device unbind will lead to double release problem leading to denial of service.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3 以上 6.3.2 未満"
    },
    "JVNDB-2023-023241": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A vulnerability exists in the memory management subsystem of the Linux kernel. The lock handling for accessing and updating virtual memory areas (VMAs) is incorrect, leading to use-after-free problems. This issue can be successfully exploited to execute arbitrary kernel code, escalate containers, and gain root privileges.",
        "technologies": "Fedora Project\nFedora 37\nFedora 38\nLinux\nLinux Kernel 6.1 以上 6.1.37 未満\nLinux Kernel 6.2 以上 6.3.11 未満\nLinux Kernel 6.4\nレッドハット\nRed Hat Enterprise Linux 6.0\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-023406": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.8. fs/smb/server/connection.c in ksmbd does not validate the relationship between the NetBIOS header's length field and the SMB header sizes, via pdu_size in ksmbd_conn_handler_loop, leading to an out-of-bounds read.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.34 未満\nLinux Kernel 6.2 以上 6.3.8 未満\nNetApp\nNetApp SolidFire & HCI Management Node\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023140": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An out of bounds (OOB) memory access flaw was found in the Linux kernel in relay_file_read_start_pos in kernel/relay.c in the relayfs. This flaw could allow a local attacker to crash the system or leak kernel internal information.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 6.4 未満"
    },
    "JVNDB-2023-023412": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.8. fs/smb/server/smb2pdu.c in ksmbd has an integer underflow and out-of-bounds read in deassemble_neg_contexts.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.34 未満\nLinux Kernel 6.2 以上 6.3.8 未満\nNetApp\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023741": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.4. ksmbd has an out-of-bounds read in smb2_find_context_vals when create_context's name_len is larger than the tag length.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.113 未満\nLinux Kernel 5.16 以上 6.1.30 未満\nLinux Kernel 6.2 以上 6.3.4 未満\nNetApp\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire & HCI Storage Node\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023407": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.9. ksmbd does not validate the SMB request protocol ID, leading to an out-of-bounds read.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.35 未満\nLinux Kernel 6.2 以上 6.3.9 未満\nNetApp\nNetApp HCI Management Node\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023411": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.4. fs/ksmbd/smb2pdu.c in ksmbd does not properly check the UserName value because it does not consider the address of security buffer, leading to an out-of-bounds read.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.113 未満\nLinux Kernel 5.16 以上 6.1.30 未満\nLinux Kernel 6.2 以上 6.3.4 未満\nNetApp\nNetApp SolidFire & HCI Management Node\nNetApp SolidFire & HCI Storage Node\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-023895": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A NULL pointer dereference vulnerability was found in netlink_dump. This issue can occur when the Netlink socket receives the message(sendmsg) for the XFRM_MSG_GETSA, XFRM_MSG_GETPOLICY type message, and the DUMP flag is set and can cause a denial of service or possibly another unspecified impact. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is unlikely.",
        "technologies": "Fedora Project\nFedora 38\nLinux\nLinux Kernel 4.8 未満\nLinux Kernel 4.8"
    },
    "JVNDB-2023-023409": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.3.4. fs/ksmbd/connection.c in ksmbd has an off-by-one error in memory allocation (because of ksmbd_smb2_check_message) that may lead to out-of-bounds access.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.113 未満\nLinux Kernel 5.16 以上 6.1.30 未満\nLinux Kernel 6.2 以上 6.3.4 未満"
    },
    "JVNDB-2023-024740": {
        "title": "Linux Foundation の cubefs における脆弱性",
        "description": "CubeFS is an open-source cloud-native file storage system. A vulnerability was found in CubeFS prior to version 3.3.1 that could allow users to read sensitive data from the logs which could allow them escalate privileges. CubeFS leaks configuration keys in plaintext format in the logs. These keys could allow anyone to carry out operations on blobs that they otherwise do not have permissions for. For example, an attacker that has succesfully retrieved a secret key from the logs can delete blogs from the blob store. The attacker can either be an internal user with limited privileges to read the log, or they can be an external user who has escalated privileges sufficiently to access the logs. The vulnerability has been patched in v3.3.1. There is no other mitigation than upgrading.",
        "technologies": "Linux Foundation\ncubefs 3.3.1 未満"
    },
    "JVNDB-2023-024063": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in mt7921_check_offload_capability in drivers/net/wireless/mediatek/mt76/mt7921/init.c in wifi mt76/mt7921 sub-component in the Linux Kernel. This flaw could allow an attacker to crash the system after 'features' memory release. This vulnerability could even lead to a kernel information leak problem.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3"
    },
    "JVNDB-2023-024074": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability was found in the Linux kernel's netfilter subsystem in net/netfilter/nf_tables_api.c. Mishandled error handling with NFT_MSG_NEWRULE makes it possible to use a dangling pointer in the same transaction causing a use-after-free vulnerability. This flaw allows a local attacker with user access to cause a privilege escalation issue. We recommend upgrading past commit 1240eb93f0616b21c675416516ff3d74798fdc97.",
        "technologies": "Linux\nLinux Kernel 3.16 以上 6.4 未満"
    },
    "JVNDB-2023-024741": {
        "title": "Linux Foundation の cubefs における不十分なランダム値の使用に関する脆弱性",
        "description": "CubeFS is an open-source cloud-native file storage system. Prior to version 3.3.1, CubeFS used an insecure random string generator to generate user-specific, sensitive keys used to authenticate users in a CubeFS deployment. This could allow an attacker to predict and/or guess the generated string and impersonate a user thereby obtaining higher privileges. When CubeFS creates new users, it creates a piece of sensitive information for the user called the “accessKey”. To create the \"accesKey\", CubeFS uses an insecure string generator which makes it easy to guess and thereby impersonate the created user. An attacker could leverage the predictable random string generator and guess a users access key and impersonate the user to obtain higher privileges. The issue has been fixed in v3.3.1. There is no other mitigation than to upgrade.",
        "technologies": "Linux Foundation\ncubefs 3.3.1 未満"
    },
    "JVNDB-2023-024467": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the processing of SMB2_SESSION_SETUP commands. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this vulnerability to execute code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.29 未満\nLinux Kernel 6.2 以上 6.2.16 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nhci storage nodes\nNetApp HCI\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-024061": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system.",
        "technologies": "Fedora Project\nFedora 39\nLinux\nLinux Kernel 6.5 未満\nLinux Kernel 6.5\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-024465": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "Linux Kernel nftables Out-Of-Bounds Read/Write Vulnerability; nft_byteorder poorly handled vm register contents when CAP_NET_ADMIN is in any user or network namespace",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nFedora Project\nFedora 37\nFedora 38\nLinux\nLinux Kernel 3.13 以上 4.14.322 未満\nLinux Kernel 4.15 から 4.19.291\nLinux Kernel 4.20 以上 5.4.251 未満\nLinux Kernel 5.5 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.15.121 未満\nLinux Kernel 5.16 以上 6.1.39 未満\nLinux Kernel 6.2 以上 6.4.4 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-024461": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における競合状態に関する脆弱性",
        "description": "A flaw was found in the Linux kernel's ksmbd, a high-performance in-kernel SMB server. The specific flaw exists within the processing of SMB2_TREE_DISCONNECT commands. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this vulnerability to execute code in the context of the kernel.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.28 未満\nLinux Kernel 6.2 以上 6.2.15 未満\nLinux Kernel 6.3 以上 6.3.2 未満\nNetApp\nNetApp HCI Management Node\nH300S ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-024103": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's ipv4: igmp component can be exploited to achieve local privilege escalation. A race condition can be exploited to cause a timer be mistakenly registered on a RCU read locked object which is freed by another thread. We recommend upgrading past commit e2b706c691905fe78468c361aaabc719d0a496f1.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 6.7 未満"
    },
    "JVNDB-2023-024113": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation. A perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group(). We recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.",
        "technologies": "Linux\nLinux Kernel 4.3 以上 6.7 未満"
    },
    "JVNDB-2023-024274": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "A time-of-check to time-of-use issue exists in io_uring subsystem's IORING_OP_CLOSE operation in the Linux kernel's versions 5.6 - 5.11 (inclusive), which allows a local user to elevate their privileges to root. Introduced in b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb, patched in 9eac1904d3364254d622bf2c771c4f85cd435fc2, backported to stable in 788d0824269bef539fe31a785b1517882eafed93.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.162 未満\nLinux Kernel 5.11 以上 5.11.6 未満\nNetApp\nH300S ファームウェア\nH410C ファームウェア\nH410S ファームウェア\nH500S ファームウェア\nH700S ファームウェア"
    },
    "JVNDB-2023-024086": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation. The out-of-bounds write is caused by missing skb->cb initialization in the ipvlan network driver. The vulnerability is reachable if CONFIG_IPVLAN is enabled. We recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nDebian GNU/Linux 12.0\nLinux\nLinux Kernel 3.19 以上 6.4 未満"
    },
    "JVNDB-2023-025190": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.6.8. atalk_ioctl in net/appletalk/ddp.c has a use-after-free because of an atalk_recvmsg race condition.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 より大きい 6.6.8 未満\nLinux Kernel 2.6.12\nLinux Kernel 6.7"
    },
    "JVNDB-2023-024082": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux Kernel io_uring subsystem can be exploited to achieve local privilege escalation. Racing a io_uring cancel poll request with a linked timeout can cause a UAF in a hrtimer. We recommend upgrading past commit ef7dfac51d8ed961b742218f526bd589f3900a59 (4716c73b188566865bdd79c3a6709696a224ac04 for 5.10 stable and 0e388fce7aec40992eadee654193cad345d62663 for 5.15 stable).",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nDebian\nDebian GNU/Linux 10.0\nDebian GNU/Linux 11.0\nLinux\nLinux Kernel 5.10.162 以上 5.10.185 未満\nLinux Kernel 5.13 以上 6.4 未満"
    },
    "JVNDB-2023-025189": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.6.8. rose_ioctl in net/rose/af_rose.c has a use-after-free because of a rose_accept race condition.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 より大きい 6.6.8 未満\nLinux Kernel 2.6.12\nLinux Kernel 6.7"
    },
    "JVNDB-2023-025525": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds access vulnerability involving netfilter was reported and fixed as: f1082dd31fe4 (netfilter: nf_tables: Reject tables of unsupported family); While creating a new netfilter table, lack of a safeguard against invalid nf_tables family (pf) values within `nf_tables_newtable` function enables an attacker to achieve out-of-bounds access.",
        "technologies": "Linux\nLinux Kernel 5.17 およびそれ以前"
    },
    "JVNDB-2023-025625": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux Kernel due to a race problem in the unix garbage collector's deletion of SKB races with unix_stream_read_generic() on the socket that the SKB is queued on.",
        "technologies": "Linux\nLinux Kernel 6.7 未満\nLinux Kernel 6.7\nレッドハット\nRed Hat Enterprise Linux 9.0\n日立\nEP8000 E1050\nEP8000 S1014\nEP8000 S1024"
    },
    "JVNDB-2023-025624": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "An out-of-bounds read vulnerability was found in Netfilter Connection Tracking (conntrack) in the Linux kernel. This flaw allows a remote user to disclose sensitive information via the DCCP protocol.",
        "technologies": "Fedora Project\nFedora 38\nLinux\nLinux Kernel"
    },
    "JVNDB-2023-025193": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "An issue was discovered in the Linux kernel before 6.6.8. do_vcc_ioctl in net/atm/ioctl.c has a use-after-free because of a vcc_recvmsg race condition.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 より大きい 6.6.8 未満\nLinux Kernel 2.6.12\nLinux Kernel 6.7"
    },
    "JVNDB-2023-024911": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "Linux Kernel nftables Use-After-Free Local Privilege Escalation Vulnerability; `nft_chain_lookup_byid()` failed to check whether a chain was active and CAP_NET_ADMIN is in any user or network namespace",
        "technologies": "Canonical\nUbuntu 14.04\nUbuntu 16.04\nUbuntu 18.04\nUbuntu 20.04\nUbuntu 22.04\nDebian\nDebian GNU/Linux 11.0\nFedora Project\nFedora 37\nFedora 38\nLinux\nLinux Kernel 5.9 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.15.121 未満\nLinux Kernel 5.16 以上 6.1.39 未満\nLinux Kernel 6.2 以上 6.4.4 未満"
    },
    "JVNDB-2023-024850": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A flaw was found in the ATA over Ethernet (AoE) driver in the Linux kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on `struct net_device`, and a use-after-free can be triggered by racing between the free on the struct and the access through the `skbtxq` global queue. This could lead to a denial of service condition or potential code execution.",
        "technologies": "Fedora Project\nFedora 39\nLinux\nLinux Kernel"
    },
    "JVNDB-2023-026041": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver and causing kernel panic and a denial of service.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\ncodeready linux builder eus 8.6\ncodeready linux builder eus 9.2\ncodeready linux builder eus for power little endian eus 8.6 ppc64le\ncodeready linux builder eus for power little endian eus 9.2 ppc64le\ncodeready linux builder for arm64 eus 8.6 aarch64\ncodeready linux builder for arm64 eus 9.2 aarch64\ncodeready linux builder for ibm z systems eus 9.2 s390x\nRed Hat Virtualization Host 4.0\nenterprise linux for arm 64 eus 8.6 aarch64\nenterprise linux for arm 64 eus 9.2 aarch64\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0\nRed Hat Enterprise Linux EUS 8.6\nRed Hat Enterprise Linux EUS 9.2\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 8.6 s390x\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 9.2 s390x\nRed Hat Enterprise Linux for Power Little Endian Update Services for SAP Solutions\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 8.6 ppc64le\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 9.2 ppc64le\nRed Hat Enterprise Linux for Real Time 9.2\nRed Hat Enterprise Linux for Real Time for NFV 9.2\nRed Hat Enterprise Linux Server AUS 8.6\nRed Hat Enterprise Linux Server TUS"
    },
    "JVNDB-2023-025722": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "Transmit requests in Xen's virtual network protocol can consist of multiple parts. While not really useful, except for the initial part any of them may be of zero length, i.e. carry no data at all. Besides a certain initial portion of the to be transferred data, these parts are directly translated into what Linux calls SKB fragments. Such converted request parts can, when for a particular SKB they are all of length zero, lead to a de-reference of NULL in core networking code.",
        "technologies": "Linux\nLinux Kernel 4.14 以上 6.7 未満"
    },
    "JVNDB-2023-026040": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\ncodeready linux builder eus 8.6\ncodeready linux builder eus 9.2\ncodeready linux builder eus for power little endian eus 8.6 ppc64le\ncodeready linux builder eus for power little endian eus 9.2 ppc64le\ncodeready linux builder for arm64 eus 8.6 aarch64\ncodeready linux builder for arm64 eus 9.2 aarch64\ncodeready linux builder for ibm z systems eus 9.2 s390x\nRed Hat Virtualization Host 4.0\nenterprise linux for arm 64 eus 8.6 aarch64\nenterprise linux for arm 64 eus 9.2 aarch64\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0\nRed Hat Enterprise Linux EUS 8.6\nRed Hat Enterprise Linux EUS 9.2\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 8.6 s390x\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 9.2 s390x\nRed Hat Enterprise Linux for Power Little Endian Update Services for SAP Solutions\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 8.6 ppc64le\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 9.2 ppc64le\nRed Hat Enterprise Linux for Real Time 9.2\nRed Hat Enterprise Linux for Real Time for NFV 9.2\nRed Hat Enterprise Linux Server AUS 8.6\nRed Hat Enterprise Linux Server TUS"
    },
    "JVNDB-2023-025682": {
        "title": "レッドハットの shim および Red Hat Enterprise Linux における境界外書き込みに関する脆弱性",
        "description": "A remote code execution vulnerability was found in Shim. The Shim boot support trusts attacker-controlled values when parsing an HTTP response. This flaw allows an attacker to craft a specific malicious HTTP request, leading to a completely controlled out-of-bounds write primitive and complete system compromise. This flaw is only exploitable during the early boot phase, an attacker needs to perform a Man-in-the-Middle or compromise the boot server to be able to exploit this vulnerability successfully.",
        "technologies": "レッドハット\nshim 15.8 未満\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0\n日立\nHRL3\nHWMC"
    },
    "JVNDB-2023-025783": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "A race condition was found in the Linux Kernel. Under certain conditions, an unauthenticated attacker from an adjacent network could send an ICMPv6 router advertisement packet, causing arbitrary code execution.",
        "technologies": "Linux\nLinux Kernel 6.7 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2023-025741": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel before 6.4.12, amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c has a fence use-after-free.",
        "technologies": "Linux\nLinux Kernel 6.4.12 未満"
    },
    "JVNDB-2023-026039": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\ncodeready linux builder eus 8.6\ncodeready linux builder eus 9.2\ncodeready linux builder eus for power little endian eus 8.6 ppc64le\ncodeready linux builder eus for power little endian eus 9.2 ppc64le\ncodeready linux builder for arm64 eus 8.6 aarch64\ncodeready linux builder for arm64 eus 9.2 aarch64\ncodeready linux builder for ibm z systems eus 9.2 s390x\nRed Hat Virtualization Host 4.0\nenterprise linux for arm 64 eus 8.6 aarch64\nenterprise linux for arm 64 eus 9.2 aarch64\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0\nRed Hat Enterprise Linux EUS 8.6\nRed Hat Enterprise Linux EUS 9.2\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 8.6 s390x\nRed Hat Enterprise Linux for IBM z Systems - Extended Update Support 9.2 s390x\nRed Hat Enterprise Linux for Power Little Endian Update Services for SAP Solutions\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 8.6 ppc64le\nRed Hat Enterprise Linux for Power, little endian - Extended Update Support 9.2 ppc64le\nRed Hat Enterprise Linux for Real Time 9.2\nRed Hat Enterprise Linux for Real Time for NFV 9.2\nRed Hat Enterprise Linux Server AUS 8.6\nRed Hat Enterprise Linux Server TUS"
    },
    "JVNDB-2023-025740": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel before 6.4.5, drivers/gpu/drm/drm_atomic.c has a use-after-free during a race condition between a nonblocking atomic commit and a driver unload.",
        "technologies": "Linux\nLinux Kernel 6.4.5 未満"
    },
    "JVNDB-2023-026053": {
        "title": "レッドハットの Red Hat Enterprise Linux 等複数ベンダの製品における観測可能な不一致に関する脆弱性",
        "description": "A flaw was found in m2crypto. This issue may allow a remote attacker to decrypt captured messages in TLS servers that use RSA key exchanges, which may lead to exposure of confidential or sensitive data.",
        "technologies": "m2crypto project\nm2crypto\nレッドハット\nRed Hat Update Infrastructure 4\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2023-026066": {
        "title": "レッドハットの Red Hat Enterprise Linux 等複数ベンダの製品における制限またはスロットリング無しのリソースの割り当てに関する脆弱性",
        "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
        "technologies": "CZ.NIC\nKnot Resolver 5.71 未満\nFedora Project\nFedora 39\nISC, Inc.\nBIND 9.0.0 から 9.16.46\nBIND 9.18.0 から 9.18.22\nBIND 9.19.0 から 9.19.20\nNLnet Labs\nunbound 1.19.1 未満\nPowerDNS\nPowerDNS Recursor 4.8.0 以上 4.8.6 未満\nPowerDNS Recursor 4.9.0 以上 4.9.3 未満\nPowerDNS Recursor 5.0.0 以上 5.0.2 未満\nthekelleys\nDnsmasq 2.90 未満\nマイクロソフト\nMicrosoft Windows Server 2008 r2\nMicrosoft Windows Server 2012\nMicrosoft Windows Server 2012 r2\nMicrosoft Windows Server 2016\nMicrosoft Windows Server 2019\nMicrosoft Windows Server 2022\nwindows server 2022 23h2\nレッドハット\nRed Hat Enterprise Linux 6.0\nRed Hat Enterprise Linux 7.0\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0\n日本電気\nESMPRO/ServerAgent\nNEC Multimedia OLAP for 映像分析サービス"
    },
    "JVNDB-2023-027628": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix uaf in jfs_evict_inode When the execution of diMount(ipimap) fails, the object ipimap that has been released may be accessed in diFreeSpecial(). Asynchronous ipimap release occurs when rcu_core() calls jfs_free_node(). Therefore, when diMount(ipimap) fails, sbi->ipimap should not be initialized as ipimap.",
        "technologies": "Linux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-027627": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: UBSAN: array-index-out-of-bounds in dtSplitRoot Syzkaller reported the following issue: oop0: detected capacity change from 0 to 32768 UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dtree.c:1971:9 index -2 is out of range for type 'struct dtslot [128]' CPU: 0 PID: 3613 Comm: syz-executor270 Not tainted 6.0.0-syzkaller-09423-g493ffd6605b2 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106 ubsan_epilogue lib/ubsan.c:151 [inline] __ubsan_handle_out_of_bounds+0xdb/0x130 lib/ubsan.c:283 dtSplitRoot+0x8d8/0x1900 fs/jfs/jfs_dtree.c:1971 dtSplitUp fs/jfs/jfs_dtree.c:985 [inline] dtInsert+0x1189/0x6b80 fs/jfs/jfs_dtree.c:863 jfs_mkdir+0x757/0xb00 fs/jfs/namei.c:270 vfs_mkdir+0x3b3/0x590 fs/namei.c:4013 do_mkdirat+0x279/0x550 fs/namei.c:4038 __do_sys_mkdirat fs/namei.c:4053 [inline] __se_sys_mkdirat fs/namei.c:4051 [inline] __x64_sys_mkdirat+0x85/0x90 fs/namei.c:4051 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fcdc0113fd9 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffeb8bc67d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000102 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fcdc0113fd9 RDX: 0000000000000000 RSI: 0000000020000340 RDI: 0000000000000003 RBP: 00007fcdc00d37a0 R08: 0000000000000000 R09: 00007fcdc00d37a0 R10: 00005555559a72c0 R11: 0000000000000246 R12: 00000000f8008000 R13: 0000000000000000 R14: 00083878000000f8 R15: 0000000000000000 </TASK> The issue is caused when the value of fsi becomes less than -1. The check to break the loop when fsi value becomes -1 is present but syzbot was able to produce value less than -1 which cause the error. This patch simply add the change for the values less than 0. The patch is tested via syzbot.",
        "technologies": "Linux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-026085": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Defer the free of inner map when necessary When updating or deleting an inner map in map array or map htab, the map may still be accessed by non-sleepable program or sleepable program. However bpf_map_fd_put_ptr() decreases the ref-counter of the inner map directly through bpf_map_put(), if the ref-counter is the last one (which is true for most cases), the inner map will be freed by ops->map_free() in a kworker. But for now, most .map_free() callbacks don't use synchronize_rcu() or its variants to wait for the elapse of a RCU grace period, so after the invocation of ops->map_free completes, the bpf program which is accessing the inner map may incur use-after-free problem. Fix the free of inner map by invoking bpf_map_free_deferred() after both one RCU grace period and one tasks trace RCU grace period if the inner map has been removed from the outer map before. The deferment is accomplished by using call_rcu() or call_rcu_tasks_trace() when releasing the last ref-counter of bpf map. The newly-added rcu_head field in bpf_map shares the same storage space with work field to reduce the size of bpf_map.",
        "technologies": "Linux\nLinux Kernel 5.9.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-027626": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: PM / devfreq: Fix buffer overflow in trans_stat_show Fix buffer overflow in trans_stat_show(). Convert simple snprintf to the more secure scnprintf with size of PAGE_SIZE. Add condition checking if we are exceeding PAGE_SIZE and exit early from loop. Also add at the end a warning that we exceeded PAGE_SIZE and that stats is disabled. Return -EFBIG in the case where we don't have enough space to write the full transition table. Also document in the ABI that this function can return -EFBIG error.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2023-027631": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: mtk-jpeg: Fix use after free bug due to error path handling in mtk_jpeg_dec_device_run In mtk_jpeg_probe, &jpeg->job_timeout_work is bound with mtk_jpeg_job_timeout_work. In mtk_jpeg_dec_device_run, if error happens in mtk_jpeg_set_dec_dst, it will finally start the worker while mark the job as finished by invoking v4l2_m2m_job_finish. There are two methods to trigger the bug. If we remove the module, it which will call mtk_jpeg_remove to make cleanup. The possible sequence is as follows, which will cause a use-after-free bug. CPU0 CPU1 mtk_jpeg_dec_... | start worker | |mtk_jpeg_job_timeout_work mtk_jpeg_remove | v4l2_m2m_release | kfree(m2m_dev); | | | v4l2_m2m_get_curr_priv | m2m_dev->curr_ctx //use If we close the file descriptor, which will call mtk_jpeg_release, it will have a similar sequence. Fix this bug by starting timeout worker only if started jpegdec worker successfully. Then v4l2_m2m_job_finish will only be called in either mtk_jpeg_job_timeout_work or mtk_jpeg_dec_device_run.",
        "technologies": "Linux\nLinux Kernel 4.12 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2023-027711": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: virtio/vsock: Fix uninit-value in virtio_transport_recv_pkt() KMSAN reported the following uninit-value access issue: ===================================================== BUG: KMSAN: uninit-value in virtio_transport_recv_pkt+0x1dfb/0x26a0 net/vmw_vsock/virtio_transport_common.c:1421 virtio_transport_recv_pkt+0x1dfb/0x26a0 net/vmw_vsock/virtio_transport_common.c:1421 vsock_loopback_work+0x3bb/0x5a0 net/vmw_vsock/vsock_loopback.c:120 process_one_work kernel/workqueue.c:2630 [inline] process_scheduled_works+0xff6/0x1e60 kernel/workqueue.c:2703 worker_thread+0xeca/0x14d0 kernel/workqueue.c:2784 kthread+0x3cc/0x520 kernel/kthread.c:388 ret_from_fork+0x66/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 Uninit was stored to memory at: virtio_transport_space_update net/vmw_vsock/virtio_transport_common.c:1274 [inline] virtio_transport_recv_pkt+0x1ee8/0x26a0 net/vmw_vsock/virtio_transport_common.c:1415 vsock_loopback_work+0x3bb/0x5a0 net/vmw_vsock/vsock_loopback.c:120 process_one_work kernel/workqueue.c:2630 [inline] process_scheduled_works+0xff6/0x1e60 kernel/workqueue.c:2703 worker_thread+0xeca/0x14d0 kernel/workqueue.c:2784 kthread+0x3cc/0x520 kernel/kthread.c:388 ret_from_fork+0x66/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 Uninit was created at: slab_post_alloc_hook+0x105/0xad0 mm/slab.h:767 slab_alloc_node mm/slub.c:3478 [inline] kmem_cache_alloc_node+0x5a2/0xaf0 mm/slub.c:3523 kmalloc_reserve+0x13c/0x4a0 net/core/skbuff.c:559 __alloc_skb+0x2fd/0x770 net/core/skbuff.c:650 alloc_skb include/linux/skbuff.h:1286 [inline] virtio_vsock_alloc_skb include/linux/virtio_vsock.h:66 [inline] virtio_transport_alloc_skb+0x90/0x11e0 net/vmw_vsock/virtio_transport_common.c:58 virtio_transport_reset_no_sock net/vmw_vsock/virtio_transport_common.c:957 [inline] virtio_transport_recv_pkt+0x1279/0x26a0 net/vmw_vsock/virtio_transport_common.c:1387 vsock_loopback_work+0x3bb/0x5a0 net/vmw_vsock/vsock_loopback.c:120 process_one_work kernel/workqueue.c:2630 [inline] process_scheduled_works+0xff6/0x1e60 kernel/workqueue.c:2703 worker_thread+0xeca/0x14d0 kernel/workqueue.c:2784 kthread+0x3cc/0x520 kernel/kthread.c:388 ret_from_fork+0x66/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304 CPU: 1 PID: 10664 Comm: kworker/1:5 Not tainted 6.6.0-rc3-00146-g9f3ebbef746f #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-1.fc38 04/01/2014 Workqueue: vsock-loopback vsock_loopback_work ===================================================== The following simple reproducer can cause the issue described above: int main(void) { int sock; struct sockaddr_vm addr = { .svm_family = AF_VSOCK, .svm_cid = VMADDR_CID_ANY, .svm_port = 1234, }; sock = socket(AF_VSOCK, SOCK_STREAM, 0); connect(sock, (struct sockaddr *)&addr, sizeof(addr)); return 0; } This issue occurs because the `buf_alloc` and `fwd_cnt` fields of the `struct virtio_vsock_hdr` are not initialized when a new skb is allocated in `virtio_transport_init_hdr()`. This patch resolves the issue by initializing these fields during allocation.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.2 未満"
    },
    "JVNDB-2023-027710": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hsr: Prevent use after free in prp_create_tagged_frame() The prp_fill_rct() function can fail. In that situation, it frees the skb and returns NULL. Meanwhile on the success path, it returns the original skb. So it's straight forward to fix bug by using the returned value.",
        "technologies": "Linux\nLinux Kernel 5.9 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-027721": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd: Fix UBSAN array-index-out-of-bounds for SMU7 For pptable structs that use flexible array sizes, use flexible arrays.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027738": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Input: synaptics-rmi4 - fix use after free in rmi_unregister_function() The put_device() calls rmi_release_function() which frees \"fn\" so the dereference on the next line \"fn->num_of_irqs\" is a use after free. Move the put_device() to the end to fix this.",
        "technologies": "Linux\nLinux Kernel 4.18 以上 4.19.299 未満\nLinux Kernel 4.20 以上 5.4.261 未満\nLinux Kernel 5.5 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-027696": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vkms: Avoid reading beyond LUT array When the floor LUT index (drm_fixp2int(lut_index) is the last index of the array the ceil LUT index will point to an entry beyond the array. Make sure we guard against it and use the value of the floor LUT index. v3: - Drop bits from commit description that didn't contribute anything of value",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2023-027766": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential deadlock when releasing mids All release_mid() callers seem to hold a reference of @mid so there is no need to call kref_put(&mid->refcount, __release_mid) under @server->mid_lock spinlock. If they don't, then an use-after-free bug would have occurred anyways. By getting rid of such spinlock also fixes a potential deadlock as shown below CPU 0 CPU 1 ------------------------------------------------------------------ cifs_demultiplex_thread() cifs_debug_data_proc_show() release_mid() spin_lock(&server->mid_lock); spin_lock(&cifs_tcp_ses_lock) spin_lock(&server->mid_lock) __release_mid() smb2_find_smb_tcon() spin_lock(&cifs_tcp_ses_lock) *deadlock*",
        "technologies": "Linux\nLinux Kernel 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027768": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: compress: fix to avoid use-after-free on dic Call trace: __memcpy+0x128/0x250 f2fs_read_multi_pages+0x940/0xf7c f2fs_mpage_readpages+0x5a8/0x624 f2fs_readahead+0x5c/0x110 page_cache_ra_unbounded+0x1b8/0x590 do_sync_mmap_readahead+0x1dc/0x2e4 filemap_fault+0x254/0xa8c f2fs_filemap_fault+0x2c/0x104 __do_fault+0x7c/0x238 do_handle_mm_fault+0x11bc/0x2d14 do_mem_abort+0x3a8/0x1004 el0_da+0x3c/0xa0 el0t_64_sync_handler+0xc4/0xec el0t_64_sync+0x1b4/0x1b8 In f2fs_read_multi_pages(), once f2fs_decompress_cluster() was called if we hit cached page in compress_inode's cache, dic may be released, it needs break the loop rather than continuing it, in order to avoid accessing invalid dic pointer.",
        "technologies": "Linux\nLinux Kernel 5.13.19 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-027759": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched/psi: Fix use-after-free in ep_remove_wait_queue() If a non-root cgroup gets removed when there is a thread that registered trigger and is polling on a pressure file within the cgroup, the polling waitqueue gets freed in the following path: do_rmdir cgroup_rmdir kernfs_drain_open_files cgroup_file_release cgroup_pressure_release psi_trigger_destroy However, the polling thread still has a reference to the pressure file and will access the freed waitqueue when the file is closed or upon exit: fput ep_eventpoll_release ep_free ep_remove_wait_queue remove_wait_queue This results in use-after-free as pasted below. The fundamental problem here is that cgroup_file_release() (and consequently waitqueue's lifetime) is not tied to the file's real lifetime. Using wake_up_pollfree() here might be less than ideal, but it is in line with the comment at commit 42288cb44c4b (\"wait: add wake_up_pollfree()\") since the waitqueue's lifetime is not tied to file's one and can be considered as another special case. While this would be fixable by somehow making cgroup_file_release() be tied to the fput(), it would require sizable refactoring at cgroups or higher layer which might be more justifiable if we identify more cases like this. BUG: KASAN: use-after-free in _raw_spin_lock_irqsave+0x60/0xc0 Write of size 4 at addr ffff88810e625328 by task a.out/4404 CPU: 19 PID: 4404 Comm: a.out Not tainted 6.2.0-rc6 #38 Hardware name: Amazon EC2 c5a.8xlarge/, BIOS 1.0 10/16/2017 Call Trace: <TASK> dump_stack_lvl+0x73/0xa0 print_report+0x16c/0x4e0 kasan_report+0xc3/0xf0 kasan_check_range+0x2d2/0x310 _raw_spin_lock_irqsave+0x60/0xc0 remove_wait_queue+0x1a/0xa0 ep_free+0x12c/0x170 ep_eventpoll_release+0x26/0x30 __fput+0x202/0x400 task_work_run+0x11d/0x170 do_exit+0x495/0x1130 do_group_exit+0x100/0x100 get_signal+0xd67/0xde0 arch_do_signal_or_restart+0x2a/0x2b0 exit_to_user_mode_prepare+0x94/0x100 syscall_exit_to_user_mode+0x20/0x40 do_syscall_64+0x52/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd </TASK> Allocated by task 4404: kasan_set_track+0x3d/0x60 __kasan_kmalloc+0x85/0x90 psi_trigger_create+0x113/0x3e0 pressure_write+0x146/0x2e0 cgroup_file_write+0x11c/0x250 kernfs_fop_write_iter+0x186/0x220 vfs_write+0x3d8/0x5c0 ksys_write+0x90/0x110 do_syscall_64+0x43/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd Freed by task 4407: kasan_set_track+0x3d/0x60 kasan_save_free_info+0x27/0x40 ____kasan_slab_free+0x11d/0x170 slab_free_freelist_hook+0x87/0x150 __kmem_cache_free+0xcb/0x180 psi_trigger_destroy+0x2e8/0x310 cgroup_file_release+0x4f/0xb0 kernfs_drain_open_files+0x165/0x1f0 kernfs_drain+0x162/0x1a0 __kernfs_remove+0x1fb/0x310 kernfs_remove_by_name_ns+0x95/0xe0 cgroup_addrm_files+0x67f/0x700 cgroup_destroy_locked+0x283/0x3c0 cgroup_rmdir+0x29/0x100 kernfs_iop_rmdir+0xd1/0x140 vfs_rmdir+0xfe/0x240 do_rmdir+0x13d/0x280 __x64_sys_rmdir+0x2c/0x30 do_syscall_64+0x43/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.169 未満\nLinux Kernel 5.11 以上 5.15.95 未満\nLinux Kernel 5.16 以上 6.1.13 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-027743": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd: check num of link levels when update pcie param In SR-IOV environment, the value of pcie_table->num_of_link_levels will be 0, and num_of_levels - 1 will cause array index out of bounds",
        "technologies": "Linux\nLinux Kernel 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027830": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vhost-vdpa: fix use after free in vhost_vdpa_probe() The put_device() calls vhost_vdpa_release_dev() which calls ida_simple_remove() and frees \"v\". So this call to ida_simple_remove() is a use after free and a double free.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2023-027793": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: j1939: Fix UAF in j1939_sk_match_filter during setsockopt(SO_J1939_FILTER) Lock jsk->sk to prevent UAF when setsockopt(..., SO_J1939_FILTER, ...) modifies jsk->filters while receiving packets. Following trace was seen on affected system: ================================================================== BUG: KASAN: slab-use-after-free in j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939] Read of size 4 at addr ffff888012144014 by task j1939/350 CPU: 0 PID: 350 Comm: j1939 Tainted: G W OE 6.5.0-rc5 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace: print_report+0xd3/0x620 ? kasan_complete_mode_report_info+0x7d/0x200 ? j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939] kasan_report+0xc2/0x100 ? j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939] __asan_load4+0x84/0xb0 j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939] j1939_sk_recv+0x20b/0x320 [can_j1939] ? __kasan_check_write+0x18/0x20 ? __pfx_j1939_sk_recv+0x10/0x10 [can_j1939] ? j1939_simple_recv+0x69/0x280 [can_j1939] ? j1939_ac_recv+0x5e/0x310 [can_j1939] j1939_can_recv+0x43f/0x580 [can_j1939] ? __pfx_j1939_can_recv+0x10/0x10 [can_j1939] ? raw_rcv+0x42/0x3c0 [can_raw] ? __pfx_j1939_can_recv+0x10/0x10 [can_j1939] can_rcv_filter+0x11f/0x350 [can] can_receive+0x12f/0x190 [can] ? __pfx_can_rcv+0x10/0x10 [can] can_rcv+0xdd/0x130 [can] ? __pfx_can_rcv+0x10/0x10 [can] __netif_receive_skb_one_core+0x13d/0x150 ? __pfx___netif_receive_skb_one_core+0x10/0x10 ? __kasan_check_write+0x18/0x20 ? _raw_spin_lock_irq+0x8c/0xe0 __netif_receive_skb+0x23/0xb0 process_backlog+0x107/0x260 __napi_poll+0x69/0x310 net_rx_action+0x2a1/0x580 ? __pfx_net_rx_action+0x10/0x10 ? __pfx__raw_spin_lock+0x10/0x10 ? handle_irq_event+0x7d/0xa0 __do_softirq+0xf3/0x3f8 do_softirq+0x53/0x80 </IRQ> <TASK> __local_bh_enable_ip+0x6e/0x70 netif_rx+0x16b/0x180 can_send+0x32b/0x520 [can] ? __pfx_can_send+0x10/0x10 [can] ? __check_object_size+0x299/0x410 raw_sendmsg+0x572/0x6d0 [can_raw] ? __pfx_raw_sendmsg+0x10/0x10 [can_raw] ? apparmor_socket_sendmsg+0x2f/0x40 ? __pfx_raw_sendmsg+0x10/0x10 [can_raw] sock_sendmsg+0xef/0x100 sock_write_iter+0x162/0x220 ? __pfx_sock_write_iter+0x10/0x10 ? __rtnl_unlock+0x47/0x80 ? security_file_permission+0x54/0x320 vfs_write+0x6ba/0x750 ? __pfx_vfs_write+0x10/0x10 ? __fget_light+0x1ca/0x1f0 ? __rcu_read_unlock+0x5b/0x280 ksys_write+0x143/0x170 ? __pfx_ksys_write+0x10/0x10 ? __kasan_check_read+0x15/0x20 ? fpregs_assert_state_consistent+0x62/0x70 __x64_sys_write+0x47/0x60 do_syscall_64+0x60/0x90 ? do_syscall_64+0x6d/0x90 ? irqentry_exit+0x3f/0x50 ? exc_page_fault+0x79/0xf0 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Allocated by task 348: kasan_save_stack+0x2a/0x50 kasan_set_track+0x29/0x40 kasan_save_alloc_info+0x1f/0x30 __kasan_kmalloc+0xb5/0xc0 __kmalloc_node_track_caller+0x67/0x160 j1939_sk_setsockopt+0x284/0x450 [can_j1939] __sys_setsockopt+0x15c/0x2f0 __x64_sys_setsockopt+0x6b/0x80 do_syscall_64+0x60/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Freed by task 349: kasan_save_stack+0x2a/0x50 kasan_set_track+0x29/0x40 kasan_save_free_info+0x2f/0x50 __kasan_slab_free+0x12e/0x1c0 __kmem_cache_free+0x1b9/0x380 kfree+0x7a/0x120 j1939_sk_setsockopt+0x3b2/0x450 [can_j1939] __sys_setsockopt+0x15c/0x2f0 __x64_sys_setsockopt+0x6b/0x80 do_syscall_64+0x60/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.4 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.79 未満\nLinux Kernel 6.2 以上 6.6.18 未満\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2023-027828": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: fix a potential double-free in fs_any_create_groups When kcalloc() for ft->g succeeds but kvzalloc() for in fails, fs_any_create_groups() will free ft->g. However, its caller fs_any_create_table() will free ft->g again through calling mlx5e_destroy_flow_table(), which will lead to a double-free. Fix this by setting ft->g to NULL in fs_any_create_groups().",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2023-027789": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: atlantic: eliminate double free in error handling logic Driver has a logic leak in ring data allocation/free, where aq_ring_free could be called multiple times on same ring, if system is under stress and got memory allocation error. Ring pointer was used as an indicator of failure, but this is not correct since only ring data is allocated/deallocated. Ring itself is an array member. Changing ring allocation functions to return error code directly. This simplifies error handling and eliminates aq_ring_free on higher layer.",
        "technologies": "Linux\nLinux Kernel 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-027869": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ring-buffer: Do not attempt to read past \"commit\" When iterating over the ring buffer while the ring buffer is active, the writer can corrupt the reader. There's barriers to help detect this and handle it, but that code missed the case where the last event was at the very end of the page and has only 4 bytes left. The checks to detect the corruption by the writer to reads needs to see the length of the event. If the length in the first 4 bytes is zero then the length is stored in the second 4 bytes. But if the writer is in the process of updating that code, there's a small window where the length in the first 4 bytes could be zero even though the length is only 4 bytes. That will cause rb_event_length() to read the next 4 bytes which could happen to be off the allocated page. To protect against this, fail immediately if the next event pointer is less than 8 bytes from the end of the commit (last byte of data), as all events must be a minimum of 8 bytes anyway.",
        "technologies": "Linux\nLinux Kernel 5.10.198 未満\nLinux Kernel 5.11 以上 5.15.134 未満\nLinux Kernel 5.16 から 6.1.56\nLinux Kernel 6.2 から 6.5.6\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027866": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mctp: perform route lookups under a RCU read-side lock Our current route lookups (mctp_route_lookup and mctp_route_lookup_null) traverse the net's route list without the RCU read lock held. This means the route lookup is subject to preemption, resulting in an potential grace period expiry, and so an eventual kfree() while we still have the route pointer. Add the proper read-side critical section locks around the route lookups, preventing premption and a possible parallel kfree. The remaining net->mctp.routes accesses are already under a rcu_read_lock, or protected by the RTNL for updates. Based on an analysis from Sili Luo <rootlab@huawei.com>, where introducing a delay in the route lookup could cause a UAF on simultaneous sendmsg() and route deletion.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.137 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027862": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: IB/mlx5: Fix init stage error handling to avoid double free of same QP and UAF In the unlikely event that workqueue allocation fails and returns NULL in mlx5_mkey_cache_init(), delete the call to mlx5r_umr_resource_cleanup() (which frees the QP) in mlx5_ib_stage_post_ib_reg_umr_init(). This will avoid attempted double free of the same QP when __mlx5_ib_add() does its cleanup. Resolves a splat: Syzkaller reported a UAF in ib_destroy_qp_user workqueue: Failed to create a rescuer kthread for wq \"mkey_cache\": -EINTR infiniband mlx5_0: mlx5_mkey_cache_init:981:(pid 1642): failed to create work queue infiniband mlx5_0: mlx5_ib_stage_post_ib_reg_umr_init:4075:(pid 1642): mr cache init failed -12 ================================================================== BUG: KASAN: slab-use-after-free in ib_destroy_qp_user (drivers/infiniband/core/verbs.c:2073) Read of size 8 at addr ffff88810da310a8 by task repro_upstream/1642 Call Trace: <TASK> kasan_report (mm/kasan/report.c:590) ib_destroy_qp_user (drivers/infiniband/core/verbs.c:2073) mlx5r_umr_resource_cleanup (drivers/infiniband/hw/mlx5/umr.c:198) __mlx5_ib_add (drivers/infiniband/hw/mlx5/main.c:4178) mlx5r_probe (drivers/infiniband/hw/mlx5/main.c:4402) ... </TASK> Allocated by task 1642: __kmalloc (./include/linux/kasan.h:198 mm/slab_common.c:1026 mm/slab_common.c:1039) create_qp (./include/linux/slab.h:603 ./include/linux/slab.h:720 ./include/rdma/ib_verbs.h:2795 drivers/infiniband/core/verbs.c:1209) ib_create_qp_kernel (drivers/infiniband/core/verbs.c:1347) mlx5r_umr_resource_init (drivers/infiniband/hw/mlx5/umr.c:164) mlx5_ib_stage_post_ib_reg_umr_init (drivers/infiniband/hw/mlx5/main.c:4070) __mlx5_ib_add (drivers/infiniband/hw/mlx5/main.c:4168) mlx5r_probe (drivers/infiniband/hw/mlx5/main.c:4402) ... Freed by task 1642: __kmem_cache_free (mm/slub.c:1826 mm/slub.c:3809 mm/slub.c:3822) ib_destroy_qp_user (drivers/infiniband/core/verbs.c:2112) mlx5r_umr_resource_cleanup (drivers/infiniband/hw/mlx5/umr.c:198) mlx5_ib_stage_post_ib_reg_umr_init (drivers/infiniband/hw/mlx5/main.c:4076 drivers/infiniband/hw/mlx5/main.c:4065) __mlx5_ib_add (drivers/infiniband/hw/mlx5/main.c:4168) mlx5r_probe (drivers/infiniband/hw/mlx5/main.c:4402) ...",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-027875": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mwifiex: Fix oob check condition in mwifiex_process_rx_packet Only skip the code path trying to access the rfc1042 headers when the buffer is too small, so the driver can still process packets without rfc1042 headers.",
        "technologies": "Linux\nLinux Kernel 5.10.195 以上 5.10.198 未満\nLinux Kernel 5.15.132 以上 5.15.135 未満\nLinux Kernel 6.1.53 以上 6.1.57 未満\nLinux Kernel 6.5.3 以上 6.5.7 未満\nLinux Kernel 4.14.326\nLinux Kernel 4.19.295\nLinux Kernel 5.4.257"
    },
    "JVNDB-2023-027857": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfc: nci: assert requested protocol is valid The protocol is used in a bit mask to determine if the protocol is supported. Assert the provided protocol is less than the maximum defined so it doesn't potentially perform a shift-out-of-bounds and provide a clearer error for undefined protocols vs unsupported ones.",
        "technologies": "Linux\nLinux Kernel 3.2 以上 4.14.328 未満\nLinux Kernel 4.15 以上 4.19.297 未満\nLinux Kernel 4.20 以上 5.4.259 未満\nLinux Kernel 5.5 以上 5.10.199 未満\nLinux Kernel 5.11 以上 5.15.136 未満\nLinux Kernel 5.16 以上 6.1.59 未満\nLinux Kernel 6.2 以上 6.5.8 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027848": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: fix a double-free in si_dpm_init When the allocation of adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries fails, amdgpu_free_extended_power_table is called to free some fields of adev. However, when the control flow returns to si_dpm_sw_init, it goes to label dpm_failed and calls si_dpm_fini, which calls amdgpu_free_extended_power_table again and free those fields again. Thus a double-free is triggered.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.9 以上 4.19.306 未満\nLinux Kernel 4.20 以上 5.4.268 未満\nLinux Kernel 5.5 以上 5.10.209 未満\nLinux Kernel 5.11 以上 5.15.148 未満\nLinux Kernel 5.16 以上 6.1.75 未満\nLinux Kernel 6.2 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-027847": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: of: Fix double free in of_parse_phandle_with_args_map In of_parse_phandle_with_args_map() the inner loop that iterates through the map entries calls of_node_put(new) to free the reference acquired by the previous iteration of the inner loop. This assumes that the value of \"new\" is NULL on the first iteration of the inner loop. Make sure that this is true in all iterations of the outer loop by setting \"new\" to NULL after its value is assigned to \"cur\". Extend the unittest to detect the double free and add an additional test case that actually triggers this path.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.17 以上 4.19.306 未満\nLinux Kernel 4.20 以上 5.4.268 未満\nLinux Kernel 5.5 以上 5.10.209 未満\nLinux Kernel 5.11 以上 5.15.148 未満\nLinux Kernel 5.16 以上 6.1.75 未満\nLinux Kernel 6.2 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-027854": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/srso: Add SRSO mitigation for Hygon processors Add mitigation for the speculative return stack overflow vulnerability which exists on Hygon processors too.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.134 未満\nLinux Kernel 5.16 以上 6.1.56 未満\nLinux Kernel 6.2 以上 6.5.6 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027773": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i3c: mipi-i3c-hci: Fix out of bounds access in hci_dma_irq_handler Do not loop over ring headers in hci_dma_irq_handler() that are not allocated and enabled in hci_dma_init(). Otherwise out of bounds access will occur from rings->headers[i] access when i >= number of allocated ring headers.",
        "technologies": "Linux\nLinux Kernel 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027772": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free in smb2_query_info_compound() The following UAF was triggered when running fstests generic/072 with KASAN enabled against Windows Server 2022 and mount options 'multichannel,max_channels=2,vers=3.1.1,mfsymlinks,noperm' BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423/0x6d0 [cifs] Read of size 8 at addr ffff888014941048 by task xfs_io/27534 CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 Call Trace: dump_stack_lvl+0x4a/0x80 print_report+0xcf/0x650 ? srso_alias_return_thunk+0x5/0x7f ? srso_alias_return_thunk+0x5/0x7f ? __phys_addr+0x46/0x90 kasan_report+0xda/0x110 ? smb2_query_info_compound+0x423/0x6d0 [cifs] ? smb2_query_info_compound+0x423/0x6d0 [cifs] smb2_query_info_compound+0x423/0x6d0 [cifs] ? __pfx_smb2_query_info_compound+0x10/0x10 [cifs] ? srso_alias_return_thunk+0x5/0x7f ? __stack_depot_save+0x39/0x480 ? kasan_save_stack+0x33/0x60 ? kasan_set_track+0x25/0x30 ? ____kasan_slab_free+0x126/0x170 smb2_queryfs+0xc2/0x2c0 [cifs] ? __pfx_smb2_queryfs+0x10/0x10 [cifs] ? __pfx___lock_acquire+0x10/0x10 smb311_queryfs+0x210/0x220 [cifs] ? __pfx_smb311_queryfs+0x10/0x10 [cifs] ? srso_alias_return_thunk+0x5/0x7f ? __lock_acquire+0x480/0x26c0 ? lock_release+0x1ed/0x640 ? srso_alias_return_thunk+0x5/0x7f ? do_raw_spin_unlock+0x9b/0x100 cifs_statfs+0x18c/0x4b0 [cifs] statfs_by_dentry+0x9b/0xf0 fd_statfs+0x4e/0xb0 __do_sys_fstatfs+0x7f/0xe0 ? __pfx___do_sys_fstatfs+0x10/0x10 ? srso_alias_return_thunk+0x5/0x7f ? lockdep_hardirqs_on_prepare+0x136/0x200 ? srso_alias_return_thunk+0x5/0x7f do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Allocated by task 27534: kasan_save_stack+0x33/0x60 kasan_set_track+0x25/0x30 __kasan_kmalloc+0x8f/0xa0 open_cached_dir+0x71b/0x1240 [cifs] smb2_query_info_compound+0x5c3/0x6d0 [cifs] smb2_queryfs+0xc2/0x2c0 [cifs] smb311_queryfs+0x210/0x220 [cifs] cifs_statfs+0x18c/0x4b0 [cifs] statfs_by_dentry+0x9b/0xf0 fd_statfs+0x4e/0xb0 __do_sys_fstatfs+0x7f/0xe0 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Freed by task 27534: kasan_save_stack+0x33/0x60 kasan_set_track+0x25/0x30 kasan_save_free_info+0x2b/0x50 ____kasan_slab_free+0x126/0x170 slab_free_freelist_hook+0xd0/0x1e0 __kmem_cache_free+0x9d/0x1b0 open_cached_dir+0xff5/0x1240 [cifs] smb2_query_info_compound+0x5c3/0x6d0 [cifs] smb2_queryfs+0xc2/0x2c0 [cifs] This is a race between open_cached_dir() and cached_dir_lease_break() where the cache entry for the open directory handle receives a lease break while creating it. And before returning from open_cached_dir(), we put the last reference of the new @cfid because of !@cfid->has_lease. Besides the UAF, while running xfstests a lot of missed lease breaks have been noticed in tests that run several concurrent statfs(2) calls on those cached fids CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108 CIFS: VFS: Dump pending requests: CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 000000005aa7316e len 108 ... To fix both, in open_cached_dir() ensure that @cfid->has_lease is set right before sending out compounded request so that any potential lease break will be get processed by demultiplex thread while we're still caching @cfid. And, if open failed for some reason, re-check @cfid->has_lease to decide whether or not put lease reference.",
        "technologies": "Linux\nLinux Kernel 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-027771": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix use-after-free in rdata->read_into_pages() When the network status is unstable, use-after-free may occur when read data from the server. BUG: KASAN: use-after-free in readpages_fill_pages+0x14c/0x7e0 Call Trace: <TASK> dump_stack_lvl+0x38/0x4c print_report+0x16f/0x4a6 kasan_report+0xb7/0x130 readpages_fill_pages+0x14c/0x7e0 cifs_readv_receive+0x46d/0xa40 cifs_demultiplex_thread+0x121c/0x1490 kthread+0x16b/0x1a0 ret_from_fork+0x2c/0x50 </TASK> Allocated by task 2535: kasan_save_stack+0x22/0x50 kasan_set_track+0x25/0x30 __kasan_kmalloc+0x82/0x90 cifs_readdata_direct_alloc+0x2c/0x110 cifs_readdata_alloc+0x2d/0x60 cifs_readahead+0x393/0xfe0 read_pages+0x12f/0x470 page_cache_ra_unbounded+0x1b1/0x240 filemap_get_pages+0x1c8/0x9a0 filemap_read+0x1c0/0x540 cifs_strict_readv+0x21b/0x240 vfs_read+0x395/0x4b0 ksys_read+0xb8/0x150 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc Freed by task 79: kasan_save_stack+0x22/0x50 kasan_set_track+0x25/0x30 kasan_save_free_info+0x2e/0x50 __kasan_slab_free+0x10e/0x1a0 __kmem_cache_free+0x7a/0x1a0 cifs_readdata_release+0x49/0x60 process_one_work+0x46c/0x760 worker_thread+0x2a4/0x6f0 kthread+0x16b/0x1a0 ret_from_fork+0x2c/0x50 Last potentially related work creation: kasan_save_stack+0x22/0x50 __kasan_record_aux_stack+0x95/0xb0 insert_work+0x2b/0x130 __queue_work+0x1fe/0x660 queue_work_on+0x4b/0x60 smb2_readv_callback+0x396/0x800 cifs_abort_connection+0x474/0x6a0 cifs_reconnect+0x5cb/0xa50 cifs_readv_from_socket.cold+0x22/0x6c cifs_read_page_from_socket+0xc1/0x100 readpages_fill_pages.cold+0x2f/0x46 cifs_readv_receive+0x46d/0xa40 cifs_demultiplex_thread+0x121c/0x1490 kthread+0x16b/0x1a0 ret_from_fork+0x2c/0x50 The following function calls will cause UAF of the rdata pointer. readpages_fill_pages cifs_read_page_from_socket cifs_readv_from_socket cifs_reconnect __cifs_reconnect cifs_abort_connection mid->callback() --> smb2_readv_callback queue_work(&rdata->work) # if the worker completes first, # the rdata is freed cifs_readv_complete kref_put cifs_readdata_release kfree(rdata) return rdata->... # UAF in readpages_fill_pages() Similarly, this problem also occurs in the uncache_fill_pages(). Fix this by adjusts the order of condition judgment in the return statement.",
        "technologies": "Linux\nLinux Kernel 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.94 未満\nLinux Kernel 5.16 以上 6.1.12 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-027876": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: nfc: llcp: Add lock when modifying device list The device list needs its associated lock held when modifying it, or the list could become corrupted, as syzbot discovered.",
        "technologies": "Linux\nLinux Kernel 5.4.251 以上 5.4.258 未満\nLinux Kernel 5.10.188 以上 5.10.198 未満\nLinux Kernel 5.15.121 以上 5.15.135 未満\nLinux Kernel 6.1.39 以上 6.1.57 未満\nLinux Kernel 6.5 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027878": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: sun6i: fix race between DMA RX transfer completion and RX FIFO drain Previously the transfer complete IRQ immediately drained to RX FIFO to read any data remaining in FIFO to the RX buffer. This behaviour is correct when dealing with SPI in interrupt mode. However in DMA mode the transfer complete interrupt still fires as soon as all bytes to be transferred have been stored in the FIFO. At that point data in the FIFO still needs to be picked up by the DMA engine. Thus the drain procedure and DMA engine end up racing to read from RX FIFO, corrupting any data read. Additionally the RX buffer pointer is never adjusted according to DMA progress in DMA mode, thus calling the RX FIFO drain procedure in DMA mode is a bug. Fix corruptions in DMA RX mode by draining RX FIFO only in interrupt mode. Also wait for completion of RX DMA when in DMA mode before returning to ensure all data has been copied to the supplied memory buffer.",
        "technologies": "Linux\nLinux Kernel 5.15.134 未満\nLinux Kernel 5.16 以上 6.1.56 未満\nLinux Kernel 6.2 以上 6.5.6 未満"
    },
    "JVNDB-2023-027877": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: intel-ish-hid: ipc: Disable and reenable ACPI GPE bit The EHL (Elkhart Lake) based platforms provide a OOB (Out of band) service, which allows to wakup device when the system is in S5 (Soft-Off state). This OOB service can be enabled/disabled from BIOS settings. When enabled, the ISH device gets PME wake capability. To enable PME wakeup, driver also needs to enable ACPI GPE bit. On resume, BIOS will clear the wakeup bit. So driver need to re-enable it in resume function to keep the next wakeup capability. But this BIOS clearing of wakeup bit doesn't decrement internal OS GPE reference count, so this reenabling on every resume will cause reference count to overflow. So first disable and reenable ACPI GPE bit using acpi_disable_gpe().",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.135 未満\nLinux Kernel 5.16 以上 6.1.57 未満\nLinux Kernel 6.2 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027884": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nbd: fix uaf in nbd_open Commit 4af5f2e03013 (\"nbd: use blk_mq_alloc_disk and blk_cleanup_disk\") cleans up disk by blk_cleanup_disk() and it won't set disk->private_data as NULL as before. UAF may be triggered in nbd_open() if someone tries to open nbd device right after nbd_put() since nbd has been free in nbd_dev_remove(). Fix this by implementing ->free_disk and free private data in it.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-027879": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix race condition between session lookup and expire Thread A + Thread B ksmbd_session_lookup | smb2_sess_setup sess = xa_load | | | xa_erase(&conn->sessions, sess->id); | | ksmbd_session_destroy(sess) --> kfree(sess) | // UAF! | sess->last_active = jiffies | + This patch add rwsem to fix race condition between ksmbd_session_lookup and ksmbd_expire_session.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.145 未満\nLinux Kernel 5.16 以上 6.1.57 未満\nLinux Kernel 6.2 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-027915": {
        "title": "フォーティネットの Linux 用 FortiClient におけるコードインジェクションの脆弱性",
        "description": "An improper control of generation of code ('code injection') in Fortinet FortiClientLinux version 7.2.0, 7.0.6 through 7.0.10 and 7.0.3 through 7.0.4 allows attacker to execute unauthorized code or commands via tricking a FortiClientLinux user into visiting a malicious website",
        "technologies": "フォーティネット\nFortiClient 7.0.6 以上 7.0.11 未満\nFortiClient 7.0.3\nFortiClient 7.0.4\nFortiClient 7.2.0"
    },
    "JVNDB-2023-028154": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/msm/dpu: Add mutex lock in control vblank irq Add a mutex lock to control vblank irq to synchronize vblank enable/disable operations happening from different threads to prevent race conditions while registering/unregistering the vblank irq callback. v4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a parameter of dpu_encoder_phys. -Switch from atomic refcnt to a simple int counter as mutex has now been added v3: Mistakenly did not change wording in last version. It is done now. v2: Slightly changed wording of commit message Patchwork: https://patchwork.freedesktop.org/patch/571854/",
        "technologies": "Linux\nLinux Kernel 6.7.4 未満"
    },
    "JVNDB-2023-028045": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: padata: Fix refcnt handling in padata_free_shell() In a high-load arm64 environment, the pcrypt_aead01 test in LTP can lead to system UAF (Use-After-Free) issues. Due to the lengthy analysis of the pcrypt_aead01 function call, I'll describe the problem scenario using a simplified model: Suppose there's a user of padata named `user_function` that adheres to the padata requirement of calling `padata_free_shell` after `serial()` has been invoked, as demonstrated in the following code: ```c struct request { struct padata_priv padata; struct completion *done; }; void parallel(struct padata_priv *padata) { do_something(); } void serial(struct padata_priv *padata) { struct request *request = container_of(padata, struct request, padata); complete(request->done); } void user_function() { DECLARE_COMPLETION(done) padata->parallel = parallel; padata->serial = serial; padata_do_parallel(); wait_for_completion(&done); padata_free_shell(); } ``` In the corresponding padata.c file, there's the following code: ```c static void padata_serial_worker(struct work_struct *serial_work) { ... cnt = 0; while (!list_empty(&local_list)) { ... padata->serial(padata); cnt++; } local_bh_enable(); if (refcount_sub_and_test(cnt, &pd->refcnt)) padata_free_pd(pd); } ``` Because of the high system load and the accumulation of unexecuted softirq at this moment, `local_bh_enable()` in padata takes longer to execute than usual. Subsequently, when accessing `pd->refcnt`, `pd` has already been released by `padata_free_shell()`, resulting in a UAF issue with `pd->refcnt`. The fix is straightforward: add `refcount_dec_and_test` before calling `padata_free_pd` in `padata_free_shell`.",
        "technologies": "Linux\nLinux Kernel 3.16.84 以上 3.17 未満\nLinux Kernel 4.4.215 以上 4.5 未満\nLinux Kernel 4.9.215 以上 4.10 未満\nLinux Kernel 4.14.172 以上 4.15 未満\nLinux Kernel 4.19.103 以上 4.20 未満\nLinux Kernel 5.4.19 以上 5.5 未満\nLinux Kernel 5.5.3 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-028152": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: soc: qcom: pmic_glink_altmode: fix port sanity check The PMIC GLINK altmode driver currently supports at most two ports. Fix the incomplete port sanity check on notifications to avoid accessing and corrupting memory beyond the port array if we ever get a notification for an unsupported port.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2023-027919": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: perf: hisi: Fix use-after-free when register pmu fails When we fail to register the uncore pmu, the pmu context may not been allocated. The error handing will call cpuhp_state_remove_instance() to call uncore pmu offline callback, which migrate the pmu context. Since that's liable to lead to some kind of use-after-free. Use cpuhp_state_remove_instance_nocalls() instead of cpuhp_state_remove_instance() so that the notifiers don't execute after the PMU device has been failed to register.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-027918": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: fix gtk offload status event locking The ath11k active pdevs are protected by RCU but the gtk offload status event handling code calling ath11k_mac_get_arvif_by_vdev_id() was not marked as a read-side critical section. Mark the code in question as an RCU read-side critical section to avoid any potential use-after-free issues. Compile tested only.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028153": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/ptrace: handle setting of fpc register correctly If the content of the floating point control (fpc) register of a traced process is modified with the ptrace interface the new value is tested for validity by temporarily loading it into the fpc register. This may lead to corruption of the fpc register of the tracing process: if an interrupt happens while the value is temporarily loaded into the fpc register, and within interrupt context floating point or vector registers are used, the current fp/vx registers are saved with save_fpu_regs() assuming they belong to user space and will be loaded into fp/vx registers when returning to user space. test_fp_ctl() restores the original user space fpc register value, however it will be discarded, when returning to user space. In result the tracer will incorrectly continue to run with the value that was supposed to be used for the traced process. Fix this by saving fpu register contents with save_fpu_regs() before using test_fp_ctl().",
        "technologies": "Linux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-028151": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to tag gcing flag on page during block migration It needs to add missing gcing flag on page during block migration, in order to garantee migrated data be persisted during checkpoint, otherwise out-of-order persistency between data and node may cause data corruption after SPOR. Similar issue was fixed by commit 2d1fe8a86bf5 (\"f2fs: fix to tag gcing flag on page during file defragment\").",
        "technologies": "Linux\nLinux Kernel 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-027994": {
        "title": "Linux Foundation の Magma における境界外書き込みに関する脆弱性",
        "description": "A Stack-based buffer overflow in the Mobile Management Entity (MME) of Magma versions <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) allows remote attackers to crash the MME with an unauthenticated cellphone by sending a NAS packet containing an oversized `Emergency Number List` Information Element.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2023-028155": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bus: mhi: host: Add alignment check for event ring read pointer Though we do check the event ring read pointer by \"is_valid_ring_ptr\" to make sure it is in the buffer range, but there is another risk the pointer may be not aligned. Since we are expecting event ring elements are 128 bits(struct mhi_ring_element) aligned, an unaligned read pointer could lead to multiple issues like DoS or ring buffer memory corruption. So add a alignment check for event ring read pointer.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満"
    },
    "JVNDB-2023-028205": {
        "title": "Linux Foundation の Magma における到達可能なアサーションに関する脆弱性",
        "description": "A reachable assertion in the Mobile Management Entity (MME) of Magma versions <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) allows remote attackers to crash the MME with an unauthenticated cellphone by sending a NAS packet containing an `Emergency Number List` Information Element.",
        "technologies": "Linux Foundation\nMagma 1.9 未満"
    },
    "JVNDB-2023-028269": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: fix out-of-bounds access may occur when coalesce info is read via debugfs The hns3 driver define an array of string to show the coalesce info, but if the kernel adds a new mode or a new state, out-of-bounds access may occur when coalesce info is read via debugfs, this patch fix the problem.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2023-028268": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix array-index-out-of-bounds in diAlloc Currently there is not check against the agno of the iag while allocating new inodes to avoid fragmentation problem. Added the check which is required.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028228": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: bttv: fix use after free error due to btv->timeout timer There may be some a race condition between timer function bttv_irq_timeout and bttv_remove. The timer is setup in probe and there is no timer_delete operation in remove function. When it hit kfree btv, the function might still be invoked, which will cause use after free bug. This bug is found by static analysis, it may be false positive. Fix it by adding del_timer_sync invoking to the remove function. cpu0 cpu1 bttv_probe ->timer_setup ->bttv_set_dma ->mod_timer; bttv_remove ->kfree(btv); ->bttv_irq_timeout ->USE btv",
        "technologies": "Linux\nLinux Kernel 4.15 以上 4.19.299 未満\nLinux Kernel 4.20 以上 5.4.261 未満\nLinux Kernel 5.5 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-028180": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: scomp - fix req->dst buffer overflow The req->dst buffer size should be checked before copying from the scomp_scratch->dst to avoid req->dst buffer overflow problem.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.10 以上 4.19.306 未満\nLinux Kernel 4.20 以上 5.4.268 未満\nLinux Kernel 5.5 以上 5.10.209 未満\nLinux Kernel 5.11 以上 5.15.148 未満\nLinux Kernel 5.16 以上 6.1.75 未満\nLinux Kernel 6.2 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-028203": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fix oob in ntfs_listxattr The length of name cannot exceed the space occupied by ea.",
        "technologies": "Linux\nLinux Kernel 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2023-028322": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix array-index-out-of-bounds in dbFindLeaf Currently while searching for dmtree_t for sufficient free blocks there is an array out of bounds while getting element in tp->dm_stree. To add the required check for out of bound we first need to determine the type of dmtree. Thus added an extra parameter to dbFindLeaf so that the type of tree can be determined and the required check can be applied.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028323": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: thermal: intel: powerclamp: fix mismatch in get function for max_idle KASAN reported this [ 444.853098] BUG: KASAN: global-out-of-bounds in param_get_int+0x77/0x90 [ 444.853111] Read of size 4 at addr ffffffffc16c9220 by task cat/2105 ... [ 444.853442] The buggy address belongs to the variable: [ 444.853443] max_idle+0x0/0xffffffffffffcde0 [intel_powerclamp] There is a mismatch between the param_get_int and the definition of max_idle. Replacing param_get_int with param_get_byte resolves this issue.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028409": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix array-index-out-of-bounds in dbAdjTree Currently there is a bound check missing in the dbAdjTree while accessing the dmt_stree. To add the required check added the bool is_ctl which is required to determine the size as suggest in the following commit. https://lore.kernel.org/linux-kernel-mentees/f9475918-2186-49b8-b801-6f0f9e75f4fa@oracle.com/",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-028424": {
        "title": "Linux の Linux Kernel における到達可能なアサーションに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Check rcu_read_lock_trace_held() before calling bpf map helpers These three bpf_map_{lookup,update,delete}_elem() helpers are also available for sleepable bpf program, so add the corresponding lock assertion for sleepable bpf program, otherwise the following warning will be reported when a sleepable bpf program manipulates bpf map under interpreter mode (aka bpf_jit_enable=0): WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ...... CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ...... RIP: 0010:bpf_map_lookup_elem+0x54/0x60 ...... Call Trace: <TASK> ? __warn+0xa5/0x240 ? bpf_map_lookup_elem+0x54/0x60 ? report_bug+0x1ba/0x1f0 ? handle_bug+0x40/0x80 ? exc_invalid_op+0x18/0x50 ? asm_exc_invalid_op+0x1b/0x20 ? __pfx_bpf_map_lookup_elem+0x10/0x10 ? rcu_lockdep_current_cpu_online+0x65/0xb0 ? rcu_is_watching+0x23/0x50 ? bpf_map_lookup_elem+0x54/0x60 ? __pfx_bpf_map_lookup_elem+0x10/0x10 ___bpf_prog_run+0x513/0x3b70 __bpf_prog_run32+0x9d/0xd0 ? __bpf_prog_enter_sleepable_recur+0xad/0x120 ? __bpf_prog_enter_sleepable_recur+0x3e/0x120 bpf_trampoline_6442580665+0x4d/0x1000 __x64_sys_getpgid+0x5/0x30 ? do_syscall_64+0x36/0xb0 entry_SYSCALL_64_after_hwframe+0x6e/0x76 </TASK>",
        "technologies": "Linux\nLinux Kernel 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-028413": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: reiserfs: Avoid touching renamed directory if parent does not change The VFS will not be locking moved directory if its parent does not change. Change reiserfs rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
        "technologies": "Linux\nLinux Kernel 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-028419": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nftables: exthdr: fix 4-byte stack OOB write If priv->len is a multiple of 4, then dst[len / 4] can write past the destination array which leads to stack corruption. This construct is necessary to clean the remainder of the register in case ->len is NOT a multiple of the register size, so make it conditional just like nft_payload.c does. The bug was added in 4.1 cycle and then copied/inherited when tcp/sctp and ip option support was added. Bug reported by Zero Day Initiative project (ZDI-CAN-21950, ZDI-CAN-21951, ZDI-CAN-21961).",
        "technologies": "Linux\nLinux Kernel 4.1 以上 5.10.198 未満\nLinux Kernel 5.11 以上 5.15.132 未満\nLinux Kernel 5.16 以上 6.1.54 未満\nLinux Kernel 6.2 以上 6.5.4 未満"
    },
    "JVNDB-2023-028471": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix operation precedence bug in port timestamping napi_poll context Indirection (*) is of lower precedence than postfix increment (++). Logic in napi_poll context would cause an out-of-bound read by first increment the pointer address by byte address space and then dereference the value. Rather, the intended logic was to dereference first and then increment the underlying value.",
        "technologies": "Linux\nLinux Kernel 6.6.3 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2023-028490": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: IORING_OP_READ did not correctly consume the provided buffer list when read i/o returned < 0 (except for -EAGAIN and -EIOCBQUEUED return). This can lead to a potential use-after-free when the completion via io_rw_done runs at separate context.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 6.1.122 未満\nLinux Kernel 6.2 以上 6.6.68 未満"
    },
    "JVNDB-2023-028452": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix uaf in smb20_oplock_break_ack drop reference after use opinfo.",
        "technologies": "Linux\nLinux Kernel 5.15.135 未満\nLinux Kernel 5.16 以上 6.1.57 未満\nLinux Kernel 6.2 以上 6.5.7 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-028410": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix slab-out-of-bounds Read in dtSearch Currently while searching for current page in the sorted entry table of the page there is a out of bound access. Added a bound check to fix the error. Dave: Set return code to -EIO",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満"
    },
    "JVNDB-2023-028448": {
        "title": "Linux の Linux Kernel におけるコマンドインジェクションの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Wake DMCUB before executing GPINT commands [Why] DMCUB can be in idle when we attempt to interface with the HW through the GPINT mailbox resulting in a system hang. [How] Add dc_wake_and_execute_gpint() to wrap the wake, execute, sleep sequence. If the GPINT executes successfully then DMCUB will be put back into sleep after the optional response is returned. It functions similar to the inbox command interface.",
        "technologies": "Linux\nLinux Kernel 6.7.3 未満"
    },
    "JVNDB-2023-028495": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix possible null pointer dereference abo->tbo.resource may be NULL in amdgpu_vm_bo_update.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.5.9 未満\nLinux Kernel 6.6"
    },
    "JVNDB-2023-028544": {
        "title": "Linux の Linux Kernel における消費電力の不適切な制限に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: don't return unset power in ieee80211_get_tx_power() We can get a UBSAN warning if ieee80211_get_tx_power() returns the INT_MIN value mac80211 internally uses for \"unset power level\". UBSAN: signed-integer-overflow in net/wireless/nl80211.c:3816:5 -2147483648 * 100 cannot be represented in type 'int' CPU: 0 PID: 20433 Comm: insmod Tainted: G WC OE Call Trace: dump_stack+0x74/0x92 ubsan_epilogue+0x9/0x50 handle_overflow+0x8d/0xd0 __ubsan_handle_mul_overflow+0xe/0x10 nl80211_send_iface+0x688/0x6b0 [cfg80211] [...] cfg80211_register_wdev+0x78/0xb0 [cfg80211] cfg80211_netdev_notifier_call+0x200/0x620 [cfg80211] [...] ieee80211_if_add+0x60e/0x8f0 [mac80211] ieee80211_register_hw+0xda5/0x1170 [mac80211] In this case, simply return an error instead, to indicate that no data is available.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-028491": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: bcm: Fix UAF in bcm_proc_show() BUG: KASAN: slab-use-after-free in bcm_proc_show+0x969/0xa80 Read of size 8 at addr ffff888155846230 by task cat/7862 CPU: 1 PID: 7862 Comm: cat Not tainted 6.5.0-rc1-00153-gc8746099c197 #230 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0xd5/0x150 print_report+0xc1/0x5e0 kasan_report+0xba/0xf0 bcm_proc_show+0x969/0xa80 seq_read_iter+0x4f6/0x1260 seq_read+0x165/0x210 proc_reg_read+0x227/0x300 vfs_read+0x1d5/0x8d0 ksys_read+0x11e/0x240 do_syscall_64+0x35/0xb0 entry_SYSCALL_64_after_hwframe+0x63/0xcd Allocated by task 7846: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 __kasan_kmalloc+0x9e/0xa0 bcm_sendmsg+0x264b/0x44e0 sock_sendmsg+0xda/0x180 ____sys_sendmsg+0x735/0x920 ___sys_sendmsg+0x11d/0x1b0 __sys_sendmsg+0xfa/0x1d0 do_syscall_64+0x35/0xb0 entry_SYSCALL_64_after_hwframe+0x63/0xcd Freed by task 7846: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_save_free_info+0x27/0x40 ____kasan_slab_free+0x161/0x1c0 slab_free_freelist_hook+0x119/0x220 __kmem_cache_free+0xb4/0x2e0 rcu_core+0x809/0x1bd0 bcm_op is freed before procfs entry be removed in bcm_release(), this lead to bcm_proc_show() may read the freed bcm_op.",
        "technologies": "Linux\nLinux Kernel 2.6.25 以上 4.14.322 未満\nLinux Kernel 4.15 以上 4.19.291 未満\nLinux Kernel 4.20 以上 5.4.251 未満\nLinux Kernel 5.5 以上 5.10.188 未満\nLinux Kernel 5.11 以上 5.15.123 未満\nLinux Kernel 5.16 以上 6.1.42 未満\nLinux Kernel 6.2 以上 6.4.7 未満\nLinux Kernel 6.5"
    },
    "JVNDB-2023-029380": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "A flaw was found within the parsing of extended attributes in the kernel ksmbd module. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this to disclose sensitive information on affected installations of Linux. Only systems with ksmbd enabled are vulnerable to this CVE.",
        "technologies": "Linux\nLinux Kernel 6.16 未満"
    },
    "JVNDB-2023-028697": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: EDAC/qcom: Do not pass llcc_driv_data as edac_device_ctl_info's pvt_info The memory for llcc_driv_data is allocated by the LLCC driver. But when it is passed as the private driver info to the EDAC core, it will get freed during the qcom_edac driver release. So when the qcom_edac driver gets probed again, it will try to use the freed data leading to the use-after-free bug. Hence, do not pass llcc_driv_data as pvt_info but rather reference it using the platform_data pointer in the qcom_edac driver.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.231 未満\nLinux Kernel 5.5 以上 5.10.166 未満\nLinux Kernel 5.11 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-028695": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: hda/via: Avoid potential array out-of-bound in add_secret_dac_path() snd_hda_get_connections() can return a negative error code. It may lead to accessing 'conn' array at a negative index. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 3.1 以上 4.14.306 未満\nLinux Kernel 4.15 以上 4.19.273 未満\nLinux Kernel 4.20 以上 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.168 未満\nLinux Kernel 5.11 以上 5.15.93 未満\nLinux Kernel 5.16 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-029670": {
        "title": "Linux Mint の Xreader における引数の挿入または変更に関する脆弱性",
        "description": "Linux Mint Xreader CBT File Parsing Argument Injection Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of Linux Mint Xreader. User interaction is required to exploit this vulnerability in that the target must visit a malicious page or open a malicious file. The specific flaw exists within the parsing of CBT files. The issue results from the lack of proper validation of a user-supplied string before using it to execute a system call. An attacker can leverage this vulnerability to execute code in the context of the current user. Was ZDI-CAN-22132.",
        "technologies": "Linux Mint\nXreader 3.8.2"
    },
    "JVNDB-2023-029721": {
        "title": "Canonical の linux-bluefield package における非効率的な正規表現の複雑さに関する脆弱性",
        "description": "Running DDoS on tcp port 22 will trigger a kernel crash. This issue is introduced by the backport of a commit regarding nft_lookup without the subsequent fixes that were introduced after this commit. The resolution of this CVE introduces those commits to the linux-bluefield package.",
        "technologies": "Canonical\nlinux-bluefield package 5.4.0-1058.64 未満"
    },
    "JVNDB-2023-028692": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915: Avoid potential vm use-after-free Adding the vm to the vm_xa table makes it visible to userspace, which could try to race with us to close the vm. So we need to take our extra reference before putting it in the table. (cherry picked from commit 99343c46d4e2b34c285d3d5f68ff04274c2f9fb4)",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.11 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-029398": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "A flaw was found within the handling of SMB2_READ commands in the kernel ksmbd module. The issue results from not releasing memory after its effective lifetime. An attacker can leverage this to create a denial-of-service condition on affected installations of Linux. Authentication is not required to exploit this vulnerability, but only systems with ksmbd enabled are vulnerable.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2023-029669": {
        "title": "Linux Mint の Xreader におけるパストラバーサルの脆弱性",
        "description": "Linux Mint Xreader EPUB File Parsing Directory Traversal Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of Linux Mint Xreader. User interaction is required to exploit this vulnerability in that the target must visit a malicious page or open a malicious file. The specific flaw exists within the parsing of EPUB files. The issue results from the lack of proper validation of a user-supplied path prior to using it in file operations. An attacker can leverage this vulnerability to execute code in the context of the current user. Was ZDI-CAN-21897.",
        "technologies": "Linux Mint\nXreader 3.8.2"
    },
    "JVNDB-2023-029399": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "A flaw was found within the handling of SMB2 read requests in the kernel ksmbd module. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this to disclose sensitive information on affected installations of Linux. Only systems with ksmbd enabled are vulnerable to this CVE.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2023-029762": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fbdev: Fix invalid page access after closing deferred I/O devices When a fbdev with deferred I/O is once opened and closed, the dirty pages still remain queued in the pageref list, and eventually later those may be processed in the delayed work. This may lead to a corruption of pages, hitting an Oops. This patch makes sure to cancel the delayed work and clean up the pageref list at closing the device for addressing the bug. A part of the cleanup code is factored out as a new helper function that is called from the common fb_release().",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.13 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-029397": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "A flaw was found within the parsing of SMB2 requests that have a transform header in the kernel ksmbd module. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this to disclose sensitive information on affected installations of Linux. Only systems with ksmbd enabled are vulnerable to this CVE.",
        "technologies": "Linux\nLinux Kernel"
    },
    "JVNDB-2023-029783": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: wmi: Fix opening of char device Since commit fa1f68db6ca7 (\"drivers: misc: pass miscdevice pointer via file private data\"), the miscdevice stores a pointer to itself inside filp->private_data, which means that private_data will not be NULL when wmi_char_open() is called. This might cause memory corruption should wmi_char_open() be unable to find its driver, something which can happen when the associated WMI device is deleted in wmi_free_devices(). Fix the problem by using the miscdevice pointer to retrieve the WMI device data associated with a char device using container_of(). This also avoids wmi_char_open() picking a wrong WMI device bound to a driver with the same name as the original driver.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 4.19.299 未満\nLinux Kernel 4.20 以上 5.4.261 未満\nLinux Kernel 5.5 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-029794": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Fix shift out-of-bounds issue [ 567.613292] shift exponent 255 is too large for 64-bit type 'long unsigned int' [ 567.614498] CPU: 5 PID: 238 Comm: kworker/5:1 Tainted: G OE 6.2.0-34-generic #34~22.04.1-Ubuntu [ 567.614502] Hardware name: AMD Splinter/Splinter-RPL, BIOS WS43927N_871 09/25/2023 [ 567.614504] Workqueue: events send_exception_work_handler [amdgpu] [ 567.614748] Call Trace: [ 567.614750] <TASK> [ 567.614753] dump_stack_lvl+0x48/0x70 [ 567.614761] dump_stack+0x10/0x20 [ 567.614763] __ubsan_handle_shift_out_of_bounds+0x156/0x310 [ 567.614769] ? srso_alias_return_thunk+0x5/0x7f [ 567.614773] ? update_sd_lb_stats.constprop.0+0xf2/0x3c0 [ 567.614780] svm_range_split_by_granularity.cold+0x2b/0x34 [amdgpu] [ 567.615047] ? srso_alias_return_thunk+0x5/0x7f [ 567.615052] svm_migrate_to_ram+0x185/0x4d0 [amdgpu] [ 567.615286] do_swap_page+0x7b6/0xa30 [ 567.615291] ? srso_alias_return_thunk+0x5/0x7f [ 567.615294] ? __free_pages+0x119/0x130 [ 567.615299] handle_pte_fault+0x227/0x280 [ 567.615303] __handle_mm_fault+0x3c0/0x720 [ 567.615311] handle_mm_fault+0x119/0x330 [ 567.615314] ? lock_mm_and_find_vma+0x44/0x250 [ 567.615318] do_user_addr_fault+0x1a9/0x640 [ 567.615323] exc_page_fault+0x81/0x1b0 [ 567.615328] asm_exc_page_fault+0x27/0x30 [ 567.615332] RIP: 0010:__get_user_8+0x1c/0x30",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-029776": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: gspca: cpia1: shift-out-of-bounds in set_flicker Syzkaller reported the following issue: UBSAN: shift-out-of-bounds in drivers/media/usb/gspca/cpia1.c:1031:27 shift exponent 245 is too large for 32-bit type 'int' When the value of the variable \"sd->params.exposure.gain\" exceeds the number of bits in an integer, a shift-out-of-bounds error is reported. It is triggered because the variable \"currentexp\" cannot be left-shifted by more than the number of bits in an integer. In order to avoid invalid range during left-shift, the conditional expression is added.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-029784": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/radeon: possible buffer overflow Buffer 'afmt_status' of size 6 could overflow, since index 'afmt_idx' is checked after access.",
        "technologies": "Linux\nLinux Kernel 4.13 以上 4.14.330 未満\nLinux Kernel 4.15 以上 4.19.299 未満\nLinux Kernel 4.20 以上 5.4.261 未満\nLinux Kernel 5.5 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-029768": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix the error handler of rfkill config When the core rfkill config throws error, it should free the allocated resources. Currently it is not freeing the core pdev create resources. Avoid this issue by calling the core pdev destroy in the error handler of core rfkill config. Found this issue in the code review and it is compile tested only.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-029792": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: avoid format-overflow warning With gcc and W=1 option, there's a warning like this: fs/f2fs/compress.c: In function ‘f2fs_init_page_array_cache’: fs/f2fs/compress.c:1984:47: error: ‘%u’ directive writing between 1 and 7 bytes into a region of size between 5 and 8 [-Werror=format-overflow=] 1984 | sprintf(slab_name, \"f2fs_page_array_entry-%u:%u\", MAJOR(dev), MINOR(dev)); | ^~ String \"f2fs_page_array_entry-%u:%u\" can up to 35. The first \"%u\" can up to 4 and the second \"%u\" can up to 7, so total size is \"24 + 4 + 7 = 35\". slab_name's size should be 35 rather than 32.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-029795": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: perf/core: Bail out early if the request AUX area is out of bound When perf-record with a large AUX area, e.g 4GB, it fails with: #perf record -C 0 -m ,4G -e arm_spe_0// -- sleep 1 failed to mmap with 12 (Cannot allocate memory) and it reveals a WARNING with __alloc_pages(): ------------[ cut here ]------------ WARNING: CPU: 44 PID: 17573 at mm/page_alloc.c:5568 __alloc_pages+0x1ec/0x248 Call trace: __alloc_pages+0x1ec/0x248 __kmalloc_large_node+0xc0/0x1f8 __kmalloc_node+0x134/0x1e8 rb_alloc_aux+0xe0/0x298 perf_mmap+0x440/0x660 mmap_region+0x308/0x8a8 do_mmap+0x3c0/0x528 vm_mmap_pgoff+0xf4/0x1b8 ksys_mmap_pgoff+0x18c/0x218 __arm64_sys_mmap+0x38/0x58 invoke_syscall+0x50/0x128 el0_svc_common.constprop.0+0x58/0x188 do_el0_svc+0x34/0x50 el0_svc+0x34/0x108 el0t_64_sync_handler+0xb8/0xc0 el0t_64_sync+0x1a4/0x1a8 'rb->aux_pages' allocated by kcalloc() is a pointer array which is used to maintains AUX trace pages. The allocated page for this array is physically contiguous (and virtually contiguous) with an order of 0..MAX_ORDER. If the size of pointer array crosses the limitation set by MAX_ORDER, it reveals a WARNING. So bail out early with -ENOMEM if the request AUX area is out of bound, e.g.: #perf record -C 0 -m ,4G -e arm_spe_0// -- sleep 1 failed to mmap with 12 (Cannot allocate memory)",
        "technologies": "Linux\nLinux Kernel 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-029772": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to wait on block writeback for post_read case If inode is compressed, but not encrypted, it missed to call f2fs_wait_on_block_writeback() to wait for GCed page writeback in IPU write path. Thread A GC-Thread - f2fs_gc - do_garbage_collect - gc_data_segment - move_data_block - f2fs_submit_page_write migrate normal cluster's block via meta_inode's page cache - f2fs_write_single_data_page - f2fs_do_write_data_page - f2fs_inplace_write_data - f2fs_submit_page_bio IRQ - f2fs_read_end_io IRQ old data overrides new data due to out-of-order GC and common IO. - f2fs_read_end_io",
        "technologies": "Linux\nLinux Kernel 5.6 以上 6.1.75 未満\nLinux Kernel 6.2 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-029782": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: locking/ww_mutex/test: Fix potential workqueue corruption In some cases running with the test-ww_mutex code, I was seeing odd behavior where sometimes it seemed flush_workqueue was returning before all the work threads were finished. Often this would cause strange crashes as the mutexes would be freed while they were being used. Looking at the code, there is a lifetime problem as the controlling thread that spawns the work allocates the \"struct stress\" structures that are passed to the workqueue threads. Then when the workqueue threads are finished, they free the stress struct that was passed to them. Unfortunately the workqueue work_struct node is in the stress struct. Which means the work_struct is freed before the work thread returns and while flush_workqueue is waiting. It seems like a better idea to have the controlling thread both allocate and free the stress structures, so that we can be sure we don't corrupt the workqueue by freeing the structure prematurely. So this patch reworks the test to do so, and with this change I no longer see the early flush_workqueue returns.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-029797": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/jfs: Add validity check for db_maxag and db_agpref Both db_maxag and db_agpref are used as the index of the db_agfree array, but there is currently no validity check for db_maxag and db_agpref, which can lead to errors. The following is related bug reported by Syzbot: UBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:639:20 index 7936 is out of range for type 'atomic_t[128]' Add checking that the values of db_maxag and db_agpref are valid indexes for the db_agfree array.",
        "technologies": "Linux\nLinux Kernel 4.14.331 未満\nLinux Kernel 4.15 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満"
    },
    "JVNDB-2023-029807": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: aspeed: Fix memory overwrite if timing is 1600x900 When capturing 1600x900, system could crash when system memory usage is tight. The way to reproduce this issue: 1. Use 1600x900 to display on host 2. Mount ISO through 'Virtual media' on OpenBMC's web 3. Run script as below on host to do sha continuously #!/bin/bash while [ [1] ]; do find /media -type f -printf '\"%h/%f\"\\n' | xargs sha256sum done 4. Open KVM on OpenBMC's web The size of macro block captured is 8x8. Therefore, we should make sure the height of src-buf is 8 aligned to fix this issue.",
        "technologies": "Linux\nLinux Kernel 5.0 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6 未満"
    },
    "JVNDB-2023-029813": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: avoid data corruption caused by decline We found a data corruption issue during testing of SMC-R on Redis applications. The benchmark has a low probability of reporting a strange error as shown below. \"Error: Protocol error, got \"\\xe2\" as reply type byte\" Finally, we found that the retrieved error data was as follows: 0xE2 0xD4 0xC3 0xD9 0x04 0x00 0x2C 0x20 0xA6 0x56 0x00 0x16 0x3E 0x0C 0xCB 0x04 0x02 0x01 0x00 0x00 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xE2 It is quite obvious that this is a SMC DECLINE message, which means that the applications received SMC protocol message. We found that this was caused by the following situations: client server ¦ clc proposal -------------> ¦ clc accept <------------- ¦ clc confirm -------------> wait llc confirm send llc confirm ¦failed llc confirm ¦ x------ (after 2s)timeout wait llc confirm rsp wait decline (after 1s) timeout (after 2s) timeout ¦ decline --------------> ¦ decline <-------------- As a result, a decline message was sent in the implementation, and this message was read from TCP by the already-fallback connection. This patch double the client timeout as 2x of the server value, With this simple change, the Decline messages should never cross or collide (during Confirm link timeout). This issue requires an immediate solution, since the protocol updates involve a more long-term solution.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.203 未満\nLinux Kernel 5.11 以上 5.15.141 未満\nLinux Kernel 5.16 以上 6.1.65 未満\nLinux Kernel 6.2 以上 6.6.4 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2023-029801": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: sof_sdw_rt_sdca_jack_common: ctx->headset_codec_dev = NULL sof_sdw_rt_sdca_jack_exit() are used by different codecs, and some of them use the same dai name. For example, rt712 and rt713 both use \"rt712-sdca-aif1\" and sof_sdw_rt_sdca_jack_exit(). As a result, sof_sdw_rt_sdca_jack_exit() will be called twice by mc_dailink_exit_loop(). Set ctx->headset_codec_dev = NULL; after put_device(ctx->headset_codec_dev); to avoid ctx->headset_codec_dev being put twice.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2023-029815": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipvlan: add ipvlan_route_v6_outbound() helper Inspired by syzbot reports using a stack of multiple ipvlan devices. Reduce stack size needed in ipvlan_process_v6_outbound() by moving the flowi6 struct used for the route lookup in an non inlined helper. ipvlan_route_v6_outbound() needs 120 bytes on the stack, immediately reclaimed. Also make sure ipvlan_process_v4_outbound() is not inlined. We might also have to lower MAX_NEST_DEV, because only syzbot uses setups with more than four stacked devices. BUG: TASK stack guard page was hit at ffffc9000e803ff8 (stack is ffffc9000e804000..ffffc9000e808000) stack guard page: 0000 [#1] SMP KASAN CPU: 0 PID: 13442 Comm: syz-executor.4 Not tainted 6.1.52-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/09/2023 RIP: 0010:kasan_check_range+0x4/0x2a0 mm/kasan/generic.c:188 Code: 48 01 c6 48 89 c7 e8 db 4e c1 03 31 c0 5d c3 cc 0f 0b eb 02 0f 0b b8 ea ff ff ff 5d c3 cc 00 00 cc cc 00 00 cc cc 55 48 89 e5 <41> 57 41 56 41 55 41 54 53 b0 01 48 85 f6 0f 84 a4 01 00 00 48 89 RSP: 0018:ffffc9000e804000 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817e5bf2 RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffff887c6568 RBP: ffffc9000e804000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: dffffc0000000001 R12: 1ffff92001d0080c R13: dffffc0000000000 R14: ffffffff87e6b100 R15: 0000000000000000 FS: 00007fd0c55826c0(0000) GS:ffff8881f6800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffc9000e803ff8 CR3: 0000000170ef7000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <#DF> </#DF> <TASK> [<ffffffff81f281d1>] __kasan_check_read+0x11/0x20 mm/kasan/shadow.c:31 [<ffffffff817e5bf2>] instrument_atomic_read include/linux/instrumented.h:72 [inline] [<ffffffff817e5bf2>] _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline] [<ffffffff817e5bf2>] cpumask_test_cpu include/linux/cpumask.h:506 [inline] [<ffffffff817e5bf2>] cpu_online include/linux/cpumask.h:1092 [inline] [<ffffffff817e5bf2>] trace_lock_acquire include/trace/events/lock.h:24 [inline] [<ffffffff817e5bf2>] lock_acquire+0xe2/0x590 kernel/locking/lockdep.c:5632 [<ffffffff8563221e>] rcu_lock_acquire+0x2e/0x40 include/linux/rcupdate.h:306 [<ffffffff8561464d>] rcu_read_lock include/linux/rcupdate.h:747 [inline] [<ffffffff8561464d>] ip6_pol_route+0x15d/0x1440 net/ipv6/route.c:2221 [<ffffffff85618120>] ip6_pol_route_output+0x50/0x80 net/ipv6/route.c:2606 [<ffffffff856f65b5>] pol_lookup_func include/net/ip6_fib.h:584 [inline] [<ffffffff856f65b5>] fib6_rule_lookup+0x265/0x620 net/ipv6/fib6_rules.c:116 [<ffffffff85618009>] ip6_route_output_flags_noref+0x2d9/0x3a0 net/ipv6/route.c:2638 [<ffffffff8561821a>] ip6_route_output_flags+0xca/0x340 net/ipv6/route.c:2651 [<ffffffff838bd5a3>] ip6_route_output include/net/ip6_route.h:100 [inline] [<ffffffff838bd5a3>] ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:473 [inline] [<ffffffff838bd5a3>] ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:529 [inline] [<ffffffff838bd5a3>] ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:602 [inline] [<ffffffff838bd5a3>] ipvlan_queue_xmit+0xc33/0x1be0 drivers/net/ipvlan/ipvlan_core.c:677 [<ffffffff838c2909>] ipvlan_start_xmit+0x49/0x100 drivers/net/ipvlan/ipvlan_main.c:229 [<ffffffff84d03900>] netdev_start_xmit include/linux/netdevice.h:4966 [inline] [<ffffffff84d03900>] xmit_one net/core/dev.c:3644 [inline] [<ffffffff84d03900>] dev_hard_start_xmit+0x320/0x980 net/core/dev.c:3660 [<ffffffff84d080e2>] __dev_queue_xmit+0x16b2/0x3370 net/core/dev.c:4324 [<ffffffff855ce4cd>] dev_queue_xmit include/linux/netdevice.h:3067 [inline] [<ffffffff855ce4cd>] neigh_hh_output include/net/neighbour.h:529 [inline] [<f ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.19 以上 4.19.300 未満\nLinux Kernel 4.20 以上 5.4.262 未満\nLinux Kernel 5.5 以上 5.10.202 未満\nLinux Kernel 5.11 以上 5.15.140 未満\nLinux Kernel 5.16 以上 6.1.64 未満\nLinux Kernel 6.2 以上 6.5.13 未満\nLinux Kernel 6.6 以上 6.6.3 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2023-029820": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: use a bounce buffer for copying skb->mark syzbot found arm64 builds would crash in sock_recv_mark() when CONFIG_HARDENED_USERCOPY=y x86 and powerpc are not detecting the issue because they define user_access_begin. This will be handled in a different patch, because a check_object_size() is missing. Only data from skb->cb[] can be copied directly to/from user space, as explained in commit 79a8a642bf05 (\"net: Whitelist the skbuff_head_cache \"cb\" field\") syzbot report was: usercopy: Kernel memory exposure attempt detected from SLUB object 'skbuff_head_cache' (offset 168, size 4)! ------------[ cut here ]------------ kernel BUG at mm/usercopy.c:102 ! Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP Modules linked in: CPU: 0 PID: 4410 Comm: syz-executor533 Not tainted 6.2.0-rc7-syzkaller-17907-g2d3827b3f393 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : usercopy_abort+0x90/0x94 mm/usercopy.c:90 lr : usercopy_abort+0x90/0x94 mm/usercopy.c:90 sp : ffff80000fb9b9a0 x29: ffff80000fb9b9b0 x28: ffff0000c6073400 x27: 0000000020001a00 x26: 0000000000000014 x25: ffff80000cf52000 x24: fffffc0000000000 x23: 05ffc00000000200 x22: fffffc000324bf80 x21: ffff0000c92fe1a8 x20: 0000000000000001 x19: 0000000000000004 x18: 0000000000000000 x17: 656a626f2042554c x16: ffff0000c6073dd0 x15: ffff80000dbd2118 x14: ffff0000c6073400 x13: 00000000ffffffff x12: ffff0000c6073400 x11: ff808000081bbb4c x10: 0000000000000000 x9 : 7b0572d7cc0ccf00 x8 : 7b0572d7cc0ccf00 x7 : ffff80000bf650d4 x6 : 0000000000000000 x5 : 0000000000000001 x4 : 0000000000000001 x3 : 0000000000000000 x2 : ffff0001fefbff08 x1 : 0000000100000000 x0 : 000000000000006c Call trace: usercopy_abort+0x90/0x94 mm/usercopy.c:90 __check_heap_object+0xa8/0x100 mm/slub.c:4761 check_heap_object mm/usercopy.c:196 [inline] __check_object_size+0x208/0x6b8 mm/usercopy.c:251 check_object_size include/linux/thread_info.h:199 [inline] __copy_to_user include/linux/uaccess.h:115 [inline] put_cmsg+0x408/0x464 net/core/scm.c:238 sock_recv_mark net/socket.c:975 [inline] __sock_recv_cmsgs+0x1fc/0x248 net/socket.c:984 sock_recv_cmsgs include/net/sock.h:2728 [inline] packet_recvmsg+0x2d8/0x678 net/packet/af_packet.c:3482 ____sys_recvmsg+0x110/0x3a0 ___sys_recvmsg net/socket.c:2737 [inline] __sys_recvmsg+0x194/0x210 net/socket.c:2767 __do_sys_recvmsg net/socket.c:2777 [inline] __se_sys_recvmsg net/socket.c:2774 [inline] __arm64_sys_recvmsg+0x2c/0x3c net/socket.c:2774 __invoke_syscall arch/arm64/kernel/syscall.c:38 [inline] invoke_syscall+0x64/0x178 arch/arm64/kernel/syscall.c:52 el0_svc_common+0xbc/0x180 arch/arm64/kernel/syscall.c:142 do_el0_svc+0x48/0x110 arch/arm64/kernel/syscall.c:193 el0_svc+0x58/0x14c arch/arm64/kernel/entry-common.c:637 el0t_64_sync_handler+0x84/0xf0 arch/arm64/kernel/entry-common.c:655 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:591 Code: 91388800 aa0903e1 f90003e8 94e6d752 (d4210000)",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.13 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2023-029827": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: thermal: core: prevent potential string overflow The dev->id value comes from ida_alloc() so it's a number between zero and INT_MAX. If it's too high then these sprintf()s will overflow.",
        "technologies": "Linux\nLinux Kernel 2.6.25 以上 4.14.330 未満\nLinux Kernel 4.15 以上 4.19.299 未満\nLinux Kernel 4.20 以上 5.4.261 未満\nLinux Kernel 5.5 以上 5.10.201 未満\nLinux Kernel 5.11 以上 5.15.139 未満\nLinux Kernel 5.16 以上 6.1.63 未満\nLinux Kernel 6.2 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2023-029838": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: uclogic: Fix user-memory-access bug in uclogic_params_ugee_v2_init_event_hooks() When CONFIG_HID_UCLOGIC=y and CONFIG_KUNIT_ALL_TESTS=y, launch kernel and then the below user-memory-access bug occurs. In hid_test_uclogic_params_cleanup_event_hooks(),it call uclogic_params_ugee_v2_init_event_hooks() with the first arg=NULL, so when it calls uclogic_params_ugee_v2_has_battery(), the hid_get_drvdata() will access hdev->dev with hdev=NULL, which will cause below user-memory-access. So add a fake_device with quirks member and call hid_set_drvdata() to assign hdev->dev->driver_data which avoids the null-ptr-def bug for drvdata->quirks in uclogic_params_ugee_v2_has_battery(). After applying this patch, the below user-memory-access bug never occurs. general protection fault, probably for non-canonical address 0xdffffc0000000329: 0000 [#1] PREEMPT SMP KASAN KASAN: probably user-memory-access in range [0x0000000000001948-0x000000000000194f] CPU: 5 PID: 2189 Comm: kunit_try_catch Tainted: G B W N 6.6.0-rc2+ #30 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 RIP: 0010:uclogic_params_ugee_v2_init_event_hooks+0x87/0x600 Code: f3 f3 65 48 8b 14 25 28 00 00 00 48 89 54 24 60 31 d2 48 89 fa c7 44 24 30 00 00 00 00 48 c7 44 24 28 02 f8 02 01 48 c1 ea 03 <80> 3c 02 00 0f 85 2c 04 00 00 48 8b 9d 48 19 00 00 48 b8 00 00 00 RSP: 0000:ffff88810679fc88 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000000004 RCX: 0000000000000000 RDX: 0000000000000329 RSI: ffff88810679fd88 RDI: 0000000000001948 RBP: 0000000000000000 R08: 0000000000000000 R09: ffffed1020f639f0 R10: ffff888107b1cf87 R11: 0000000000000400 R12: 1ffff11020cf3f92 R13: ffff88810679fd88 R14: ffff888100b97b08 R15: ffff8881030bb080 FS: 0000000000000000(0000) GS:ffff888119e80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000000005286001 CR4: 0000000000770ee0 DR0: ffffffff8fdd6cf4 DR1: ffffffff8fdd6cf5 DR2: ffffffff8fdd6cf6 DR3: ffffffff8fdd6cf7 DR6: 00000000fffe0ff0 DR7: 0000000000000600 PKRU: 55555554 Call Trace: <TASK> ? die_addr+0x3d/0xa0 ? exc_general_protection+0x144/0x220 ? asm_exc_general_protection+0x22/0x30 ? uclogic_params_ugee_v2_init_event_hooks+0x87/0x600 ? sched_clock_cpu+0x69/0x550 ? uclogic_parse_ugee_v2_desc_gen_params+0x70/0x70 ? load_balance+0x2950/0x2950 ? rcu_trc_cmpxchg_need_qs+0x67/0xa0 hid_test_uclogic_params_cleanup_event_hooks+0x9e/0x1a0 ? uclogic_params_ugee_v2_init_event_hooks+0x600/0x600 ? __switch_to+0x5cf/0xe60 ? migrate_enable+0x260/0x260 ? __kthread_parkme+0x83/0x150 ? kunit_try_run_case_cleanup+0xe0/0xe0 kunit_generic_run_threadfn_adapter+0x4a/0x90 ? kunit_try_catch_throw+0x80/0x80 kthread+0x2b5/0x380 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x2d/0x70 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork_asm+0x11/0x20 </TASK> Modules linked in: Dumping ftrace buffer: (ftrace buffer empty) ---[ end trace 0000000000000000 ]--- RIP: 0010:uclogic_params_ugee_v2_init_event_hooks+0x87/0x600 Code: f3 f3 65 48 8b 14 25 28 00 00 00 48 89 54 24 60 31 d2 48 89 fa c7 44 24 30 00 00 00 00 48 c7 44 24 28 02 f8 02 01 48 c1 ea 03 <80> 3c 02 00 0f 85 2c 04 00 00 48 8b 9d 48 19 00 00 48 b8 00 00 00 RSP: 0000:ffff88810679fc88 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000000004 RCX: 0000000000000000 RDX: 0000000000000329 RSI: ffff88810679fd88 RDI: 0000000000001948 RBP: 0000000000000000 R08: 0000000000000000 R09: ffffed1020f639f0 R10: ffff888107b1cf87 R11: 0000000000000400 R12: 1ffff11020cf3f92 R13: ffff88810679fd88 R14: ffff888100b97b08 R15: ffff8881030bb080 FS: 0000000000000000(0000) GS:ffff888119e80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000000005286001 CR4: 0000000000770ee0 DR0: ffffffff8fdd6cf4 DR1: ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.5.12 未満\nLinux Kernel 6.6 以上 6.6.2 未満"
    },
    "JVNDB-2024-001544": {
        "title": "Gentoo Linux の ebuild for slurm における脆弱性",
        "description": "pkg_postinst in the Gentoo ebuild for Slurm through 22.05.3 unnecessarily calls chown to assign root's ownership on files in the live root filesystem. This could be exploited by the slurm user to become the owner of root-owned files.",
        "technologies": "Gentoo Linux\nebuild for slurm 22.05.3 およびそれ以前"
    },
    "JVNDB-2024-001040": {
        "title": "マイクロソフトの複数の Microsoft 製品における権限を昇格される脆弱性",
        "description": "Windows Subsystem for Linux Elevation of Privilege Vulnerability",
        "technologies": "マイクロソフト\nMicrosoft Windows 10 Version 21H2 for 32-bit Systems\nMicrosoft Windows 10 Version 21H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 21H2 for x64-based Systems\nMicrosoft Windows 10 Version 22H2 for 32-bit Systems\nMicrosoft Windows 10 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 version 21H2 for ARM64-based Systems\nMicrosoft Windows 11 version 21H2 for x64-based Systems\nMicrosoft Windows 11 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 Version 23H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 23H2 for x64-based Systems\nMicrosoft Windows Server 2022 (Server Core installation)\nMicrosoft Windows Server 2022 , 23H2 Edition (Server Core installation)\nMicrosoft Windows Server 2022"
    },
    "JVNDB-2024-001583": {
        "title": "Gentoo Linux の Portage におけるデジタル署名の検証に関する脆弱性",
        "description": "In Gentoo Portage before 3.0.47, there is missing PGP validation of executed code: the standalone emerge-webrsync downloads a .gpgsig file but does not perform signature verification. Unless emerge-webrsync is used, Portage is not vulnerable.",
        "technologies": "Gentoo Linux\nPortage 3.0.47 未満"
    },
    "JVNDB-2024-001605": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A memory leak flaw was found in the Linux kernel’s io_uring functionality in how a user registers a buffer ring with IORING_REGISTER_PBUF_RING, mmap() it, and then frees it. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.5 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2024-001759": {
        "title": "Linux Foundation の argocd におけるクロスサイトリクエストフォージェリの脆弱性",
        "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. The Argo CD API prior to versions 2.10-rc2, 2.9.4, 2.8.8, and 2.7.15 are vulnerable to a cross-server request forgery (CSRF) attack when the attacker has the ability to write HTML to a page on the same parent domain as Argo CD. A CSRF attack works by tricking an authenticated Argo CD user into loading a web page which contains code to call Argo CD API endpoints on the victim’s behalf. For example, an attacker could send an Argo CD user a link to a page which looks harmless but in the background calls an Argo CD API endpoint to create an application running malicious code. Argo CD uses the “Lax” SameSite cookie policy to prevent CSRF attacks where the attacker controls an external domain. The malicious external website can attempt to call the Argo CD API, but the web browser will refuse to send the Argo CD auth token with the request. Many companies host Argo CD on an internal subdomain. If an attacker can place malicious code on, for example, https://test.internal.example.com/, they can still perform a CSRF attack. In this case, the “Lax” SameSite cookie does not prevent the browser from sending the auth cookie, because the destination is a parent domain of the Argo CD API. Browsers generally block such attacks by applying CORS policies to sensitive requests with sensitive content types. Specifically, browsers will send a “preflight request” for POSTs with content type “application/json” asking the destination API “are you allowed to accept requests from my domain?” If the destination API does not answer “yes,” the browser will block the request. Before the patched versions, Argo CD did not validate that requests contained the correct content type header. So an attacker could bypass the browser’s CORS check by setting the content type to something which is considered “not sensitive” such as “text/plain.” The browser wouldn’t send the preflight request, and Argo CD would happily accept the contents (which are actually still JSON) and perform the requested action (such as running malicious code). A patch for this vulnerability has been released in the following Argo CD versions: 2.10-rc2, 2.9.4, 2.8.8, and 2.7.15. The patch contains a breaking API change. The Argo CD API will no longer accept non-GET requests which do not specify application/json as their Content-Type. The accepted content types list is configurable, and it is possible (but discouraged) to disable the content type check completely. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "technologies": "Linux Foundation\nargocd 0.1.0 以上 2.7.16 未満\nargocd 2.8.0 以上 2.8.8 未満\nargocd 2.9.0 以上 2.9.4 未満\nargocd 2.10.0"
    },
    "JVNDB-2024-001736": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "An out-of-bounds memory read flaw was found in receive_encrypted_standard in fs/smb/client/smb2ops.c in the SMB Client sub-component in the Linux Kernel. This issue occurs due to integer underflow on the memcpy length, leading to a denial of service.",
        "technologies": "Linux\nLinux Kernel 6.7 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2024-001737": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the Linux Kernel. When a disk is removed, bdi_unregister is called to stop further write-back and waits for associated delayed work to complete. However, wb_inode_writeback_end() may schedule bandwidth estimation work after this has completed, which can result in the timer attempting to access the recently freed bdi_writeback.",
        "technologies": "Linux\nLinux Kernel 6.0 未満\nLinux Kernel 6.0\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2024-001890": {
        "title": "Linux Foundation の dex における暗号強度に関する脆弱性",
        "description": "Dex is an identity service that uses OpenID Connect to drive authentication for other apps. Dex 2.37.0 serves HTTPS with insecure TLS 1.0 and TLS 1.1. `cmd/dex/serve.go` line 425 seemingly sets TLS 1.2 as minimum version, but the whole `tlsConfig` is ignored after `TLS cert reloader` was introduced in v2.37.0. Configured cipher suites are not respected either. This issue is fixed in Dex 2.38.0.",
        "technologies": "Linux Foundation\ndex 2.37.0"
    },
    "JVNDB-2024-001938": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "An issue was discovered in ksmbd in the Linux kernel before 6.6.10. smb2_get_data_area_len in fs/smb/server/smb2misc.c can cause an smb_strndup_from_utf16 out-of-bounds access because the relationship between Name data and CreateContexts data is mishandled.",
        "technologies": "Linux\nLinux Kernel 6.6.10 未満\nLinux Kernel 6.7"
    },
    "JVNDB-2024-001803": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "An out-of-bounds memory write flaw was found in the Linux kernel’s Transport Layer Security functionality in how a user calls a function splice with a ktls socket as the destination. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel 6.7 未満\nLinux Kernel 6.7\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2024-002150": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "Integer Overflow or Wraparound vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (md, raid, raid5 modules) allows Forced Integer Overflow.",
        "technologies": "Linux\nLinux Kernel 4.1 から 6.7.2"
    },
    "JVNDB-2024-002121": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. The nft_setelem_catchall_deactivate() function checks whether the catch-all set element is active in the current generation instead of the next generation before freeing it, but only flags it inactive in the next generation, making it possible to free the element multiple times, leading to a double free vulnerability. We recommend upgrading past commit b1db244ffd041a49ecc9618e8feb6b5c1afcdaa7.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.148 未満\nLinux Kernel 5.16 以上 6.1.75 未満\nLinux Kernel 6.2 以上 6.6.14 未満\nLinux Kernel 6.7 以上 6.7.2 未満"
    },
    "JVNDB-2024-002117": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. The nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability when NF_DROP is issued with a drop error which resembles NF_ACCEPT. We recommend upgrading past commit f342de4e2f33e0e39165d8639387aa6c19dff660.",
        "technologies": "Linux\nLinux Kernel 3.15 以上 6.1.76 未満\nLinux Kernel 6.2 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-001862": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "A use-after-free flaw was found in the __ext4_remount in fs/ext4/super.c in ext4 in the Linux kernel. This flaw allows a local user to cause an information leak problem while freeing the old quota file names before a potential failure, leading to a use-after-free.",
        "technologies": "Linux\nLinux Kernel 6.4 未満\nLinux Kernel 6.4\nレッドハット\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2024-002178": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における NULL ポインタデリファレンスに関する脆弱性",
        "description": "A null pointer dereference flaw was found in the hugetlbfs_fill_super function in the Linux kernel hugetlbfs (HugeTLB pages) functionality. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
        "technologies": "Linux\nLinux Kernel\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2024-002457": {
        "title": "Linux Foundation の runc 等複数ベンダの製品における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc 1.1.11 and earlier, due to an internal file descriptor leak, an attacker could cause a newly-spawned container process (from runc exec) to have a working directory in the host filesystem namespace, allowing for a container escape by giving access to the host filesystem (\"attack 2\"). The same attack could be used by a malicious image to allow a container process to gain access to the host filesystem through runc run (\"attack 1\"). Variants of attacks 1 and 2 could be also be used to overwrite semi-arbitrary host binaries, allowing for complete container escapes (\"attack 3a\" and \"attack 3b\"). runc 1.1.12 includes patches for this issue.",
        "technologies": "Fedora Project\nFedora 39\nLinux Foundation\nrunc 1.1.12 未満"
    },
    "JVNDB-2024-002398": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C. This issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.",
        "technologies": "Linux\nLinux Kernel 2.6.12.1 以上 6.8 未満\nLinux Kernel 2.6.12"
    },
    "JVNDB-2024-002999": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Reject variable offset alu on PTR_TO_FLOW_KEYS For PTR_TO_FLOW_KEYS, check_flow_keys_access() only uses fixed off for validation. However, variable offset ptr alu is not prohibited for this ptr kind. So the variable offset is not checked. The following prog is accepted: func#0 @0 0: R1=ctx() R10=fp0 0: (bf) r6 = r1 ; R1=ctx() R6_w=ctx() 1: (79) r7 = *(u64 *)(r6 +144) ; R6_w=ctx() R7_w=flow_keys() 2: (b7) r8 = 1024 ; R8_w=1024 3: (37) r8 /= 1 ; R8_w=scalar() 4: (57) r8 &= 1024 ; R8_w=scalar(smin=smin32=0, smax=umax=smax32=umax32=1024,var_off=(0x0; 0x400)) 5: (0f) r7 += r8 mark_precise: frame0: last_idx 5 first_idx 0 subseq_idx -1 mark_precise: frame0: regs=r8 stack= before 4: (57) r8 &= 1024 mark_precise: frame0: regs=r8 stack= before 3: (37) r8 /= 1 mark_precise: frame0: regs=r8 stack= before 2: (b7) r8 = 1024 6: R7_w=flow_keys(smin=smin32=0,smax=umax=smax32=umax32=1024,var_off =(0x0; 0x400)) R8_w=scalar(smin=smin32=0,smax=umax=smax32=umax32=1024, var_off=(0x0; 0x400)) 6: (79) r0 = *(u64 *)(r7 +0) ; R0_w=scalar() 7: (95) exit This prog loads flow_keys to r7, and adds the variable offset r8 to r7, and finally causes out-of-bounds access: BUG: unable to handle page fault for address: ffffc90014c80038 [...] Call Trace: <TASK> bpf_dispatcher_nop_func include/linux/bpf.h:1231 [inline] __bpf_prog_run include/linux/filter.h:651 [inline] bpf_prog_run include/linux/filter.h:658 [inline] bpf_prog_run_pin_on_cpu include/linux/filter.h:675 [inline] bpf_flow_dissect+0x15f/0x350 net/core/flow_dissector.c:991 bpf_prog_test_run_flow_dissector+0x39d/0x620 net/bpf/test_run.c:1359 bpf_prog_test_run kernel/bpf/syscall.c:4107 [inline] __sys_bpf+0xf8f/0x4560 kernel/bpf/syscall.c:5475 __do_sys_bpf kernel/bpf/syscall.c:5561 [inline] __se_sys_bpf kernel/bpf/syscall.c:5559 [inline] __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:5559 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b Fix this by rejecting ptr alu with variable offset on flow_keys. Applying the patch rejects the program with \"R7 pointer arithmetic on flow_keys prohibited\".",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-002993": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: pvrusb2: fix use after free on context disconnection Upon module load, a kthread is created targeting the pvr2_context_thread_func function, which may call pvr2_context_destroy and thus call kfree() on the context object. However, that might happen before the usb hub_event handler is able to notify the driver. This patch adds a sanity check before the invalid read reported by syzbot, within the context disconnection call stack.",
        "technologies": "Linux\nLinux Kernel 4.19.306 未満\nLinux Kernel 4.20 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-002994": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: uio: Fix use-after-free in uio_open core-1 core-2 ------------------------------------------------------- uio_unregister_device uio_open idev = idr_find() device_unregister(&idev->dev) put_device(&idev->dev) uio_device_release get_device(&idev->dev) kfree(idev) uio_free_minor(minor) uio_release put_device(&idev->dev) kfree(idev) ------------------------------------------------------- In the core-1 uio_unregister_device(), the device_unregister will kfree idev when the idev->dev kobject ref is 1. But after core-1 device_unregister, put_device and before doing kfree, the core-2 may get_device. Then: 1. After core-1 kfree idev, the core-2 will do use-after-free for idev. 2. When core-2 do uio_release and put_device, the idev will be double freed. To address this issue, we can get idev atomic & inc idev reference with minor_lock.",
        "technologies": "Linux\nLinux Kernel 4.18.0 より大きい 4.19.306 未満\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.74 未満\nLinux Kernel 6.2.0 以上 6.6.13 未満\nLinux Kernel 6.7.0 以上 6.7.1 未満\nLinux Kernel 4.18"
    },
    "JVNDB-2024-003000": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: BPF: Prevent out-of-bounds memory access The test_tag test triggers an unhandled page fault: # ./test_tag [ 130.640218] CPU 0 Unable to handle kernel paging request at virtual address ffff80001b898004, era == 9000000003137f7c, ra == 9000000003139e70 [ 130.640501] Oops[#3]: [ 130.640553] CPU: 0 PID: 1326 Comm: test_tag Tainted: G D O 6.7.0-rc4-loong-devel-gb62ab1a397cf #47 61985c1d94084daa2432f771daa45b56b10d8d2a [ 130.640764] Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022 [ 130.640874] pc 9000000003137f7c ra 9000000003139e70 tp 9000000104cb4000 sp 9000000104cb7a40 [ 130.641001] a0 ffff80001b894000 a1 ffff80001b897ff8 a2 000000006ba210be a3 0000000000000000 [ 130.641128] a4 000000006ba210be a5 00000000000000f1 a6 00000000000000b3 a7 0000000000000000 [ 130.641256] t0 0000000000000000 t1 00000000000007f6 t2 0000000000000000 t3 9000000004091b70 [ 130.641387] t4 000000006ba210be t5 0000000000000004 t6 fffffffffffffff0 t7 90000000040913e0 [ 130.641512] t8 0000000000000005 u0 0000000000000dc0 s9 0000000000000009 s0 9000000104cb7ae0 [ 130.641641] s1 00000000000007f6 s2 0000000000000009 s3 0000000000000095 s4 0000000000000000 [ 130.641771] s5 ffff80001b894000 s6 ffff80001b897fb0 s7 9000000004090c50 s8 0000000000000000 [ 130.641900] ra: 9000000003139e70 build_body+0x1fcc/0x4988 [ 130.642007] ERA: 9000000003137f7c build_body+0xd8/0x4988 [ 130.642112] CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE) [ 130.642261] PRMD: 00000004 (PPLV0 +PIE -PWE) [ 130.642353] EUEN: 00000003 (+FPE +SXE -ASXE -BTE) [ 130.642458] ECFG: 00071c1c (LIE=2-4,10-12 VS=7) [ 130.642554] ESTAT: 00010000 [PIL] (IS= ECode=1 EsubCode=0) [ 130.642658] BADV: ffff80001b898004 [ 130.642719] PRID: 0014c010 (Loongson-64bit, Loongson-3A5000) [ 130.642815] Modules linked in: [last unloaded: bpf_testmod(O)] [ 130.642924] Process test_tag (pid: 1326, threadinfo=00000000f7f4015f, task=000000006499f9fd) [ 130.643062] Stack : 0000000000000000 9000000003380724 0000000000000000 0000000104cb7be8 [ 130.643213] 0000000000000000 25af8d9b6e600558 9000000106250ea0 9000000104cb7ae0 [ 130.643378] 0000000000000000 0000000000000000 9000000104cb7be8 90000000049f6000 [ 130.643538] 0000000000000090 9000000106250ea0 ffff80001b894000 ffff80001b894000 [ 130.643685] 00007ffffb917790 900000000313ca94 0000000000000000 0000000000000000 [ 130.643831] ffff80001b894000 0000000000000ff7 0000000000000000 9000000100468000 [ 130.643983] 0000000000000000 0000000000000000 0000000000000040 25af8d9b6e600558 [ 130.644131] 0000000000000bb7 ffff80001b894048 0000000000000000 0000000000000000 [ 130.644276] 9000000104cb7be8 90000000049f6000 0000000000000090 9000000104cb7bdc [ 130.644423] ffff80001b894000 0000000000000000 00007ffffb917790 90000000032acfb0 [ 130.644572] ... [ 130.644629] Call Trace: [ 130.644641] [<9000000003137f7c>] build_body+0xd8/0x4988 [ 130.644785] [<900000000313ca94>] bpf_int_jit_compile+0x228/0x4ec [ 130.644891] [<90000000032acfb0>] bpf_prog_select_runtime+0x158/0x1b0 [ 130.645003] [<90000000032b3504>] bpf_prog_load+0x760/0xb44 [ 130.645089] [<90000000032b6744>] __sys_bpf+0xbb8/0x2588 [ 130.645175] [<90000000032b8388>] sys_bpf+0x20/0x2c [ 130.645259] [<9000000003f6ab38>] do_syscall+0x7c/0x94 [ 130.645369] [<9000000003121c5c>] handle_syscall+0xbc/0x158 [ 130.645507] [ 130.645539] Code: 380839f6 380831f9 28412bae <24000ca6> 004081ad 0014cb50 004083e8 02bff34c 58008e91 [ 130.645729] [ 130.646418] ---[ end trace 0000000000000000 ]--- On my machine, which has CONFIG_PAGE_SIZE_16KB=y, the test failed at loading a BPF prog with 2039 instructions: prog = (struct bpf_prog *)ffff80001b894000 insn = (struct bpf_insn *)(prog->insnsi)fff ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-002996": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: tls: fix use-after-free with partial reads and async decrypt tls_decrypt_sg doesn't take a reference on the pages from clear_skb, so the put_page() in tls_decrypt_done releases them, and we trigger a use-after-free in process_rx_list when we try to read from the partially-read skb.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.79 未満\nLinux Kernel 6.2.0 以上 6.6.18 未満\nLinux Kernel 6.7.0 以上 6.7.6 未満"
    },
    "JVNDB-2024-003114": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i2c: i801: Fix block process call transactions According to the Intel datasheets, software must reset the block buffer index twice for block process call transactions: once before writing the outgoing data to the buffer, and once again before reading the incoming data from the buffer. The driver is currently missing the second reset, causing the wrong portion of the block buffer to be read.",
        "technologies": "Linux\nLinux Kernel 5.3.0 以上 5.4.269 未満\nLinux Kernel 5.5.0 以上 5.10.210 未満\nLinux Kernel 5.11.0 以上 5.15.149 未満\nLinux Kernel 5.16.0 以上 6.1.79 未満\nLinux Kernel 6.2.0 以上 6.6.18 未満\nLinux Kernel 6.7.0 以上 6.7.6 未満"
    },
    "JVNDB-2024-003054": {
        "title": "The Tukaani Project の xz における埋め込まれた悪意のあるコードに関する脆弱性",
        "description": "Malicious code was discovered in the upstream tarballs of xz, starting with version 5.6.0. Through a series of complex obfuscations, the liblzma build process extracts a prebuilt object file from a disguised test file existing in the source code, which is then used to modify specific functions in the liblzma code. This results in a modified liblzma library that can be used by any software linked against this library, intercepting and modifying the data interaction with this library.",
        "technologies": "The Tukaani Project\nxz 5.6.0\nxz 5.6.1"
    },
    "JVNDB-2024-003091": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pwm: Fix out-of-bounds access in of_pwm_single_xlate() With args->args_count == 2 args->args[2] is not defined. Actually the flags are contained in args->args[1].",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-003098": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: vgic-its: Avoid potential UAF in LPI translation cache There is a potential UAF scenario in the case of an LPI translation cache hit racing with an operation that invalidates the cache, such as a DISCARD ITS command. The root of the problem is that vgic_its_check_cache() does not elevate the refcount on the vgic_irq before dropping the lock that serializes refcount changes. Have vgic_its_check_cache() raise the refcount on the returned vgic_irq and add the corresponding decrement after queueing the interrupt.",
        "technologies": "Linux\nLinux Kernel 5.4.269 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-003100": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: qualcomm: rmnet: fix global oob in rmnet_policy The variable rmnet_link_ops assign a *bigger* maxtype which leads to a global out-of-bounds read when parsing the netlink attributes. See bug trace below: ================================================================== BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline] BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600 Read of size 1 at addr ffffffff92c438d0 by task syz-executor.6/84207 CPU: 0 PID: 84207 Comm: syz-executor.6 Tainted: G N 6.1.0 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:284 [inline] print_report+0x172/0x475 mm/kasan/report.c:395 kasan_report+0xbb/0x1c0 mm/kasan/report.c:495 validate_nla lib/nlattr.c:386 [inline] __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600 __nla_parse+0x3e/0x50 lib/nlattr.c:697 nla_parse_nested_deprecated include/net/netlink.h:1248 [inline] __rtnl_newlink+0x50a/0x1880 net/core/rtnetlink.c:3485 rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3594 rtnetlink_rcv_msg+0x43c/0xd70 net/core/rtnetlink.c:6091 netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg+0x154/0x190 net/socket.c:734 ____sys_sendmsg+0x6df/0x840 net/socket.c:2482 ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536 __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fdcf2072359 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fdcf13e3168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007fdcf219ff80 RCX: 00007fdcf2072359 RDX: 0000000000000000 RSI: 0000000020000200 RDI: 0000000000000003 RBP: 00007fdcf20bd493 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007fffbb8d7bdf R14: 00007fdcf13e3300 R15: 0000000000022000 </TASK> The buggy address belongs to the variable: rmnet_policy+0x30/0xe0 The buggy address belongs to the physical page: page:0000000065bdeb3c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x155243 flags: 0x200000000001000(reserved|node=0|zone=2) raw: 0200000000001000 ffffea00055490c8 ffffea00055490c8 0000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffffffff92c43780: f9 f9 f9 f9 00 00 00 02 f9 f9 f9 f9 00 00 00 07 ffffffff92c43800: f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 06 f9 f9 f9 >ffffffff92c43880: f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9 ^ ffffffff92c43900: 00 00 00 00 00 00 00 00 07 f9 f9 f9 f9 f9 f9 f9 ffffffff92c43980: 00 00 00 07 f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 According to the comment of `nla_parse_nested_deprecated`, the maxtype should be len(destination array) - 1. Hence use `IFLA_RMNET_MAX` here.",
        "technologies": "Linux\nLinux Kernel 4.17.0 以上 4.19.306 未満\nLinux Kernel 4.20.0 以上 5.4.268 未満\nLinux Kernel 5.5.0 以上 5.10.209 未満\nLinux Kernel 5.11.0 以上 5.15.148 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2023-028699": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.4.232 未満\nLinux Kernel 5.5 以上 5.10.169 未満\nLinux Kernel 5.11 以上 5.15.95 未満\nLinux Kernel 5.16 以上 6.1.13 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2024-003118": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: validate mech token in session setup If client send invalid mech token in session setup request, ksmbd validate and make the error if it is invalid.",
        "technologies": "Linux\nLinux Kernel 5.15.149 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-003121": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix UAF issue in ksmbd_tcp_new_connection() The race is between the handling of a new TCP connection and its disconnection. It leads to UAF on `struct tcp_transport` in ksmbd_tcp_new_connection() function.",
        "technologies": "Linux\nLinux Kernel 5.15.0 以上 5.15.149 未満\nLinux Kernel 5.16.0 以上 6.1.75 未満\nLinux Kernel 6.2.0 以上 6.6.14 未満\nLinux Kernel 6.7.0 以上 6.7.2 未満"
    },
    "JVNDB-2024-003115": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_set_rbtree: skip end interval element from gc rbtree lazy gc on insert might collect an end interval element that has been just added in this transactions, skip end interval elements that are not yet active.",
        "technologies": "Linux\nLinux Kernel 5.4.269 未満\nLinux Kernel 5.5.0 以上 5.10.210 未満\nLinux Kernel 5.11.0 以上 5.15.149 未満\nLinux Kernel 5.16.0 以上 6.1.78 未満\nLinux Kernel 6.2.0 以上 6.6.17 未満\nLinux Kernel 6.7.0 以上 6.7.5 未満"
    },
    "JVNDB-2024-003134": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix dcn35 8k30 Underflow/Corruption Issue [why] odm calculation is missing for pipe split policy determination and cause Underflow/Corruption issue. [how] Add the odm calculation.",
        "technologies": "Linux\nLinux Kernel 6.7.6 未満"
    },
    "JVNDB-2024-003140": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix stackmap overflow check on 32-bit arches The stackmap code relies on roundup_pow_of_two() to compute the number of hash buckets, and contains an overflow check by checking if the resulting value is 0. However, on 32-bit arches, the roundup code itself can overflow by doing a 32-bit left-shift of an unsigned long value, which is undefined behaviour, so it is not guaranteed to truncate neatly. This was triggered by syzbot on the DEVMAP_HASH type, which contains the same check, copied from the hashtab code. The commit in the fixes tag actually attempted to fix this, but the fix did not account for the UB, so the fix only works on CPUs where an overflow does result in a neat truncation to zero, which is not guaranteed. Checking the value before rounding does not have this problem.",
        "technologies": "Linux\nLinux Kernel 4.19.311 未満\nLinux Kernel 4.20 以上 5.4.273 未満\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-003156": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Fix fortify source warning while accessing Eth segment ------------[ cut here ]------------ memcpy: detected field-spanning write (size 56) of single field \"eseg->inline_hdr.start\" at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 (size 2) WARNING: CPU: 0 PID: 293779 at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib] Modules linked in: 8021q garp mrp stp llc rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) ib_uverbs(OE) ib_core(OE) mlx5_core(OE) pci_hyperv_intf mlxdevm(OE) mlx_compat(OE) tls mlxfw(OE) psample nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink mst_pciconf(OE) knem(OE) vfio_pci vfio_pci_core vfio_iommu_type1 vfio iommufd irqbypass cuse nfsv3 nfs fscache netfs xfrm_user xfrm_algo ipmi_devintf ipmi_msghandler binfmt_misc crct10dif_pclmul crc32_pclmul polyval_clmulni polyval_generic ghash_clmulni_intel sha512_ssse3 snd_pcsp aesni_intel crypto_simd cryptd snd_pcm snd_timer joydev snd soundcore input_leds serio_raw evbug nfsd auth_rpcgss nfs_acl lockd grace sch_fq_codel sunrpc drm efi_pstore ip_tables x_tables autofs4 psmouse virtio_net net_failover failover floppy [last unloaded: mlx_compat(OE)] CPU: 0 PID: 293779 Comm: ssh Tainted: G OE 6.2.0-32-generic #32~22.04.1-Ubuntu Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011 RIP: 0010:mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib] Code: 0c 01 00 a8 01 75 25 48 8b 75 a0 b9 02 00 00 00 48 c7 c2 10 5b fd c0 48 c7 c7 80 5b fd c0 c6 05 57 0c 03 00 01 e8 95 4d 93 da <0f> 0b 44 8b 4d b0 4c 8b 45 c8 48 8b 4d c0 e9 49 fb ff ff 41 0f b7 RSP: 0018:ffffb5b48478b570 EFLAGS: 00010046 RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000 RBP: ffffb5b48478b628 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: ffffb5b48478b5e8 R13: ffff963a3c609b5e R14: ffff9639c3fbd800 R15: ffffb5b480475a80 FS: 00007fc03b444c80(0000) GS:ffff963a3dc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000556f46bdf000 CR3: 0000000006ac6003 CR4: 00000000003706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? show_regs+0x72/0x90 ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib] ? __warn+0x8d/0x160 ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib] ? report_bug+0x1bb/0x1d0 ? handle_bug+0x46/0x90 ? exc_invalid_op+0x19/0x80 ? asm_exc_invalid_op+0x1b/0x20 ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib] mlx5_ib_post_send_nodrain+0xb/0x20 [mlx5_ib] ipoib_send+0x2ec/0x770 [ib_ipoib] ipoib_start_xmit+0x5a0/0x770 [ib_ipoib] dev_hard_start_xmit+0x8e/0x1e0 ? validate_xmit_skb_list+0x4d/0x80 sch_direct_xmit+0x116/0x3a0 __dev_xmit_skb+0x1fd/0x580 __dev_queue_xmit+0x284/0x6b0 ? _raw_spin_unlock_irq+0xe/0x50 ? __flush_work.isra.0+0x20d/0x370 ? push_pseudo_header+0x17/0x40 [ib_ipoib] neigh_connected_output+0xcd/0x110 ip_finish_output2+0x179/0x480 ? __smp_call_single_queue+0x61/0xa0 __ip_finish_output+0xc3/0x190 ip_finish_output+0x2e/0xf0 ip_output+0x78/0x110 ? __pfx_ip_finish_output+0x10/0x10 ip_local_out+0x64/0x70 __ip_queue_xmit+0x18a/0x460 ip_queue_xmit+0x15/0x30 __tcp_transmit_skb+0x914/0x9c0 tcp_write_xmit+0x334/0x8d0 tcp_push_one+0x3c/0x60 tcp_sendmsg_locked+0x2e1/0xac0 tcp_sendmsg+0x2d/0x50 inet_sendmsg+0x43/0x90 sock_sendmsg+0x68/0x80 sock_write_iter+0x93/0x100 vfs_write+0x326/0x3c0 ksys_write+0xbd/0xf0 ? do_syscall_64+0x69/0x90 __x64_sys_write+0x19/0x30 do_syscall_ ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満"
    },
    "JVNDB-2024-003155": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix DEVMAP_HASH overflow check on 32-bit arches The devmap code allocates a number hash buckets equal to the next power of two of the max_entries value provided when creating the map. When rounding up to the next power of two, the 32-bit variable storing the number of buckets can overflow, and the code checks for overflow by checking if the truncated 32-bit value is equal to 0. However, on 32-bit arches the rounding up itself can overflow mid-way through, because it ends up doing a left-shift of 32 bits on an unsigned long value. If the size of an unsigned long is four bytes, this is undefined behaviour, so there is no guarantee that we'll end up with a nice and tidy 0-value at the end. Syzbot managed to turn this into a crash on arm32 by creating a DEVMAP_HASH with max_entries > 0x80000000 and then trying to update it. Fix this by moving the overflow check to before the rounding up operation.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-003153": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: aoe: fix the potential use-after-free problem in aoecmd_cfg_pkts This patch is against CVE-2023-6270. The description of cve is: A flaw was found in the ATA over Ethernet (AoE) driver in the Linux kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on `struct net_device`, and a use-after-free can be triggered by racing between the free on the struct and the access through the `skbtxq` global queue. This could lead to a denial of service condition or potential code execution. In aoecmd_cfg_pkts(), it always calls dev_put(ifp) when skb initial code is finished. But the net_device ifp will still be used in later tx()->dev_queue_xmit() in kthread. Which means that the dev_put(ifp) should NOT be called in the success path of skb initial code in aoecmd_cfg_pkts(). Otherwise tx() may run into use-after-free because the net_device is freed. This patch removed the dev_put(ifp) in the success path in aoecmd_cfg_pkts(), and added dev_put() after skb xmit in tx().",
        "technologies": "Linux\nLinux Kernel 2.6.22 以上 4.19.311 未満\nLinux Kernel 4.20 以上 5.4.273 未満\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2023-028653": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.91 未満\nLinux Kernel 5.16 以上 6.1.9 未満\nLinux Kernel 6.2"
    },
    "JVNDB-2024-003213": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fork: defer linking file vma until vma is fully initialized Thorvald reported a WARNING [1]. And the root cause is below race: CPU 1 CPU 2 fork hugetlbfs_fallocate dup_mmap hugetlbfs_punch_hole i_mmap_lock_write(mapping); vma_interval_tree_insert_after -- Child vma is visible through i_mmap tree. i_mmap_unlock_write(mapping); hugetlb_dup_vma_private -- Clear vma_lock outside i_mmap_rwsem! i_mmap_lock_write(mapping); hugetlb_vmdelete_list vma_interval_tree_foreach hugetlb_vma_trylock_write -- Vma_lock is cleared. tmp->vm_ops->open -- Alloc new vma_lock outside i_mmap_rwsem! hugetlb_vma_unlock_write -- Vma_lock is assigned!!! i_mmap_unlock_write(mapping); hugetlb_dup_vma_private() and hugetlb_vm_op_open() are called outside i_mmap_rwsem lock while vma lock can be used in the same time. Fix this by deferring linking file vma until vma is fully initialized. Those vmas should be initialized first before they can be used.",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003214": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: r8169: fix LED-related deadlock on module removal Binding devm_led_classdev_register() to the netdev is problematic because on module removal we get a RTNL-related deadlock. Fix this by avoiding the device-managed LED functions. Note: We can safely call led_classdev_unregister() for a LED even if registering it failed, because led_classdev_unregister() detects this and is a no-op in this case.",
        "technologies": "Fedora Project\nFedora 38\nFedora 39\nFedora 40\nLinux\nLinux Kernel 6.8 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003217": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: br_netfilter: skip conntrack input hook for promisc packets For historical reasons, when bridge device is in promisc mode, packets that are directed to the taps follow bridge input hook path. This patch adds a workaround to reset conntrack for these packets. Jianbo Liu reports warning splats in their test infrastructure where cloned packets reach the br_netfilter input hook to confirm the conntrack object. Scratch one bit from BR_INPUT_SKB_CB to annotate that this packet has reached the input hook because it is passed up to the bridge device to reach the taps. [ 57.571874] WARNING: CPU: 1 PID: 0 at net/bridge/br_netfilter_hooks.c:616 br_nf_local_in+0x157/0x180 [br_netfilter] [ 57.572749] Modules linked in: xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat xt_addrtype xt_conntrack nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_isc si ib_umad rdma_cm ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5ctl mlx5_core [ 57.575158] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.8.0+ #19 [ 57.575700] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [ 57.576662] RIP: 0010:br_nf_local_in+0x157/0x180 [br_netfilter] [ 57.577195] Code: fe ff ff 41 bd 04 00 00 00 be 04 00 00 00 e9 4a ff ff ff be 04 00 00 00 48 89 ef e8 f3 a9 3c e1 66 83 ad b4 00 00 00 04 eb 91 <0f> 0b e9 f1 fe ff ff 0f 0b e9 df fe ff ff 48 89 df e8 b3 53 47 e1 [ 57.578722] RSP: 0018:ffff88885f845a08 EFLAGS: 00010202 [ 57.579207] RAX: 0000000000000002 RBX: ffff88812dfe8000 RCX: 0000000000000000 [ 57.579830] RDX: ffff88885f845a60 RSI: ffff8881022dc300 RDI: 0000000000000000 [ 57.580454] RBP: ffff88885f845a60 R08: 0000000000000001 R09: 0000000000000003 [ 57.581076] R10: 00000000ffff1300 R11: 0000000000000002 R12: 0000000000000000 [ 57.581695] R13: ffff8881047ffe00 R14: ffff888108dbee00 R15: ffff88814519b800 [ 57.582313] FS: 0000000000000000(0000) GS:ffff88885f840000(0000) knlGS:0000000000000000 [ 57.583040] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 57.583564] CR2: 000000c4206aa000 CR3: 0000000103847001 CR4: 0000000000370eb0 [ 57.584194] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 57.584820] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 57.585440] Call Trace: [ 57.585721] <IRQ> [ 57.585976] ? __warn+0x7d/0x130 [ 57.586323] ? br_nf_local_in+0x157/0x180 [br_netfilter] [ 57.586811] ? report_bug+0xf1/0x1c0 [ 57.587177] ? handle_bug+0x3f/0x70 [ 57.587539] ? exc_invalid_op+0x13/0x60 [ 57.587929] ? asm_exc_invalid_op+0x16/0x20 [ 57.588336] ? br_nf_local_in+0x157/0x180 [br_netfilter] [ 57.588825] nf_hook_slow+0x3d/0xd0 [ 57.589188] ? br_handle_vlan+0x4b/0x110 [ 57.589579] br_pass_frame_up+0xfc/0x150 [ 57.589970] ? br_port_flags_change+0x40/0x40 [ 57.590396] br_handle_frame_finish+0x346/0x5e0 [ 57.590837] ? ipt_do_table+0x32e/0x430 [ 57.591221] ? br_handle_local_finish+0x20/0x20 [ 57.591656] br_nf_hook_thresh+0x4b/0xf0 [br_netfilter] [ 57.592286] ? br_handle_local_finish+0x20/0x20 [ 57.592802] br_nf_pre_routing_finish+0x178/0x480 [br_netfilter] [ 57.593348] ? br_handle_local_finish+0x20/0x20 [ 57.593782] ? nf_nat_ipv4_pre_routing+0x25/0x60 [nf_nat] [ 57.594279] br_nf_pre_routing+0x24c/0x550 [br_netfilter] [ 57.594780] ? br_nf_hook_thresh+0xf0/0xf0 [br_netfilter] [ 57.595280] br_handle_frame+0x1f3/0x3d0 [ 57.595676] ? br_handle_local_finish+0x20/0x20 [ 57.596118] ? br_handle_frame_finish+0x5e0/0x5e0 [ 57.596566] __netif_receive_skb_core+0x25b/0xfc0 [ 57.597017] ? __napi_build_skb+0x37/0x40 [ 57.597418] __netif_receive_skb_list_core+0xfb/0x220",
        "technologies": "Fedora Project\nFedora 38\nFedora 39\nFedora 40\nLinux\nLinux Kernel 5.15.157 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003175": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ip_tunnel: make sure to pull inner header in ip_tunnel_rcv() Apply the same fix than ones found in : 8d975c15c0cd (\"ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()\") 1ca1ba465e55 (\"geneve: make sure to pull inner header in geneve_rx()\") We have to save skb->network_header in a temporary variable in order to be able to recompute the network_header pointer after a pskb_inet_may_pull() call. pskb_inet_may_pull() makes sure the needed headers are in skb->head. syzbot reported: BUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline] BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline] BUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline] BUG: KMSAN: uninit-value in ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409 __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline] INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline] IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline] ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409 __ipgre_rcv+0x9bc/0xbc0 net/ipv4/ip_gre.c:389 ipgre_rcv net/ipv4/ip_gre.c:411 [inline] gre_rcv+0x423/0x19f0 net/ipv4/ip_gre.c:447 gre_rcv+0x2a4/0x390 net/ipv4/gre_demux.c:163 ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233 NF_HOOK include/linux/netfilter.h:314 [inline] ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254 dst_input include/net/dst.h:461 [inline] ip_rcv_finish net/ipv4/ip_input.c:449 [inline] NF_HOOK include/linux/netfilter.h:314 [inline] ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569 __netif_receive_skb_one_core net/core/dev.c:5534 [inline] __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648 netif_receive_skb_internal net/core/dev.c:5734 [inline] netif_receive_skb+0x58/0x660 net/core/dev.c:5793 tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1556 tun_get_user+0x53b9/0x66e0 drivers/net/tun.c:2009 tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055 call_write_iter include/linux/fs.h:2087 [inline] new_sync_write fs/read_write.c:497 [inline] vfs_write+0xb6b/0x1520 fs/read_write.c:590 ksys_write+0x20f/0x4c0 fs/read_write.c:643 __do_sys_write fs/read_write.c:655 [inline] __se_sys_write fs/read_write.c:652 [inline] __x64_sys_write+0x93/0xd0 fs/read_write.c:652 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b Uninit was created at: __alloc_pages+0x9a6/0xe00 mm/page_alloc.c:4590 alloc_pages_mpol+0x62b/0x9d0 mm/mempolicy.c:2133 alloc_pages+0x1be/0x1e0 mm/mempolicy.c:2204 skb_page_frag_refill+0x2bf/0x7c0 net/core/sock.c:2909 tun_build_skb drivers/net/tun.c:1686 [inline] tun_get_user+0xe0a/0x66e0 drivers/net/tun.c:1826 tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055 call_write_iter include/linux/fs.h:2087 [inline] new_sync_write fs/read_write.c:497 [inline] vfs_write+0xb6b/0x1520 fs/read_write.c:590 ksys_write+0x20f/0x4c0 fs/read_write.c:643 __do_sys_write fs/read_write.c:655 [inline] __se_sys_write fs/read_write.c:652 [inline] __x64_sys_write+0x93/0xd0 fs/read_write.c:652 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b",
        "technologies": "Linux\nLinux Kernel 3.10 以上 5.4.273 未満\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-003764": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tpm_tis_spi: Account for SPI header when allocating TPM SPI xfer buffer The TPM SPI transfer mechanism uses MAX_SPI_FRAMESIZE for computing the maximum transfer length and the size of the transfer buffer. As such, it does not account for the 4 bytes of header that prepends the SPI data frame. This can result in out-of-bounds accesses and was confirmed with KASAN. Introduce SPI_HDRSIZE to account for the header and use to allocate the transfer buffer.",
        "technologies": "Linux\nLinux Kernel 6.6.0 未満\nLinux Kernel 6.6.1 以上 6.6.33 未満\nLinux Kernel 6.9 以上 6.9.4 未満\nLinux Kernel 6.10.0"
    },
    "JVNDB-2024-003481": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: fix __dst_negative_advice() race __dst_negative_advice() does not enforce proper RCU rules when sk->dst_cache must be cleared, leading to possible UAF. RCU rules are that we must first clear sk->sk_dst_cache, then call dst_release(old_dst). Note that sk_dst_reset(sk) is implementing this protocol correctly, while __dst_negative_advice() uses the wrong order. Given that ip6_negative_advice() has special logic against RTF_CACHE, this means each of the three ->negative_advice() existing methods must perform the sk_dst_reset() themselves. Note the check against NULL dst is centralized in __dst_negative_advice(), there is no need to duplicate it in various callbacks. Many thanks to Clement Lecigne for tracking this issue. This old bug became visible after the blamed commit, using UDP sockets.",
        "technologies": "Linux\nLinux Kernel 4.6 以上 6.9.4 未満\nLinux Kernel 6.10.0"
    },
    "JVNDB-2024-003139": {
        "title": "Linux の Linux Kernel におけるバッファエラーの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix hashtab overflow check on 32-bit arches The hashtab code relies on roundup_pow_of_two() to compute the number of hash buckets, and contains an overflow check by checking if the resulting value is 0. However, on 32-bit arches, the roundup code itself can overflow by doing a 32-bit left-shift of an unsigned long value, which is undefined behaviour, so it is not guaranteed to truncate neatly. This was triggered by syzbot on the DEVMAP_HASH type, which contains the same check, copied from the hashtab code. So apply the same fix to hashtab, by moving the overflow check to before the roundup.",
        "technologies": "Linux\nLinux Kernel 3.19 以上 4.19.311 未満\nLinux Kernel 4.20 以上 5.4.273 未満\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-003247": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: fix double-free issue in tcpm_port_unregister_pd() When unregister pd capabilitie in tcpm, KASAN will capture below double -free issue. The root cause is the same capabilitiy will be kfreed twice, the first time is kfreed by pd_capabilities_release() and the second time is explicitly kfreed by tcpm_port_unregister_pd(). [ 3.988059] BUG: KASAN: double-free in tcpm_port_unregister_pd+0x1a4/0x3dc [ 3.995001] Free of addr ffff0008164d3000 by task kworker/u16:0/10 [ 4.001206] [ 4.002712] CPU: 2 PID: 10 Comm: kworker/u16:0 Not tainted 6.8.0-rc5-next-20240220-05616-g52728c567a55 #53 [ 4.012402] Hardware name: Freescale i.MX8QXP MEK (DT) [ 4.017569] Workqueue: events_unbound deferred_probe_work_func [ 4.023456] Call trace: [ 4.025920] dump_backtrace+0x94/0xec [ 4.029629] show_stack+0x18/0x24 [ 4.032974] dump_stack_lvl+0x78/0x90 [ 4.036675] print_report+0xfc/0x5c0 [ 4.040289] kasan_report_invalid_free+0xa0/0xc0 [ 4.044937] __kasan_slab_free+0x124/0x154 [ 4.049072] kfree+0xb4/0x1e8 [ 4.052069] tcpm_port_unregister_pd+0x1a4/0x3dc [ 4.056725] tcpm_register_port+0x1dd0/0x2558 [ 4.061121] tcpci_register_port+0x420/0x71c [ 4.065430] tcpci_probe+0x118/0x2e0 To fix the issue, this will remove kree() from tcpm_port_unregister_pd().",
        "technologies": "Linux\nLinux Kernel 6.8 より大きい 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003244": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: USB: core: Fix deadlock in usb_deauthorize_interface() Among the attribute file callback routines in drivers/usb/core/sysfs.c, the interface_authorized_store() function is the only one which acquires a device lock on an ancestor device: It calls usb_deauthorize_interface(), which locks the interface's parent USB device. The will lead to deadlock if another process already owns that lock and tries to remove the interface, whether through a configuration change or because the device has been disconnected. As part of the removal procedure, device_del() waits for all ongoing sysfs attribute callbacks to complete. But usb_deauthorize_interface() can't complete until the device lock has been released, and the lock won't be released until the removal has finished. The mechanism provided by sysfs to prevent this kind of deadlock is to use the sysfs_break_active_protection() function, which tells sysfs not to wait for the attribute callback. Reported-and-tested by: Yue Sun <samsun1006219@gmail.com> Reported by: xingwei lee <xrivendell7@gmail.com>",
        "technologies": "Linux\nLinux Kernel 4.4 以上 4.19.312 未満\nLinux Kernel 4.20.0 以上 5.4.274 未満\nLinux Kernel 5.5.0 以上 5.10.215 未満\nLinux Kernel 5.11.0 以上 5.15.154 未満\nLinux Kernel 5.16.0 以上 6.1.84 未満\nLinux Kernel 6.2.0 以上 6.6.24 未満\nLinux Kernel 6.7.0 以上 6.7.12 未満\nLinux Kernel 6.8.0 以上 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003248": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Fix double free of the ha->vp_map pointer Coverity scan reported potential risk of double free of the pointer ha->vp_map. ha->vp_map was freed in qla2x00_mem_alloc(), and again freed in function qla2x00_mem_free(ha). Assign NULL to vp_map and kfree take care of NULL.",
        "technologies": "Linux\nLinux Kernel 6.6.24 未満\nLinux Kernel 6.7 より大きい 6.7.12 未満\nLinux Kernel 6.8 より大きい 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003245": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: USB: core: Fix deadlock in port \"disable\" sysfs attribute The show and store callback routines for the \"disable\" sysfs attribute file in port.c acquire the device lock for the port's parent hub device. This can cause problems if another process has locked the hub to remove it or change its configuration: Removing the hub or changing its configuration requires the hub interface to be removed, which requires the port device to be removed, and device_del() waits until all outstanding sysfs attribute callbacks for the ports have returned. The lock can't be released until then. But the disable_show() or disable_store() routine can't return until after it has acquired the lock. The resulting deadlock can be avoided by calling sysfs_break_active_protection(). This will cause the sysfs core not to wait for the attribute's callback routine to return, allowing the removal to proceed. The disadvantage is that after making this call, there is no guarantee that the hub structure won't be deallocated at any moment. To prevent this, we have to acquire a reference to it first by calling hub_get().",
        "technologies": "Linux\nLinux Kernel 6.1.84 未満\nLinux Kernel 6.2.0 以上 6.6.24 未満\nLinux Kernel 6.7.0 以上 6.7.12 未満\nLinux Kernel 6.8.0 以上 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003229": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix potencial out-of-bounds when buffer offset is invalid I found potencial out-of-bounds when buffer offset fields of a few requests is invalid. This patch set the minimum value of buffer offset field to ->Buffer offset to validate buffer length.",
        "technologies": "Linux\nLinux Kernel 6.7.12 未満\nLinux Kernel 6.8 より大きい 6.8.3 未満"
    },
    "JVNDB-2024-003215": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: Fix potential data-race in __nft_expr_type_get() nft_unregister_expr() can concurrent with __nft_expr_type_get(), and there is not any protection when iterate over nf_tables_expressions list in __nft_expr_type_get(). Therefore, there is potential data-race of nf_tables_expressions list entry. Use list_for_each_entry_rcu() to iterate over nf_tables_expressions list in __nft_expr_type_get(), and use rcu_read_lock() in the caller nft_expr_type_get() to protect the entire type query process.",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.19.313 未満\nLinux Kernel 4.20 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.157 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-003798": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix buffer size in gfx_v9_4_3_init_ cp_compute_microcode() and rlc_microcode() The function gfx_v9_4_3_init_microcode in gfx_v9_4_3.c was generating about potential truncation of output when using the snprintf function. The issue was due to the size of the buffer 'ucode_prefix' being too small to accommodate the maximum possible length of the string being written into it. The string being written is \"amdgpu/%s_mec.bin\" or \"amdgpu/%s_rlc.bin\", where %s is replaced by the value of 'chip_name'. The length of this string without the %s is 16 characters. The warning message indicated that 'chip_name' could be up to 29 characters long, resulting in a total of 45 characters, which exceeds the buffer size of 30 characters. To resolve this issue, the size of the 'ucode_prefix' buffer has been reduced from 30 to 15. This ensures that the maximum possible length of the string being written into the buffer will not exceed its size, thus preventing potential buffer overflow and truncation issues. Fixes the below with gcc W=1: drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c: In function ‘gfx_v9_4_3_early_init’: drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c:379:52: warning: ‘%s’ directive output may be truncated writing up to 29 bytes into a region of size 23 [-Wformat-truncation=] 379 | snprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc.bin\", chip_name); | ^~ ...... 439 | r = gfx_v9_4_3_init_rlc_microcode(adev, ucode_prefix); | ~~~~~~~~~~~~ drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c:379:9: note: ‘snprintf’ output between 16 and 45 bytes into a destination of size 30 379 | snprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_rlc.bin\", chip_name); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c:413:52: warning: ‘%s’ directive output may be truncated writing up to 29 bytes into a region of size 23 [-Wformat-truncation=] 413 | snprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", chip_name); | ^~ ...... 443 | r = gfx_v9_4_3_init_cp_compute_microcode(adev, ucode_prefix); | ~~~~~~~~~~~~ drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c:413:9: note: ‘snprintf’ output between 16 and 45 bytes into a destination of size 30 413 | snprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_mec.bin\", chip_name); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
        "technologies": "Linux\nLinux Kernel 6.5 未満\nLinux Kernel 6.6 以上 6.6.33 未満\nLinux Kernel 6.9 以上 6.9.4 未満\nLinux Kernel 6.10.0"
    },
    "JVNDB-2024-003765": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dma-mapping: benchmark: handle NUMA_NO_NODE correctly cpumask_of_node() can be called for NUMA_NO_NODE inside do_map_benchmark() resulting in the following sanitizer report: UBSAN: array-index-out-of-bounds in ./arch/x86/include/asm/topology.h:72:28 index -1 is out of range for type 'cpumask [64][1]' CPU: 1 PID: 990 Comm: dma_map_benchma Not tainted 6.9.0-rc6 #29 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:117) ubsan_epilogue (lib/ubsan.c:232) __ubsan_handle_out_of_bounds (lib/ubsan.c:429) cpumask_of_node (arch/x86/include/asm/topology.h:72) [inline] do_map_benchmark (kernel/dma/map_benchmark.c:104) map_benchmark_ioctl (kernel/dma/map_benchmark.c:246) full_proxy_unlocked_ioctl (fs/debugfs/file.c:333) __x64_sys_ioctl (fs/ioctl.c:890) do_syscall_64 (arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) Use cpumask_of_node() in place when binding a kernel thread to a cpuset of a particular node. Note that the provided node id is checked inside map_benchmark_ioctl(). It's just a NUMA_NO_NODE case which is not handled properly later. Found by Linux Verification Center (linuxtesting.org).",
        "technologies": "Linux\nLinux Kernel 5.11 未満\nLinux Kernel 5.15 以上 5.15.161 未満\nLinux Kernel 6.1 以上 6.1.93 未満\nLinux Kernel 6.6 以上 6.6.33 未満\nLinux Kernel 6.9 以上 6.9.4 未満\nLinux Kernel 6.10.0"
    },
    "JVNDB-2024-004918": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dsa: mv88e6xxx: Correct check for empty list Since commit a3c53be55c95 (\"net: dsa: mv88e6xxx: Support multiple MDIO busses\") mv88e6xxx_default_mdio_bus() has checked that the return value of list_first_entry() is non-NULL. This appears to be intended to guard against the list chip->mdios being empty. However, it is not the correct check as the implementation of list_first_entry is not designed to return NULL for empty lists. Instead, use list_first_entry_or_null() which does return NULL if the list is empty. Flagged by Smatch. Compile tested only.",
        "technologies": "Linux\nLinux Kernel 4.11 以上 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-004963": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Avoid uninitialized value in BPF_CORE_READ_BITFIELD [Changes from V1: - Use a default branch in the switch statement to initialize `val'.] GCC warns that `val' may be used uninitialized in the BPF_CRE_READ_BITFIELD macro, defined in bpf_core_read.h as: [...] unsigned long long val; \\ [...] \\ switch (__CORE_RELO(s, field, BYTE_SIZE)) { \\ case 1: val = *(const unsigned char *)p; break; \\ case 2: val = *(const unsigned short *)p; break; \\ case 4: val = *(const unsigned int *)p; break; \\ case 8: val = *(const unsigned long long *)p; break; \\ } \\ [...] val; \\ } \\ This patch adds a default entry in the switch statement that sets `val' to zero in order to avoid the warning, and random values to be used in case __builtin_preserve_field_info returns unexpected values for BPF_FIELD_BYTE_SIZE. Tested in bpf-next master. No regressions.",
        "technologies": "Linux\nLinux Kernel 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-005162": {
        "title": "Linux 用 journyx におけるコードインジェクションの脆弱性",
        "description": "Attackers with a valid username and password can exploit a python code injection vulnerability during the natural login flow.",
        "technologies": "journyx\njournyx 11.5.4"
    },
    "JVNDB-2024-005297": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/gt: Fix potential UAF by revoke of fence registers CI has been sporadically reporting the following issue triggered by igt@i915_selftest@live@hangcheck on ADL-P and similar machines: <6> [414.049203] i915: Running intel_hangcheck_live_selftests/igt_reset_evict_fence ... <6> [414.068804] i915 0000:00:02.0: [drm] GT0: GUC: submission enabled <6> [414.068812] i915 0000:00:02.0: [drm] GT0: GUC: SLPC enabled <3> [414.070354] Unable to pin Y-tiled fence; err:-4 <3> [414.071282] i915_vma_revoke_fence:301 GEM_BUG_ON(!i915_active_is_idle(&fence->active)) ... <4>[ 609.603992] ------------[ cut here ]------------ <2>[ 609.603995] kernel BUG at drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:301! <4>[ 609.604003] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI <4>[ 609.604006] CPU: 0 PID: 268 Comm: kworker/u64:3 Tainted: G U W 6.9.0-CI_DRM_14785-g1ba62f8cea9c+ #1 <4>[ 609.604008] Hardware name: Intel Corporation Alder Lake Client Platform/AlderLake-P DDR4 RVP, BIOS RPLPFWI1.R00.4035.A00.2301200723 01/20/2023 <4>[ 609.604010] Workqueue: i915 __i915_gem_free_work [i915] <4>[ 609.604149] RIP: 0010:i915_vma_revoke_fence+0x187/0x1f0 [i915] ... <4>[ 609.604271] Call Trace: <4>[ 609.604273] <TASK> ... <4>[ 609.604716] __i915_vma_evict+0x2e9/0x550 [i915] <4>[ 609.604852] __i915_vma_unbind+0x7c/0x160 [i915] <4>[ 609.604977] force_unbind+0x24/0xa0 [i915] <4>[ 609.605098] i915_vma_destroy+0x2f/0xa0 [i915] <4>[ 609.605210] __i915_gem_object_pages_fini+0x51/0x2f0 [i915] <4>[ 609.605330] __i915_gem_free_objects.isra.0+0x6a/0xc0 [i915] <4>[ 609.605440] process_scheduled_works+0x351/0x690 ... In the past, there were similar failures reported by CI from other IGT tests, observed on other platforms. Before commit 63baf4f3d587 (\"drm/i915/gt: Only wait for GPU activity before unbinding a GGTT fence\"), i915_vma_revoke_fence() was waiting for idleness of vma->active via fence_update(). That commit introduced vma->fence->active in order for the fence_update() to be able to wait selectively on that one instead of vma->active since only idleness of fence registers was needed. But then, another commit 0d86ee35097a (\"drm/i915/gt: Make fence revocation unequivocal\") replaced the call to fence_update() in i915_vma_revoke_fence() with only fence_write(), and also added that GEM_BUG_ON(!i915_active_is_idle(&fence->active)) in front. No justification was provided on why we might then expect idleness of vma->fence->active without first waiting on it. The issue can be potentially caused by a race among revocation of fence registers on one side and sequential execution of signal callbacks invoked on completion of a request that was using them on the other, still processed in parallel to revocation of those fence registers. Fix it by waiting for idleness of vma->fence->active in i915_vma_revoke_fence(). (cherry picked from commit 24bb052d3dd499c5956abad5f7d8e4fd07da7fb1)",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満"
    },
    "JVNDB-2024-004958": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gve: Account for stopped queues when reading NIC stats We now account for the fact that the NIC might send us stats for a subset of queues. Without this change, gve_get_ethtool_stats might make an invalid access on the priv->stats_report->stats array.",
        "technologies": "Linux\nLinux Kernel 5.3 から 6.9.9"
    },
    "JVNDB-2024-005148": {
        "title": "Linux 用 journyx における XML 外部エンティティの脆弱性",
        "description": "The \"soap_cgi.pyc\" API handler allows the XML body of SOAP requests to contain references to external entities. This allows an unauthenticated attacker to read local files, perform server-side request forgery, and overwhelm the web server resources.",
        "technologies": "journyx\njournyx 11.5.4"
    },
    "JVNDB-2024-005149": {
        "title": "Linux 用 journyx におけるハードコードされた認証情報の使用に関する脆弱性",
        "description": "Password reset tokens are generated using an insecure source of randomness. Attackers who know the username of the Journyx installation user can bruteforce the password reset and change the administrator password.",
        "technologies": "journyx\njournyx 11.5.4"
    },
    "JVNDB-2024-005293": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: PCI/MSI: Fix UAF in msi_capability_init KFENCE reports the following UAF: BUG: KFENCE: use-after-free read in __pci_enable_msi_range+0x2c0/0x488 Use-after-free read at 0x0000000024629571 (in kfence-#12): __pci_enable_msi_range+0x2c0/0x488 pci_alloc_irq_vectors_affinity+0xec/0x14c pci_alloc_irq_vectors+0x18/0x28 kfence-#12: 0x0000000008614900-0x00000000e06c228d, size=104, cache=kmalloc-128 allocated by task 81 on cpu 7 at 10.808142s: __kmem_cache_alloc_node+0x1f0/0x2bc kmalloc_trace+0x44/0x138 msi_alloc_desc+0x3c/0x9c msi_domain_insert_msi_desc+0x30/0x78 msi_setup_msi_desc+0x13c/0x184 __pci_enable_msi_range+0x258/0x488 pci_alloc_irq_vectors_affinity+0xec/0x14c pci_alloc_irq_vectors+0x18/0x28 freed by task 81 on cpu 7 at 10.811436s: msi_domain_free_descs+0xd4/0x10c msi_domain_free_locked.part.0+0xc0/0x1d8 msi_domain_alloc_irqs_all_locked+0xb4/0xbc pci_msi_setup_msi_irqs+0x30/0x4c __pci_enable_msi_range+0x2a8/0x488 pci_alloc_irq_vectors_affinity+0xec/0x14c pci_alloc_irq_vectors+0x18/0x28 Descriptor allocation done in: __pci_enable_msi_range msi_capability_init msi_setup_msi_desc msi_insert_msi_desc msi_domain_insert_msi_desc msi_alloc_desc ... Freed in case of failure in __msi_domain_alloc_locked() __pci_enable_msi_range msi_capability_init pci_msi_setup_msi_irqs msi_domain_alloc_irqs_all_locked msi_domain_alloc_locked __msi_domain_alloc_locked => fails msi_domain_free_locked ... That failure propagates back to pci_msi_setup_msi_irqs() in msi_capability_init() which accesses the descriptor for unmasking in the error exit path. Cure it by copying the descriptor and using the copy for the error exit path unmask operation. [ tglx: Massaged change log ]",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満"
    },
    "JVNDB-2024-005288": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ata: libata-core: Fix double free on error If e.g. the ata_port_alloc() call in ata_host_alloc() fails, we will jump to the err_out label, which will call devres_release_group(). devres_release_group() will trigger a call to ata_host_release(). ata_host_release() calls kfree(host), so executing the kfree(host) in ata_host_alloc() will lead to a double free: kernel BUG at mm/slub.c:553! Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 11 PID: 599 Comm: (udev-worker) Not tainted 6.10.0-rc5 #47 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:kfree+0x2cf/0x2f0 Code: 5d 41 5e 41 5f 5d e9 80 d6 ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da RSP: 0018:ffffc90000f377f0 EFLAGS: 00010246 RAX: ffff888112b1f2c0 RBX: ffff888112b1f2c0 RCX: ffff888112b1f320 RDX: 000000000000400b RSI: ffffffffc02c9de5 RDI: ffff888112b1f2c0 RBP: ffffc90000f37830 R08: 0000000000000000 R09: 0000000000000000 R10: ffffc90000f37610 R11: 617461203a736b6e R12: ffffea00044ac780 R13: ffff888100046400 R14: ffffffffc02c9de5 R15: 0000000000000006 FS: 00007f2f1cabe980(0000) GS:ffff88813b380000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f2f1c3acf75 CR3: 0000000111724000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> ? __die_body.cold+0x19/0x27 ? die+0x2e/0x50 ? do_trap+0xca/0x110 ? do_error_trap+0x6a/0x90 ? kfree+0x2cf/0x2f0 ? exc_invalid_op+0x50/0x70 ? kfree+0x2cf/0x2f0 ? asm_exc_invalid_op+0x1a/0x20 ? ata_host_alloc+0xf5/0x120 [libata] ? ata_host_alloc+0xf5/0x120 [libata] ? kfree+0x2cf/0x2f0 ata_host_alloc+0xf5/0x120 [libata] ata_host_alloc_pinfo+0x14/0xa0 [libata] ahci_init_one+0x6c9/0xd20 [ahci] Ensure that we will not call kfree(host) twice, by performing the kfree() only if the devres_open_group() call failed.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満"
    },
    "JVNDB-2024-006032": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tipc: Return non-zero value from tipc_udp_addr2str() on error tipc_udp_addr2str() should return non-zero value if the UDP media address is invalid. Otherwise, a buffer overflow access can occur in tipc_media_addr_printf(). Fix this by returning 1 on an invalid UDP media address.",
        "technologies": "Linux\nLinux Kernel 4.1 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006033": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/iwcm: Fix a use-after-free related to destroying CM IDs iw_conn_req_handler() associates a new struct rdma_id_private (conn_id) with an existing struct iw_cm_id (cm_id) as follows: conn_id->cm_id.iw = cm_id; cm_id->context = conn_id; cm_id->cm_handler = cma_iw_handler; rdma_destroy_id() frees both the cm_id and the struct rdma_id_private. Make sure that cm_work_handler() does not trigger a use-after-free by only freeing of the struct rdma_id_private after all pending work has finished.",
        "technologies": "Linux\nLinux Kernel 4.8 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006133": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (ltc2991) re-order conditions to fix off by one bug LTC2991_T_INT_CH_NR is 4. The st->temp_en[] array has LTC2991_MAX_CHANNEL (4) elements. Thus if \"channel\" is equal to LTC2991_T_INT_CH_NR then we have read one element beyond the end of the array. Flip the conditions around so that we check if \"channel\" is valid before using it as an array index.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006303": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: fix slab-use-after-free in fscache_withdraw_volume() We got the following issue in our fault injection stress test: ================================================================== BUG: KASAN: slab-use-after-free in fscache_withdraw_volume+0x2e1/0x370 Read of size 4 at addr ffff88810680be08 by task ondemand-04-dae/5798 CPU: 0 PID: 5798 Comm: ondemand-04-dae Not tainted 6.8.0-dirty #565 Call Trace: kasan_check_range+0xf6/0x1b0 fscache_withdraw_volume+0x2e1/0x370 cachefiles_withdraw_volume+0x31/0x50 cachefiles_withdraw_cache+0x3ad/0x900 cachefiles_put_unbind_pincount+0x1f6/0x250 cachefiles_daemon_release+0x13b/0x290 __fput+0x204/0xa00 task_work_run+0x139/0x230 Allocated by task 5820: __kmalloc+0x1df/0x4b0 fscache_alloc_volume+0x70/0x600 __fscache_acquire_volume+0x1c/0x610 erofs_fscache_register_volume+0x96/0x1a0 erofs_fscache_register_fs+0x49a/0x690 erofs_fc_fill_super+0x6c0/0xcc0 vfs_get_super+0xa9/0x140 vfs_get_tree+0x8e/0x300 do_new_mount+0x28c/0x580 [...] Freed by task 5820: kfree+0xf1/0x2c0 fscache_put_volume.part.0+0x5cb/0x9e0 erofs_fscache_unregister_fs+0x157/0x1b0 erofs_kill_sb+0xd9/0x1c0 deactivate_locked_super+0xa3/0x100 vfs_get_super+0x105/0x140 vfs_get_tree+0x8e/0x300 do_new_mount+0x28c/0x580 [...] ================================================================== Following is the process that triggers the issue: mount failed | daemon exit ------------------------------------------------------------ deactivate_locked_super cachefiles_daemon_release erofs_kill_sb erofs_fscache_unregister_fs fscache_relinquish_volume __fscache_relinquish_volume fscache_put_volume(fscache_volume, fscache_volume_put_relinquish) zero = __refcount_dec_and_test(&fscache_volume->ref, &ref); cachefiles_put_unbind_pincount cachefiles_daemon_unbind cachefiles_withdraw_cache cachefiles_withdraw_volumes list_del_init(&volume->cache_link) fscache_free_volume(fscache_volume) cache->ops->free_volume cachefiles_free_volume list_del_init(&cachefiles_volume->cache_link); kfree(fscache_volume) cachefiles_withdraw_volume fscache_withdraw_volume fscache_volume->n_accesses // fscache_volume UAF !!! The fscache_volume in cache->volumes must not have been freed yet, but its reference count may be 0. So use the new fscache_try_get_volume() helper function try to get its reference count. If the reference count of fscache_volume is 0, fscache_put_volume() is freeing it, so wait for it to be removed from cache->volumes. If its reference count is not 0, call cachefiles_withdraw_volume() with reference count protection to avoid the above issue.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満"
    },
    "JVNDB-2024-006039": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: sch_multiq: fix possible OOB write in multiq_tune() q->bands will be assigned to qopt->bands to execute subsequent code logic after kmalloc. So the old q->bands should not be used in kmalloc. Otherwise, an out-of-bounds write will occur.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006296": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Avoid splat in pskb_pull_reason syzkaller builds (CONFIG_DEBUG_NET=y) frequently trigger a debug hint in pskb_may_pull. We'd like to retain this debug check because it might hint at integer overflows and other issues (kernel code should pull headers, not huge value). In bpf case, this splat isn't interesting at all: such (nonsensical) bpf programs are typically generated by a fuzzer anyway. Do what Eric suggested and suppress such warning. For CONFIG_DEBUG_NET=n we don't need the extra check because pskb_may_pull will do the right thing: return an error without the WARN() backtrace.",
        "technologies": "Linux\nLinux Kernel 6.1.86 以上 6.1.96 未満\nLinux Kernel 6.6.27 以上 6.6.36 未満\nLinux Kernel 6.9 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006019": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/iucv: fix use after free in iucv_sock_close() iucv_sever_path() is called from process context and from bh context. iucv->path is used as indicator whether somebody else is taking care of severing the path (or it is already removed / never existed). This needs to be done with atomic compare and swap, otherwise there is a small window where iucv_sock_close() will try to work with a path that has already been severed and freed by iucv_callback_connrej() called by iucv_tasklet_fn(). Example: [452744.123844] Call Trace: [452744.123845] ([<0000001e87f03880>] 0x1e87f03880) [452744.123966] [<00000000d593001e>] iucv_path_sever+0x96/0x138 [452744.124330] [<000003ff801ddbca>] iucv_sever_path+0xc2/0xd0 [af_iucv] [452744.124336] [<000003ff801e01b6>] iucv_sock_close+0xa6/0x310 [af_iucv] [452744.124341] [<000003ff801e08cc>] iucv_sock_release+0x3c/0xd0 [af_iucv] [452744.124345] [<00000000d574794e>] __sock_release+0x5e/0xe8 [452744.124815] [<00000000d5747a0c>] sock_close+0x34/0x48 [452744.124820] [<00000000d5421642>] __fput+0xba/0x268 [452744.124826] [<00000000d51b382c>] task_work_run+0xbc/0xf0 [452744.124832] [<00000000d5145710>] do_notify_resume+0x88/0x90 [452744.124841] [<00000000d5978096>] system_call+0xe2/0x2c8 [452744.125319] Last Breaking-Event-Address: [452744.125321] [<00000000d5930018>] iucv_path_sever+0x90/0x138 [452744.125324] [452744.125325] Kernel panic - not syncing: Fatal exception in interrupt Note that bh_lock_sock() is not serializing the tasklet context against process context, because the check for sock_owned_by_user() and corresponding handling is missing. Ideas for a future clean-up patch: A) Correct usage of bh_lock_sock() in tasklet context, as described in Re-enqueue, if needed. This may require adding return values to the tasklet functions and thus changes to all users of iucv. B) Change iucv tasklet into worker and use only lock_sock() in af_iucv.",
        "technologies": "Linux\nLinux Kernel 3.4 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.104 未満\nLinux Kernel 6.2 以上 6.6.45 未満\nLinux Kernel 6.7 以上 6.10.4 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-006289": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/drm_file: Fix pid refcounting race <maarten.lankhorst@linux.intel.com>, Maxime Ripard <mripard@kernel.org>, Thomas Zimmermann <tzimmermann@suse.de> filp->pid is supposed to be a refcounted pointer; however, before this patch, drm_file_update_pid() only increments the refcount of a struct pid after storing a pointer to it in filp->pid and dropping the dev->filelist_mutex, making the following race possible: process A process B ========= ========= begin drm_file_update_pid mutex_lock(&dev->filelist_mutex) rcu_replace_pointer(filp->pid, <pid B>, 1) mutex_unlock(&dev->filelist_mutex) begin drm_file_update_pid mutex_lock(&dev->filelist_mutex) rcu_replace_pointer(filp->pid, <pid A>, 1) mutex_unlock(&dev->filelist_mutex) get_pid(<pid A>) synchronize_rcu() put_pid(<pid B>) *** pid B reaches refcount 0 and is freed here *** get_pid(<pid B>) *** UAF *** synchronize_rcu() put_pid(<pid A>) As far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y because it requires RCU to detect a quiescent state in code that is not explicitly calling into the scheduler. This race leads to use-after-free of a \"struct pid\". It is probably somewhat hard to hit because process A has to pass through a synchronize_rcu() operation while process B is between mutex_unlock() and get_pid(). Fix it by ensuring that by the time a pointer to the current task's pid is stored in the file, an extra reference to the pid has been taken. This fix also removes the condition for synchronize_rcu(); I think that optimization is unnecessary complexity, since in that case we would usually have bailed out on the lockless check above.",
        "technologies": "Linux\nLinux Kernel 6.6.9 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006284": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: rswitch: Avoid use-after-free in rswitch_poll() The use-after-free is actually in rswitch_tx_free(), which is inlined in rswitch_poll(). Since `skb` and `gq->skbs[gq->dirty]` are in fact the same pointer, the skb is first freed using dev_kfree_skb_any(), then the value in skb->len is used to update the interface statistics. Let's move around the instructions to use skb->len before the skb is freed. This bug is trivial to reproduce using KFENCE. It will trigger a splat every few packets. A simple ARP request or ICMP echo request is enough.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.9.9 未満"
    },
    "JVNDB-2024-006321": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme: avoid double free special payload If a discard request needs to be retried, and that retry may fail before a new special payload is added, a double free will result. Clear the RQF_SPECIAL_LOAD when the request is cleaned.",
        "technologies": "Linux\nLinux Kernel 5.15.164 未満\nLinux Kernel 5.16 以上 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満"
    },
    "JVNDB-2024-006054": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: 9p: add missing locking around taking dentry fid list Fix a use-after-free on dentry's d_fsdata fid list when a thread looks up a fid through dentry while another thread unlinks it: UAF thread: refcount_t: addition on 0; use-after-free. p9_fid_get linux/./include/net/9p/client.h:262 v9fs_fid_find+0x236/0x280 linux/fs/9p/fid.c:129 v9fs_fid_lookup_with_uid linux/fs/9p/fid.c:181 v9fs_fid_lookup+0xbf/0xc20 linux/fs/9p/fid.c:314 v9fs_vfs_getattr_dotl+0xf9/0x360 linux/fs/9p/vfs_inode_dotl.c:400 vfs_statx+0xdd/0x4d0 linux/fs/stat.c:248 Freed by: p9_fid_destroy (inlined) p9_client_clunk+0xb0/0xe0 linux/net/9p/client.c:1456 p9_fid_put linux/./include/net/9p/client.h:278 v9fs_dentry_release+0xb5/0x140 linux/fs/9p/vfs_dentry.c:55 v9fs_remove+0x38f/0x620 linux/fs/9p/vfs_inode.c:518 vfs_unlink+0x29a/0x810 linux/fs/namei.c:4335 The problem is that d_fsdata was not accessed under d_lock, because d_release() normally is only called once the dentry is otherwise no longer accessible but since we also call it explicitly in v9fs_remove that lock is required: move the hlist out of the dentry under lock then unref its fids once they are no longer accessible.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 6.1.94 未満\nLinux Kernel 6.2 以上 6.6.34 未満\nLinux Kernel 6.7 以上 6.9.5 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006288": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bonding: Fix out-of-bounds read in bond_option_arp_ip_targets_set() In function bond_option_arp_ip_targets_set(), if newval->string is an empty string, newval->string+1 will point to the byte after the string, causing an out-of-bound read. BUG: KASAN: slab-out-of-bounds in strlen+0x7d/0xa0 lib/string.c:418 Read of size 1 at addr ffff8881119c4781 by task syz-executor665/8107 CPU: 1 PID: 8107 Comm: syz-executor665 Not tainted 6.7.0-rc7 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:364 [inline] print_report+0xc1/0x5e0 mm/kasan/report.c:475 kasan_report+0xbe/0xf0 mm/kasan/report.c:588 strlen+0x7d/0xa0 lib/string.c:418 __fortify_strlen include/linux/fortify-string.h:210 [inline] in4_pton+0xa3/0x3f0 net/core/utils.c:130 bond_option_arp_ip_targets_set+0xc2/0x910 drivers/net/bonding/bond_options.c:1201 __bond_opt_set+0x2a4/0x1030 drivers/net/bonding/bond_options.c:767 __bond_opt_set_notify+0x48/0x150 drivers/net/bonding/bond_options.c:792 bond_opt_tryset_rtnl+0xda/0x160 drivers/net/bonding/bond_options.c:817 bonding_sysfs_store_option+0xa1/0x120 drivers/net/bonding/bond_sysfs.c:156 dev_attr_store+0x54/0x80 drivers/base/core.c:2366 sysfs_kf_write+0x114/0x170 fs/sysfs/file.c:136 kernfs_fop_write_iter+0x337/0x500 fs/kernfs/file.c:334 call_write_iter include/linux/fs.h:2020 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x96a/0xd80 fs/read_write.c:584 ksys_write+0x122/0x250 fs/read_write.c:637 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0x40/0x110 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x63/0x6b ---[ end trace ]--- Fix it by adding a check of string length before using it.",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006328": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: PPC: Book3S HV: Prevent UAF in kvm_spapr_tce_attach_iommu_group() Al reported a possible use-after-free (UAF) in kvm_spapr_tce_attach_iommu_group(). It looks up `stt` from tablefd, but then continues to use it after doing fdput() on the returned fd. After the fdput() the tablefd is free to be closed by another thread. The close calls kvm_spapr_tce_release() and then release_spapr_tce_table() (via call_rcu()) which frees `stt`. Although there are calls to rcu_read_lock() in kvm_spapr_tce_attach_iommu_group() they are not sufficient to prevent the UAF, because `stt` is used outside the locked regions. With an artifcial delay after the fdput() and a userspace program which triggers the race, KASAN detects the UAF: BUG: KASAN: slab-use-after-free in kvm_spapr_tce_attach_iommu_group+0x298/0x720 [kvm] Read of size 4 at addr c000200027552c30 by task kvm-vfio/2505 CPU: 54 PID: 2505 Comm: kvm-vfio Not tainted 6.10.0-rc3-next-20240612-dirty #1 Hardware name: 8335-GTH POWER9 0x4e1202 opal:skiboot-v6.5.3-35-g1851b2a06 PowerNV Call Trace: dump_stack_lvl+0xb4/0x108 (unreliable) print_report+0x2b4/0x6ec kasan_report+0x118/0x2b0 __asan_load4+0xb8/0xd0 kvm_spapr_tce_attach_iommu_group+0x298/0x720 [kvm] kvm_vfio_set_attr+0x524/0xac0 [kvm] kvm_device_ioctl+0x144/0x240 [kvm] sys_ioctl+0x62c/0x1810 system_call_exception+0x190/0x440 system_call_vectored_common+0x15c/0x2ec ... Freed by task 0: ... kfree+0xec/0x3e0 release_spapr_tce_table+0xd4/0x11c [kvm] rcu_core+0x568/0x16a0 handle_softirqs+0x23c/0x920 do_softirq_own_stack+0x6c/0x90 do_softirq_own_stack+0x58/0x90 __irq_exit_rcu+0x218/0x2d0 irq_exit+0x30/0x80 arch_local_irq_restore+0x128/0x230 arch_local_irq_enable+0x1c/0x30 cpuidle_enter_state+0x134/0x5cc cpuidle_enter+0x6c/0xb0 call_cpuidle+0x7c/0x100 do_idle+0x394/0x410 cpu_startup_entry+0x60/0x70 start_secondary+0x3fc/0x410 start_secondary_prolog+0x10/0x14 Fix it by delaying the fdput() until `stt` is no longer in use, which is effectively the entire function. To keep the patch minimal add a call to fdput() at each of the existing return paths. Future work can convert the function to goto or __cleanup style cleanup. With the fix in place the test case no longer triggers the UAF.",
        "technologies": "Linux\nLinux Kernel 5.4.281 未満\nLinux Kernel 5.5 以上 5.10.223 未満\nLinux Kernel 5.11 以上 5.15.164 未満\nLinux Kernel 5.16 以上 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満"
    },
    "JVNDB-2024-006323": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block/ioctl: prefer different overflow check Running syzkaller with the newly reintroduced signed integer overflow sanitizer shows this report: [ 62.982337] ------------[ cut here ]------------ [ 62.985692] cgroup: Invalid name [ 62.986211] UBSAN: signed-integer-overflow in ../block/ioctl.c:36:46 [ 62.989370] 9pnet_fd: p9_fd_create_tcp (7343): problem connecting socket to 127.0.0.1 [ 62.992992] 9223372036854775807 + 4095 cannot be represented in type 'long long' [ 62.997827] 9pnet_fd: p9_fd_create_tcp (7345): problem connecting socket to 127.0.0.1 [ 62.999369] random: crng reseeded on system resumption [ 63.000634] GUP no longer grows the stack in syz-executor.2 (7353): 20002000-20003000 (20001000) [ 63.000668] CPU: 0 PID: 7353 Comm: syz-executor.2 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1 [ 63.000677] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 63.000682] Call Trace: [ 63.000686] <TASK> [ 63.000731] dump_stack_lvl+0x93/0xd0 [ 63.000919] __get_user_pages+0x903/0xd30 [ 63.001030] __gup_longterm_locked+0x153e/0x1ba0 [ 63.001041] ? _raw_read_unlock_irqrestore+0x17/0x50 [ 63.001072] ? try_get_folio+0x29c/0x2d0 [ 63.001083] internal_get_user_pages_fast+0x1119/0x1530 [ 63.001109] iov_iter_extract_pages+0x23b/0x580 [ 63.001206] bio_iov_iter_get_pages+0x4de/0x1220 [ 63.001235] iomap_dio_bio_iter+0x9b6/0x1410 [ 63.001297] __iomap_dio_rw+0xab4/0x1810 [ 63.001316] iomap_dio_rw+0x45/0xa0 [ 63.001328] ext4_file_write_iter+0xdde/0x1390 [ 63.001372] vfs_write+0x599/0xbd0 [ 63.001394] ksys_write+0xc8/0x190 [ 63.001403] do_syscall_64+0xd4/0x1b0 [ 63.001421] ? arch_exit_to_user_mode_prepare+0x3a/0x60 [ 63.001479] entry_SYSCALL_64_after_hwframe+0x6f/0x77 [ 63.001535] RIP: 0033:0x7f7fd3ebf539 [ 63.001551] Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 [ 63.001562] RSP: 002b:00007f7fd32570c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 [ 63.001584] RAX: ffffffffffffffda RBX: 00007f7fd3ff3f80 RCX: 00007f7fd3ebf539 [ 63.001590] RDX: 4db6d1e4f7e43360 RSI: 0000000020000000 RDI: 0000000000000004 [ 63.001595] RBP: 00007f7fd3f1e496 R08: 0000000000000000 R09: 0000000000000000 [ 63.001599] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 [ 63.001604] R13: 0000000000000006 R14: 00007f7fd3ff3f80 R15: 00007ffd415ad2b8 ... [ 63.018142] ---[ end trace ]--- Historically, the signed integer overflow sanitizer did not work in the kernel due to its interaction with `-fwrapv` but this has since been changed [1] in the newest version of Clang; It was re-enabled in the kernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow sanitizer\"). Let's rework this overflow checking logic to not actually perform an overflow during the check itself, thus avoiding the UBSAN splat. [1]: https://github.com/llvm/llvm-project/pull/82432",
        "technologies": "Linux\nLinux Kernel 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満"
    },
    "JVNDB-2024-006339": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: fix slab-use-after-free in cachefiles_withdraw_cookie() We got the following issue in our fault injection stress test: ================================================================== BUG: KASAN: slab-use-after-free in cachefiles_withdraw_cookie+0x4d9/0x600 Read of size 8 at addr ffff888118efc000 by task kworker/u78:0/109 CPU: 13 PID: 109 Comm: kworker/u78:0 Not tainted 6.8.0-dirty #566 Call Trace: <TASK> kasan_report+0x93/0xc0 cachefiles_withdraw_cookie+0x4d9/0x600 fscache_cookie_state_machine+0x5c8/0x1230 fscache_cookie_worker+0x91/0x1c0 process_one_work+0x7fa/0x1800 [...] Allocated by task 117: kmalloc_trace+0x1b3/0x3c0 cachefiles_acquire_volume+0xf3/0x9c0 fscache_create_volume_work+0x97/0x150 process_one_work+0x7fa/0x1800 [...] Freed by task 120301: kfree+0xf1/0x2c0 cachefiles_withdraw_cache+0x3fa/0x920 cachefiles_put_unbind_pincount+0x1f6/0x250 cachefiles_daemon_release+0x13b/0x290 __fput+0x204/0xa00 task_work_run+0x139/0x230 do_exit+0x87a/0x29b0 [...] ================================================================== Following is the process that triggers the issue: p1 | p2 ------------------------------------------------------------ fscache_begin_lookup fscache_begin_volume_access fscache_cache_is_live(fscache_cache) cachefiles_daemon_release cachefiles_put_unbind_pincount cachefiles_daemon_unbind cachefiles_withdraw_cache fscache_withdraw_cache fscache_set_cache_state(cache, FSCACHE_CACHE_IS_WITHDRAWN); cachefiles_withdraw_objects(cache) fscache_wait_for_objects(fscache) atomic_read(&fscache_cache->object_count) == 0 fscache_perform_lookup cachefiles_lookup_cookie cachefiles_alloc_object refcount_set(&object->ref, 1); object->volume = volume fscache_count_object(vcookie->cache); atomic_inc(&fscache_cache->object_count) cachefiles_withdraw_volumes cachefiles_withdraw_volume fscache_withdraw_volume __cachefiles_free_volume kfree(cachefiles_volume) fscache_cookie_state_machine cachefiles_withdraw_cookie cache = object->volume->cache; // cachefiles_volume UAF !!! After setting FSCACHE_CACHE_IS_WITHDRAWN, wait for all the cookie lookups to complete first, and then wait for fscache_cache->object_count == 0 to avoid the cookie exiting after the volume has been freed and triggering the above issue. Therefore call fscache_withdraw_volume() before calling cachefiles_withdraw_objects(). This way, after setting FSCACHE_CACHE_IS_WITHDRAWN, only the following two cases will occur: 1) fscache_begin_lookup fails in fscache_begin_volume_access(). 2) fscache_withdraw_volume() will ensure that fscache_count_object() has been executed before calling fscache_wait_for_objects().",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満"
    },
    "JVNDB-2024-006332": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix array-index-out-of-bounds in dml2/FCLKChangeSupport [Why] Potential out of bounds access in dml2_calculate_rq_and_dlg_params() because the value of out_lowest_state_idx used as an index for FCLKChangeSupport array can be greater than 1. [How] Currently dml2 core specifies identical values for all FCLKChangeSupport elements. Always use index 0 in the condition to avoid out of bounds access.",
        "technologies": "Linux\nLinux Kernel 6.9.11 未満"
    },
    "JVNDB-2024-006498": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix extent map use-after-free when adding pages to compressed bio At add_ra_bio_pages() we are accessing the extent map to calculate 'add_size' after we dropped our reference on the extent map, resulting in a use-after-free. Fix this by computing 'add_size' before dropping our extent map reference.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006499": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: venus: fix use after free in vdec_close There appears to be a possible use after free with vdec_close(). The firmware will add buffer release work to the work queue through HFI callbacks as a normal part of decoding. Randomly closing the decoder device from userspace during normal decoding can incur a read after free for inst. Fix it by cancelling the work in vdec_close.",
        "technologies": "Linux\nLinux Kernel 4.13 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006526": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dev/parport: fix the array out-of-bounds risk Fixed array out-of-bounds issues caused by sprintf by replacing it with snprintf for safer data copying, ensuring the destination buffer is not overflowed. Below is the stack trace I encountered during the actual issue: [ 66.575408s] [pid:5118,cpu4,QThread,4]Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: do_hardware_base_addr+0xcc/0xd0 [parport] [ 66.575408s] [pid:5118,cpu4,QThread,5]CPU: 4 PID: 5118 Comm: QThread Tainted: G S W O 5.10.97-arm64-desktop #7100.57021.2 [ 66.575439s] [pid:5118,cpu4,QThread,6]TGID: 5087 Comm: EFileApp [ 66.575439s] [pid:5118,cpu4,QThread,7]Hardware name: HUAWEI HUAWEI QingYun PGUX-W515x-B081/SP1PANGUXM, BIOS 1.00.07 04/29/2024 [ 66.575439s] [pid:5118,cpu4,QThread,8]Call trace: [ 66.575469s] [pid:5118,cpu4,QThread,9] dump_backtrace+0x0/0x1c0 [ 66.575469s] [pid:5118,cpu4,QThread,0] show_stack+0x14/0x20 [ 66.575469s] [pid:5118,cpu4,QThread,1] dump_stack+0xd4/0x10c [ 66.575500s] [pid:5118,cpu4,QThread,2] panic+0x1d8/0x3bc [ 66.575500s] [pid:5118,cpu4,QThread,3] __stack_chk_fail+0x2c/0x38 [ 66.575500s] [pid:5118,cpu4,QThread,4] do_hardware_base_addr+0xcc/0xd0 [parport]",
        "technologies": "Linux\nLinux Kernel 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006341": {
        "title": "Linux の Linux Kernel における整数オーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ptp: fix integer overflow in max_vclocks_store On 32bit systems, the \"4 * max\" multiply can overflow. Use kcalloc() to do the allocation to prevent this.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006572": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: Fix array-index-out-of-bounds in diFree",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006656": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ethernet: lantiq_etop: fix double free in detach The number of the currently released descriptor is never incremented which results in the same skb being released multiple times.",
        "technologies": "Linux\nLinux Kernel 3.0 以上 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.100 未満\nLinux Kernel 6.2 以上 6.6.41 未満\nLinux Kernel 6.7 以上 6.9.10 未満"
    },
    "JVNDB-2024-005310": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp_metrics: validate source addr length I don't see anything checking that TCP_METRICS_ATTR_SADDR_IPV4 is at least 4 bytes long, and the policy doesn't have an entry for this attribute at all (neither does it for IPv6 but v6 is manually validated).",
        "technologies": "Linux\nLinux Kernel 3.14 以上 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006664": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: mst: fix vlan use-after-free syzbot reported a suspicious rcu usage[1] in bridge's mst code. While fixing it I noticed that nothing prevents a vlan to be freed while walking the list from the same path (br forward delay timer). Fix the rcu usage and also make sure we are not accessing freed memory by making br_mst_vlan_set_state use rcu read lock. [1] WARNING: suspicious RCU usage 6.9.0-rc6-syzkaller #0 Not tainted ----------------------------- net/bridge/br_private.h:1599 suspicious rcu_dereference_protected() usage! ... stack backtrace: CPU: 1 PID: 8017 Comm: syz-executor.1 Not tainted 6.9.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <IRQ> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 lockdep_rcu_suspicious+0x221/0x340 kernel/locking/lockdep.c:6712 nbp_vlan_group net/bridge/br_private.h:1599 [inline] br_mst_set_state+0x1ea/0x650 net/bridge/br_mst.c:105 br_set_state+0x28a/0x7b0 net/bridge/br_stp.c:47 br_forward_delay_timer_expired+0x176/0x440 net/bridge/br_stp_timer.c:88 call_timer_fn+0x18e/0x650 kernel/time/timer.c:1793 expire_timers kernel/time/timer.c:1844 [inline] __run_timers kernel/time/timer.c:2418 [inline] __run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2429 run_timer_base kernel/time/timer.c:2438 [inline] run_timer_softirq+0xb7/0x170 kernel/time/timer.c:2448 __do_softirq+0x2c6/0x980 kernel/softirq.c:554 invoke_softirq kernel/softirq.c:428 [inline] __irq_exit_rcu+0xf2/0x1c0 kernel/softirq.c:633 irq_exit_rcu+0x9/0x30 kernel/softirq.c:645 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1043 [inline] sysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1043 </IRQ> <TASK> asm_sysvec_apic_timer_interrupt+0x1a/0x20 arch/x86/include/asm/idtentry.h:702 RIP: 0010:lock_acquire+0x264/0x550 kernel/locking/lockdep.c:5758 Code: 2b 00 74 08 4c 89 f7 e8 ba d1 84 00 f6 44 24 61 02 0f 85 85 01 00 00 41 f7 c7 00 02 00 00 74 01 fb 48 c7 44 24 40 0e 36 e0 45 <4b> c7 44 25 00 00 00 00 00 43 c7 44 25 09 00 00 00 00 43 c7 44 25 RSP: 0018:ffffc90013657100 EFLAGS: 00000206 RAX: 0000000000000001 RBX: 1ffff920026cae2c RCX: 0000000000000001 RDX: dffffc0000000000 RSI: ffffffff8bcaca00 RDI: ffffffff8c1eaa60 RBP: ffffc90013657260 R08: ffffffff92efe507 R09: 1ffffffff25dfca0 R10: dffffc0000000000 R11: fffffbfff25dfca1 R12: 1ffff920026cae28 R13: dffffc0000000000 R14: ffffc90013657160 R15: 0000000000000246",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-006731": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: idpf: fix UAFs when destroying the queues The second tagged commit started sometimes (very rarely, but possible) throwing WARNs from net/core/page_pool.c:page_pool_disable_direct_recycling(). Turned out idpf frees interrupt vectors with embedded NAPIs *before* freeing the queues making page_pools' NAPI pointers lead to freed memory before these pools are destroyed by libeth. It's not clear whether there are other accesses to the freed vectors when destroying the queues, but anyway, we usually free queue/interrupt vectors only when the queues are destroyed and the NAPIs are guaranteed to not be referenced anywhere. Invert the allocation and freeing logic making queue/interrupt vectors be allocated first and freed last. Vectors don't require queues to be present, so this is safe. Additionally, this change allows to remove that useless queue->q_vector pointer cleanup, as vectors are still valid when freeing the queues (+ both are freed within one function, so it's not clear why nullify the pointers at all).",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-006670": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/dpaa2: Avoid explicit cpumask var allocation on stack For CONFIG_CPUMASK_OFFSTACK=y kernel, explicit allocation of cpumask variable on stack is not recommended since it can cause potential stack overflow. Instead, kernel code should always use *cpumask_var API(s) to allocate cpumask var in config-neutral way, leaving allocation strategy to CONFIG_CPUMASK_OFFSTACK. Use *cpumask_var API(s) to address it.",
        "technologies": "Linux\nLinux Kernel 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満"
    },
    "JVNDB-2024-006673": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: filelock: fix potential use-after-free in posix_lock_inode Light Hsieh reported a KASAN UAF warning in trace_posix_lock_inode(). The request pointer had been changed earlier to point to a lock entry that was added to the inode's list. However, before the tracepoint could fire, another task raced in and freed that lock. Fix this by moving the tracepoint inside the spinlock, which should ensure that this doesn't happen.",
        "technologies": "Linux\nLinux Kernel 5.4.257 以上 5.4.280 未満\nLinux Kernel 5.10.197 以上 5.10.222 未満\nLinux Kernel 5.15.133 以上 5.15.163 未満\nLinux Kernel 6.1.55 以上 6.1.100 未満\nLinux Kernel 6.6 以上 6.6.41 未満\nLinux Kernel 6.7 以上 6.9.10 未満"
    },
    "JVNDB-2024-006733": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GC syzbot reports a f2fs bug as below: ------------[ cut here ]------------ kernel BUG at fs/f2fs/inline.c:258! CPU: 1 PID: 34 Comm: kworker/u8:2 Not tainted 6.9.0-rc6-syzkaller-00012-g9e4bc4bcae01 #0 RIP: 0010:f2fs_write_inline_data+0x781/0x790 fs/f2fs/inline.c:258 Call Trace: f2fs_write_single_data_page+0xb65/0x1d60 fs/f2fs/data.c:2834 f2fs_write_cache_pages fs/f2fs/data.c:3133 [inline] __f2fs_write_data_pages fs/f2fs/data.c:3288 [inline] f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3315 do_writepages+0x35b/0x870 mm/page-writeback.c:2612 __writeback_single_inode+0x165/0x10b0 fs/fs-writeback.c:1650 writeback_sb_inodes+0x905/0x1260 fs/fs-writeback.c:1941 wb_writeback+0x457/0xce0 fs/fs-writeback.c:2117 wb_do_writeback fs/fs-writeback.c:2264 [inline] wb_workfn+0x410/0x1090 fs/fs-writeback.c:2304 process_one_work kernel/workqueue.c:3254 [inline] process_scheduled_works+0xa12/0x17c0 kernel/workqueue.c:3335 worker_thread+0x86d/0xd70 kernel/workqueue.c:3416 kthread+0x2f2/0x390 kernel/kthread.c:388 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 The root cause is: inline_data inode can be fuzzed, so that there may be valid blkaddr in its direct node, once f2fs triggers background GC to migrate the block, it will hit f2fs_bug_on() during dirty page writeback. Let's add sanity check on F2FS_INLINE_DATA flag in inode during GC, so that, it can forbid migrating inline_data inode's data block for fixing.",
        "technologies": "Linux\nLinux Kernel 6.6.47 未満\nLinux Kernel 6.7 以上 6.10.6 未満"
    },
    "JVNDB-2024-006752": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: list_lru: fix UAF for memory cgroup The mem_cgroup_from_slab_obj() is supposed to be called under rcu lock or cgroup_mutex or others which could prevent returned memcg from being freed. Fix it by adding missing rcu read lock. Found by code inspection. [songmuchun@bytedance.com: only grab rcu lock when necessary, per Vlastimil]",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-006751": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: xc2028: avoid use-after-free in load_firmware_cb() syzkaller reported use-after-free in load_firmware_cb() [1]. The reason is because the module allocated a struct tuner in tuner_probe(), and then the module initialization failed, the struct tuner was released. A worker which created during module initialization accesses this struct tuner later, it caused use-after-free. The process is as follows: task-6504 worker_thread tuner_probe <= alloc dvb_frontend [2] ... request_firmware_nowait <= create a worker ... tuner_remove <= free dvb_frontend ... request_firmware_work_func <= the firmware is ready load_firmware_cb <= but now the dvb_frontend has been freed To fix the issue, check the dvd_frontend in load_firmware_cb(), if it is null, report a warning and just return. [1]: ================================================================== BUG: KASAN: use-after-free in load_firmware_cb+0x1310/0x17a0 Read of size 8 at addr ffff8000d7ca2308 by task kworker/2:3/6504 Call trace: load_firmware_cb+0x1310/0x17a0 request_firmware_work_func+0x128/0x220 process_one_work+0x770/0x1824 worker_thread+0x488/0xea0 kthread+0x300/0x430 ret_from_fork+0x10/0x20 Allocated by task 6504: kzalloc tuner_probe+0xb0/0x1430 i2c_device_probe+0x92c/0xaf0 really_probe+0x678/0xcd0 driver_probe_device+0x280/0x370 __device_attach_driver+0x220/0x330 bus_for_each_drv+0x134/0x1c0 __device_attach+0x1f4/0x410 device_initial_probe+0x20/0x30 bus_probe_device+0x184/0x200 device_add+0x924/0x12c0 device_register+0x24/0x30 i2c_new_device+0x4e0/0xc44 v4l2_i2c_new_subdev_board+0xbc/0x290 v4l2_i2c_new_subdev+0xc8/0x104 em28xx_v4l2_init+0x1dd0/0x3770 Freed by task 6504: kfree+0x238/0x4e4 tuner_remove+0x144/0x1c0 i2c_device_remove+0xc8/0x290 __device_release_driver+0x314/0x5fc device_release_driver+0x30/0x44 bus_remove_device+0x244/0x490 device_del+0x350/0x900 device_unregister+0x28/0xd0 i2c_unregister_device+0x174/0x1d0 v4l2_device_unregister+0x224/0x380 em28xx_v4l2_init+0x1d90/0x3770 The buggy address belongs to the object at ffff8000d7ca2000 which belongs to the cache kmalloc-2k of size 2048 The buggy address is located 776 bytes inside of 2048-byte region [ffff8000d7ca2000, ffff8000d7ca2800) The buggy address belongs to the page: page:ffff7fe00035f280 count:1 mapcount:0 mapping:ffff8000c001f000 index:0x0 flags: 0x7ff800000000100(slab) raw: 07ff800000000100 ffff7fe00049d880 0000000300000003 ffff8000c001f000 raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff8000d7ca2200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8000d7ca2280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb >ffff8000d7ca2300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8000d7ca2380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8000d7ca2400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ================================================================== [2] Actually, it is allocated for struct tuner, and dvb_frontend is inside.",
        "technologies": "Linux\nLinux Kernel 6.1.105 未満\nLinux Kernel 6.2 以上 6.6.46 未満\nLinux Kernel 6.7 以上 6.10.5 未満"
    },
    "JVNDB-2024-006749": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: add missing check for inode numbers on directory entries Syzbot reported that mounting and unmounting a specific pattern of corrupted nilfs2 filesystem images causes a use-after-free of metadata file inodes, which triggers a kernel bug in lru_add_fn(). As Jan Kara pointed out, this is because the link count of a metadata file gets corrupted to 0, and nilfs_evict_inode(), which is called from iput(), tries to delete that inode (ifile inode in this case). The inconsistency occurs because directories containing the inode numbers of these metadata files that should not be visible in the namespace are read without checking. Fix this issue by treating the inode numbers of these internal files as errors in the sanity check helper when reading directory folios/pages. Also thanks to Hillf Danton and Matthew Wilcox for their initial mm-layer analysis.",
        "technologies": "Linux\nLinux Kernel 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-006769": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix UAF for cq async event The refcount of CQ is not protected by locks. When CQ asynchronous events and CQ destruction are concurrent, CQ may have been released, which will cause UAF. Use the xa_lock() to protect the CQ refcount.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-006583": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: PCI/DPC: Fix use-after-free on concurrent DPC and hot-removal Keith reports a use-after-free when a DPC event occurs concurrently to hot-removal of the same portion of the hierarchy: The dpc_handler() awaits readiness of the secondary bus below the Downstream Port where the DPC event occurred. To do so, it polls the config space of the first child device on the secondary bus. If that child device is concurrently removed, accesses to its struct pci_dev cause the kernel to oops. That's because pci_bridge_wait_for_secondary_bus() neglects to hold a reference on the child device. Before v6.3, the function was only called on resume from system sleep or on runtime resume. Holding a reference wasn't necessary back then because the pciehp IRQ thread could never run concurrently. (On resume from system sleep, IRQs are not enabled until after the resume_noirq phase. And runtime resume is always awaited before a PCI device is removed.) However starting with v6.3, pci_bridge_wait_for_secondary_bus() is also called on a DPC event. Commit 53b54ad074de (\"PCI/DPC: Await readiness of secondary bus after reset\"), which introduced that, failed to appreciate that pci_bridge_wait_for_secondary_bus() now needs to hold a reference on the child device because dpc_handler() and pciehp may indeed run concurrently. The commit was backported to v5.10+ stable kernels, so that's the oldest one affected. Add the missing reference acquisition. Abridged stack trace: BUG: unable to handle page fault for address: 00000000091400c0 CPU: 15 PID: 2464 Comm: irq/53-pcie-dpc 6.9.0 RIP: pci_bus_read_config_dword+0x17/0x50 pci_dev_wait() pci_bridge_wait_for_secondary_bus() dpc_reset_link() pcie_do_recovery() dpc_handler()",
        "technologies": "Linux\nLinux Kernel 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-006739": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Discard command completions in internal error Fix use after free when FW completion arrives while device is in internal error state. Avoid calling completion handler in this case, since the device will flush the command interface and trigger all completions manually. Kernel log: ------------[ cut here ]------------ refcount_t: underflow; use-after-free. ... RIP: 0010:refcount_warn_saturate+0xd8/0xe0 ... Call Trace: <IRQ> ? __warn+0x79/0x120 ? refcount_warn_saturate+0xd8/0xe0 ? report_bug+0x17c/0x190 ? handle_bug+0x3c/0x60 ? exc_invalid_op+0x14/0x70 ? asm_exc_invalid_op+0x16/0x20 ? refcount_warn_saturate+0xd8/0xe0 cmd_ent_put+0x13b/0x160 [mlx5_core] mlx5_cmd_comp_handler+0x5f9/0x670 [mlx5_core] cmd_comp_notifier+0x1f/0x30 [mlx5_core] notifier_call_chain+0x35/0xb0 atomic_notifier_call_chain+0x16/0x20 mlx5_eq_async_int+0xf6/0x290 [mlx5_core] notifier_call_chain+0x35/0xb0 atomic_notifier_call_chain+0x16/0x20 irq_int_handler+0x19/0x30 [mlx5_core] __handle_irq_event_percpu+0x4b/0x160 handle_irq_event+0x2e/0x80 handle_edge_irq+0x98/0x230 __common_interrupt+0x3b/0xa0 common_interrupt+0x7b/0xa0 </IRQ> <TASK> asm_common_interrupt+0x22/0x40",
        "technologies": "Linux\nLinux Kernel 5.10.20 以上 5.10.219 未満\nLinux Kernel 5.12 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-006748": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: mcast: wait for previous gc cycles when removing port syzbot hit a use-after-free[1] which is caused because the bridge doesn't make sure that all previous garbage has been collected when removing a port. What happens is: CPU 1 CPU 2 start gc cycle remove port acquire gc lock first wait for lock call br_multicasg_gc() directly acquire lock now but free port the port can be freed while grp timers still running Make sure all previous gc cycles have finished by using flush_work before freeing the port. [1] BUG: KASAN: slab-use-after-free in br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861 Read of size 8 at addr ffff888071d6d000 by task syz.5.1232/9699 CPU: 1 PID: 9699 Comm: syz.5.1232 Not tainted 6.10.0-rc5-syzkaller-00021-g24ca36a562d6 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/07/2024 Call Trace: <IRQ> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0xc3/0x620 mm/kasan/report.c:488 kasan_report+0xd9/0x110 mm/kasan/report.c:601 br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861 call_timer_fn+0x1a3/0x610 kernel/time/timer.c:1792 expire_timers kernel/time/timer.c:1843 [inline] __run_timers+0x74b/0xaf0 kernel/time/timer.c:2417 __run_timer_base kernel/time/timer.c:2428 [inline] __run_timer_base kernel/time/timer.c:2421 [inline] run_timer_base+0x111/0x190 kernel/time/timer.c:2437",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.105 未満\nLinux Kernel 6.2 以上 6.6.46 未満\nLinux Kernel 6.7 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-006793": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/iucv: Avoid explicit cpumask var allocation on stack For CONFIG_CPUMASK_OFFSTACK=y kernel, explicit allocation of cpumask variable on stack is not recommended since it can cause potential stack overflow. Instead, kernel code should always use *cpumask_var API(s) to allocate cpumask var in config-neutral way, leaving allocation strategy to CONFIG_CPUMASK_OFFSTACK. Use *cpumask_var API(s) to address it.",
        "technologies": "Linux\nLinux Kernel 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満"
    },
    "JVNDB-2024-006801": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: do not leave a dangling sk pointer, when socket creation fails It is possible to trigger a use-after-free by: * attaching an fentry probe to __sock_release() and the probe calling the bpf_get_socket_cookie() helper * running traceroute -I 1.1.1.1 on a freshly booted VM A KASAN enabled kernel will log something like below (decoded and stripped): ================================================================== BUG: KASAN: slab-use-after-free in __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) Read of size 8 at addr ffff888007110dd8 by task traceroute/299 CPU: 2 PID: 299 Comm: traceroute Tainted: G E 6.10.0-rc2+ #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:117 (discriminator 1)) print_report (mm/kasan/report.c:378 mm/kasan/report.c:488) ? __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) kasan_report (mm/kasan/report.c:603) ? __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) kasan_check_range (mm/kasan/generic.c:183 mm/kasan/generic.c:189) __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) bpf_get_socket_ptr_cookie (./arch/x86/include/asm/preempt.h:94 ./include/linux/sock_diag.h:42 net/core/filter.c:5094 net/core/filter.c:5092) bpf_prog_875642cf11f1d139___sock_release+0x6e/0x8e bpf_trampoline_6442506592+0x47/0xaf __sock_release (net/socket.c:652) __sock_create (net/socket.c:1601) ... Allocated by task 299 on cpu 2 at 78.328492s: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:68) __kasan_slab_alloc (mm/kasan/common.c:312 mm/kasan/common.c:338) kmem_cache_alloc_noprof (mm/slub.c:3941 mm/slub.c:4000 mm/slub.c:4007) sk_prot_alloc (net/core/sock.c:2075) sk_alloc (net/core/sock.c:2134) inet_create (net/ipv4/af_inet.c:327 net/ipv4/af_inet.c:252) __sock_create (net/socket.c:1572) __sys_socket (net/socket.c:1660 net/socket.c:1644 net/socket.c:1706) __x64_sys_socket (net/socket.c:1718) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) Freed by task 299 on cpu 2 at 78.328502s: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:68) kasan_save_free_info (mm/kasan/generic.c:582) poison_slab_object (mm/kasan/common.c:242) __kasan_slab_free (mm/kasan/common.c:256) kmem_cache_free (mm/slub.c:4437 mm/slub.c:4511) __sk_destruct (net/core/sock.c:2117 net/core/sock.c:2208) inet_create (net/ipv4/af_inet.c:397 net/ipv4/af_inet.c:252) __sock_create (net/socket.c:1572) __sys_socket (net/socket.c:1660 net/socket.c:1644 net/socket.c:1706) __x64_sys_socket (net/socket.c:1718) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) Fix this by clearing the struct socket reference in sk_common_release() to cover all protocol families create functions, which may already attached the reference to the sk object with sock_init_data().",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006821": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netns: Make get_net_ns() handle zero refcount net Syzkaller hit a warning: refcount_t: addition on 0; use-after-free. WARNING: CPU: 3 PID: 7890 at lib/refcount.c:25 refcount_warn_saturate+0xdf/0x1d0 Modules linked in: CPU: 3 PID: 7890 Comm: tun Not tainted 6.10.0-rc3-00100-gcaa4f9578aba-dirty #310 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 RIP: 0010:refcount_warn_saturate+0xdf/0x1d0 Code: 41 49 04 31 ff 89 de e8 9f 1e cd fe 84 db 75 9c e8 76 26 cd fe c6 05 b6 41 49 04 01 90 48 c7 c7 b8 8e 25 86 e8 d2 05 b5 fe 90 <0f> 0b 90 90 e9 79 ff ff ff e8 53 26 cd fe 0f b6 1 RSP: 0018:ffff8881067b7da0 EFLAGS: 00010286 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff811c72ac RDX: ffff8881026a2140 RSI: ffffffff811c72b5 RDI: 0000000000000001 RBP: ffff8881067b7db0 R08: 0000000000000000 R09: 205b5d3730353139 R10: 0000000000000000 R11: 205d303938375420 R12: ffff8881086500c4 R13: ffff8881086500c4 R14: ffff8881086500b0 R15: ffff888108650040 FS: 00007f5b2961a4c0(0000) GS:ffff88823bd00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055d7ed36fd18 CR3: 00000001482f6000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? show_regs+0xa3/0xc0 ? __warn+0xa5/0x1c0 ? refcount_warn_saturate+0xdf/0x1d0 ? report_bug+0x1fc/0x2d0 ? refcount_warn_saturate+0xdf/0x1d0 ? handle_bug+0xa1/0x110 ? exc_invalid_op+0x3c/0xb0 ? asm_exc_invalid_op+0x1f/0x30 ? __warn_printk+0xcc/0x140 ? __warn_printk+0xd5/0x140 ? refcount_warn_saturate+0xdf/0x1d0 get_net_ns+0xa4/0xc0 ? __pfx_get_net_ns+0x10/0x10 open_related_ns+0x5a/0x130 __tun_chr_ioctl+0x1616/0x2370 ? __sanitizer_cov_trace_switch+0x58/0xa0 ? __sanitizer_cov_trace_const_cmp2+0x1c/0x30 ? __pfx_tun_chr_ioctl+0x10/0x10 tun_chr_ioctl+0x2f/0x40 __x64_sys_ioctl+0x11b/0x160 x64_sys_call+0x1211/0x20d0 do_syscall_64+0x9e/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f5b28f165d7 Code: b3 66 90 48 8b 05 b1 48 2d 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 81 48 2d 00 8 RSP: 002b:00007ffc2b59c5e8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f5b28f165d7 RDX: 0000000000000000 RSI: 00000000000054e3 RDI: 0000000000000003 RBP: 00007ffc2b59c650 R08: 00007f5b291ed8c0 R09: 00007f5b2961a4c0 R10: 0000000029690010 R11: 0000000000000246 R12: 0000000000400730 R13: 00007ffc2b59cf40 R14: 0000000000000000 R15: 0000000000000000 </TASK> Kernel panic - not syncing: kernel: panic_on_warn set ... This is trigger as below: ns0 ns1 tun_set_iff() //dev is tun0 tun->dev = dev //ip link set tun0 netns ns1 put_net() //ref is 0 __tun_chr_ioctl() //TUNGETDEVNETNS net = dev_net(tun->dev); open_related_ns(&net->ns, get_net_ns); //ns1 get_net_ns() get_net() //addition on 0 Use maybe_get_net() in get_net_ns in case net's ref is zero to fix this",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006794": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dmaengine: idxd: Fix possible Use-After-Free in irq_process_work_list Use list_for_each_entry_safe() to allow iterating through the list and deleting the entry in the iteration process. The descriptor is freed via idxd_desc_complete() and there's a slight chance may cause issue for the list iterator when the descriptor is reused by another thread without it being deleted from the list.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-007047": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: nl80211: Avoid address calculations via out of bounds array indexing Before request->channels[] can be used, request->n_channels must be set. Additionally, address calculations for memory after the \"channels\" array need to be calculated from the allocation base (\"request\") rather than via the first \"out of bounds\" index of \"channels\", otherwise run-time bounds checking will throw a warning.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-006815": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: fix slab-use-after-free in cachefiles_ondemand_get_fd() We got the following issue in a fuzz test of randomly issuing the restore command: ================================================================== BUG: KASAN: slab-use-after-free in cachefiles_ondemand_daemon_read+0x609/0xab0 Write of size 4 at addr ffff888109164a80 by task ondemand-04-dae/4962 CPU: 11 PID: 4962 Comm: ondemand-04-dae Not tainted 6.8.0-rc7-dirty #542 Call Trace: kasan_report+0x94/0xc0 cachefiles_ondemand_daemon_read+0x609/0xab0 vfs_read+0x169/0xb50 ksys_read+0xf5/0x1e0 Allocated by task 626: __kmalloc+0x1df/0x4b0 cachefiles_ondemand_send_req+0x24d/0x690 cachefiles_create_tmpfile+0x249/0xb30 cachefiles_create_file+0x6f/0x140 cachefiles_look_up_object+0x29c/0xa60 cachefiles_lookup_cookie+0x37d/0xca0 fscache_cookie_state_machine+0x43c/0x1230 [...] Freed by task 626: kfree+0xf1/0x2c0 cachefiles_ondemand_send_req+0x568/0x690 cachefiles_create_tmpfile+0x249/0xb30 cachefiles_create_file+0x6f/0x140 cachefiles_look_up_object+0x29c/0xa60 cachefiles_lookup_cookie+0x37d/0xca0 fscache_cookie_state_machine+0x43c/0x1230 [...] ================================================================== Following is the process that triggers the issue: mount | daemon_thread1 | daemon_thread2 ------------------------------------------------------------ cachefiles_ondemand_init_object cachefiles_ondemand_send_req REQ_A = kzalloc(sizeof(*req) + data_len) wait_for_completion(&REQ_A->done) cachefiles_daemon_read cachefiles_ondemand_daemon_read REQ_A = cachefiles_ondemand_select_req cachefiles_ondemand_get_fd copy_to_user(_buffer, msg, n) process_open_req(REQ_A) ------ restore ------ cachefiles_ondemand_restore xas_for_each(&xas, req, ULONG_MAX) xas_set_mark(&xas, CACHEFILES_REQ_NEW); cachefiles_daemon_read cachefiles_ondemand_daemon_read REQ_A = cachefiles_ondemand_select_req write(devfd, (\"copen %u,%llu\", msg->msg_id, size)); cachefiles_ondemand_copen xa_erase(&cache->reqs, id) complete(&REQ_A->done) kfree(REQ_A) cachefiles_ondemand_get_fd(REQ_A) fd = get_unused_fd_flags file = anon_inode_getfile fd_install(fd, file) load = (void *)REQ_A->msg.data; load->fd = fd; // load UAF !!! This issue is caused by issuing a restore command when the daemon is still alive, which results in a request being processed multiple times thus triggering a UAF. So to avoid this problem, add an additional reference count to cachefiles_req, which is held while waiting and reading, and then released when the waiting and reading is over. Note that since there is only one reference count for waiting, we need to avoid the same request being completed multiple times, so we can only complete the request if it is successfully removed from the xarray.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006837": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix potential index out of bounds in color transformation function Fixes index out of bounds issue in the color transformation function. The issue could occur when the index 'i' exceeds the number of transfer function points (TRANSFER_FUNC_POINTS). The fix adds a check to ensure 'i' is within bounds before accessing the transfer function points. If 'i' is out of bounds, an error message is logged and the function returns false to indicate an error. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405 cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406 cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407 cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
        "technologies": "Linux\nLinux Kernel 4.16 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-007108": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kunit: Fix kthread reference There is a race condition when a kthread finishes after the deadline and before the call to kthread_stop(), which may lead to use after free.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-003246": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 より大きい 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-007130": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: add error handle to avoid out-of-bounds if the sdma_v4_0_irq_id_to_seq return -EINVAL, the process should be stop to avoid out-of-bounds read, so directly return -EINVAL.",
        "technologies": "Linux\nLinux Kernel 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.94 未満\nLinux Kernel 6.2 以上 6.6.34 未満\nLinux Kernel 6.7 以上 6.9.5 未満"
    },
    "JVNDB-2024-007059": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix a potential use-after-free in bpf_link_free() After commit 1a80dbcb2dba, bpf_link can be freed by link->ops->dealloc_deferred, but the code still tests and uses link->ops->dealloc afterward, which leads to a use-after-free as reported by syzbot. Actually, one of them should be sufficient, so just call one of them instead of both. Also add a WARN_ON() in case of any problematic implementation.",
        "technologies": "Linux\nLinux Kernel 6.6.26 以上 6.6.35 未満\nLinux Kernel 6.9 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006947": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Always stop health timer during driver removal Currently, if teardown_hca fails to execute during driver removal, mlx5 does not stop the health timer. Afterwards, mlx5 continue with driver teardown. This may lead to a UAF bug, which results in page fault Oops[1], since the health timer invokes after resources were freed. Hence, stop the health monitor even if teardown_hca fails. [1] mlx5_core 0000:18:00.0: E-Switch: Unload vfs: mode(LEGACY), nvfs(0), necvfs(0), active vports(0) mlx5_core 0000:18:00.0: E-Switch: Disable: mode(LEGACY), nvfs(0), necvfs(0), active vports(0) mlx5_core 0000:18:00.0: E-Switch: Disable: mode(LEGACY), nvfs(0), necvfs(0), active vports(0) mlx5_core 0000:18:00.0: E-Switch: cleanup mlx5_core 0000:18:00.0: wait_func:1155:(pid 1967079): TEARDOWN_HCA(0x103) timeout. Will cause a leak of a command resource mlx5_core 0000:18:00.0: mlx5_function_close:1288:(pid 1967079): tear_down_hca failed, skip cleanup BUG: unable to handle page fault for address: ffffa26487064230 PGD 100c00067 P4D 100c00067 PUD 100e5a067 PMD 105ed7067 PTE 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 0 Comm: swapper/0 Tainted: G OE ------- --- 6.7.0-68.fc38.x86_64 #1 Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0013.121520200651 12/15/2020 RIP: 0010:ioread32be+0x34/0x60 RSP: 0018:ffffa26480003e58 EFLAGS: 00010292 RAX: ffffa26487064200 RBX: ffff9042d08161a0 RCX: ffff904c108222c0 RDX: 000000010bbf1b80 RSI: ffffffffc055ddb0 RDI: ffffa26487064230 RBP: ffff9042d08161a0 R08: 0000000000000022 R09: ffff904c108222e8 R10: 0000000000000004 R11: 0000000000000441 R12: ffffffffc055ddb0 R13: ffffa26487064200 R14: ffffa26480003f00 R15: ffff904c108222c0 FS: 0000000000000000(0000) GS:ffff904c10800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffa26487064230 CR3: 00000002c4420006 CR4: 00000000007706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <IRQ> ? __die+0x23/0x70 ? page_fault_oops+0x171/0x4e0 ? exc_page_fault+0x175/0x180 ? asm_exc_page_fault+0x26/0x30 ? __pfx_poll_health+0x10/0x10 [mlx5_core] ? __pfx_poll_health+0x10/0x10 [mlx5_core] ? ioread32be+0x34/0x60 mlx5_health_check_fatal_sensors+0x20/0x100 [mlx5_core] ? __pfx_poll_health+0x10/0x10 [mlx5_core] poll_health+0x42/0x230 [mlx5_core] ? __next_timer_interrupt+0xbc/0x110 ? __pfx_poll_health+0x10/0x10 [mlx5_core] call_timer_fn+0x21/0x130 ? __pfx_poll_health+0x10/0x10 [mlx5_core] __run_timers+0x222/0x2c0 run_timer_softirq+0x1d/0x40 __do_softirq+0xc9/0x2c8 __irq_exit_rcu+0xa6/0xc0 sysvec_apic_timer_interrupt+0x72/0x90 </IRQ> <TASK> asm_sysvec_apic_timer_interrupt+0x1a/0x20 RIP: 0010:cpuidle_enter_state+0xcc/0x440 ? cpuidle_enter_state+0xbd/0x440 cpuidle_enter+0x2d/0x40 do_idle+0x20d/0x270 cpu_startup_entry+0x2a/0x30 rest_init+0xd0/0xd0 arch_call_rest_init+0xe/0x30 start_kernel+0x709/0xa90 x86_64_start_reservations+0x18/0x30 x86_64_start_kernel+0x96/0xa0 secondary_startup_64_no_verify+0x18f/0x19b ---[ end trace 0000000000000000 ]---",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-007003": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: xmit: make sure we have at least eth header len bytes syzbot triggered an uninit value[1] error in bridge device's xmit path by sending a short (less than ETH_HLEN bytes) skb. To fix it check if we can actually pull that amount instead of assuming. Tested with dropwatch: drop at: br_dev_xmit+0xb93/0x12d0 [bridge] (0xffffffffc06739b3) origin: software timestamp: Mon May 13 11:31:53 2024 778214037 nsec protocol: 0x88a8 length: 2 original length: 2 drop reason: PKT_TOO_SMALL [1] BUG: KMSAN: uninit-value in br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65 br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65 __netdev_start_xmit include/linux/netdevice.h:4903 [inline] netdev_start_xmit include/linux/netdevice.h:4917 [inline] xmit_one net/core/dev.c:3531 [inline] dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3547 __dev_queue_xmit+0x34db/0x5350 net/core/dev.c:4341 dev_queue_xmit include/linux/netdevice.h:3091 [inline] __bpf_tx_skb net/core/filter.c:2136 [inline] __bpf_redirect_common net/core/filter.c:2180 [inline] __bpf_redirect+0x14a6/0x1620 net/core/filter.c:2187 ____bpf_clone_redirect net/core/filter.c:2460 [inline] bpf_clone_redirect+0x328/0x470 net/core/filter.c:2432 ___bpf_prog_run+0x13fe/0xe0f0 kernel/bpf/core.c:1997 __bpf_prog_run512+0xb5/0xe0 kernel/bpf/core.c:2238 bpf_dispatcher_nop_func include/linux/bpf.h:1234 [inline] __bpf_prog_run include/linux/filter.h:657 [inline] bpf_prog_run include/linux/filter.h:664 [inline] bpf_test_run+0x499/0xc30 net/bpf/test_run.c:425 bpf_prog_test_run_skb+0x14ea/0x1f20 net/bpf/test_run.c:1058 bpf_prog_test_run+0x6b7/0xad0 kernel/bpf/syscall.c:4269 __sys_bpf+0x6aa/0xd90 kernel/bpf/syscall.c:5678 __do_sys_bpf kernel/bpf/syscall.c:5767 [inline] __se_sys_bpf kernel/bpf/syscall.c:5765 [inline] __x64_sys_bpf+0xa0/0xe0 kernel/bpf/syscall.c:5765 x64_sys_call+0x96b/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:322 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-006822": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: fix slab-use-after-free in cachefiles_ondemand_daemon_read() We got the following issue in a fuzz test of randomly issuing the restore command: ================================================================== BUG: KASAN: slab-use-after-free in cachefiles_ondemand_daemon_read+0xb41/0xb60 Read of size 8 at addr ffff888122e84088 by task ondemand-04-dae/963 CPU: 13 PID: 963 Comm: ondemand-04-dae Not tainted 6.8.0-dirty #564 Call Trace: kasan_report+0x93/0xc0 cachefiles_ondemand_daemon_read+0xb41/0xb60 vfs_read+0x169/0xb50 ksys_read+0xf5/0x1e0 Allocated by task 116: kmem_cache_alloc+0x140/0x3a0 cachefiles_lookup_cookie+0x140/0xcd0 fscache_cookie_state_machine+0x43c/0x1230 [...] Freed by task 792: kmem_cache_free+0xfe/0x390 cachefiles_put_object+0x241/0x480 fscache_cookie_state_machine+0x5c8/0x1230 [...] ================================================================== Following is the process that triggers the issue: mount | daemon_thread1 | daemon_thread2 ------------------------------------------------------------ cachefiles_withdraw_cookie cachefiles_ondemand_clean_object(object) cachefiles_ondemand_send_req REQ_A = kzalloc(sizeof(*req) + data_len) wait_for_completion(&REQ_A->done) cachefiles_daemon_read cachefiles_ondemand_daemon_read REQ_A = cachefiles_ondemand_select_req msg->object_id = req->object->ondemand->ondemand_id ------ restore ------ cachefiles_ondemand_restore xas_for_each(&xas, req, ULONG_MAX) xas_set_mark(&xas, CACHEFILES_REQ_NEW) cachefiles_daemon_read cachefiles_ondemand_daemon_read REQ_A = cachefiles_ondemand_select_req copy_to_user(_buffer, msg, n) xa_erase(&cache->reqs, id) complete(&REQ_A->done) ------ close(fd) ------ cachefiles_ondemand_fd_release cachefiles_put_object cachefiles_put_object kmem_cache_free(cachefiles_object_jar, object) REQ_A->object->ondemand->ondemand_id // object UAF !!! When we see the request within xa_lock, req->object must not have been freed yet, so grab the reference count of object before xa_unlock to avoid the above issue.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-006946": {
        "title": "マイクロソフトの Azure Data Science Virtual Machines for Linux における権限を昇格される脆弱性",
        "description": "Azure Science Virtual Machine (DSVM) Elevation of Privilege Vulnerability",
        "technologies": "マイクロソフト\nAzure Data Science Virtual Machines for Linux"
    },
    "JVNDB-2024-007140": {
        "title": "Linux の Linux Kernel におけるリソースの初期化の不備に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vhost/vsock: always initialize seqpacket_allow There are two issues around seqpacket_allow: 1. seqpacket_allow is not initialized when socket is created. Thus if features are never set, it will be read uninitialized. 2. if VIRTIO_VSOCK_F_SEQPACKET is set and then cleared, then seqpacket_allow will not be cleared appropriately (existing apps I know about don't usually do this but it's legal and there's no way to be sure no one relies on this). To fix: - initialize seqpacket_allow after allocation - set it unconditionally in set_features",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-007339": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bnx2x: Fix multiple UBSAN array-index-out-of-bounds Fix UBSAN warnings that occur when using a system with 32 physical cpu cores or more, or when the user defines a number of Ethernet queues greater than or equal to FP_SB_MAX_E1x using the num_queues module parameter. Currently there is a read/write out of bounds that occurs on the array \"struct stats_query_entry query\" present inside the \"bnx2x_fw_stats_req\" struct in \"drivers/net/ethernet/broadcom/bnx2x/bnx2x.h\". Looking at the definition of the \"struct stats_query_entry query\" array: struct stats_query_entry query[FP_SB_MAX_E1x+ BNX2X_FIRST_QUEUE_QUERY_IDX]; FP_SB_MAX_E1x is defined as the maximum number of fast path interrupts and has a value of 16, while BNX2X_FIRST_QUEUE_QUERY_IDX has a value of 3 meaning the array has a total size of 19. Since accesses to \"struct stats_query_entry query\" are offset-ted by BNX2X_FIRST_QUEUE_QUERY_IDX, that means that the total number of Ethernet queues should not exceed FP_SB_MAX_E1x (16). However one of these queues is reserved for FCOE and thus the number of Ethernet queues should be set to [FP_SB_MAX_E1x -1] (15) if FCOE is enabled or [FP_SB_MAX_E1x] (16) if it is not. This is also described in a comment in the source code in drivers/net/ethernet/broadcom/bnx2x/bnx2x.h just above the Macro definition of FP_SB_MAX_E1x. Below is the part of this explanation that it important for this patch /* * The total number of L2 queues, MSIX vectors and HW contexts (CIDs) is * control by the number of fast-path status blocks supported by the * device (HW/FW). Each fast-path status block (FP-SB) aka non-default * status block represents an independent interrupts context that can * serve a regular L2 networking queue. However special L2 queues such * as the FCoE queue do not require a FP-SB and other components like * the CNIC may consume FP-SB reducing the number of possible L2 queues * * If the maximum number of FP-SB available is X then: * a. If CNIC is supported it consumes 1 FP-SB thus the max number of * regular L2 queues is Y=X-1 * b. In MF mode the actual number of L2 queues is Y= (X-1/MF_factor) * c. If the FCoE L2 queue is supported the actual number of L2 queues * is Y+1 * d. The number of irqs (MSIX vectors) is either Y+1 (one extra for * slow-path interrupts) or Y+2 if CNIC is supported (one additional * FP interrupt context for the CNIC). * e. The number of HW context (CID count) is always X or X+1 if FCoE * L2 queue is supported. The cid for the FCoE L2 queue is always X. */ However this driver also supports NICs that use the E2 controller which can handle more queues due to having more FP-SB represented by FP_SB_MAX_E2. Looking at the commits when the E2 support was added, it was originally using the E1x parameters: commit f2e0899f0f27 (\"bnx2x: Add 57712 support\"). Back then FP_SB_MAX_E2 was set to 16 the same as E1x. However the driver was later updated to take full advantage of the E2 instead of having it be limited to the capabilities of the E1x. But as far as we can tell, the array \"stats_query_entry query\" was still limited to using the FP-SB available to the E1x cards as part of an oversignt when the driver was updated to take full advantage of the E2, and now with the driver being aware of the greater queue size supported by E2 NICs, it causes the UBSAN warnings seen in the stack traces below. This patch increases the size of the \"stats_query_entry query\" array by replacing FP_SB_MAX_E1x with FP_SB_MAX_E2 to be large enough to handle both types of NICs. Stack traces: UBSAN: array-index-out-of-bounds in drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:1529:11 index 20 is out of range for type 'stats_query_entry [19]' CPU: 12 PID: 858 Comm: systemd-network Not tainted 6.9.0-060900rc7-generic #202405052133 Hardware name: HP ProLiant DL360 Gen9/ProLiant DL360 ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.3 以上 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-007155": {
        "title": "Linux の Linux Kernel における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: exec: Fix ToCToU between perm check and set-uid/gid usage When opening a file for exec via do_filp_open(), permission checking is done against the file's metadata at that moment, and on success, a file pointer is passed back. Much later in the execve() code path, the file metadata (specifically mode, uid, and gid) is used to determine if/how to set the uid and gid. However, those values may have changed since the permissions check, meaning the execution may gain unintended privileges. For example, if a file could change permissions from executable and not set-id: ---------x 1 root root 16048 Aug 7 13:16 target to set-id and non-executable: ---S------ 1 root root 16048 Aug 7 13:16 target it is possible to gain root privileges when execution should have been disallowed. While this race condition is rare in real-world scenarios, it has been observed (and proven exploitable) when package managers are updating the setuid bits of installed programs. Such files start with being world-executable but then are adjusted to be group-exec with a set-uid bit. For example, \"chmod o-x,u+s target\" makes \"target\" executable only by uid \"root\" and gid \"cdrom\", while also becoming setuid-root: -rwxr-xr-x 1 root cdrom 16048 Aug 7 13:16 target becomes: -rwsr-xr-- 1 root cdrom 16048 Aug 7 13:16 target But racing the chmod means users without group \"cdrom\" membership can get the permission to execute \"target\" just before the chmod, and when the chmod finishes, the exec reaches brpm_fill_uid(), and performs the setuid to root, violating the expressed authorization of \"only cdrom group members can setuid to root\". Re-check that we still have execute permissions in case the metadata has changed. It would be better to keep a copy from the perm-check time, but until we can do that refactoring, the least-bad option is to do a full inode_permission() call (under inode lock). It is understood that this is safe against dead-locks, but hardly optimal.",
        "technologies": "Linux\nLinux Kernel 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.106 未満\nLinux Kernel 6.2 以上 6.6.47 未満\nLinux Kernel 6.7 以上 6.10.6 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007425": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: pm: avoid possible UaF when selecting endp select_local_address() and select_signal_address() both select an endpoint entry from the list inside an RCU protected section, but return a reference to it, to be read later on. If the entry is dereferenced after the RCU unlock, reading info could cause a Use-after-Free. A simple solution is to copy the required info while inside the RCU protected section to avoid any risk of UaF later. The address ID might need to be modified later to handle the ID0 case later, so a copy seems OK to deal with.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007375": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における例外的な状態のチェックに関する脆弱性",
        "description": "In wlan, there is a possible denial of service due to incorrect error handling. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS08861558; Issue ID: MSV-1526.",
        "technologies": "Google\nAndroid 13.0\nAndroid 14.0\nLinux Foundation\nYocto 2.6\nYocto 3.3\nYocto 4.0\nRDK Management, LLC\nrdk-b 2022q3"
    },
    "JVNDB-2024-007463": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: fix possible UAF in ip6_finish_output2() If skb_expand_head() returns NULL, skb has been freed and associated dst/idev could also have been freed. We need to hold rcu_read_lock() to make sure the dst and associated idev are alive.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007470": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: prevent possible UAF in ip6_xmit() If skb_expand_head() returns NULL, skb has been freed and the associated dst/idev could also have been freed. We must use rcu_read_lock() to prevent a possible UAF.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007583": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: use memtostr_pad() for s_volume_name As with the other strings in struct ext4_super_block, s_volume_name is not NUL terminated. The other strings were marked in commit 072ebb3bffe6 (\"ext4: add nonstring annotations to ext4.h\"). Using strscpy() isn't the right replacement for strncpy(); it should use memtostr_pad() instead.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.1 未満"
    },
    "JVNDB-2024-007574": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel before 6.6.7, an untrusted VMM can trigger int80 syscall handling at any given point. This is related to arch/x86/coco/tdx/tdx.c and arch/x86/mm/mem_encrypt_amd.c.",
        "technologies": "Linux\nLinux Kernel 6.6.7 未満"
    },
    "JVNDB-2024-007576": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix server re-repick on subrequest retry When a subrequest is marked for needing retry, netfs will call cifs_prepare_write() which will make cifs repick the server for the op before renegotiating credits; it then calls cifs_issue_write() which invokes smb2_async_writev() - which re-repicks the server. If a different server is then selected, this causes the increment of server->in_flight to happen against one record and the decrement to happen against another, leading to misaccounting. Fix this by just removing the repick code in smb2_async_writev(). As this is only called from netfslib-driven code, cifs_prepare_write() should always have been called first, and so server should never be NULL and the preparatory step is repeated in the event that we do a retry. The problem manifests as a warning looking something like: WARNING: CPU: 4 PID: 72896 at fs/smb/client/smb2ops.c:97 smb2_add_credits+0x3f0/0x9e0 [cifs] ... RIP: 0010:smb2_add_credits+0x3f0/0x9e0 [cifs] ... smb2_writev_callback+0x334/0x560 [cifs] cifs_demultiplex_thread+0x77a/0x11b0 [cifs] kthread+0x187/0x1d0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30 Which may be triggered by a number of different xfstests running against an Azure server in multichannel mode. generic/249 seems the most repeatable, but generic/215, generic/249 and generic/308 may also show it.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.1 未満"
    },
    "JVNDB-2024-007579": {
        "title": "Linux の Linux Kernel における計算の誤りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: don't allow mapping the MMIO HDP page with large pages We don't get the right offset in that case. The GPU has an unused 4K area of the register BAR space into which you can remap registers. We remap the HDP flush registers into this space to allow userspace (CPU or GPU) to flush the HDP when it updates VRAM. However, on systems with >4K pages, we end up exposing PAGE_SIZE of MMIO space.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-007602": {
        "title": "インテルの Linux 用 ethernet 800 series controllers driver における脆弱性",
        "description": "Improper access control in Linux kernel mode driver for some Intel(R) Ethernet Network Controllers and Adapters before version 28.3 may allow an authenticated user to potentially enable escalation of privilege via local access.",
        "technologies": "インテル\nethernet 800 series controllers driver 28.3 未満\n日立\n日立アドバンストサーバ HA8000V シリーズ"
    },
    "JVNDB-2024-007581": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gtp: pull network headers in gtp_dev_xmit() syzbot/KMSAN reported use of uninit-value in get_dev_xmit() [1] We must make sure the IPv4 or Ipv6 header is pulled in skb->head before accessing fields in them. Use pskb_inet_may_pull() to fix this issue. [1] BUG: KMSAN: uninit-value in ipv6_pdp_find drivers/net/gtp.c:220 [inline] BUG: KMSAN: uninit-value in gtp_build_skb_ip6 drivers/net/gtp.c:1229 [inline] BUG: KMSAN: uninit-value in gtp_dev_xmit+0x1424/0x2540 drivers/net/gtp.c:1281 ipv6_pdp_find drivers/net/gtp.c:220 [inline] gtp_build_skb_ip6 drivers/net/gtp.c:1229 [inline] gtp_dev_xmit+0x1424/0x2540 drivers/net/gtp.c:1281 __netdev_start_xmit include/linux/netdevice.h:4913 [inline] netdev_start_xmit include/linux/netdevice.h:4922 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3596 __dev_queue_xmit+0x358c/0x5610 net/core/dev.c:4423 dev_queue_xmit include/linux/netdevice.h:3105 [inline] packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276 packet_snd net/packet/af_packet.c:3145 [inline] packet_sendmsg+0x90e3/0xa3a0 net/packet/af_packet.c:3177 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:745 __sys_sendto+0x685/0x830 net/socket.c:2204 __do_sys_sendto net/socket.c:2216 [inline] __se_sys_sendto net/socket.c:2212 [inline] __x64_sys_sendto+0x125/0x1d0 net/socket.c:2212 x64_sys_call+0x3799/0x3c10 arch/x86/include/generated/asm/syscalls_64.h:45 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: slab_post_alloc_hook mm/slub.c:3994 [inline] slab_alloc_node mm/slub.c:4037 [inline] kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4080 kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:583 __alloc_skb+0x363/0x7b0 net/core/skbuff.c:674 alloc_skb include/linux/skbuff.h:1320 [inline] alloc_skb_with_frags+0xc8/0xbf0 net/core/skbuff.c:6526 sock_alloc_send_pskb+0xa81/0xbf0 net/core/sock.c:2815 packet_alloc_skb net/packet/af_packet.c:2994 [inline] packet_snd net/packet/af_packet.c:3088 [inline] packet_sendmsg+0x749c/0xa3a0 net/packet/af_packet.c:3177 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:745 __sys_sendto+0x685/0x830 net/socket.c:2204 __do_sys_sendto net/socket.c:2216 [inline] __se_sys_sendto net/socket.c:2212 [inline] __x64_sys_sendto+0x125/0x1d0 net/socket.c:2212 x64_sys_call+0x3799/0x3c10 arch/x86/include/generated/asm/syscalls_64.h:45 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f CPU: 0 UID: 0 PID: 7115 Comm: syz.1.515 Not tainted 6.11.0-rc1-syzkaller-00043-g94ede2a3e913 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024",
        "technologies": "Linux\nLinux Kernel 4.7 以上 4.19.321 未満\nLinux Kernel 4.20 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007577": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: atm: idt77252: prevent use after free in dequeue_rx() We can't dereference \"skb\" after calling vcc->push() because the skb is released.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 4.19.321 未満\nLinux Kernel 4.20 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007431": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: prevent UAF in ip6_send_skb() syzbot reported an UAF in ip6_send_skb() [1] After ip6_local_out() has returned, we no longer can safely dereference rt, unless we hold rcu_read_lock(). A similar issue has been fixed in commit a688caa34beb (\"ipv6: take rcu lock in rawv6_send_hdrinc()\") Another potential issue in ip6_finish_output2() is handled in a separate patch. [1] BUG: KASAN: slab-use-after-free in ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964 Read of size 8 at addr ffff88806dde4858 by task syz.1.380/6530 CPU: 1 UID: 0 PID: 6530 Comm: syz.1.380 Not tainted 6.11.0-rc3-syzkaller-00306-gdf6cbc62cc9b #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964 rawv6_push_pending_frames+0x75c/0x9e0 net/ipv6/raw.c:588 rawv6_sendmsg+0x19c7/0x23c0 net/ipv6/raw.c:926 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x1a6/0x270 net/socket.c:745 sock_write_iter+0x2dd/0x400 net/socket.c:1160 do_iter_readv_writev+0x60a/0x890 vfs_writev+0x37c/0xbb0 fs/read_write.c:971 do_writev+0x1b1/0x350 fs/read_write.c:1018 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f936bf79e79 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f936cd7f038 EFLAGS: 00000246 ORIG_RAX: 0000000000000014 RAX: ffffffffffffffda RBX: 00007f936c115f80 RCX: 00007f936bf79e79 RDX: 0000000000000001 RSI: 0000000020000040 RDI: 0000000000000004 RBP: 00007f936bfe7916 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f936c115f80 R15: 00007fff2860a7a8 </TASK> Allocated by task 6530: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 unpoison_slab_object mm/kasan/common.c:312 [inline] __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:338 kasan_slab_alloc include/linux/kasan.h:201 [inline] slab_post_alloc_hook mm/slub.c:3988 [inline] slab_alloc_node mm/slub.c:4037 [inline] kmem_cache_alloc_noprof+0x135/0x2a0 mm/slub.c:4044 dst_alloc+0x12b/0x190 net/core/dst.c:89 ip6_blackhole_route+0x59/0x340 net/ipv6/route.c:2670 make_blackhole net/xfrm/xfrm_policy.c:3120 [inline] xfrm_lookup_route+0xd1/0x1c0 net/xfrm/xfrm_policy.c:3313 ip6_dst_lookup_flow+0x13e/0x180 net/ipv6/ip6_output.c:1257 rawv6_sendmsg+0x1283/0x23c0 net/ipv6/raw.c:898 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x1a6/0x270 net/socket.c:745 ____sys_sendmsg+0x525/0x7d0 net/socket.c:2597 ___sys_sendmsg net/socket.c:2651 [inline] __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2680 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 45: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579 poison_slab_object+0xe0/0x150 mm/kasan/common.c:240 __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256 kasan_slab_free include/linux/kasan.h:184 [inline] slab_free_hook mm/slub.c:2252 [inline] slab_free mm/slub.c:4473 [inline] kmem_cache_free+0x145/0x350 mm/slub.c:4548 dst_destroy+0x2ac/0x460 net/core/dst.c:124 rcu_do_batch kernel/rcu/tree.c:2569 [inline] rcu_core+0xafd/0x1830 kernel/rcu/tree. ---truncated---",
        "technologies": "Linux\nLinux Kernel 2.6.32 以上 4.19.321 未満\nLinux Kernel 4.20 以上 5.4.283 未満\nLinux Kernel 5.5 以上 5.10.225 未満\nLinux Kernel 5.11 以上 5.15.166 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007658": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Fix out-of-bounds read in `v3d_csd_job_run()` When enabling UBSAN on Raspberry Pi 5, we get the following warning: [ 387.894977] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/v3d/v3d_sched.c:320:3 [ 387.903868] index 7 is out of range for type '__u32 [7]' [ 387.909692] CPU: 0 PID: 1207 Comm: kworker/u16:2 Tainted: G WC 6.10.3-v8-16k-numa #151 [ 387.919166] Hardware name: Raspberry Pi 5 Model B Rev 1.0 (DT) [ 387.925961] Workqueue: v3d_csd drm_sched_run_job_work [gpu_sched] [ 387.932525] Call trace: [ 387.935296] dump_backtrace+0x170/0x1b8 [ 387.939403] show_stack+0x20/0x38 [ 387.942907] dump_stack_lvl+0x90/0xd0 [ 387.946785] dump_stack+0x18/0x28 [ 387.950301] __ubsan_handle_out_of_bounds+0x98/0xd0 [ 387.955383] v3d_csd_job_run+0x3a8/0x438 [v3d] [ 387.960707] drm_sched_run_job_work+0x520/0x6d0 [gpu_sched] [ 387.966862] process_one_work+0x62c/0xb48 [ 387.971296] worker_thread+0x468/0x5b0 [ 387.975317] kthread+0x1c4/0x1e0 [ 387.978818] ret_from_fork+0x10/0x20 [ 387.983014] ---[ end trace ]--- This happens because the UAPI provides only seven configuration registers and we are reading the eighth position of this u32 array. Therefore, fix the out-of-bounds read in `v3d_csd_job_run()` by accessing only seven positions on the '__u32 [7]' array. The eighth register exists indeed on V3D 7.1, but it isn't currently used. That being so, let's guarantee that it remains unused and add a note that it could be set in a future patch.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007524": {
        "title": "インテルの Linux 用 ethernet 800 series controllers driver における脆弱性",
        "description": "Protection mechanism failure in Linux kernel mode driver for some Intel(R) Ethernet Network Controllers and Adapters E810 Series before version 28.3 may allow an unauthenticated user to potentially enable denial of service via network access.",
        "technologies": "インテル\nethernet 800 series controllers driver 28.3 未満\n日立\n日立アドバンストサーバ HA8000V シリーズ"
    },
    "JVNDB-2024-007657": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ethernet: mtk_wed: fix use-after-free panic in mtk_wed_setup_tc_block_cb() When there are multiple ap interfaces on one band and with WED on, turning the interface down will cause a kernel panic on MT798X. Previously, cb_priv was freed in mtk_wed_setup_tc_block() without marking NULL,and mtk_wed_setup_tc_block_cb() didn't check the value, too. Assign NULL after free cb_priv in mtk_wed_setup_tc_block() and check NULL in mtk_wed_setup_tc_block_cb(). ---------- Unable to handle kernel paging request at virtual address 0072460bca32b4f5 Call trace: mtk_wed_setup_tc_block_cb+0x4/0x38 0xffffffc0794084bc tcf_block_playback_offloads+0x70/0x1e8 tcf_block_unbind+0x6c/0xc8 ... ---------",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.48 未満\nLinux Kernel 6.7 以上 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007624": {
        "title": "インテルの Linux 用 ethernet 800 series controllers driver における計算の誤りに関する脆弱性",
        "description": "Wrap-around error in Linux kernel mode driver for some Intel(R) Ethernet Network Controllers and Adapters before version 28.3 may allow an authenticated user to potentially enable escalation of privilege via local access.",
        "technologies": "インテル\nethernet 800 series controllers driver 28.3 未満\n日立\n日立アドバンストサーバ HA8000V シリーズ"
    },
    "JVNDB-2024-007689": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfc: nci: Fix uninit-value in nci_rx_work syzbot reported the following uninit-value access issue [1] nci_rx_work() parses received packet from ndev->rx_q. It should be validated header size, payload size and total packet size before processing the packet. If an invalid packet is detected, it should be silently discarded.",
        "technologies": "Linux\nLinux Kernel 4.19.312 以上 6.19.316 未満\nLinux Kernel 5.4.274 以上 5.4.278 未満\nLinux Kernel 5.10.215 以上 5.10.219 未満\nLinux Kernel 5.15.154 以上 5.15.161 未満\nLinux Kernel 6.1.85 以上 6.1.93 未満\nLinux Kernel 6.6.26 以上 6.6.33 未満\nLinux Kernel 6.8.5 以上 6.9.4 未満"
    },
    "JVNDB-2024-007690": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: watchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_trigger When the cpu5wdt module is removing, the origin code uses del_timer() to de-activate the timer. If the timer handler is running, del_timer() could not stop it and will return directly. If the port region is released by release_region() and then the timer handler cpu5wdt_trigger() calls outb() to write into the region that is released, the use-after-free bug will happen. Change del_timer() to timer_shutdown_sync() in order that the timer handler could be finished before the port region is released.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-008593": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drivers/perf: hisi_pcie: Fix out-of-bound access when valid event group The perf tool allows users to create event groups through following cmd [1], but the driver does not check whether the array index is out of bounds when writing data to the event_group array. If the number of events in an event_group is greater than HISI_PCIE_MAX_COUNTERS, the memory write overflow of event_group array occurs. Add array index check to fix the possible array out of bounds violation, and return directly when write new events are written to array bounds. There are 9 different events in an event_group. [1] perf stat -e '{pmu/event1/, ... ,pmu/event9/}'",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-008571": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drivers/perf: hisi: hns3: Fix out-of-bound access when valid event group The perf tool allows users to create event groups through following cmd [1], but the driver does not check whether the array index is out of bounds when writing data to the event_group array. If the number of events in an event_group is greater than HNS3_PMU_MAX_HW_EVENTS, the memory write overflow of event_group array occurs. Add array index check to fix the possible array out of bounds violation, and return directly when write new events are written to array bounds. There are 9 different events in an event_group. [1] perf stat -e '{pmu/event1/, ... ,pmu/event9/}",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-008769": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix mc_data out-of-bounds read warning Clear warning that read mc_data[i-1] may out-of-bounds.",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-008764": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: of/irq: Prevent device address out-of-bounds read in interrupt map walk When of_irq_parse_raw() is invoked with a device address smaller than the interrupt parent node (from #address-cells property), KASAN detects the following out-of-bounds read when populating the initial match table (dyndbg=\"func of_irq_parse_* +p\"): OF: of_irq_parse_one: dev=/soc@0/picasso/watchdog, index=0 OF: parent=/soc@0/pci@878000000000/gpio0@17,0, intsize=2 OF: intspec=4 OF: of_irq_parse_raw: ipar=/soc@0/pci@878000000000/gpio0@17,0, size=2 OF: -> addrsize=3 ================================================================== BUG: KASAN: slab-out-of-bounds in of_irq_parse_raw+0x2b8/0x8d0 Read of size 4 at addr ffffff81beca5608 by task bash/764 CPU: 1 PID: 764 Comm: bash Tainted: G O 6.1.67-484c613561-nokia_sm_arm64 #1 Hardware name: Unknown Unknown Product/Unknown Product, BIOS 2023.01-12.24.03-dirty 01/01/2023 Call trace: dump_backtrace+0xdc/0x130 show_stack+0x1c/0x30 dump_stack_lvl+0x6c/0x84 print_report+0x150/0x448 kasan_report+0x98/0x140 __asan_load4+0x78/0xa0 of_irq_parse_raw+0x2b8/0x8d0 of_irq_parse_one+0x24c/0x270 parse_interrupts+0xc0/0x120 of_fwnode_add_links+0x100/0x2d0 fw_devlink_parse_fwtree+0x64/0xc0 device_add+0xb38/0xc30 of_device_add+0x64/0x90 of_platform_device_create_pdata+0xd0/0x170 of_platform_bus_create+0x244/0x600 of_platform_notify+0x1b0/0x254 blocking_notifier_call_chain+0x9c/0xd0 __of_changeset_entry_notify+0x1b8/0x230 __of_changeset_apply_notify+0x54/0xe4 of_overlay_fdt_apply+0xc04/0xd94 ... The buggy address belongs to the object at ffffff81beca5600 which belongs to the cache kmalloc-128 of size 128 The buggy address is located 8 bytes inside of 128-byte region [ffffff81beca5600, ffffff81beca5680) The buggy address belongs to the physical page: page:00000000230d3d03 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1beca4 head:00000000230d3d03 order:1 compound_mapcount:0 compound_pincount:0 flags: 0x8000000000010200(slab|head|zone=2) raw: 8000000000010200 0000000000000000 dead000000000122 ffffff810000c300 raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffffff81beca5500: 04 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffffff81beca5580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc >ffffff81beca5600: 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ^ ffffff81beca5680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffffff81beca5700: 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc ================================================================== OF: -> got it ! Prevent the out-of-bounds read by copying the device address into a buffer of sufficient size.",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-006671": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 6.9.11 未満"
    },
    "JVNDB-2024-008762": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix double put of @cfile in smb2_set_path_size() If smb2_compound_op() is called with a valid @cfile and returned -EINVAL, we need to call cifs_get_writable_path() before retrying it as the reference of @cfile was already dropped by previous call. This fixes the following KASAN splat when running fstests generic/013 against Windows Server 2022: CIFS: Attempting to mount //w22-fs0/scratch run fstests generic/013 at 2024-09-02 19:48:59 ================================================================== BUG: KASAN: slab-use-after-free in detach_if_pending+0xab/0x200 Write of size 8 at addr ffff88811f1a3730 by task kworker/3:2/176 CPU: 3 UID: 0 PID: 176 Comm: kworker/3:2 Not tainted 6.11.0-rc6 #2 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014 Workqueue: cifsoplockd cifs_oplock_break [cifs] Call Trace: <TASK> dump_stack_lvl+0x5d/0x80 ? detach_if_pending+0xab/0x200 print_report+0x156/0x4d9 ? detach_if_pending+0xab/0x200 ? __virt_addr_valid+0x145/0x300 ? __phys_addr+0x46/0x90 ? detach_if_pending+0xab/0x200 kasan_report+0xda/0x110 ? detach_if_pending+0xab/0x200 detach_if_pending+0xab/0x200 timer_delete+0x96/0xe0 ? __pfx_timer_delete+0x10/0x10 ? rcu_is_watching+0x20/0x50 try_to_grab_pending+0x46/0x3b0 __cancel_work+0x89/0x1b0 ? __pfx___cancel_work+0x10/0x10 ? kasan_save_track+0x14/0x30 cifs_close_deferred_file+0x110/0x2c0 [cifs] ? __pfx_cifs_close_deferred_file+0x10/0x10 [cifs] ? __pfx_down_read+0x10/0x10 cifs_oplock_break+0x4c1/0xa50 [cifs] ? __pfx_cifs_oplock_break+0x10/0x10 [cifs] ? lock_is_held_type+0x85/0xf0 ? mark_held_locks+0x1a/0x90 process_one_work+0x4c6/0x9f0 ? find_held_lock+0x8a/0xa0 ? __pfx_process_one_work+0x10/0x10 ? lock_acquired+0x220/0x550 ? __list_add_valid_or_report+0x37/0x100 worker_thread+0x2e4/0x570 ? __kthread_parkme+0xd1/0xf0 ? __pfx_worker_thread+0x10/0x10 kthread+0x17f/0x1c0 ? kthread+0xda/0x1c0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x60 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 1118: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 cifs_new_fileinfo+0xc8/0x9d0 [cifs] cifs_atomic_open+0x467/0x770 [cifs] lookup_open.isra.0+0x665/0x8b0 path_openat+0x4c3/0x1380 do_filp_open+0x167/0x270 do_sys_openat2+0x129/0x160 __x64_sys_creat+0xad/0xe0 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 83: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x70 poison_slab_object+0xe9/0x160 __kasan_slab_free+0x32/0x50 kfree+0xf2/0x300 process_one_work+0x4c6/0x9f0 worker_thread+0x2e4/0x570 kthread+0x17f/0x1c0 ret_from_fork+0x31/0x60 ret_from_fork_asm+0x1a/0x30 Last potentially related work creation: kasan_save_stack+0x30/0x50 __kasan_record_aux_stack+0xad/0xc0 insert_work+0x29/0xe0 __queue_work+0x5ea/0x760 queue_work_on+0x6d/0x90 _cifsFileInfo_put+0x3f6/0x770 [cifs] smb2_compound_op+0x911/0x3940 [cifs] smb2_set_path_size+0x228/0x270 [cifs] cifs_set_file_size+0x197/0x460 [cifs] cifs_setattr+0xd9c/0x14b0 [cifs] notify_change+0x4e3/0x740 do_truncate+0xfa/0x180 vfs_truncate+0x195/0x200 __x64_sys_truncate+0x109/0x150 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
        "technologies": "Linux\nLinux Kernel 6.6.32 以上 6.6.51 未満\nLinux Kernel 6.9 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008754": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix possible use-after-free issue in ftrace_location() KASAN reports a bug: BUG: KASAN: use-after-free in ftrace_location+0x90/0x120 Read of size 8 at addr ffff888141d40010 by task insmod/424 CPU: 8 PID: 424 Comm: insmod Tainted: G W 6.9.0-rc2+ [...] Call Trace: <TASK> dump_stack_lvl+0x68/0xa0 print_report+0xcf/0x610 kasan_report+0xb5/0xe0 ftrace_location+0x90/0x120 register_kprobe+0x14b/0xa40 kprobe_init+0x2d/0xff0 [kprobe_example] do_one_initcall+0x8f/0x2d0 do_init_module+0x13a/0x3c0 load_module+0x3082/0x33d0 init_module_from_file+0xd2/0x130 __x64_sys_finit_module+0x306/0x440 do_syscall_64+0x68/0x140 entry_SYSCALL_64_after_hwframe+0x71/0x79 The root cause is that, in lookup_rec(), ftrace record of some address is being searched in ftrace pages of some module, but those ftrace pages at the same time is being freed in ftrace_release_mod() as the corresponding module is being deleted: CPU1 | CPU2 register_kprobes() { | delete_module() { check_kprobe_address_safe() { | arch_check_ftrace_location() { | ftrace_location() { | lookup_rec() // USE! | ftrace_release_mod() // Free! To fix this issue: 1. Hold rcu lock as accessing ftrace pages in ftrace_location_range(); 2. Use ftrace_location_range() instead of lookup_rec() in ftrace_location(); 3. Call synchronize_rcu() before freeing any ftrace pages both in ftrace_process_locs()/ftrace_release_mod()/ftrace_free_mem().",
        "technologies": "Linux\nLinux Kernel 3.7 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-008706": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix ucode out-of-bounds read warning Clear warning that read ucode[] may out-of-bounds.",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-008784": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: binder: fix UAF caused by offsets overwrite Binder objects are processed and copied individually into the target buffer during transactions. Any raw data in-between these objects is copied as well. However, this raw data copy lacks an out-of-bounds check. If the raw data exceeds the data section size then the copy overwrites the offsets section. This eventually triggers an error that attempts to unwind the processed objects. However, at this point the offsets used to index these objects are now corrupted. Unwinding with corrupted offsets can result in decrements of arbitrary nodes and lead to their premature release. Other users of such nodes are left with a dangling pointer triggering a use-after-free. This issue is made evident by the following KASAN report (trimmed): ================================================================== BUG: KASAN: slab-use-after-free in _raw_spin_lock+0xe4/0x19c Write of size 4 at addr ffff47fc91598f04 by task binder-util/743 CPU: 9 UID: 0 PID: 743 Comm: binder-util Not tainted 6.11.0-rc4 #1 Hardware name: linux,dummy-virt (DT) Call trace: _raw_spin_lock+0xe4/0x19c binder_free_buf+0x128/0x434 binder_thread_write+0x8a4/0x3260 binder_ioctl+0x18f0/0x258c [...] Allocated by task 743: __kmalloc_cache_noprof+0x110/0x270 binder_new_node+0x50/0x700 binder_transaction+0x413c/0x6da8 binder_thread_write+0x978/0x3260 binder_ioctl+0x18f0/0x258c [...] Freed by task 745: kfree+0xbc/0x208 binder_thread_read+0x1c5c/0x37d4 binder_ioctl+0x16d8/0x258c [...] ================================================================== To avoid this issue, let's check that the raw data copy is within the boundaries of the data section.",
        "technologies": "Linux\nLinux Kernel 5.4.226 以上 5.4.284 未満\nLinux Kernel 5.10.157 以上 5.10.226 未満\nLinux Kernel 5.15.17 以上 5.15.167 未満\nLinux Kernel 5.17 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008981": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix out-of-bounds read of df_v1_7_channel_number Check the fb_channel_number range to avoid the array out-of-bounds read error",
        "technologies": "Linux\nLinux Kernel 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-008771": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix out-of-bounds write warning Check the ring type value to fix the out-of-bounds write warning",
        "technologies": "Linux\nLinux Kernel 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-008889": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: cougar: fix slab-out-of-bounds Read in cougar_report_fixup report_fixup for the Cougar 500k Gaming Keyboard was not verifying that the report descriptor size was correct before accessing it",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-007659": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: idpf: fix memory leaks and crashes while performing a soft reset The second tagged commit introduced a UAF, as it removed restoring q_vector->vport pointers after reinitializating the structures. This is due to that all queue allocation functions are performed here with the new temporary vport structure and those functions rewrite the backpointers to the vport. Then, this new struct is freed and the pointers start leading to nowhere. But generally speaking, the current logic is very fragile. It claims to be more reliable when the system is low on memory, but in fact, it consumes two times more memory as at the moment of running this function, there are two vports allocated with their queues and vectors. Moreover, it claims to prevent the driver from running into \"bad state\", but in fact, any error during the rebuild leaves the old vport in the partially allocated state. Finally, if the interface is down when the function is called, it always allocates a new queue set, but when the user decides to enable the interface later on, vport_open() allocates them once again, IOW there's a clear memory leak here. Just don't allocate a new queue set when performing a reset, that solves crashes and memory leaks. Readd the old queue number and reopen the interface on rollback - that solves limbo states when the device is left disabled and/or without HW queues enabled.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008773": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: dapm: Fix UAF for snd_soc_pcm_runtime object When using kernel with the following extra config, - CONFIG_KASAN=y - CONFIG_KASAN_GENERIC=y - CONFIG_KASAN_INLINE=y - CONFIG_KASAN_VMALLOC=y - CONFIG_FRAME_WARN=4096 kernel detects that snd_pcm_suspend_all() access a freed 'snd_soc_pcm_runtime' object when the system is suspended, which leads to a use-after-free bug: [ 52.047746] BUG: KASAN: use-after-free in snd_pcm_suspend_all+0x1a8/0x270 [ 52.047765] Read of size 1 at addr ffff0000b9434d50 by task systemd-sleep/2330 [ 52.047785] Call trace: [ 52.047787] dump_backtrace+0x0/0x3c0 [ 52.047794] show_stack+0x34/0x50 [ 52.047797] dump_stack_lvl+0x68/0x8c [ 52.047802] print_address_description.constprop.0+0x74/0x2c0 [ 52.047809] kasan_report+0x210/0x230 [ 52.047815] __asan_report_load1_noabort+0x3c/0x50 [ 52.047820] snd_pcm_suspend_all+0x1a8/0x270 [ 52.047824] snd_soc_suspend+0x19c/0x4e0 The snd_pcm_sync_stop() has a NULL check on 'substream->runtime' before making any access. So we need to always set 'substream->runtime' to NULL everytime we kfree() it.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008786": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sch/netem: fix use after free in netem_dequeue If netem_dequeue() enqueues packet to inner qdisc and that qdisc returns __NET_XMIT_STOLEN. The packet is dropped but qdisc_tree_reduce_backlog() is not called to update the parent's q.qlen, leading to the similar use-after-free as Commit e04991a48dbaf382 (\"netem: fix return value if duplicate enqueue fails\") Commands to trigger KASAN UaF: ip link add type dummy ip link set lo up ip link set dummy0 up tc qdisc add dev lo parent root handle 1: drr tc filter add dev lo parent 1: basic classid 1:1 tc class add dev lo classid 1:1 drr tc qdisc add dev lo parent 1:1 handle 2: netem tc qdisc add dev lo parent 2: handle 3: drr tc filter add dev lo parent 3: basic classid 3:1 action mirred egress redirect dev dummy0 tc class add dev lo classid 3:1 drr ping -c1 -W0.01 localhost # Trigger bug tc class del dev lo classid 1:1 tc class add dev lo classid 1:1 drr ping -c1 -W0.01 localhost # UaF",
        "technologies": "Linux\nLinux Kernel 3.3 以上 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008772": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: fastrpc: Fix double free of 'buf' in error path smatch warning: drivers/misc/fastrpc.c:1926 fastrpc_req_mmap() error: double free of 'buf' In fastrpc_req_mmap() error path, the fastrpc buffer is freed in fastrpc_req_munmap_impl() if unmap is successful. But in the end, there is an unconditional call to fastrpc_buf_free(). So the above case triggers the double free of fastrpc buf.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008989": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ila: call nf_unregister_net_hooks() sooner syzbot found an use-after-free Read in ila_nf_input [1] Issue here is that ila_xlat_exit_net() frees the rhashtable, then call nf_unregister_net_hooks(). It should be done in the reverse way, with a synchronize_rcu(). This is a good match for a pre_exit() method. [1] BUG: KASAN: use-after-free in rht_key_hashfn include/linux/rhashtable.h:159 [inline] BUG: KASAN: use-after-free in __rhashtable_lookup include/linux/rhashtable.h:604 [inline] BUG: KASAN: use-after-free in rhashtable_lookup include/linux/rhashtable.h:646 [inline] BUG: KASAN: use-after-free in rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672 Read of size 4 at addr ffff888064620008 by task ksoftirqd/0/16 CPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.11.0-rc4-syzkaller-00238-g2ad6d23f465a #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 rht_key_hashfn include/linux/rhashtable.h:159 [inline] __rhashtable_lookup include/linux/rhashtable.h:604 [inline] rhashtable_lookup include/linux/rhashtable.h:646 [inline] rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672 ila_lookup_wildcards net/ipv6/ila/ila_xlat.c:132 [inline] ila_xlat_addr net/ipv6/ila/ila_xlat.c:652 [inline] ila_nf_input+0x1fe/0x3c0 net/ipv6/ila/ila_xlat.c:190 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xc3/0x220 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] NF_HOOK+0x29e/0x450 include/linux/netfilter.h:312 __netif_receive_skb_one_core net/core/dev.c:5661 [inline] __netif_receive_skb+0x1ea/0x650 net/core/dev.c:5775 process_backlog+0x662/0x15b0 net/core/dev.c:6108 __napi_poll+0xcb/0x490 net/core/dev.c:6772 napi_poll net/core/dev.c:6841 [inline] net_rx_action+0x89b/0x1240 net/core/dev.c:6963 handle_softirqs+0x2c4/0x970 kernel/softirq.c:554 run_ksoftirqd+0xca/0x130 kernel/softirq.c:928 smpboot_thread_fn+0x544/0xa30 kernel/smpboot.c:164 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> The buggy address belongs to the physical page: page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x64620 flags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff) page_type: 0xbfffffff(buddy) raw: 00fff00000000000 ffffea0000959608 ffffea00019d9408 0000000000000000 raw: 0000000000000000 0000000000000003 00000000bfffffff 0000000000000000 page dumped because: kasan: bad access detected page_owner tracks the page as freed page last allocated via order 3, migratetype Unmovable, gfp_mask 0x52dc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_ZERO), pid 5242, tgid 5242 (syz-executor), ts 73611328570, free_ts 618981657187 set_page_owner include/linux/page_owner.h:32 [inline] post_alloc_hook+0x1f3/0x230 mm/page_alloc.c:1493 prep_new_page mm/page_alloc.c:1501 [inline] get_page_from_freelist+0x2e4c/0x2f10 mm/page_alloc.c:3439 __alloc_pages_noprof+0x256/0x6c0 mm/page_alloc.c:4695 __alloc_pages_node_noprof include/linux/gfp.h:269 [inline] alloc_pages_node_noprof include/linux/gfp.h:296 [inline] ___kmalloc_large_node+0x8b/0x1d0 mm/slub.c:4103 __kmalloc_large_node_noprof+0x1a/0x80 mm/slub.c:4130 __do_kmalloc_node mm/slub.c:4146 [inline] __kmalloc_node_noprof+0x2d2/0x440 mm/slub.c:4164 __kvmalloc_node_noprof+0x72/0x190 mm/util.c:650 bucket_table_alloc lib/rhashtable.c:186 [inline] rhashtable_init_noprof+0x534/0xa60 lib/rhashtable.c:1071 ila_xlat_init_net+0xa0/0x110 net/ipv6/ila/ila_xlat.c:613 ops_ini ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.5 以上 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-008982": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: VMCI: Fix use-after-free when removing resource in vmci_resource_remove() When removing a resource from vmci_resource_table in vmci_resource_remove(), the search is performed using the resource handle by comparing context and resource fields. It is possible though to create two resources with different types but same handle (same context and resource fields). When trying to remove one of the resources, vmci_resource_remove() may not remove the intended one, but the object will still be freed as in the case of the datagram type in vmci_datagram_destroy_handle(). vmci_resource_table will still hold a pointer to this freed resource leading to a use-after-free vulnerability. BUG: KASAN: use-after-free in vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline] BUG: KASAN: use-after-free in vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147 Read of size 4 at addr ffff88801c16d800 by task syz-executor197/1592 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x82/0xa9 lib/dump_stack.c:106 print_address_description.constprop.0+0x21/0x366 mm/kasan/report.c:239 __kasan_report.cold+0x7f/0x132 mm/kasan/report.c:425 kasan_report+0x38/0x51 mm/kasan/report.c:442 vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline] vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147 vmci_qp_broker_detach+0x89a/0x11b9 drivers/misc/vmw_vmci/vmci_queue_pair.c:2182 ctx_free_ctx+0x473/0xbe1 drivers/misc/vmw_vmci/vmci_context.c:444 kref_put include/linux/kref.h:65 [inline] vmci_ctx_put drivers/misc/vmw_vmci/vmci_context.c:497 [inline] vmci_ctx_destroy+0x170/0x1d6 drivers/misc/vmw_vmci/vmci_context.c:195 vmci_host_close+0x125/0x1ac drivers/misc/vmw_vmci/vmci_host.c:143 __fput+0x261/0xa34 fs/file_table.c:282 task_work_run+0xf0/0x194 kernel/task_work.c:164 tracehook_notify_resume include/linux/tracehook.h:189 [inline] exit_to_user_mode_loop+0x184/0x189 kernel/entry/common.c:187 exit_to_user_mode_prepare+0x11b/0x123 kernel/entry/common.c:220 __syscall_exit_to_user_mode_work kernel/entry/common.c:302 [inline] syscall_exit_to_user_mode+0x18/0x42 kernel/entry/common.c:313 do_syscall_64+0x41/0x85 arch/x86/entry/common.c:86 entry_SYSCALL_64_after_hwframe+0x6e/0x0 This change ensures the type is also checked when removing the resource from vmci_resource_table in vmci_resource_remove().",
        "technologies": "Linux\nLinux Kernel 3.9 以上 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009012": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (adc128d818) Fix underflows seen when writing limit attributes DIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large negative number such as -9223372036854775808 is provided by the user. Fix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満"
    },
    "JVNDB-2024-009169": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: move netif_queue_set_napi to rtnl-protected sections Currently, netif_queue_set_napi() is called from ice_vsi_rebuild() that is not rtnl-locked when called from the reset. This creates the need to take the rtnl_lock just for a single function and complicates the synchronization with .ndo_bpf. At the same time, there no actual need to fill napi-to-queue information at this exact point. Fill napi-to-queue information when opening the VSI and clear it when the VSI is being closed. Those routines are already rtnl-locked. Also, rewrite napi-to-queue assignment in a way that prevents inclusion of XDP queues, as this leads to out-of-bounds writes, such as one below. [ +0.000004] BUG: KASAN: slab-out-of-bounds in netif_queue_set_napi+0x1c2/0x1e0 [ +0.000012] Write of size 8 at addr ffff889881727c80 by task bash/7047 [ +0.000006] CPU: 24 PID: 7047 Comm: bash Not tainted 6.10.0-rc2+ #2 [ +0.000004] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021 [ +0.000003] Call Trace: [ +0.000003] <TASK> [ +0.000002] dump_stack_lvl+0x60/0x80 [ +0.000007] print_report+0xce/0x630 [ +0.000007] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ +0.000007] ? __virt_addr_valid+0x1c9/0x2c0 [ +0.000005] ? netif_queue_set_napi+0x1c2/0x1e0 [ +0.000003] kasan_report+0xe9/0x120 [ +0.000004] ? netif_queue_set_napi+0x1c2/0x1e0 [ +0.000004] netif_queue_set_napi+0x1c2/0x1e0 [ +0.000005] ice_vsi_close+0x161/0x670 [ice] [ +0.000114] ice_dis_vsi+0x22f/0x270 [ice] [ +0.000095] ice_pf_dis_all_vsi.constprop.0+0xae/0x1c0 [ice] [ +0.000086] ice_prepare_for_reset+0x299/0x750 [ice] [ +0.000087] pci_dev_save_and_disable+0x82/0xd0 [ +0.000006] pci_reset_function+0x12d/0x230 [ +0.000004] reset_store+0xa0/0x100 [ +0.000006] ? __pfx_reset_store+0x10/0x10 [ +0.000002] ? __pfx_mutex_lock+0x10/0x10 [ +0.000004] ? __check_object_size+0x4c1/0x640 [ +0.000007] kernfs_fop_write_iter+0x30b/0x4a0 [ +0.000006] vfs_write+0x5d6/0xdf0 [ +0.000005] ? fd_install+0x180/0x350 [ +0.000005] ? __pfx_vfs_write+0x10/0xA10 [ +0.000004] ? do_fcntl+0x52c/0xcd0 [ +0.000004] ? kasan_save_track+0x13/0x60 [ +0.000003] ? kasan_save_free_info+0x37/0x60 [ +0.000006] ksys_write+0xfa/0x1d0 [ +0.000003] ? __pfx_ksys_write+0x10/0x10 [ +0.000002] ? __x64_sys_fcntl+0x121/0x180 [ +0.000004] ? _raw_spin_lock+0x87/0xe0 [ +0.000005] do_syscall_64+0x80/0x170 [ +0.000007] ? _raw_spin_lock+0x87/0xe0 [ +0.000004] ? __pfx__raw_spin_lock+0x10/0x10 [ +0.000003] ? file_close_fd_locked+0x167/0x230 [ +0.000005] ? syscall_exit_to_user_mode+0x7d/0x220 [ +0.000005] ? do_syscall_64+0x8c/0x170 [ +0.000004] ? do_syscall_64+0x8c/0x170 [ +0.000003] ? do_syscall_64+0x8c/0x170 [ +0.000003] ? fput+0x1a/0x2c0 [ +0.000004] ? filp_close+0x19/0x30 [ +0.000004] ? do_dup2+0x25a/0x4c0 [ +0.000004] ? __x64_sys_dup2+0x6e/0x2e0 [ +0.000002] ? syscall_exit_to_user_mode+0x7d/0x220 [ +0.000004] ? do_syscall_64+0x8c/0x170 [ +0.000003] ? __count_memcg_events+0x113/0x380 [ +0.000005] ? handle_mm_fault+0x136/0x820 [ +0.000005] ? do_user_addr_fault+0x444/0xa80 [ +0.000004] ? clear_bhb_loop+0x25/0x80 [ +0.000004] ? clear_bhb_loop+0x25/0x80 [ +0.000002] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ +0.000005] RIP: 0033:0x7f2033593154",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009583": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: pm: Fix uaf in __timer_delete_sync There are two paths to access mptcp_pm_del_add_timer, result in a race condition: CPU1 CPU2 ==== ==== net_rx_action napi_poll netlink_sendmsg __napi_poll netlink_unicast process_backlog netlink_unicast_kernel __netif_receive_skb genl_rcv __netif_receive_skb_one_core netlink_rcv_skb NF_HOOK genl_rcv_msg ip_local_deliver_finish genl_family_rcv_msg ip_protocol_deliver_rcu genl_family_rcv_msg_doit tcp_v4_rcv mptcp_pm_nl_flush_addrs_doit tcp_v4_do_rcv mptcp_nl_remove_addrs_list tcp_rcv_established mptcp_pm_remove_addrs_and_subflows tcp_data_queue remove_anno_list_by_saddr mptcp_incoming_options mptcp_pm_del_add_timer mptcp_pm_del_add_timer kfree(entry) In remove_anno_list_by_saddr(running on CPU2), after leaving the critical zone protected by \"pm.lock\", the entry will be released, which leads to the occurrence of uaf in the mptcp_pm_del_add_timer(running on CPU1). Keeping a reference to add_timer inside the lock, and calling sk_stop_timer_sync() with this reference, instead of \"entry->add_timer\". Move list_del(&entry->list) to mptcp_pm_del_add_timer and inside the pm lock, do not directly access any members of the entry outside the pm lock, which can avoid similar \"entry->x\" uaf.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 6.1.111 未満\nLinux Kernel 6.2 以上 6.6.52 未満\nLinux Kernel 6.7 以上 6.10.11 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009494": {
        "title": "Linux の Linux Kernel におけるリンク解釈に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Squashfs: sanity check symbolic link size Syzkiller reports a \"KMSAN: uninit-value in pick_link\" bug. This is caused by an uninitialised page, which is ultimately caused by a corrupted symbolic link size read from disk. The reason why the corrupted symlink size causes an uninitialised page is due to the following sequence of events: 1. squashfs_read_inode() is called to read the symbolic link from disk. This assigns the corrupted value 3875536935 to inode->i_size. 2. Later squashfs_symlink_read_folio() is called, which assigns this corrupted value to the length variable, which being a signed int, overflows producing a negative number. 3. The following loop that fills in the page contents checks that the copied bytes is less than length, which being negative means the loop is skipped, producing an uninitialised page. This patch adds a sanity check which checks that the symbolic link size is not larger than expected. -- V2: fix spelling mistake.",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009257": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: amd_sfh: free driver_data after destroying hid device HID driver callbacks aren't called anymore once hid_destroy_device() has been called. Hence, hid driver_data should be freed only after the hid_destroy_device() function returned as driver_data is used in several callbacks. I observed a crash with kernel 6.10.0 on my T14s Gen 3, after enabling KASAN to debug memory allocation, I got this output: [ 13.050438] ================================================================== [ 13.054060] BUG: KASAN: slab-use-after-free in amd_sfh_get_report+0x3ec/0x530 [amd_sfh] [ 13.054809] psmouse serio1: trackpoint: Synaptics TrackPoint firmware: 0x02, buttons: 3/3 [ 13.056432] Read of size 8 at addr ffff88813152f408 by task (udev-worker)/479 [ 13.060970] CPU: 5 PID: 479 Comm: (udev-worker) Not tainted 6.10.0-arch1-2 #1 893bb55d7f0073f25c46adbb49eb3785fefd74b0 [ 13.063978] Hardware name: LENOVO 21CQCTO1WW/21CQCTO1WW, BIOS R22ET70W (1.40 ) 03/21/2024 [ 13.067860] Call Trace: [ 13.069383] input: TPPS/2 Synaptics TrackPoint as /devices/platform/i8042/serio1/input/input8 [ 13.071486] <TASK> [ 13.071492] dump_stack_lvl+0x5d/0x80 [ 13.074870] snd_hda_intel 0000:33:00.6: enabling device (0000 -> 0002) [ 13.078296] ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38] [ 13.082199] print_report+0x174/0x505 [ 13.085776] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 13.089367] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.093255] ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38] [ 13.097464] kasan_report+0xc8/0x150 [ 13.101461] ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38] [ 13.105802] amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38] [ 13.110303] amdtp_hid_request+0xb8/0x110 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38] [ 13.114879] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.119450] sensor_hub_get_feature+0x1d3/0x540 [hid_sensor_hub 3f13be3016ff415bea03008d45d99da837ee3082] [ 13.124097] hid_sensor_parse_common_attributes+0x4d0/0xad0 [hid_sensor_iio_common c3a5cbe93969c28b122609768bbe23efe52eb8f5] [ 13.127404] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.131925] ? __pfx_hid_sensor_parse_common_attributes+0x10/0x10 [hid_sensor_iio_common c3a5cbe93969c28b122609768bbe23efe52eb8f5] [ 13.136455] ? _raw_spin_lock_irqsave+0x96/0xf0 [ 13.140197] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 13.143602] ? devm_iio_device_alloc+0x34/0x50 [industrialio 3d261d5e5765625d2b052be40e526d62b1d2123b] [ 13.147234] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.150446] ? __devm_add_action+0x167/0x1d0 [ 13.155061] hid_gyro_3d_probe+0x120/0x7f0 [hid_sensor_gyro_3d 63da36a143b775846ab2dbb86c343b401b5e3172] [ 13.158581] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.161814] platform_probe+0xa2/0x150 [ 13.165029] really_probe+0x1e3/0x8a0 [ 13.168243] __driver_probe_device+0x18c/0x370 [ 13.171500] driver_probe_device+0x4a/0x120 [ 13.175000] __driver_attach+0x190/0x4a0 [ 13.178521] ? __pfx___driver_attach+0x10/0x10 [ 13.181771] bus_for_each_dev+0x106/0x180 [ 13.185033] ? __pfx__raw_spin_lock+0x10/0x10 [ 13.188229] ? __pfx_bus_for_each_dev+0x10/0x10 [ 13.191446] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.194382] bus_add_driver+0x29e/0x4d0 [ 13.197328] driver_register+0x1a5/0x360 [ 13.200283] ? __pfx_hid_gyro_3d_platform_driver_init+0x10/0x10 [hid_sensor_gyro_3d 63da36a143b775846ab2dbb86c343b401b5e3172] [ 13.203362] do_one_initcall+0xa7/0x380 [ 13.206432] ? __pfx_do_one_initcall+0x10/0x10 [ 13.210175] ? srso_alias_return_thunk+0x5/0xfbef5 [ 13.213211] ? kasan_unpoison+0x44/0x70 [ 13.216688] do_init_module+0x238/0x750 [ 13.2196 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009736": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/mgag200: Bind I2C lifetime to DRM device Managed cleanup with devm_add_action_or_reset() will release the I2C adapter when the underlying Linux device goes away. But the connector still refers to it, so this cleanup leaves behind a stale pointer in struct drm_connector.ddc. Bind the lifetime of the I2C adapter to the connector's lifetime by using DRM's managed release. When the DRM device goes away (after the Linux device) DRM will first clean up the connector and then clean up the I2C adapter.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.105 未満\nLinux Kernel 6.2 以上 6.6.46 未満\nLinux Kernel 6.7 以上 6.10.5 未満"
    },
    "JVNDB-2024-009666": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dma-buf: heaps: Fix off-by-one in CMA heap fault handler Until VM_DONTEXPAND was added in commit 1c1914d6e8c6 (\"dma-buf: heaps: Don't track CMA dma-buf pages under RssFile\") it was possible to obtain a mapping larger than the buffer size via mremap and bypass the overflow check in dma_buf_mmap_internal. When using such a mapping to attempt to fault past the end of the buffer, the CMA heap fault handler also checks the fault offset against the buffer size, but gets the boundary wrong by 1. Fix the boundary check so that we don't read off the end of the pages array and insert an arbitrary page in the mapping.",
        "technologies": "Linux\nLinux Kernel 5.11 以上 6.1.111 未満\nLinux Kernel 6.2 以上 6.6.52 未満\nLinux Kernel 6.7 以上 6.10.11 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009267": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fscache: delete fscache_cookie_lru_timer when fscache exits to avoid UAF The fscache_cookie_lru_timer is initialized when the fscache module is inserted, but is not deleted when the fscache module is removed. If timer_reduce() is called before removing the fscache module, the fscache_cookie_lru_timer will be added to the timer list of the current cpu. Afterwards, a use-after-free will be triggered in the softIRQ after removing the fscache module, as follows: ================================================================== BUG: unable to handle page fault for address: fffffbfff803c9e9 PF: supervisor read access in kernel mode PF: error_code(0x0000) - not-present page PGD 21ffea067 P4D 21ffea067 PUD 21ffe6067 PMD 110a7c067 PTE 0 Oops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Tainted: G W 6.11.0-rc3 #855 Tainted: [W]=WARN RIP: 0010:__run_timer_base.part.0+0x254/0x8a0 Call Trace: <IRQ> tmigr_handle_remote_up+0x627/0x810 __walk_groups.isra.0+0x47/0x140 tmigr_handle_remote+0x1fa/0x2f0 handle_softirqs+0x180/0x590 irq_exit_rcu+0x84/0xb0 sysvec_apic_timer_interrupt+0x6e/0x90 </IRQ> <TASK> asm_sysvec_apic_timer_interrupt+0x1a/0x20 RIP: 0010:default_idle+0xf/0x20 default_idle_call+0x38/0x60 do_idle+0x2b5/0x300 cpu_startup_entry+0x54/0x60 start_secondary+0x20d/0x280 common_startup_64+0x13e/0x148 </TASK> Modules linked in: [last unloaded: netfs] ================================================================== Therefore delete fscache_cookie_lru_timer when removing the fscahe module.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009469": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: Fix array index mistake in rtw89_sta_info_get_iter() In rtw89_sta_info_get_iter() 'status->he_gi' is compared to array size. But then 'rate->he_gi' is used as array index instead of 'status->he_gi'. This can lead to go beyond array boundaries in case of 'rate->he_gi' is not equal to 'status->he_gi' and is bigger than array size. Looks like \"copy-paste\" mistake. Fix this mistake by replacing 'rate->he_gi' with 'status->he_gi'. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-009284": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: fix the Out-of-bounds read warning using index i - 1U may beyond element index for mc_data[] when i = 0.",
        "technologies": "Linux\nLinux Kernel 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-009663": {
        "title": "Linux の Linux Kernel における初期化されていないポインタのアクセスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: um: line: always fill *error_out in setup_one_line() The pointer isn't initialized by callers, but I have encountered cases where it's still printed; initialize it in all possible cases in setup_one_line().",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満"
    },
    "JVNDB-2024-009670": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: microchip: vcap: Fix use-after-free error in kunit test This is a clear use-after-free error. We remove it, and rely on checking the return code of vcap_del_rule.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009584": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fou: fix initialization of grc The grc must be initialize first. There can be a condition where if fou is NULL, goto out will be executed and grc would be used uninitialized.",
        "technologies": "Linux\nLinux Kernel 5.10.226\nLinux Kernel 5.15.167\nLinux Kernel 6.1.110\nLinux Kernel 6.6.51\nLinux Kernel 6.10.10"
    },
    "JVNDB-2024-009628": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing/timerlat: Only clear timer if a kthread exists The timerlat tracer can use user space threads to check for osnoise and timer latency. If the program using this is killed via a SIGTERM, the threads are shutdown one at a time and another tracing instance can start up resetting the threads before they are fully closed. That causes the hrtimer assigned to the kthread to be shutdown and freed twice when the dying thread finally closes the file descriptors, causing a use-after-free bug. Only cancel the hrtimer if the associated thread is still around. Also add the interface_lock around the resetting of the tlat_var->kthread. Note, this is just a quick fix that can be backported to stable. A real fix is to have a better synchronization between the shutdown of old threads and the starting of new ones.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009644": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: meson: axg-card: fix 'use-after-free' Buffer 'card->dai_link' is reallocated in 'meson_card_reallocate_links()', so move 'pad' pointer initialization after this function when memory is already reallocated. Kasan bug report: ================================================================== BUG: KASAN: slab-use-after-free in axg_card_add_link+0x76c/0x9bc Read of size 8 at addr ffff000000e8b260 by task modprobe/356 CPU: 0 PID: 356 Comm: modprobe Tainted: G O 6.9.12-sdkernel #1 Call trace: dump_backtrace+0x94/0xec show_stack+0x18/0x24 dump_stack_lvl+0x78/0x90 print_report+0xfc/0x5c0 kasan_report+0xb8/0xfc __asan_load8+0x9c/0xb8 axg_card_add_link+0x76c/0x9bc [snd_soc_meson_axg_sound_card] meson_card_probe+0x344/0x3b8 [snd_soc_meson_card_utils] platform_probe+0x8c/0xf4 really_probe+0x110/0x39c __driver_probe_device+0xb8/0x18c driver_probe_device+0x108/0x1d8 __driver_attach+0xd0/0x25c bus_for_each_dev+0xe0/0x154 driver_attach+0x34/0x44 bus_add_driver+0x134/0x294 driver_register+0xa8/0x1e8 __platform_driver_register+0x44/0x54 axg_card_pdrv_init+0x20/0x1000 [snd_soc_meson_axg_sound_card] do_one_initcall+0xdc/0x25c do_init_module+0x10c/0x334 load_module+0x24c4/0x26cc init_module_from_file+0xd4/0x128 __arm64_sys_finit_module+0x1f4/0x41c invoke_syscall+0x60/0x188 el0_svc_common.constprop.0+0x78/0x13c do_el0_svc+0x30/0x40 el0_svc+0x38/0x78 el0t_64_sync_handler+0x100/0x12c el0t_64_sync+0x190/0x194",
        "technologies": "Linux\nLinux Kernel 4.19 以上 6.1.111 未満\nLinux Kernel 6.2 以上 6.6.52 未満\nLinux Kernel 6.7 以上 6.10.11 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009823": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check link_index before accessing dc->links[] [WHY & HOW] dc->links[] has max size of MAX_LINKS and NULL is return when trying to access with out-of-bound index. This fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 6.10.9 未満"
    },
    "JVNDB-2024-009824": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add array index check for hdcp ddc access [Why] Coverity reports OVERRUN warning. Do not check if array index valid. [How] Check msg_id valid and valid array index.",
        "technologies": "Linux\nLinux Kernel 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-009496": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: Fix the sorting functionality in iio_gts_build_avail_time_table The sorting in iio_gts_build_avail_time_table is not working as intended. It could result in an out-of-bounds access when the time is zero. Here are more details: 1. When the gts->itime_table[i].time_us is zero, e.g., the time sequence is `3, 0, 1`, the inner for-loop will not terminate and do out-of-bound writes. This is because once `times[j] > new`, the value `new` will be added in the current position and the `times[j]` will be moved to `j+1` position, which makes the if-condition always hold. Meanwhile, idx will be added one, making the loop keep running without termination and out-of-bound write. 2. If none of the gts->itime_table[i].time_us is zero, the elements will just be copied without being sorted as described in the comment \"Sort times from all tables to one and remove duplicates\". For more details, please refer to https://lore.kernel.org/all/6dd0d822-046c-4dd2-9532-79d7ab96ec05@gmail.com.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-009854": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check msg_id before processing transcation [WHY & HOW] HDCP_MESSAGE_ID_INVALID (-1) is not a valid msg_id nor is it a valid array index, and it needs checking before used. This fixes 4 OVERRUN issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-009827": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check gpio_id before used as array index [WHY & HOW] GPIO_ID_UNKNOWN (-1) is not a valid value for array index and therefore should be checked in advance. This fixes 5 OVERRUN issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-009844": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Fix negative array index read Avoid using the negative values for clk_idex as an index into an array pptable->DpmDescriptor. V2: fix clk_index return check (Tim Huang)",
        "technologies": "Linux\nLinux Kernel 6.1.109 未満\nLinux Kernel 6.2 以上 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-011025": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ep93xx: clock: Fix off by one in ep93xx_div_recalc_rate() The psc->div[] array has psc->num_div elements. These values come from when we call clk_hw_register_div(). It's adc_divisors and ARRAY_SIZE(adc_divisors)) and so on. So this condition needs to be >= instead of > to prevent an out of bounds read.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-010189": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Validate TA binary size Add TA binary size validation to avoid OOB write. (cherry picked from commit c0a04e3570d72aaf090962156ad085e37c62e442)",
        "technologies": "Linux\nLinux Kernel 6.1.107 未満\nLinux Kernel 6.2 より大きい 6.6.48 未満\nLinux Kernel 6.7 より大きい 6.10.7 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-011026": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drivers: media: dvb-frontends/rtl2830: fix an out-of-bounds write error Ensure index in rtl2830_pid_filter does not exceed 31 to prevent out-of-bounds access. dev->filters is a 32-bit value, so set_bit and clear_bit functions should only operate on indices from 0 to 31. If index is 32, it will attempt to access a non-existent 33rd bit, leading to out-of-bounds access. Change the boundary check from index > 32 to index >= 32 to resolve this issue.",
        "technologies": "Linux\nLinux Kernel 4.0 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-010988": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix potential oob read in nilfs_btree_check_delete() The function nilfs_btree_check_delete(), which checks whether degeneration to direct mapping occurs before deleting a b-tree entry, causes memory access outside the block buffer when retrieving the maximum key if the root node has no entries. This does not usually happen because b-tree mappings with 0 child nodes are never created by mkfs.nilfs2 or nilfs2 itself. However, it can happen if the b-tree root node read from a device is configured that way, so fix this potential issue by adding a check for that case.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-010118": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: void array out of bound when loop tnl_num When query reg inf of SSU, it loops tnl_num times. However, tnl_num comes from hardware and the length of array is a fixed value. To void array out of bound, make sure the loop time is not greater than the length of array",
        "technologies": "Linux\nLinux Kernel 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-010731": {
        "title": "マイクロソフトの Visual Studio Code におけるリモートでコードを実行される脆弱性",
        "description": "Visual Studio Code for Linux Remote Code Execution Vulnerability",
        "technologies": "マイクロソフト\nVisual Studio Code"
    },
    "JVNDB-2024-009749": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: panasonic-laptop: Fix SINF array out of bounds accesses The panasonic laptop code in various places uses the SINF array with index values of 0 - SINF_CUR_BRIGHT(0x0d) without checking that the SINF array is big enough. Not all panasonic laptops have this many SINF array entries, for example the Toughbook CF-18 model only has 10 SINF array entries. So it only supports the AC+DC brightness entries and mute. Check that the SINF array has a minimum size which covers all AC+DC brightness entries and refuse to load if the SINF array is smaller. For higher SINF indexes hide the sysfs attributes when the SINF array does not contain an entry for that attribute, avoiding show()/store() accessing the array out of bounds and add bounds checking to the probe() and resume() code accessing these.",
        "technologies": "Linux\nLinux Kernel 3.3 以上 6.1.111 未満\nLinux Kernel 6.2 以上 6.6.52 未満\nLinux Kernel 6.7 以上 6.10.11 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-010983": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/hugetlb.c: fix UAF of vma in hugetlb fault pathway Syzbot reports a UAF in hugetlb_fault(). This happens because vmf_anon_prepare() could drop the per-VMA lock and allow the current VMA to be freed before hugetlb_vma_unlock_read() is called. We can fix this by using a modified version of vmf_anon_prepare() that doesn't release the VMA lock on failure, and then release it ourselves after hugetlb_vma_unlock_read().",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-010082": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: serial: sc16is7xx: fix TX fifo corruption Sometimes, when a packet is received on channel A at almost the same time as a packet is about to be transmitted on channel B, we observe with a logic analyzer that the received packet on channel A is transmitted on channel B. In other words, the Tx buffer data on channel B is corrupted with data from channel A. The problem appeared since commit 4409df5866b7 (\"serial: sc16is7xx: change EFR lock to operate on each channels\"), which changed the EFR locking to operate on each channel instead of chip-wise. This commit has introduced a regression, because the EFR lock is used not only to protect the EFR registers access, but also, in a very obscure and undocumented way, to protect access to the data buffer, which is shared by the Tx and Rx handlers, but also by each channel of the IC. Fix this regression first by switching to kfifo_out_linear_ptr() in sc16is7xx_handle_tx() to eliminate the need for a shared Rx/Tx buffer. Secondly, replace the chip-wise Rx buffer with a separate Rx buffer for each channel.",
        "technologies": "Linux\nLinux Kernel 6.1.76 以上 6.2 未満\nLinux Kernel 6.6.15 以上 6.7 未満\nLinux Kernel 6.7.3 以上 6.8 未満\nLinux Kernel 6.8 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-010116": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: parisc: fix a possible DMA corruption ARCH_DMA_MINALIGN was defined as 16 - this is too small - it may be possible that two unrelated 16-byte allocations share a cache line. If one of these allocations is written using DMA and the other is written using cached write, the value that was written with DMA may be corrupted. This commit changes ARCH_DMA_MINALIGN to be 128 on PA20 and 32 on PA1.1 - that's the largest possible cache line size. As different parisc microarchitectures have different cache line size, we define arch_slab_minalign(), cache_line_size() and dma_get_cache_alignment() so that the kernel may tune slab cache parameters dynamically, based on the detected cache line size.",
        "technologies": "Linux\nLinux Kernel 6.6.46 未満\nLinux Kernel 6.7 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-009828": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: nxp-fspi: fix the KASAN report out-of-bounds bug Change the memcpy length to fix the out-of-bounds issue when writing the data that is not 4 byte aligned to TX FIFO. To reproduce the issue, write 3 bytes data to NOR chip. dd if=3b of=/dev/mtd0 [ 36.926103] ================================================================== [ 36.933409] BUG: KASAN: slab-out-of-bounds in nxp_fspi_exec_op+0x26ec/0x2838 [ 36.940514] Read of size 4 at addr ffff00081037c2a0 by task dd/455 [ 36.946721] [ 36.948235] CPU: 3 UID: 0 PID: 455 Comm: dd Not tainted 6.11.0-rc5-gc7b0e37c8434 #1070 [ 36.956185] Hardware name: Freescale i.MX8QM MEK (DT) [ 36.961260] Call trace: [ 36.963723] dump_backtrace+0x90/0xe8 [ 36.967414] show_stack+0x18/0x24 [ 36.970749] dump_stack_lvl+0x78/0x90 [ 36.974451] print_report+0x114/0x5cc [ 36.978151] kasan_report+0xa4/0xf0 [ 36.981670] __asan_report_load_n_noabort+0x1c/0x28 [ 36.986587] nxp_fspi_exec_op+0x26ec/0x2838 [ 36.990800] spi_mem_exec_op+0x8ec/0xd30 [ 36.994762] spi_mem_no_dirmap_read+0x190/0x1e0 [ 36.999323] spi_mem_dirmap_write+0x238/0x32c [ 37.003710] spi_nor_write_data+0x220/0x374 [ 37.007932] spi_nor_write+0x110/0x2e8 [ 37.011711] mtd_write_oob_std+0x154/0x1f0 [ 37.015838] mtd_write_oob+0x104/0x1d0 [ 37.019617] mtd_write+0xb8/0x12c [ 37.022953] mtdchar_write+0x224/0x47c [ 37.026732] vfs_write+0x1e4/0x8c8 [ 37.030163] ksys_write+0xec/0x1d0 [ 37.033586] __arm64_sys_write+0x6c/0x9c [ 37.037539] invoke_syscall+0x6c/0x258 [ 37.041327] el0_svc_common.constprop.0+0x160/0x22c [ 37.046244] do_el0_svc+0x44/0x5c [ 37.049589] el0_svc+0x38/0x78 [ 37.052681] el0t_64_sync_handler+0x13c/0x158 [ 37.057077] el0t_64_sync+0x190/0x194 [ 37.060775] [ 37.062274] Allocated by task 455: [ 37.065701] kasan_save_stack+0x2c/0x54 [ 37.069570] kasan_save_track+0x20/0x3c [ 37.073438] kasan_save_alloc_info+0x40/0x54 [ 37.077736] __kasan_kmalloc+0xa0/0xb8 [ 37.081515] __kmalloc_noprof+0x158/0x2f8 [ 37.085563] mtd_kmalloc_up_to+0x120/0x154 [ 37.089690] mtdchar_write+0x130/0x47c [ 37.093469] vfs_write+0x1e4/0x8c8 [ 37.096901] ksys_write+0xec/0x1d0 [ 37.100332] __arm64_sys_write+0x6c/0x9c [ 37.104287] invoke_syscall+0x6c/0x258 [ 37.108064] el0_svc_common.constprop.0+0x160/0x22c [ 37.112972] do_el0_svc+0x44/0x5c [ 37.116319] el0_svc+0x38/0x78 [ 37.119401] el0t_64_sync_handler+0x13c/0x158 [ 37.123788] el0t_64_sync+0x190/0x194 [ 37.127474] [ 37.128977] The buggy address belongs to the object at ffff00081037c2a0 [ 37.128977] which belongs to the cache kmalloc-8 of size 8 [ 37.141177] The buggy address is located 0 bytes inside of [ 37.141177] allocated 3-byte region [ffff00081037c2a0, ffff00081037c2a3) [ 37.153465] [ 37.154971] The buggy address belongs to the physical page: [ 37.160559] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x89037c [ 37.168596] flags: 0xbfffe0000000000(node=0|zone=2|lastcpupid=0x1ffff) [ 37.175149] page_type: 0xfdffffff(slab) [ 37.179021] raw: 0bfffe0000000000 ffff000800002500 dead000000000122 0000000000000000 [ 37.186788] raw: 0000000000000000 0000000080800080 00000001fdffffff 0000000000000000 [ 37.194553] page dumped because: kasan: bad access detected [ 37.200144] [ 37.201647] Memory state around the buggy address: [ 37.206460] ffff00081037c180: fa fc fc fc fa fc fc fc fa fc fc fc fa fc fc fc [ 37.213701] ffff00081037c200: fa fc fc fc 05 fc fc fc 03 fc fc fc 02 fc fc fc [ 37.220946] >ffff00081037c280: 06 fc fc fc 03 fc fc fc fc fc fc fc fc fc fc fc [ 37.228186] ^ [ 37.232473] ffff00081037c300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 37.239718] ffff00081037c380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 37.246962] ============================================================== ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.1 以上 6.1.111 未満\nLinux Kernel 6.2 以上 6.6.52 未満\nLinux Kernel 6.7 以上 6.10.11 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-010113": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: aspeed_udc: validate endpoint index for ast udc We should verify the bound of the array to assure that host may not manipulate the index to point past endpoint array. Found by static analysis.",
        "technologies": "Linux\nLinux Kernel 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満"
    },
    "JVNDB-2024-009937": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_box [Why] Coverity reports OVERRUN warning. soc.num_states could be 40. But array range of bw_params->clk_table.entries is 8. [How] Assert if soc.num_states greater than 8.",
        "technologies": "Linux\nLinux Kernel 6.6.50 未満\nLinux Kernel 6.7 以上 6.10.9 未満"
    },
    "JVNDB-2024-009851": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: dpaa: Pad packets to ETH_ZLEN When sending packets under 60 bytes, up to three bytes of the buffer following the data may be leaked. Avoid this by extending all packets to ETH_ZLEN, ensuring nothing is leaked in the padding. This bug can be reproduced by running $ ping -s 11 destination",
        "technologies": "Linux\nLinux Kernel 4.10 以上 6.1.111 未満\nLinux Kernel 6.2 以上 6.6.52 未満\nLinux Kernel 6.7 以上 6.10.11 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-011027": {
        "title": "Linux の Linux Kernel における例外的な状態のチェックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/tdx: Fix \"in-kernel MMIO\" check TDX only supports kernel-initiated MMIO operations. The handle_mmio() function checks if the #VE exception occurred in the kernel and rejects the operation if it did not. However, userspace can deceive the kernel into performing MMIO on its behalf. For example, if userspace can point a syscall to an MMIO address, syscall does get_user() or put_user() on it, triggering MMIO #VE. The kernel will treat the #VE as in-kernel MMIO. Ensure that the target MMIO address is within the kernel before decoding instruction.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011061": {
        "title": "Linux の Linux Kernel における型の取り違えに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ACPI: sysfs: validate return type of _STR method Only buffer objects are valid return values of _STR. If something else is returned description_show() will access invalid memory.",
        "technologies": "Linux\nLinux Kernel 3.7 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011062": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix helper writes to read-only maps Lonial found an issue that despite user- and BPF-side frozen BPF map (like in case of .rodata), it was still possible to write into it from a BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT} as arguments. In check_func_arg() when the argument is as mentioned, the meta->raw_mode is never set. Later, check_helper_mem_access(), under the case of PTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the subsequent call to check_map_access_type() and given the BPF map is read-only it succeeds. The helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT when results are written into them as opposed to read out of them. The latter indicates that it's okay to pass a pointer to uninitialized memory as the memory is written to anyway. However, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM just with additional alignment requirement. So it is better to just get rid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the fixed size memory types. For this, add MEM_ALIGNED to additionally ensure alignment given these helpers write directly into the args via *<ptr> = val. The .arg*_size has been initialized reflecting the actual sizeof(*<ptr>). MEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated argument types, since in !MEM_FIXED_SIZE cases the verifier does not know the buffer size a priori and therefore cannot blindly write *<ptr> = val.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011114": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drivers: media: dvb-frontends/rtl2832: fix an out-of-bounds write error Ensure index in rtl2832_pid_filter does not exceed 31 to prevent out-of-bounds access. dev->filters is a 32-bit value, so set_bit and clear_bit functions should only operate on indices from 0 to 31. If index is 32, it will attempt to access a non-existent 33rd bit, leading to out-of-bounds access. Change the boundary check from index > 32 to index >= 32 to resolve this issue. [hverkuil: added fixes tag, rtl2830_pid_filter -> rtl2832_pid_filter in logmsg]",
        "technologies": "Linux\nLinux Kernel 4.0 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011113": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: hisilicon/qm - inject error before stopping queue The master ooo cannot be completely closed when the accelerator core reports memory error. Therefore, the driver needs to inject the qm error to close the master ooo. Currently, the qm error is injected after stopping queue, memory may be released immediately after stopping queue, causing the device to access the released memory. Therefore, error is injected to close master ooo before stopping queue to ensure that the device does not access the released memory.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-008905": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満"
    },
    "JVNDB-2024-011110": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: elx: libefc: Fix potential use after free in efc_nport_vport_del() The kref_put() function will call nport->release if the refcount drops to zero. The nport->release release function is _efc_nport_free() which frees \"nport\". But then we dereference \"nport\" on the next line which is a use after free. Re-order these lines to avoid the use after free.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011111": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: PCI: kirin: Fix buffer overflow in kirin_pcie_parse_port() Within kirin_pcie_parse_port(), the pcie->num_slots is compared to pcie->gpio_id_reset size (MAX_PCI_SLOTS) which is correct and would lead to an overflow. Thus, fix condition to pcie->num_slots + 1 >= MAX_PCI_SLOTS and move pcie->num_slots increment below the if-statement to avoid out-of-bounds array access. Found by Linux Verification Center (linuxtesting.org) with SVACE. [kwilczynski: commit log]",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011057": {
        "title": "Linux の Linux Kernel におけるパストラバーサルの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware_loader: Block path traversal Most firmware names are hardcoded strings, or are constructed from fairly constrained format strings where the dynamic parts are just some hex numbers or such. However, there are a couple codepaths in the kernel where firmware file names contain string components that are passed through from a device or semi-privileged userspace; the ones I could find (not counting interfaces that require root privileges) are: - lpfc_sli4_request_firmware_update() seems to construct the firmware filename from \"ModelName\", a string that was previously parsed out of some descriptor (\"Vital Product Data\") in lpfc_fill_vpd() - nfp_net_fw_find() seems to construct a firmware filename from a model name coming from nfp_hwinfo_lookup(pf->hwinfo, \"nffw.partno\"), which I think parses some descriptor that was read from the device. (But this case likely isn't exploitable because the format string looks like \"netronome/nic_%s\", and there shouldn't be any *folders* starting with \"netronome/nic_\". The previous case was different because there, the \"%s\" is *at the start* of the format string.) - module_flash_fw_schedule() is reachable from the ETHTOOL_MSG_MODULE_FW_FLASH_ACT netlink command, which is marked as GENL_UNS_ADMIN_PERM (meaning CAP_NET_ADMIN inside a user namespace is enough to pass the privilege check), and takes a userspace-provided firmware name. (But I think to reach this case, you need to have CAP_NET_ADMIN over a network namespace that a special kind of ethernet device is mapped into, so I think this is not a viable attack path in practice.) Fix it by rejecting any firmware names containing \"..\" path components. For what it's worth, I went looking and haven't found any USB device drivers that use the firmware loader dangerously.",
        "technologies": "Linux\nLinux Kernel 3.7 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011051": {
        "title": "Linux Foundation の ONNX におけるパストラバーサルの脆弱性",
        "description": "A vulnerability in the `download_model_with_test_data` function of the onnx/onnx framework, version 1.16.0, allows for arbitrary file overwrite due to inadequate prevention of path traversal attacks in malicious tar files. This vulnerability enables attackers to overwrite any file on the system, potentially leading to remote code execution, deletion of system, personal, or application files, thus impacting the integrity and availability of the system. The issue arises from the function's handling of tar file extraction without performing security checks on the paths within the tar file, as demonstrated by the ability to overwrite the `/home/kali/.ssh/authorized_keys` file by specifying an absolute path in the malicious tar file.",
        "technologies": "Linux Foundation\nONNX 1.16.0"
    },
    "JVNDB-2024-011112": {
        "title": "Linux の Linux Kernel における常に不適切な制御フローの実装に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: call the security_mmap_file() LSM hook in remap_file_pages() The remap_file_pages syscall handler calls do_mmap() directly, which doesn't contain the LSM security check. And if the process has called personality(READ_IMPLIES_EXEC) before and remap_file_pages() is called for RW pages, this will actually result in remapping the pages to RWX, bypassing a W^X policy enforced by SELinux. So we should check prot by security_mmap_file LSM hook in the remap_file_pages syscall handler before do_mmap() is called. Otherwise, it potentially permits an attacker to bypass a W^X policy enforced by SELinux. The bypass is similar to CVE-2016-10044, which bypass the same thing via AIO and can be found in [1]. The PoC: $ cat > test.c int main(void) { size_t pagesz = sysconf(_SC_PAGE_SIZE); int mfd = syscall(SYS_memfd_create, \"test\", 0); const char *buf = mmap(NULL, 4 * pagesz, PROT_READ | PROT_WRITE, MAP_SHARED, mfd, 0); unsigned int old = syscall(SYS_personality, 0xffffffff); syscall(SYS_personality, READ_IMPLIES_EXEC | old); syscall(SYS_remap_file_pages, buf, pagesz, 0, 2, 0); syscall(SYS_personality, old); // show the RWX page exists even if W^X policy is enforced int fd = open(\"/proc/self/maps\", O_RDONLY); unsigned char buf2[1024]; while (1) { int ret = read(fd, buf2, 1024); if (ret <= 0) break; write(1, buf2, ret); } close(fd); } $ gcc test.c -o test $ ./test | grep rwx 7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted) [PM: subject line tweaks]",
        "technologies": "Linux\nLinux Kernel 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011059": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Fix double free in OPTEE transport Channels can be shared between protocols, avoid freeing the same channel descriptors twice when unloading the stack.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011054": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: remove unused C2H event ID RTW89_MAC_C2H_FUNC_READ_WOW_CAM to prevent out-of-bounds reading The handler of firmware C2H event RTW89_MAC_C2H_FUNC_READ_WOW_CAM isn't implemented, but driver expects number of handlers is NUM_OF_RTW89_MAC_C2H_FUNC_WOW causing out-of-bounds access. Fix it by removing ID. Addresses-Coverity-ID: 1598775 (\"Out-of-bounds read\")",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-008985": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満"
    },
    "JVNDB-2024-009009": {
        "title": "Linux の Linux Kernel における整数アンダーフローの脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 4.19.322 未満\nLinux Kernel 4.20 以上 5.4.284 未満\nLinux Kernel 5.5 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満"
    },
    "JVNDB-2024-011128": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw88: always wait for both firmware loading attempts In 'rtw_wait_firmware_completion()', always wait for both (regular and wowlan) firmware loading attempts. Otherwise if 'rtw_usb_intf_init()' has failed in 'rtw_usb_probe()', 'rtw_usb_disconnect()' may issue 'ieee80211_free_hw()' when one of 'rtw_load_firmware_cb()' (usually the wowlan one) is still in progress, causing UAF detected by KASAN.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011046": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powercap: intel_rapl: Fix off by one in get_rpi() The rp->priv->rpi array is either rpi_msr or rpi_tpmi which have NR_RAPL_PRIMITIVES number of elements. Thus the > needs to be >= to prevent an off by one access.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011039": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread() syzbot reports a f2fs bug as below: __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_report+0xe8/0x550 mm/kasan/report.c:491 kasan_report+0x143/0x180 mm/kasan/report.c:601 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189 instrument_atomic_read_write include/linux/instrumented.h:96 [inline] atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:252 [inline] __refcount_add include/linux/refcount.h:184 [inline] __refcount_inc include/linux/refcount.h:241 [inline] refcount_inc include/linux/refcount.h:258 [inline] get_task_struct include/linux/sched/task.h:118 [inline] kthread_stop+0xca/0x630 kernel/kthread.c:704 f2fs_stop_gc_thread+0x65/0xb0 fs/f2fs/gc.c:210 f2fs_do_shutdown+0x192/0x540 fs/f2fs/file.c:2283 f2fs_ioc_shutdown fs/f2fs/file.c:2325 [inline] __f2fs_ioctl+0x443a/0xbe60 fs/f2fs/file.c:4325 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The root cause is below race condition, it may cause use-after-free issue in sbi->gc_th pointer. - remount - f2fs_remount - f2fs_stop_gc_thread - kfree(gc_th) - f2fs_ioc_shutdown - f2fs_do_shutdown - f2fs_stop_gc_thread - kthread_stop(gc_th->f2fs_gc_task) : sbi->gc_thread = NULL; We will call f2fs_do_shutdown() in two paths: - for f2fs_ioc_shutdown() path, we should grab sb->s_umount semaphore for fixing. - for f2fs_shutdown() path, it's safe since caller has already grabbed sb->s_umount semaphore.",
        "technologies": "Linux\nLinux Kernel 4.16 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011120": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/rtrs-clt: Reset cid to con_num - 1 to stay in bounds In the function init_conns(), after the create_con() and create_cm() for loop if something fails. In the cleanup for loop after the destroy tag, we access out of bound memory because cid is set to clt_path->s.con_num. This commits resets the cid to clt_path->s.con_num - 1, to stay in bounds in the cleanup loop later.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011040": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: avoid OOB when system.data xattr changes underneath the filesystem When looking up for an entry in an inlined directory, if e_value_offs is changed underneath the filesystem by some change in the block device, it will lead to an out-of-bounds access that KASAN detects as an UAF. EXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 r/w without journal. Quota mode: none. loop0: detected capacity change from 2048 to 2047 ================================================================== BUG: KASAN: use-after-free in ext4_search_dir+0xf2/0x1c0 fs/ext4/namei.c:1500 Read of size 1 at addr ffff88803e91130f by task syz-executor269/5103 CPU: 0 UID: 0 PID: 5103 Comm: syz-executor269 Not tainted 6.11.0-rc4-syzkaller #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 ext4_search_dir+0xf2/0x1c0 fs/ext4/namei.c:1500 ext4_find_inline_entry+0x4be/0x5e0 fs/ext4/inline.c:1697 __ext4_find_entry+0x2b4/0x1b30 fs/ext4/namei.c:1573 ext4_lookup_entry fs/ext4/namei.c:1727 [inline] ext4_lookup+0x15f/0x750 fs/ext4/namei.c:1795 lookup_one_qstr_excl+0x11f/0x260 fs/namei.c:1633 filename_create+0x297/0x540 fs/namei.c:3980 do_symlinkat+0xf9/0x3a0 fs/namei.c:4587 __do_sys_symlinkat fs/namei.c:4610 [inline] __se_sys_symlinkat fs/namei.c:4607 [inline] __x64_sys_symlinkat+0x95/0xb0 fs/namei.c:4607 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f3e73ced469 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 21 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fff4d40c258 EFLAGS: 00000246 ORIG_RAX: 000000000000010a RAX: ffffffffffffffda RBX: 0032656c69662f2e RCX: 00007f3e73ced469 RDX: 0000000020000200 RSI: 00000000ffffff9c RDI: 00000000200001c0 RBP: 0000000000000000 R08: 00007fff4d40c290 R09: 00007fff4d40c290 R10: 0023706f6f6c2f76 R11: 0000000000000246 R12: 00007fff4d40c27c R13: 0000000000000003 R14: 431bde82d7b634db R15: 00007fff4d40c2b0 </TASK> Calling ext4_xattr_ibody_find right after reading the inode with ext4_get_inode_loc will lead to a check of the validity of the xattrs, avoiding this problem.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011031": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix Use-After-Free of rsv_qp on HIP08 Currently rsv_qp is freed before ib_unregister_device() is called on HIP08. During the time interval, users can still dereg MR and rsv_qp will be used in this process, leading to a UAF. Move the release of rsv_qp after calling ib_unregister_device() to fix it.",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011123": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: af_unix: Don't return OOB skb in manage_oob(). syzbot reported use-after-free in unix_stream_recv_urg(). [0] The scenario is 1. send(MSG_OOB) 2. recv(MSG_OOB) -> The consumed OOB remains in recv queue 3. send(MSG_OOB) 4. recv() -> manage_oob() returns the next skb of the consumed OOB -> This is also OOB, but unix_sk(sk)->oob_skb is not cleared 5. recv(MSG_OOB) -> unix_sk(sk)->oob_skb is used but already freed The recent commit 8594d9b85c07 (\"af_unix: Don't call skb_get() for OOB skb.\") uncovered the issue. If the OOB skb is consumed and the next skb is peeked in manage_oob(), we still need to check if the skb is OOB. Let's do so by falling back to the following checks in manage_oob() and add the test case in selftest. Note that we need to add a similar check for SIOCATMARK. [0]: BUG: KASAN: slab-use-after-free in unix_stream_read_actor+0xa6/0xb0 net/unix/af_unix.c:2959 Read of size 4 at addr ffff8880326abcc4 by task syz-executor178/5235 CPU: 0 UID: 0 PID: 5235 Comm: syz-executor178 Not tainted 6.11.0-rc5-syzkaller-00742-gfbdaffe41adc #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 unix_stream_read_actor+0xa6/0xb0 net/unix/af_unix.c:2959 unix_stream_recv_urg+0x1df/0x320 net/unix/af_unix.c:2640 unix_stream_read_generic+0x2456/0x2520 net/unix/af_unix.c:2778 unix_stream_recvmsg+0x22b/0x2c0 net/unix/af_unix.c:2996 sock_recvmsg_nosec net/socket.c:1046 [inline] sock_recvmsg+0x22f/0x280 net/socket.c:1068 ____sys_recvmsg+0x1db/0x470 net/socket.c:2816 ___sys_recvmsg net/socket.c:2858 [inline] __sys_recvmsg+0x2f0/0x3e0 net/socket.c:2888 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f5360d6b4e9 Code: 48 83 c4 28 c3 e8 37 17 00 00 0f 1f 80 00 00 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fff29b3a458 EFLAGS: 00000246 ORIG_RAX: 000000000000002f RAX: ffffffffffffffda RBX: 00007fff29b3a638 RCX: 00007f5360d6b4e9 RDX: 0000000000002001 RSI: 0000000020000640 RDI: 0000000000000003 RBP: 00007f5360dde610 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001 R13: 00007fff29b3a628 R14: 0000000000000001 R15: 0000000000000001 </TASK> Allocated by task 5235: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 unpoison_slab_object mm/kasan/common.c:312 [inline] __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:338 kasan_slab_alloc include/linux/kasan.h:201 [inline] slab_post_alloc_hook mm/slub.c:3988 [inline] slab_alloc_node mm/slub.c:4037 [inline] kmem_cache_alloc_node_noprof+0x16b/0x320 mm/slub.c:4080 __alloc_skb+0x1c3/0x440 net/core/skbuff.c:667 alloc_skb include/linux/skbuff.h:1320 [inline] alloc_skb_with_frags+0xc3/0x770 net/core/skbuff.c:6528 sock_alloc_send_pskb+0x91a/0xa60 net/core/sock.c:2815 sock_alloc_send_skb include/net/sock.h:1778 [inline] queue_oob+0x108/0x680 net/unix/af_unix.c:2198 unix_stream_sendmsg+0xd24/0xf80 net/unix/af_unix.c:2351 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:745 ____sys_sendmsg+0x525/0x7d0 net/socket.c:2597 ___sys_sendmsg net/socket.c:2651 [inline] __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2680 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 5235: kasan_save_stack mm/kasan/common.c:47 ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.9.8 以上 6.10 未満\nLinux Kernel 6.10 以上 6.11.2 未満"
    },
    "JVNDB-2024-011129": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/vm: move xa_alloc to prevent UAF Evil user can guess the next id of the vm before the ioctl completes and then call vm destroy ioctl to trigger UAF since create ioctl is still referencing the same vm. Move the xa_alloc all the way to the end to prevent this. v2: - Rebase (cherry picked from commit dcfd3971327f3ee92765154baebbaece833d3ca9)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.11.3 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011131": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommufd: Protect against overflow of ALIGN() during iova allocation Userspace can supply an iova and uptr such that the target iova alignment becomes really big and ALIGN() overflows which corrupts the selected area range during allocation. CONFIG_IOMMUFD_TEST can detect this: WARNING: CPU: 1 PID: 5092 at drivers/iommu/iommufd/io_pagetable.c:268 iopt_alloc_area_pages drivers/iommu/iommufd/io_pagetable.c:268 [inline] WARNING: CPU: 1 PID: 5092 at drivers/iommu/iommufd/io_pagetable.c:268 iopt_map_pages+0xf95/0x1050 drivers/iommu/iommufd/io_pagetable.c:352 Modules linked in: CPU: 1 PID: 5092 Comm: syz-executor294 Not tainted 6.10.0-rc5-syzkaller-00294-g3ffea9a7a6f7 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/07/2024 RIP: 0010:iopt_alloc_area_pages drivers/iommu/iommufd/io_pagetable.c:268 [inline] RIP: 0010:iopt_map_pages+0xf95/0x1050 drivers/iommu/iommufd/io_pagetable.c:352 Code: fc e9 a4 f3 ff ff e8 1a 8b 4c fc 41 be e4 ff ff ff e9 8a f3 ff ff e8 0a 8b 4c fc 90 0f 0b 90 e9 37 f5 ff ff e8 fc 8a 4c fc 90 <0f> 0b 90 e9 68 f3 ff ff 48 c7 c1 ec 82 ad 8f 80 e1 07 80 c1 03 38 RSP: 0018:ffffc90003ebf9e0 EFLAGS: 00010293 RAX: ffffffff85499fa4 RBX: 00000000ffffffef RCX: ffff888079b49e00 RDX: 0000000000000000 RSI: 00000000ffffffef RDI: 0000000000000000 RBP: ffffc90003ebfc50 R08: ffffffff85499b30 R09: ffffffff85499942 R10: 0000000000000002 R11: ffff888079b49e00 R12: ffff8880228e0010 R13: 0000000000000000 R14: 1ffff920007d7f68 R15: ffffc90003ebfd00 FS: 000055557d760380(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000005fdeb8 CR3: 000000007404a000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> iommufd_ioas_copy+0x610/0x7b0 drivers/iommu/iommufd/ioas.c:274 iommufd_fops_ioctl+0x4d9/0x5a0 drivers/iommu/iommufd/main.c:421 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Cap the automatic alignment to the huge page size, which is probably a better idea overall. Huge automatic alignments can fragment and chew up the available IOVA space without any reason.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011511": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: uprobe: avoid out-of-bounds memory access of fetching args Uprobe needs to fetch args into a percpu buffer, and then copy to ring buffer to avoid non-atomic context problem. Sometimes user-space strings, arrays can be very large, but the size of percpu buffer is only page size. And store_trace_args() won't check whether these data exceeds a single page or not, caused out-of-bounds memory access. It could be reproduced by following steps: 1. build kernel with CONFIG_KASAN enabled 2. save follow program as test.c ``` \\#include <stdio.h> \\#include <stdlib.h> \\#include <string.h> // If string length large than MAX_STRING_SIZE, the fetch_store_strlen() // will return 0, cause __get_data_size() return shorter size, and // store_trace_args() will not trigger out-of-bounds access. // So make string length less than 4096. \\#define STRLEN 4093 void generate_string(char *str, int n) { int i; for (i = 0; i < n; ++i) { char c = i % 26 + 'a'; str[i] = c; } str[n-1] = '\\0'; } void print_string(char *str) { printf(\"%s\\n\", str); } int main() { char tmp[STRLEN]; generate_string(tmp, STRLEN); print_string(tmp); return 0; } ``` 3. compile program `gcc -o test test.c` 4. get the offset of `print_string()` ``` objdump -t test | grep -w print_string 0000000000401199 g F .text 000000000000001b print_string ``` 5. configure uprobe with offset 0x1199 ``` off=0x1199 cd /sys/kernel/debug/tracing/ echo \"p /root/test:${off} arg1=+0(%di):ustring arg2=\\$comm arg3=+0(%di):ustring\" > uprobe_events echo 1 > events/uprobes/enable echo 1 > tracing_on ``` 6. run `test`, and kasan will report error. ================================================================== BUG: KASAN: use-after-free in strncpy_from_user+0x1d6/0x1f0 Write of size 8 at addr ffff88812311c004 by task test/499CPU: 0 UID: 0 PID: 499 Comm: test Not tainted 6.12.0-rc3+ #18 Hardware name: Red Hat KVM, BIOS 1.16.0-4.al8 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x55/0x70 print_address_description.constprop.0+0x27/0x310 kasan_report+0x10f/0x120 ? strncpy_from_user+0x1d6/0x1f0 strncpy_from_user+0x1d6/0x1f0 ? rmqueue.constprop.0+0x70d/0x2ad0 process_fetch_insn+0xb26/0x1470 ? __pfx_process_fetch_insn+0x10/0x10 ? _raw_spin_lock+0x85/0xe0 ? __pfx__raw_spin_lock+0x10/0x10 ? __pte_offset_map+0x1f/0x2d0 ? unwind_next_frame+0xc5f/0x1f80 ? arch_stack_walk+0x68/0xf0 ? is_bpf_text_address+0x23/0x30 ? kernel_text_address.part.0+0xbb/0xd0 ? __kernel_text_address+0x66/0xb0 ? unwind_get_return_address+0x5e/0xa0 ? __pfx_stack_trace_consume_entry+0x10/0x10 ? arch_stack_walk+0xa2/0xf0 ? _raw_spin_lock_irqsave+0x8b/0xf0 ? __pfx__raw_spin_lock_irqsave+0x10/0x10 ? depot_alloc_stack+0x4c/0x1f0 ? _raw_spin_unlock_irqrestore+0xe/0x30 ? stack_depot_save_flags+0x35d/0x4f0 ? kasan_save_stack+0x34/0x50 ? kasan_save_stack+0x24/0x50 ? mutex_lock+0x91/0xe0 ? __pfx_mutex_lock+0x10/0x10 prepare_uprobe_buffer.part.0+0x2cd/0x500 uprobe_dispatcher+0x2c3/0x6a0 ? __pfx_uprobe_dispatcher+0x10/0x10 ? __kasan_slab_alloc+0x4d/0x90 handler_chain+0xdd/0x3e0 handle_swbp+0x26e/0x3d0 ? __pfx_handle_swbp+0x10/0x10 ? uprobe_pre_sstep_notifier+0x151/0x1b0 irqentry_exit_to_user_mode+0xe2/0x1b0 asm_exc_int3+0x39/0x40 RIP: 0033:0x401199 Code: 01 c2 0f b6 45 fb 88 02 83 45 fc 01 8b 45 fc 3b 45 e4 7c b7 8b 45 e4 48 98 48 8d 50 ff 48 8b 45 e8 48 01 d0 ce RSP: 002b:00007ffdf00576a8 EFLAGS: 00000206 RAX: 00007ffdf00576b0 RBX: 0000000000000000 RCX: 0000000000000ff2 RDX: 0000000000000ffc RSI: 0000000000000ffd RDI: 00007ffdf00576b0 RBP: 00007ffdf00586b0 R08: 00007feb2f9c0d20 R09: 00007feb2f9c0d20 R10: 0000000000000001 R11: 0000000000000202 R12: 0000000000401040 R13: 00007ffdf0058780 R14: 0000000000000000 R15: 0000000000000000 </TASK> This commit enforces the buffer's maxlen less than a page-size to avoid store_trace_args() out-of-memory access.",
        "technologies": "Linux\nLinux Kernel 3.14 以上 6.12 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011372": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix use-after-free in bpf_uprobe_multi_link_attach() If bpf_link_prime() fails, bpf_uprobe_multi_link_attach() goes to the error_free label and frees the array of bpf_uprobe's without calling bpf_uprobe_unregister(). This leaks bpf_uprobe->uprobe and worse, this frees bpf_uprobe->consumer without removing it from the uprobe->consumers list.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011429": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: fix possible badness in FREE_STATEID When multiple FREE_STATEIDs are sent for the same delegation stateid, it can lead to a possible either use-after-free or counter refcount underflow errors. In nfsd4_free_stateid() under the client lock we find a delegation stateid, however the code drops the lock before calling nfs4_put_stid(), that allows another FREE_STATE to find the stateid again. The first one will proceed to then free the stateid which leads to either use-after-free or decrementing already zeroed counter.",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.11.4 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011130": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe: fix UAF around queue destruction We currently do stuff like queuing the final destruction step on a random system wq, which will outlive the driver instance. With bad timing we can teardown the driver with one or more work workqueue still being alive leading to various UAF splats. Add a fini step to ensure user queues are properly torn down. At this point GuC should already be nuked so queue itself should no longer be referenced from hw pov. v2 (Matt B) - Looks much safer to use a waitqueue and then just wait for the xa_array to become empty before triggering the drain. (cherry picked from commit 861108666cc0e999cffeab6aff17b662e68774e3)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011390": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix race setting file private on concurrent lseek using same fd When doing concurrent lseek(2) system calls against the same file descriptor, using multiple threads belonging to the same process, we have a short time window where a race happens and can result in a memory leak. The race happens like this: 1) A program opens a file descriptor for a file and then spawns two threads (with the pthreads library for example), lets call them task A and task B; 2) Task A calls lseek with SEEK_DATA or SEEK_HOLE and ends up at file.c:find_desired_extent() while holding a read lock on the inode; 3) At the start of find_desired_extent(), it extracts the file's private_data pointer into a local variable named 'private', which has a value of NULL; 4) Task B also calls lseek with SEEK_DATA or SEEK_HOLE, locks the inode in shared mode and enters file.c:find_desired_extent(), where it also extracts file->private_data into its local variable 'private', which has a NULL value; 5) Because it saw a NULL file private, task A allocates a private structure and assigns to the file structure; 6) Task B also saw a NULL file private so it also allocates its own file private and then assigns it to the same file structure, since both tasks are using the same file descriptor. At this point we leak the private structure allocated by task A. Besides the memory leak, there's also the detail that both tasks end up using the same cached state record in the private structure (struct btrfs_file_private::llseek_cached_state), which can result in a use-after-free problem since one task can free it while the other is still using it (only one task took a reference count on it). Also, sharing the cached state is not a good idea since it could result in incorrect results in the future - right now it should not be a problem because it end ups being used only in extent-io-tree.c:count_range_bits() where we do range validation before using the cached state. Fix this by protecting the private assignment and check of a file while holding the inode's spinlock and keep track of the task that allocated the private, so that it's used only by that task in order to prevent user-after-free issues with the cached state record as well as potentially using it incorrectly in the future.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.54 未満\nLinux Kernel 6.7 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011524": {
        "title": "Linux の Linux Kernel におけるバッファサイズの計算の誤りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv, bpf: Fix out-of-bounds issue when preparing trampoline image We get the size of the trampoline image during the dry run phase and allocate memory based on that size. The allocated image will then be populated with instructions during the real patch phase. But after commit 26ef208c209a (\"bpf: Use arch_bpf_trampoline_size\"), the `im` argument is inconsistent in the dry run and real patch phase. This may cause emit_imm in RV64 to generate a different number of instructions when generating the 'im' address, potentially causing out-of-bounds issues. Let's emit the maximum number of instructions for the \"im\" address during dry run to fix this problem.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.3 未満"
    },
    "JVNDB-2024-011420": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/iwcm: Fix WARNING:at_kernel/workqueue.c:#check_flush_dependency In the commit aee2424246f9 (\"RDMA/iwcm: Fix a use-after-free related to destroying CM IDs\"), the function flush_workqueue is invoked to flush the work queue iwcm_wq. But at that time, the work queue iwcm_wq was created via the function alloc_ordered_workqueue without the flag WQ_MEM_RECLAIM. Because the current process is trying to flush the whole iwcm_wq, if iwcm_wq doesn't have the flag WQ_MEM_RECLAIM, verify that the current process is not reclaiming memory or running on a workqueue which doesn't have the flag WQ_MEM_RECLAIM as that can break forward-progress guarantee leading to a deadlock. The call trace is as below: [ 125.350876][ T1430] Call Trace: [ 125.356281][ T1430] <TASK> [ 125.361285][ T1430] ? __warn (kernel/panic.c:693) [ 125.367640][ T1430] ? check_flush_dependency (kernel/workqueue.c:3706 (discriminator 9)) [ 125.375689][ T1430] ? report_bug (lib/bug.c:180 lib/bug.c:219) [ 125.382505][ T1430] ? handle_bug (arch/x86/kernel/traps.c:239) [ 125.388987][ T1430] ? exc_invalid_op (arch/x86/kernel/traps.c:260 (discriminator 1)) [ 125.395831][ T1430] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h:621) [ 125.403125][ T1430] ? check_flush_dependency (kernel/workqueue.c:3706 (discriminator 9)) [ 125.410984][ T1430] ? check_flush_dependency (kernel/workqueue.c:3706 (discriminator 9)) [ 125.418764][ T1430] __flush_workqueue (kernel/workqueue.c:3970) [ 125.426021][ T1430] ? __pfx___might_resched (kernel/sched/core.c:10151) [ 125.433431][ T1430] ? destroy_cm_id (drivers/infiniband/core/iwcm.c:375) iw_cm [ 125.441209][ T1430] ? __pfx___flush_workqueue (kernel/workqueue.c:3910) [ 125.473900][ T1430] ? _raw_spin_lock_irqsave (arch/x86/include/asm/atomic.h:107 include/linux/atomic/atomic-arch-fallback.h:2170 include/linux/atomic/atomic-instrumented.h:1302 include/asm-generic/qspinlock.h:111 include/linux/spinlock.h:187 include/linux/spinlock_api_smp.h:111 kernel/locking/spinlock.c:162) [ 125.473909][ T1430] ? __pfx__raw_spin_lock_irqsave (kernel/locking/spinlock.c:161) [ 125.482537][ T1430] _destroy_id (drivers/infiniband/core/cma.c:2044) rdma_cm [ 125.495072][ T1430] nvme_rdma_free_queue (drivers/nvme/host/rdma.c:656 drivers/nvme/host/rdma.c:650) nvme_rdma [ 125.505827][ T1430] nvme_rdma_reset_ctrl_work (drivers/nvme/host/rdma.c:2180) nvme_rdma [ 125.505831][ T1430] process_one_work (kernel/workqueue.c:3231) [ 125.515122][ T1430] worker_thread (kernel/workqueue.c:3306 kernel/workqueue.c:3393) [ 125.515127][ T1430] ? __pfx_worker_thread (kernel/workqueue.c:3339) [ 125.531837][ T1430] kthread (kernel/kthread.c:389) [ 125.539864][ T1430] ? __pfx_kthread (kernel/kthread.c:342) [ 125.550628][ T1430] ret_from_fork (arch/x86/kernel/process.c:147) [ 125.558840][ T1430] ? __pfx_kthread (kernel/kthread.c:342) [ 125.558844][ T1430] ret_from_fork_asm (arch/x86/entry/entry_64.S:257) [ 125.566487][ T1430] </TASK> [ 125.566488][ T1430] ---[ end trace 0000000000000000 ]---",
        "technologies": "Linux\nLinux Kernel 4.19.320 以上 5.4 未満\nLinux Kernel 5.4.282 以上 5.10 未満\nLinux Kernel 5.10.224 以上 5.10.227 未満\nLinux Kernel 5.15.165 以上 5.15.168 未満\nLinux Kernel 6.1.103 以上 6.1.113 未満\nLinux Kernel 6.6.44 以上 6.6.54 未満\nLinux Kernel 6.10.3 以上 6.10.13 未満\nLinux Kernel 6.11 以上 6.11.2 未満"
    },
    "JVNDB-2024-011405": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: amdkfd_free_gtt_mem clear the correct pointer Pass pointer reference to amdgpu_bo_unref to clear the correct pointer, otherwise amdgpu_bo_unref clear the local variable, the original pointer not set to NULL, this could cause use-after-free bug.",
        "technologies": "Linux\nLinux Kernel 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011539": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: drop ppath from ext4_ext_replay_update_ex() to avoid double-free When calling ext4_force_split_extent_at() in ext4_ext_replay_update_ex(), the 'ppath' is updated but it is the 'path' that is freed, thus potentially triggering a double-free in the following process: ext4_ext_replay_update_ex ppath = path ext4_force_split_extent_at(&ppath) ext4_split_extent_at ext4_ext_insert_extent ext4_ext_create_new_leaf ext4_ext_grow_indepth ext4_find_extent if (depth > path[0].p_maxdepth) kfree(path) ---> path First freed *orig_path = path = NULL ---> null ppath kfree(path) ---> path double-free !!! So drop the unnecessary ppath and use path directly to avoid this problem. And use ext4_find_extent() directly to update path, avoiding unnecessary memory allocation and freeing. Also, propagate the error returned by ext4_find_extent() instead of using strange error codes.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011540": {
        "title": "Linux の Linux Kernel における保存または転送前の重要な情報の削除に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ethernet: lantiq_etop: fix memory disclosure When applying padding, the buffer is not zeroed, which results in memory disclosure. The mentioned data is observed on the wire. This patch uses skb_put_padto() to pad Ethernet frames properly. The mentioned function zeroes the expanded buffer. In case the packet cannot be padded it is silently dropped. Statistics are also not incremented. This driver does not support statistics in the old 32-bit format or the new 64-bit format. These will be added in the future. In its current form, the patch should be easily backported to stable versions. Ethernet MACs on Amazon-SE and Danube cannot do padding of the packets in hardware, so software padding must be applied.",
        "technologies": "Linux\nLinux Kernel 3.0 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011552": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix index out of bounds in DCN30 degamma hardware format translation This commit addresses a potential index out of bounds issue in the `cm3_helper_translate_curve_to_degamma_hw_format` function in the DCN30 color management module. The issue could occur when the index 'i' exceeds the number of transfer function points (TRANSFER_FUNC_POINTS). The fix adds a check to ensure 'i' is within bounds before accessing the transfer function points. If 'i' is out of bounds, the function returns false to indicate an error. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:338 cm3_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:339 cm3_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:340 cm3_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011556": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix array out-of-bound access in SoC stats Currently, the ath12k_soc_dp_stats::hal_reo_error array is defined with a maximum size of DP_REO_DST_RING_MAX. However, the ath12k_dp_rx_process() function access ath12k_soc_dp_stats::hal_reo_error using the REO destination SRNG ring ID, which is incorrect. SRNG ring ID differ from normal ring ID, and this usage leads to out-of-bounds array access. To fix this issue, modify ath12k_dp_rx_process() to use the normal ring ID directly instead of the SRNG ring ID to avoid out-of-bounds array access. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
        "technologies": "Linux\nLinux Kernel 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011553": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: Fix uaf in dbFreeBits [syzbot reported] ================================================================== BUG: KASAN: slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c:587 [inline] BUG: KASAN: slab-use-after-free in __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c:752 Read of size 8 at addr ffff8880229254b0 by task syz-executor357/5216 CPU: 0 UID: 0 PID: 5216 Comm: syz-executor357 Not tainted 6.11.0-rc3-syzkaller-00156-gd7a5aa4b3c00 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 __mutex_lock_common kernel/locking/mutex.c:587 [inline] __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c:752 dbFreeBits+0x7ea/0xd90 fs/jfs/jfs_dmap.c:2390 dbFreeDmap fs/jfs/jfs_dmap.c:2089 [inline] dbFree+0x35b/0x680 fs/jfs/jfs_dmap.c:409 dbDiscardAG+0x8a9/0xa20 fs/jfs/jfs_dmap.c:1650 jfs_ioc_trim+0x433/0x670 fs/jfs/jfs_discard.c:100 jfs_ioctl+0x2d0/0x3e0 fs/jfs/ioctl.c:131 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 Freed by task 5218: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579 poison_slab_object+0xe0/0x150 mm/kasan/common.c:240 __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256 kasan_slab_free include/linux/kasan.h:184 [inline] slab_free_hook mm/slub.c:2252 [inline] slab_free mm/slub.c:4473 [inline] kfree+0x149/0x360 mm/slub.c:4594 dbUnmount+0x11d/0x190 fs/jfs/jfs_dmap.c:278 jfs_mount_rw+0x4ac/0x6a0 fs/jfs/jfs_mount.c:247 jfs_remount+0x3d1/0x6b0 fs/jfs/super.c:454 reconfigure_super+0x445/0x880 fs/super.c:1083 vfs_cmd_reconfigure fs/fsopen.c:263 [inline] vfs_fsconfig_locked fs/fsopen.c:292 [inline] __do_sys_fsconfig fs/fsopen.c:473 [inline] __se_sys_fsconfig+0xb6e/0xf80 fs/fsopen.c:345 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f [Analysis] There are two paths (dbUnmount and jfs_ioc_trim) that generate race condition when accessing bmap, which leads to the occurrence of uaf. Use the lock s_umount to synchronize them, in order to avoid uaf caused by race condition.",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011532": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Prevent out of bounds access in performance query extensions Check that the number of perfmons userspace is passing in the copy and reset extensions is not greater than the internal kernel storage where the ids will be copied into.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.4 未満\nLinux Kernel 6.10.5 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011555": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fbdev: pxafb: Fix possible use after free in pxafb_task() In the pxafb_probe function, it calls the pxafb_init_fbinfo function, after which &fbi->task is associated with pxafb_task. Moreover, within this pxafb_init_fbinfo function, the pxafb_blank function within the &pxafb_ops struct is capable of scheduling work. If we remove the module which will call pxafb_remove to make cleanup, it will call unregister_framebuffer function which can call do_unregister_framebuffer to free fbi->fb through put_fb_info(fb_info), while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | pxafb_task pxafb_remove | unregister_framebuffer(info) | do_unregister_framebuffer(fb_info) | put_fb_info(fb_info) | // free fbi->fb | set_ctrlr_state(fbi, state) | __pxafb_lcd_power(fbi, 0) | fbi->lcd_power(on, &fbi->fb.var) | //use fbi->fb Fix it by ensuring that the work is canceled before proceeding with the cleanup in pxafb_remove. Note that only root user can remove the driver at runtime.",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011557": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix index out of bounds in DCN30 color transformation This commit addresses a potential index out of bounds issue in the `cm3_helper_translate_curve_to_hw_format` function in the DCN30 color management module. The issue could occur when the index 'i' exceeds the number of transfer function points (TRANSFER_FUNC_POINTS). The fix adds a check to ensure 'i' is within bounds before accessing the transfer function points. If 'i' is out of bounds, the function returns false to indicate an error. drivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:180 cm3_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:181 cm3_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max drivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:182 cm3_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011558": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: venus: fix use after free bug in venus_remove due to race condition in venus_probe, core->work is bound with venus_sys_error_handler, which is used to handle error. The code use core->sys_err_done to make sync work. The core->work is started in venus_event_notify. If we call venus_remove, there might be an unfished work. The possible sequence is as follows: CPU0 CPU1 |venus_sys_error_handler venus_remove | hfi_destroy | venus_hfi_destroy | kfree(hdev); | |hfi_reinit |venus_hfi_queues_reinit |//use hdev Fix it by canceling the work in venus_remove.",
        "technologies": "Linux\nLinux Kernel 4.13 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011559": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix double free issue during amdgpu module unload Flexible endpoints use DIGs from available inflexible endpoints, so only the encoders of inflexible links need to be freed. Otherwise, a double free issue may occur when unloading the amdgpu module. [ 279.190523] RIP: 0010:__slab_free+0x152/0x2f0 [ 279.190577] Call Trace: [ 279.190580] <TASK> [ 279.190582] ? show_regs+0x69/0x80 [ 279.190590] ? die+0x3b/0x90 [ 279.190595] ? do_trap+0xc8/0xe0 [ 279.190601] ? do_error_trap+0x73/0xa0 [ 279.190605] ? __slab_free+0x152/0x2f0 [ 279.190609] ? exc_invalid_op+0x56/0x70 [ 279.190616] ? __slab_free+0x152/0x2f0 [ 279.190642] ? asm_exc_invalid_op+0x1f/0x30 [ 279.190648] ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu] [ 279.191096] ? __slab_free+0x152/0x2f0 [ 279.191102] ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu] [ 279.191469] kfree+0x260/0x2b0 [ 279.191474] dcn10_link_encoder_destroy+0x19/0x30 [amdgpu] [ 279.191821] link_destroy+0xd7/0x130 [amdgpu] [ 279.192248] dc_destruct+0x90/0x270 [amdgpu] [ 279.192666] dc_destroy+0x19/0x40 [amdgpu] [ 279.193020] amdgpu_dm_fini+0x16e/0x200 [amdgpu] [ 279.193432] dm_hw_fini+0x26/0x40 [amdgpu] [ 279.193795] amdgpu_device_fini_hw+0x24c/0x400 [amdgpu] [ 279.194108] amdgpu_driver_unload_kms+0x4f/0x70 [amdgpu] [ 279.194436] amdgpu_pci_remove+0x40/0x80 [amdgpu] [ 279.194632] pci_device_remove+0x3a/0xa0 [ 279.194638] device_remove+0x40/0x70 [ 279.194642] device_release_driver_internal+0x1ad/0x210 [ 279.194647] driver_detach+0x4e/0xa0 [ 279.194650] bus_remove_driver+0x6f/0xf0 [ 279.194653] driver_unregister+0x33/0x60 [ 279.194657] pci_unregister_driver+0x44/0x90 [ 279.194662] amdgpu_exit+0x19/0x1f0 [amdgpu] [ 279.194939] __do_sys_delete_module.isra.0+0x198/0x2f0 [ 279.194946] __x64_sys_delete_module+0x16/0x20 [ 279.194950] do_syscall_64+0x58/0x120 [ 279.194954] entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 279.194980] </TASK>",
        "technologies": "Linux\nLinux Kernel 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011662": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix user-after-free from session log off There is racy issue between smb2 session log off and smb2 session setup. It will cause user-after-free from session log off. This add session_lock when setting SMB2_SESSION_EXPIRED and referece count to session struct not to free session while it is being used.",
        "technologies": "Linux\nLinux Kernel 6.1.114 未満\nLinux Kernel 6.2 以上 6.6.58 未満\nLinux Kernel 6.7 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011660": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp: fix mptcp DSS corruption due to large pmtu xmit Syzkaller was able to trigger a DSS corruption: TCP: request_sock_subflow_v4: Possible SYN flooding on port [::]:20002. Sending cookies. ------------[ cut here ]------------ WARNING: CPU: 0 PID: 5227 at net/mptcp/protocol.c:695 __mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695 Modules linked in: CPU: 0 UID: 0 PID: 5227 Comm: syz-executor350 Not tainted 6.11.0-syzkaller-08829-gaf9c191ac2a0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 RIP: 0010:__mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695 Code: 0f b6 dc 31 ff 89 de e8 b5 dd ea f5 89 d8 48 81 c4 50 01 00 00 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc e8 98 da ea f5 90 <0f> 0b 90 e9 47 ff ff ff e8 8a da ea f5 90 0f 0b 90 e9 99 e0 ff ff RSP: 0018:ffffc90000006db8 EFLAGS: 00010246 RAX: ffffffff8ba9df18 RBX: 00000000000055f0 RCX: ffff888030023c00 RDX: 0000000000000100 RSI: 00000000000081e5 RDI: 00000000000055f0 RBP: 1ffff110062bf1ae R08: ffffffff8ba9cf12 R09: 1ffff110062bf1b8 R10: dffffc0000000000 R11: ffffed10062bf1b9 R12: 0000000000000000 R13: dffffc0000000000 R14: 00000000700cec61 R15: 00000000000081e5 FS: 000055556679c380(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020287000 CR3: 0000000077892000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> move_skbs_to_msk net/mptcp/protocol.c:811 [inline] mptcp_data_ready+0x29c/0xa90 net/mptcp/protocol.c:854 subflow_data_ready+0x34a/0x920 net/mptcp/subflow.c:1490 tcp_data_queue+0x20fd/0x76c0 net/ipv4/tcp_input.c:5283 tcp_rcv_established+0xfba/0x2020 net/ipv4/tcp_input.c:6237 tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915 tcp_v4_rcv+0x2dc0/0x37f0 net/ipv4/tcp_ipv4.c:2350 ip_protocol_deliver_rcu+0x22e/0x440 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x341/0x5f0 net/ipv4/ip_input.c:233 NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314 NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314 __netif_receive_skb_one_core net/core/dev.c:5662 [inline] __netif_receive_skb+0x2bf/0x650 net/core/dev.c:5775 process_backlog+0x662/0x15b0 net/core/dev.c:6107 __napi_poll+0xcb/0x490 net/core/dev.c:6771 napi_poll net/core/dev.c:6840 [inline] net_rx_action+0x89b/0x1240 net/core/dev.c:6962 handle_softirqs+0x2c5/0x980 kernel/softirq.c:554 do_softirq+0x11b/0x1e0 kernel/softirq.c:455 </IRQ> <TASK> __local_bh_enable_ip+0x1bb/0x200 kernel/softirq.c:382 local_bh_enable include/linux/bottom_half.h:33 [inline] rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline] __dev_queue_xmit+0x1764/0x3e80 net/core/dev.c:4451 dev_queue_xmit include/linux/netdevice.h:3094 [inline] neigh_hh_output include/net/neighbour.h:526 [inline] neigh_output include/net/neighbour.h:540 [inline] ip_finish_output2+0xd41/0x1390 net/ipv4/ip_output.c:236 ip_local_out net/ipv4/ip_output.c:130 [inline] __ip_queue_xmit+0x118c/0x1b80 net/ipv4/ip_output.c:536 __tcp_transmit_skb+0x2544/0x3b30 net/ipv4/tcp_output.c:1466 tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline] tcp_mtu_probe net/ipv4/tcp_output.c:2547 [inline] tcp_write_xmit+0x641d/0x6bf0 net/ipv4/tcp_output.c:2752 __tcp_push_pending_frames+0x9b/0x360 net/ipv4/tcp_output.c:3015 tcp_push_pending_frames include/net/tcp.h:2107 [inline] tcp_data_snd_check net/ipv4/tcp_input.c:5714 [inline] tcp_rcv_established+0x1026/0x2020 net/ipv4/tcp_input.c:6239 tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915 sk_backlog_rcv include/net/sock.h:1113 [inline] __release_sock+0x214/0x350 net/core/sock.c:3072 release_sock+0x61/0x1f0 net/core/sock.c:3626 mptcp_push_ ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.228 未満\nLinux Kernel 5.11 以上 5.15.169 未満\nLinux Kernel 5.16 以上 6.1.114 未満\nLinux Kernel 6.2 以上 6.6.58 未満\nLinux Kernel 6.7 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011741": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bna: adjust 'name' buf size of bna_tcb and bna_ccb structures To have enough space to write all possible sprintf() args. Currently 'name' size is 16, but the first '%s' specifier may already need at least 16 characters, since 'bnad->netdev->name' is used there. For '%d' specifiers, assume that they require: * 1 char for 'tx_id + tx_info->tcb[i]->id' sum, BNAD_MAX_TXQ_PER_TX is 8 * 2 chars for 'rx_id + rx_info->rx_ctrl[i].ccb->id', BNAD_MAX_RXP_PER_RX is 16 And replace sprintf with snprintf. Detected using the static analysis tool - Svace.",
        "technologies": "Linux\nLinux Kernel 2.6.37 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-011908": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix double brelse() the buffer of the extents path In ext4_ext_try_to_merge_up(), set path[1].p_bh to NULL after it has been released, otherwise it may be released twice. An example of what triggers this is as follows: split2 map split1 |--------|-------|--------| ext4_ext_map_blocks ext4_ext_handle_unwritten_extents ext4_split_convert_extents // path->p_depth == 0 ext4_split_extent // 1. do split1 ext4_split_extent_at |ext4_ext_insert_extent | ext4_ext_create_new_leaf | ext4_ext_grow_indepth | le16_add_cpu(&neh->eh_depth, 1) | ext4_find_extent | // return -ENOMEM |// get error and try zeroout |path = ext4_find_extent | path->p_depth = 1 |ext4_ext_try_to_merge | ext4_ext_try_to_merge_up | path->p_depth = 0 | brelse(path[1].p_bh) ---> not set to NULL here |// zeroout success // 2. update path ext4_find_extent // 3. do split2 ext4_split_extent_at ext4_ext_insert_extent ext4_ext_create_new_leaf ext4_ext_grow_indepth le16_add_cpu(&neh->eh_depth, 1) ext4_find_extent path[0].p_bh = NULL; path->p_depth = 1 read_extent_tree_block ---> return err // path[1].p_bh is still the old value ext4_free_ext_path ext4_ext_drop_refs // path->p_depth == 1 brelse(path[1].p_bh) ---> brelse a buffer twice Finally got the following WARRNING when removing the buffer from lru: ============================================ VFS: brelse: Trying to free free buffer WARNING: CPU: 2 PID: 72 at fs/buffer.c:1241 __brelse+0x58/0x90 CPU: 2 PID: 72 Comm: kworker/u19:1 Not tainted 6.9.0-dirty #716 RIP: 0010:__brelse+0x58/0x90 Call Trace: <TASK> __find_get_block+0x6e7/0x810 bdev_getblk+0x2b/0x480 __ext4_get_inode_loc+0x48a/0x1240 ext4_get_inode_loc+0xb2/0x150 ext4_reserve_inode_write+0xb7/0x230 __ext4_mark_inode_dirty+0x144/0x6a0 ext4_ext_insert_extent+0x9c8/0x3230 ext4_ext_map_blocks+0xf45/0x2dc0 ext4_map_blocks+0x724/0x1700 ext4_do_writepages+0x12d6/0x2a70 [...] ============================================",
        "technologies": "Linux\nLinux Kernel 3.7 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011865": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: asihpi: Fix potential OOB array access ASIHPI driver stores some values in the static array upon a response from the driver, and its index depends on the firmware. We shouldn't trust it blindly. This patch adds a sanity check of the array index to fit in the array size.",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011560": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix buffer overflow when parsing NFS reparse points ReparseDataLength is sum of the InodeType size and DataBuffer size. So to get DataBuffer size it is needed to subtract InodeType's size from ReparseDataLength. Function cifs_strndup_from_utf16() is currentlly accessing buf->DataBuffer at position after the end of the buffer because it does not subtract InodeType size from the length. Fix this problem and correctly subtract variable len. Member InodeType is present only when reparse buffer is large enough. Check for ReparseDataLength before accessing InodeType to prevent another invalid memory access. Major and minor rdev values are present also only when reparse buffer is large enough. Check for reparse buffer size before calling reparse_mkdev().",
        "technologies": "Linux\nLinux Kernel 5.3 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-011929": {
        "title": "Linux の Linux Kernel における初期化されていないポインタのアクセスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix uninitialized pointer free in add_inode_ref() The add_inode_ref() function does not initialize the \"name\" struct when it is declared. If any of the following calls to \"read_one_inode() returns NULL, dir = read_one_inode(root, parent_objectid); if (!dir) { ret = -ENOENT; goto out; } inode = read_one_inode(root, inode_objectid); if (!inode) { ret = -EIO; goto out; } then \"name.name\" would be freed on \"out\" before being initialized. out: ... kfree(name.name); This issue was reported by Coverity with CID 1526744.",
        "technologies": "Linux\nLinux Kernel 6.1.57 以上 6.1.114 未満\nLinux Kernel 6.2 以上 6.6.58 未満\nLinux Kernel 6.7 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011953": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tty: n_gsm: Fix use-after-free in gsm_cleanup_mux BUG: KASAN: slab-use-after-free in gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm] Read of size 8 at addr ffff88815fe99c00 by task poc/3379 CPU: 0 UID: 0 PID: 3379 Comm: poc Not tainted 6.11.0+ #56 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Call Trace: <TASK> gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm] __pfx_gsm_cleanup_mux+0x10/0x10 drivers/tty/n_gsm.c:3124 [n_gsm] __pfx_sched_clock_cpu+0x10/0x10 kernel/sched/clock.c:389 update_load_avg+0x1c1/0x27b0 kernel/sched/fair.c:4500 __pfx_min_vruntime_cb_rotate+0x10/0x10 kernel/sched/fair.c:846 __rb_insert_augmented+0x492/0xbf0 lib/rbtree.c:161 gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm] _raw_spin_lock_irqsave+0x92/0xf0 arch/x86/include/asm/atomic.h:107 __pfx_gsmld_ioctl+0x10/0x10 drivers/tty/n_gsm.c:3822 [n_gsm] ktime_get+0x5e/0x140 kernel/time/timekeeping.c:195 ldsem_down_read+0x94/0x4e0 arch/x86/include/asm/atomic64_64.h:79 __pfx_ldsem_down_read+0x10/0x10 drivers/tty/tty_ldsem.c:338 __pfx_do_vfs_ioctl+0x10/0x10 fs/ioctl.c:805 tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818 Allocated by task 65: gsm_data_alloc.constprop.0+0x27/0x190 drivers/tty/n_gsm.c:926 [n_gsm] gsm_send+0x2c/0x580 drivers/tty/n_gsm.c:819 [n_gsm] gsm1_receive+0x547/0xad0 drivers/tty/n_gsm.c:3038 [n_gsm] gsmld_receive_buf+0x176/0x280 drivers/tty/n_gsm.c:3609 [n_gsm] tty_ldisc_receive_buf+0x101/0x1e0 drivers/tty/tty_buffer.c:391 tty_port_default_receive_buf+0x61/0xa0 drivers/tty/tty_port.c:39 flush_to_ldisc+0x1b0/0x750 drivers/tty/tty_buffer.c:445 process_scheduled_works+0x2b0/0x10d0 kernel/workqueue.c:3229 worker_thread+0x3dc/0x950 kernel/workqueue.c:3391 kthread+0x2a3/0x370 kernel/kthread.c:389 ret_from_fork+0x2d/0x70 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:257 Freed by task 3367: kfree+0x126/0x420 mm/slub.c:4580 gsm_cleanup_mux+0x36c/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm] gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm] tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818 [Analysis] gsm_msg on the tx_ctrl_list or tx_data_list of gsm_mux can be freed by multi threads through ioctl,which leads to the occurrence of uaf. Protect it by gsm tx lock.",
        "technologies": "Linux\nLinux Kernel 6.1.114 未満\nLinux Kernel 6.2 以上 6.6.58 未満\nLinux Kernel 6.7 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011789": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pinctrl: nuvoton: fix a double free in ma35_pinctrl_dt_node_to_map_func() 'new_map' is allocated using devm_* which takes care of freeing the allocated data on device removal, call to .dt_free_map = pinconf_generic_dt_free_map double frees the map as pinconf_generic_dt_free_map() calls pinctrl_utils_free_map(). Fix this by using kcalloc() instead of auto-managed devm_kcalloc().",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012259": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mac802154: Fix potential RCU dereference issue in mac802154_scan_worker In the `mac802154_scan_worker` function, the `scan_req->type` field was accessed after the RCU read-side critical section was unlocked. According to RCU usage rules, this is illegal and can lead to unpredictable behavior, such as accessing memory that has been updated or causing use-after-free issues. This possible bug was identified using a static analysis tool developed by myself, specifically designed to detect RCU-related issues. To address this, the `scan_req->type` value is now stored in a local variable `scan_req_type` while still within the RCU read-side critical section. The `scan_req_type` is then used after the RCU lock is released, ensuring that the type value is safely accessed without violating RCU rules.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011787": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: parport: Proper fix for array out-of-bounds access The recent fix for array out-of-bounds accesses replaced sprintf() calls blindly with snprintf(). However, since snprintf() returns the would-be-printed size, not the actually output size, the length calculation can still go over the given limit. Use scnprintf() instead of snprintf(), which returns the actually output letters, for addressing the potential out-of-bounds access properly.",
        "technologies": "Linux\nLinux Kernel 5.10.224 以上 5.10.228 未満\nLinux Kernel 5.11 以上 5.15.169 未満\nLinux Kernel 5.16 以上 6.1.114 未満\nLinux Kernel 6.2 以上 6.6.58 未満\nLinux Kernel 6.7 以上 6.11.5 未満\nLinux Kernel 6.12\nレッドハット\nRed Hat Enterprise Linux 8.0\nRed Hat Enterprise Linux 9.0"
    },
    "JVNDB-2024-011955": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix uaf in l2cap_connect [Syzbot reported] BUG: KASAN: slab-use-after-free in l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949 Read of size 8 at addr ffff8880241e9800 by task kworker/u9:0/54 CPU: 0 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-00268-g788220eee30d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Workqueue: hci2 hci_rx_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0xc3/0x620 mm/kasan/report.c:488 kasan_report+0xd9/0x110 mm/kasan/report.c:601 l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949 l2cap_connect_req net/bluetooth/l2cap_core.c:4080 [inline] l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:4772 [inline] l2cap_sig_channel net/bluetooth/l2cap_core.c:5543 [inline] l2cap_recv_frame+0xf0b/0x8eb0 net/bluetooth/l2cap_core.c:6825 l2cap_recv_acldata+0x9b4/0xb70 net/bluetooth/l2cap_core.c:7514 hci_acldata_packet net/bluetooth/hci_core.c:3791 [inline] hci_rx_work+0xaab/0x1610 net/bluetooth/hci_core.c:4028 process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231 process_scheduled_works kernel/workqueue.c:3312 [inline] worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389 kthread+0x2c1/0x3a0 kernel/kthread.c:389 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 ... Freed by task 5245: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:579 poison_slab_object+0xf7/0x160 mm/kasan/common.c:240 __kasan_slab_free+0x32/0x50 mm/kasan/common.c:256 kasan_slab_free include/linux/kasan.h:184 [inline] slab_free_hook mm/slub.c:2256 [inline] slab_free mm/slub.c:4477 [inline] kfree+0x12a/0x3b0 mm/slub.c:4598 l2cap_conn_free net/bluetooth/l2cap_core.c:1810 [inline] kref_put include/linux/kref.h:65 [inline] l2cap_conn_put net/bluetooth/l2cap_core.c:1822 [inline] l2cap_conn_del+0x59d/0x730 net/bluetooth/l2cap_core.c:1802 l2cap_connect_cfm+0x9e6/0xf80 net/bluetooth/l2cap_core.c:7241 hci_connect_cfm include/net/bluetooth/hci_core.h:1960 [inline] hci_conn_failed+0x1c3/0x370 net/bluetooth/hci_conn.c:1265 hci_abort_conn_sync+0x75a/0xb50 net/bluetooth/hci_sync.c:5583 abort_conn_sync+0x197/0x360 net/bluetooth/hci_conn.c:2917 hci_cmd_sync_work+0x1a4/0x410 net/bluetooth/hci_sync.c:328 process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231 process_scheduled_works kernel/workqueue.c:3312 [inline] worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389 kthread+0x2c1/0x3a0 kernel/kthread.c:389 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244",
        "technologies": "Linux\nLinux Kernel 3.8 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-012213": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: cancel dqi_sync_work before freeing oinfo ocfs2_global_read_info() will initialize and schedule dqi_sync_work at the end, if error occurs after successfully reading global quota, it will trigger the following warning with CONFIG_DEBUG_OBJECTS_* enabled: ODEBUG: free active (active state 0) object: 00000000d8b0ce28 object type: timer_list hint: qsync_work_fn+0x0/0x16c This reports that there is an active delayed work when freeing oinfo in error handling, so cancel dqi_sync_work first. BTW, return status instead of -1 when .read_file_info fails.",
        "technologies": "Linux\nLinux Kernel 2.6.29 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-012055": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm/mremap: fix move_normal_pmd/retract_page_tables race In mremap(), move_page_tables() looks at the type of the PMD entry and the specified address range to figure out by which method the next chunk of page table entries should be moved. At that point, the mmap_lock is held in write mode, but no rmap locks are held yet. For PMD entries that point to page tables and are fully covered by the source address range, move_pgt_entry(NORMAL_PMD, ...) is called, which first takes rmap locks, then does move_normal_pmd(). move_normal_pmd() takes the necessary page table locks at source and destination, then moves an entire page table from the source to the destination. The problem is: The rmap locks, which protect against concurrent page table removal by retract_page_tables() in the THP code, are only taken after the PMD entry has been read and it has been decided how to move it. So we can race as follows (with two processes that have mappings of the same tmpfs file that is stored on a tmpfs mount with huge=advise); note that process A accesses page tables through the MM while process B does it through the file rmap: process A process B ========= ========= mremap mremap_to move_vma move_page_tables get_old_pmd alloc_new_pmd *** PREEMPT *** madvise(MADV_COLLAPSE) do_madvise madvise_walk_vmas madvise_vma_behavior madvise_collapse hpage_collapse_scan_file collapse_file retract_page_tables i_mmap_lock_read(mapping) pmdp_collapse_flush i_mmap_unlock_read(mapping) move_pgt_entry(NORMAL_PMD, ...) take_rmap_locks move_normal_pmd drop_rmap_locks When this happens, move_normal_pmd() can end up creating bogus PMD entries in the line `pmd_populate(mm, new_pmd, pmd_pgtable(pmd))`. The effect depends on arch-specific and machine-specific details; on x86, you can end up with physical page 0 mapped as a page table, which is likely exploitable for user->kernel privilege escalation. Fix the race by letting process B recheck that the PMD still points to a page table after the rmap locks have been taken. Otherwise, we bail and let the caller fall back to the PTE-level copying path, which will then bail immediately at the pmd_none() check. Bug reachability: Reaching this bug requires that you can create shmem/file THP mappings - anonymous THP uses different code that doesn't zap stuff under rmap locks. File THP is gated on an experimental config flag (CONFIG_READ_ONLY_THP_FOR_FS), so on normal distro kernels you need shmem THP to hit this bug. As far as I know, getting shmem THP normally requires that you can mount your own tmpfs with the right mount flags, which would require creating your own user+mount namespace; though I don't know if some distros maybe enable shmem THP by default or something like that. Bug impact: This issue can likely be used for user->kernel privilege escalation when it is reachable.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.58 未満\nLinux Kernel 6.7 以上 6.11.5 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012367": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: Unregister redistributor for failed vCPU creation Alex reports that syzkaller has managed to trigger a use-after-free when tearing down a VM: BUG: KASAN: slab-use-after-free in kvm_put_kvm+0x300/0xe68 virt/kvm/kvm_main.c:5769 Read of size 8 at addr ffffff801c6890d0 by task syz.3.2219/10758 CPU: 3 UID: 0 PID: 10758 Comm: syz.3.2219 Not tainted 6.11.0-rc6-dirty #64 Hardware name: linux,dummy-virt (DT) Call trace: dump_backtrace+0x17c/0x1a8 arch/arm64/kernel/stacktrace.c:317 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:324 __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x94/0xc0 lib/dump_stack.c:119 print_report+0x144/0x7a4 mm/kasan/report.c:377 kasan_report+0xcc/0x128 mm/kasan/report.c:601 __asan_report_load8_noabort+0x20/0x2c mm/kasan/report_generic.c:381 kvm_put_kvm+0x300/0xe68 virt/kvm/kvm_main.c:5769 kvm_vm_release+0x4c/0x60 virt/kvm/kvm_main.c:1409 __fput+0x198/0x71c fs/file_table.c:422 ____fput+0x20/0x30 fs/file_table.c:450 task_work_run+0x1cc/0x23c kernel/task_work.c:228 do_notify_resume+0x144/0x1a0 include/linux/resume_user_mode.h:50 el0_svc+0x64/0x68 arch/arm64/kernel/entry-common.c:169 el0t_64_sync_handler+0x90/0xfc arch/arm64/kernel/entry-common.c:730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598 Upon closer inspection, it appears that we do not properly tear down the MMIO registration for a vCPU that fails creation late in the game, e.g. a vCPU w/ the same ID already exists in the VM. It is important to consider the context of commit that introduced this bug by moving the unregistration out of __kvm_vgic_vcpu_destroy(). That change correctly sought to avoid an srcu v. config_lock inversion by breaking up the vCPU teardown into two parts, one guarded by the config_lock. Fix the use-after-free while avoiding lock inversion by adding a special-cased unregistration to __kvm_vgic_vcpu_destroy(). This is safe because failed vCPUs are torn down outside of the config_lock.",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012363": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing: Consider the NULL character when validating the event length strlen() returns a string length excluding the null byte. If the string length equals to the maximum buffer length, the buffer will have no space for the NULL terminating character. This commit checks this condition and returns failure for it.",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012357": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: SCO: Fix UAF on sco_sock_timeout conn->sk maybe have been unlinked/freed while waiting for sco_conn_lock so this checks if the conn->sk is still valid by checking if it part of sco_sk_list.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 4.14.263\nLinux Kernel 4.19.207\nLinux Kernel 5.4.148\nLinux Kernel 5.10.67\nLinux Kernel 5.13.19\nLinux Kernel 5.14.6\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012358": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: wwan: fix global oob in wwan_rtnl_policy The variable wwan_rtnl_link_ops assign a *bigger* maxtype which leads to a global out-of-bounds read when parsing the netlink attributes. Exactly same bug cause as the oob fixed in commit b33fb5b801c6 (\"net: qualcomm: rmnet: fix global oob in rmnet_policy\"). ================================================================== BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:388 [inline] BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x19d7/0x29a0 lib/nlattr.c:603 Read of size 1 at addr ffffffff8b09cb60 by task syz.1.66276/323862 CPU: 0 PID: 323862 Comm: syz.1.66276 Not tainted 6.1.70 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x177/0x231 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:284 [inline] print_report+0x14f/0x750 mm/kasan/report.c:395 kasan_report+0x139/0x170 mm/kasan/report.c:495 validate_nla lib/nlattr.c:388 [inline] __nla_validate_parse+0x19d7/0x29a0 lib/nlattr.c:603 __nla_parse+0x3c/0x50 lib/nlattr.c:700 nla_parse_nested_deprecated include/net/netlink.h:1269 [inline] __rtnl_newlink net/core/rtnetlink.c:3514 [inline] rtnl_newlink+0x7bc/0x1fd0 net/core/rtnetlink.c:3623 rtnetlink_rcv_msg+0x794/0xef0 net/core/rtnetlink.c:6122 netlink_rcv_skb+0x1de/0x420 net/netlink/af_netlink.c:2508 netlink_unicast_kernel net/netlink/af_netlink.c:1326 [inline] netlink_unicast+0x74b/0x8c0 net/netlink/af_netlink.c:1352 netlink_sendmsg+0x882/0xb90 net/netlink/af_netlink.c:1874 sock_sendmsg_nosec net/socket.c:716 [inline] __sock_sendmsg net/socket.c:728 [inline] ____sys_sendmsg+0x5cc/0x8f0 net/socket.c:2499 ___sys_sendmsg+0x21c/0x290 net/socket.c:2553 __sys_sendmsg net/socket.c:2582 [inline] __do_sys_sendmsg net/socket.c:2591 [inline] __se_sys_sendmsg+0x19e/0x270 net/socket.c:2589 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x45/0x90 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7f67b19a24ad RSP: 002b:00007f67b17febb8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f67b1b45f80 RCX: 00007f67b19a24ad RDX: 0000000000000000 RSI: 0000000020005e40 RDI: 0000000000000004 RBP: 00007f67b1a1e01d R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007ffd2513764f R14: 00007ffd251376e0 R15: 00007f67b17fed40 </TASK> The buggy address belongs to the variable: wwan_rtnl_policy+0x20/0x40 The buggy address belongs to the physical page: page:ffffea00002c2700 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xb09c flags: 0xfff00000001000(reserved|node=0|zone=1|lastcpupid=0x7ff) raw: 00fff00000001000 ffffea00002c2708 ffffea00002c2708 0000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected page_owner info is not present (never set?) Memory state around the buggy address: ffffffff8b09ca00: 05 f9 f9 f9 05 f9 f9 f9 00 01 f9 f9 00 01 f9 f9 ffffffff8b09ca80: 00 00 00 05 f9 f9 f9 f9 00 00 03 f9 f9 f9 f9 f9 >ffffffff8b09cb00: 00 00 00 00 05 f9 f9 f9 00 00 00 00 f9 f9 f9 f9 ^ ffffffff8b09cb80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ================================================================== According to the comment of `nla_parse_nested_deprecated`, use correct size `IFLA_WWAN_MAX` here to fix this issue.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012368": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: nSVM: Ignore nCR3[4:0] when loading PDPTEs from memory Ignore nCR3[4:0] when loading PDPTEs from memory for nested SVM, as bits 4:0 of CR3 are ignored when PAE paging is used, and thus VMRUN doesn't enforce 32-byte alignment of nCR3. In the absolute worst case scenario, failure to ignore bits 4:0 can result in an out-of-bounds read, e.g. if the target page is at the end of a memslot, and the VMM isn't using guard pages. Per the APM: The CR3 register points to the base address of the page-directory-pointer table. The page-directory-pointer table is aligned on a 32-byte boundary, with the low 5 address bits 4:0 assumed to be 0. And the SDM's much more explicit: 4:0 Ignored Note, KVM gets this right when loading PDPTRs, it's only the nSVM flow that is broken.",
        "technologies": "Linux\nLinux Kernel 3.2 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012369": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Add the missing BPF_LINK_TYPE invocation for sockmap There is an out-of-bounds read in bpf_link_show_fdinfo() for the sockmap link fd. Fix it by adding the missing BPF_LINK_TYPE invocation for sockmap link Also add comments for bpf_link_type to prevent missing updates in the future.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012373": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: bpf: must hold reference on net namespace BUG: KASAN: slab-use-after-free in __nf_unregister_net_hook+0x640/0x6b0 Read of size 8 at addr ffff8880106fe400 by task repro/72= bpf_nf_link_release+0xda/0x1e0 bpf_link_free+0x139/0x2d0 bpf_link_release+0x68/0x80 __fput+0x414/0xb60 Eric says: It seems that bpf was able to defer the __nf_unregister_net_hook() after exit()/close() time. Perhaps a netns reference is missing, because the netns has been dismantled/freed already. bpf_nf_link_attach() does : link->net = net; But I do not see a reference being taken on net. Add such a reference and release it after hook unreg. Note that I was unable to get syzbot reproducer to work, so I do not know if this resolves this splat.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012371": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: ISO: Fix UAF on iso_sock_timeout conn->sk maybe have been unlinked/freed while waiting for iso_conn_lock so this checks if the conn->sk is still valid by checking if it part of iso_sk_list.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012372": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: use RCU read-side critical section in taprio_dump() Fix possible use-after-free in 'taprio_dump()' by adding RCU read-side critical section there. Never seen on x86 but found on a KASAN-enabled arm64 system when investigating https://syzkaller.appspot.com/bug?extid=b65e0af58423fc8a73aa: [T15862] BUG: KASAN: slab-use-after-free in taprio_dump+0xa0c/0xbb0 [T15862] Read of size 4 at addr ffff0000d4bb88f8 by task repro/15862 [T15862] [T15862] CPU: 0 UID: 0 PID: 15862 Comm: repro Not tainted 6.11.0-rc1-00293-gdefaf1a2113a-dirty #2 [T15862] Hardware name: QEMU QEMU Virtual Machine, BIOS edk2-20240524-5.fc40 05/24/2024 [T15862] Call trace: [T15862] dump_backtrace+0x20c/0x220 [T15862] show_stack+0x2c/0x40 [T15862] dump_stack_lvl+0xf8/0x174 [T15862] print_report+0x170/0x4d8 [T15862] kasan_report+0xb8/0x1d4 [T15862] __asan_report_load4_noabort+0x20/0x2c [T15862] taprio_dump+0xa0c/0xbb0 [T15862] tc_fill_qdisc+0x540/0x1020 [T15862] qdisc_notify.isra.0+0x330/0x3a0 [T15862] tc_modify_qdisc+0x7b8/0x1838 [T15862] rtnetlink_rcv_msg+0x3c8/0xc20 [T15862] netlink_rcv_skb+0x1f8/0x3d4 [T15862] rtnetlink_rcv+0x28/0x40 [T15862] netlink_unicast+0x51c/0x790 [T15862] netlink_sendmsg+0x79c/0xc20 [T15862] __sock_sendmsg+0xe0/0x1a0 [T15862] ____sys_sendmsg+0x6c0/0x840 [T15862] ___sys_sendmsg+0x1ac/0x1f0 [T15862] __sys_sendmsg+0x110/0x1d0 [T15862] __arm64_sys_sendmsg+0x74/0xb0 [T15862] invoke_syscall+0x88/0x2e0 [T15862] el0_svc_common.constprop.0+0xe4/0x2a0 [T15862] do_el0_svc+0x44/0x60 [T15862] el0_svc+0x50/0x184 [T15862] el0t_64_sync_handler+0x120/0x12c [T15862] el0t_64_sync+0x190/0x194 [T15862] [T15862] Allocated by task 15857: [T15862] kasan_save_stack+0x3c/0x70 [T15862] kasan_save_track+0x20/0x3c [T15862] kasan_save_alloc_info+0x40/0x60 [T15862] __kasan_kmalloc+0xd4/0xe0 [T15862] __kmalloc_cache_noprof+0x194/0x334 [T15862] taprio_change+0x45c/0x2fe0 [T15862] tc_modify_qdisc+0x6a8/0x1838 [T15862] rtnetlink_rcv_msg+0x3c8/0xc20 [T15862] netlink_rcv_skb+0x1f8/0x3d4 [T15862] rtnetlink_rcv+0x28/0x40 [T15862] netlink_unicast+0x51c/0x790 [T15862] netlink_sendmsg+0x79c/0xc20 [T15862] __sock_sendmsg+0xe0/0x1a0 [T15862] ____sys_sendmsg+0x6c0/0x840 [T15862] ___sys_sendmsg+0x1ac/0x1f0 [T15862] __sys_sendmsg+0x110/0x1d0 [T15862] __arm64_sys_sendmsg+0x74/0xb0 [T15862] invoke_syscall+0x88/0x2e0 [T15862] el0_svc_common.constprop.0+0xe4/0x2a0 [T15862] do_el0_svc+0x44/0x60 [T15862] el0_svc+0x50/0x184 [T15862] el0t_64_sync_handler+0x120/0x12c [T15862] el0t_64_sync+0x190/0x194 [T15862] [T15862] Freed by task 6192: [T15862] kasan_save_stack+0x3c/0x70 [T15862] kasan_save_track+0x20/0x3c [T15862] kasan_save_free_info+0x4c/0x80 [T15862] poison_slab_object+0x110/0x160 [T15862] __kasan_slab_free+0x3c/0x74 [T15862] kfree+0x134/0x3c0 [T15862] taprio_free_sched_cb+0x18c/0x220 [T15862] rcu_core+0x920/0x1b7c [T15862] rcu_core_si+0x10/0x1c [T15862] handle_softirqs+0x2e8/0xd64 [T15862] __do_softirq+0x14/0x20",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012410": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: pse-pd: Fix out of bound for loop Adjust the loop limit to prevent out-of-bounds access when iterating over PI structures. The loop should not reach the index pcdev->nr_lines since we allocate exactly pcdev->nr_lines number of PI structures. This fix ensures proper bounds are maintained during iterations.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012411": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net In the normal case, when we excute `echo 0 > /proc/fs/nfsd/threads`, the function `nfs4_state_destroy_net` in `nfs4_state_shutdown_net` will release all resources related to the hashed `nfs4_client`. If the `nfsd_client_shrinker` is running concurrently, the `expire_client` function will first unhash this client and then destroy it. This can lead to the following warning. Additionally, numerous use-after-free errors may occur as well. nfsd_client_shrinker echo 0 > /proc/fs/nfsd/threads expire_client nfsd_shutdown_net unhash_client ... nfs4_state_shutdown_net /* won't wait shrinker exit */ /* cancel_work(&nn->nfsd_shrinker_work) * nfsd_file for this /* won't destroy unhashed client1 */ * client1 still alive nfs4_state_destroy_net */ nfsd_file_cache_shutdown /* trigger warning */ kmem_cache_destroy(nfsd_file_slab) kmem_cache_destroy(nfsd_file_mark_slab) /* release nfsd_file and mark */ __destroy_client ==================================================================== BUG nfsd_file (Not tainted): Objects remaining in nfsd_file on __kmem_cache_shutdown() -------------------------------------------------------------------- CPU: 4 UID: 0 PID: 764 Comm: sh Not tainted 6.12.0-rc3+ #1 dump_stack_lvl+0x53/0x70 slab_err+0xb0/0xf0 __kmem_cache_shutdown+0x15c/0x310 kmem_cache_destroy+0x66/0x160 nfsd_file_cache_shutdown+0xac/0x210 [nfsd] nfsd_destroy_serv+0x251/0x2a0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e ==================================================================== BUG nfsd_file_mark (Tainted: G B W ): Objects remaining nfsd_file_mark on __kmem_cache_shutdown() -------------------------------------------------------------------- dump_stack_lvl+0x53/0x70 slab_err+0xb0/0xf0 __kmem_cache_shutdown+0x15c/0x310 kmem_cache_destroy+0x66/0x160 nfsd_file_cache_shutdown+0xc8/0x210 [nfsd] nfsd_destroy_serv+0x251/0x2a0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e To resolve this issue, cancel `nfsd_shrinker_work` using synchronous mode in nfs4_state_shutdown_net.",
        "technologies": "Linux\nLinux Kernel 5.10.220 以上 5.15 未満\nLinux Kernel 5.15.154 以上 6.1 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012418": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: fix use-after-free in taprio_change() In 'taprio_change()', 'admin' pointer may become dangling due to sched switch / removal caused by 'advance_sched()', and critical section protected by 'q->current_entry_lock' is too small to prevent from such a scenario (which causes use-after-free detected by KASAN). Fix this by prefer 'rcu_replace_pointer()' over 'rcu_assign_pointer()' to update 'admin' immediately before an attempt to schedule freeing.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012376": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/lam: Disable ADDRESS_MASKING in most cases Linear Address Masking (LAM) has a weakness related to transient execution as described in the SLAM paper[1]. Unless Linear Address Space Separation (LASS) is enabled this weakness may be exploitable. Until kernel adds support for LASS[2], only allow LAM for COMPILE_TEST, or when speculation mitigations have been disabled at compile time, otherwise keep LAM disabled. There are no processors in market that support LAM yet, so currently nobody is affected by this issue. [1] SLAM: https://download.vusec.net/papers/slam_sp24.pdf [2] LASS: https://lore.kernel.org/lkml/20230609183632.48706-1-alexander.shishkin@linux.intel.com/ [ dhansen: update SPECULATION_MITIGATIONS -> CPU_MITIGATIONS ]",
        "technologies": "Linux\nLinux Kernel 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012459": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: fix race between laundromat and free_stateid There is a race between laundromat handling of revoked delegations and a client sending free_stateid operation. Laundromat thread finds that delegation has expired and needs to be revoked so it marks the delegation stid revoked and it puts it on a reaper list but then it unlock the state lock and the actual delegation revocation happens without the lock. Once the stid is marked revoked a racing free_stateid processing thread does the following (1) it calls list_del_init() which removes it from the reaper list and (2) frees the delegation stid structure. The laundromat thread ends up not calling the revoke_delegation() function for this particular delegation but that means it will no release the lock lease that exists on the file. Now, a new open for this file comes in and ends up finding that lease list isn't empty and calls nfsd_breaker_owns_lease() which ends up trying to derefence a freed delegation stateid. Leading to the followint use-after-free KASAN warning: kernel: ================================================================== kernel: BUG: KASAN: slab-use-after-free in nfsd_breaker_owns_lease+0x140/0x160 [nfsd] kernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205 kernel: kernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9 kernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024 kernel: Call trace: kernel: dump_backtrace+0x98/0x120 kernel: show_stack+0x1c/0x30 kernel: dump_stack_lvl+0x80/0xe8 kernel: print_address_description.constprop.0+0x84/0x390 kernel: print_report+0xa4/0x268 kernel: kasan_report+0xb4/0xf8 kernel: __asan_report_load8_noabort+0x1c/0x28 kernel: nfsd_breaker_owns_lease+0x140/0x160 [nfsd] kernel: nfsd_file_do_acquire+0xb3c/0x11d0 [nfsd] kernel: nfsd_file_acquire_opened+0x84/0x110 [nfsd] kernel: nfs4_get_vfs_file+0x634/0x958 [nfsd] kernel: nfsd4_process_open2+0xa40/0x1a40 [nfsd] kernel: nfsd4_open+0xa08/0xe80 [nfsd] kernel: nfsd4_proc_compound+0xb8c/0x2130 [nfsd] kernel: nfsd_dispatch+0x22c/0x718 [nfsd] kernel: svc_process_common+0x8e8/0x1960 [sunrpc] kernel: svc_process+0x3d4/0x7e0 [sunrpc] kernel: svc_handle_xprt+0x828/0xe10 [sunrpc] kernel: svc_recv+0x2cc/0x6a8 [sunrpc] kernel: nfsd+0x270/0x400 [nfsd] kernel: kthread+0x288/0x310 kernel: ret_from_fork+0x10/0x20 This patch proposes a fixed that's based on adding 2 new additional stid's sc_status values that help coordinate between the laundromat and other operations (nfsd4_free_stateid() and nfsd4_delegreturn()). First to make sure, that once the stid is marked revoked, it is not removed by the nfsd4_free_stateid(), the laundromat take a reference on the stateid. Then, coordinating whether the stid has been put on the cl_revoked list or we are processing FREE_STATEID and need to make sure to remove it from the list, each check that state and act accordingly. If laundromat has added to the cl_revoke list before the arrival of FREE_STATEID, then nfsd4_free_stateid() knows to remove it from the list. If nfsd4_free_stateid() finds that operations arrived before laundromat has placed it on cl_revoke list, it marks the state freed and then laundromat will no longer add it to the list. Also, for nfsd4_delegreturn() when looking for the specified stid, we need to access stid that are marked removed or freeable, it means the laundromat has started processing it but hasn't finished and this delegreturn needs to return nfserr_deleg_revoked and not nfserr_bad_stateid. The latter will not trigger a FREE_STATEID and the lack of it will leave this stid on the cl_revoked list indefinitely.",
        "technologies": "Linux\nLinux Kernel 3.17 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012585": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free of block device file in __btrfs_free_extra_devids() Mounting btrfs from two images (which have the same one fsid and two different dev_uuids) in certain executing order may trigger an UAF for variable 'device->bdev_file' in __btrfs_free_extra_devids(). And following are the details: 1. Attach image_1 to loop0, attach image_2 to loop1, and scan btrfs devices by ioctl(BTRFS_IOC_SCAN_DEV): / btrfs_device_1 → loop0 fs_device \\ btrfs_device_2 → loop1 2. mount /dev/loop0 /mnt btrfs_open_devices btrfs_device_1->bdev_file = btrfs_get_bdev_and_sb(loop0) btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1) btrfs_fill_super open_ctree fail: btrfs_close_devices // -ENOMEM btrfs_close_bdev(btrfs_device_1) fput(btrfs_device_1->bdev_file) // btrfs_device_1->bdev_file is freed btrfs_close_bdev(btrfs_device_2) fput(btrfs_device_2->bdev_file) 3. mount /dev/loop1 /mnt btrfs_open_devices btrfs_get_bdev_and_sb(&bdev_file) // EIO, btrfs_device_1->bdev_file is not assigned, // which points to a freed memory area btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1) btrfs_fill_super open_ctree btrfs_free_extra_devids if (btrfs_device_1->bdev_file) fput(btrfs_device_1->bdev_file) // UAF ! Fix it by setting 'device->bdev_file' as 'NULL' after closing the btrfs_device in btrfs_close_one_device().",
        "technologies": "Linux\nLinux Kernel 4.8 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012582": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: thunderbolt: Fix KASAN reported stack out-of-bounds read in tb_retimer_scan() KASAN reported following issue: BUG: KASAN: stack-out-of-bounds in tb_retimer_scan+0xffe/0x1550 [thunderbolt] Read of size 4 at addr ffff88810111fc1c by task kworker/u56:0/11 CPU: 0 UID: 0 PID: 11 Comm: kworker/u56:0 Tainted: G U 6.11.0+ #1387 Tainted: [U]=USER Workqueue: thunderbolt0 tb_handle_hotplug [thunderbolt] Call Trace: <TASK> dump_stack_lvl+0x6c/0x90 print_report+0xd1/0x630 kasan_report+0xdb/0x110 __asan_report_load4_noabort+0x14/0x20 tb_retimer_scan+0xffe/0x1550 [thunderbolt] tb_scan_port+0xa6f/0x2060 [thunderbolt] tb_handle_hotplug+0x17b1/0x3080 [thunderbolt] process_one_work+0x626/0x1100 worker_thread+0x6c8/0xfa0 kthread+0x2c8/0x3a0 ret_from_fork+0x3a/0x80 ret_from_fork_asm+0x1a/0x30 This happens because the loop variable still gets incremented by one so max becomes 3 instead of 2, and this makes the second loop read past the the array declared on the stack. Fix this by assigning to max directly in the loop body.",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012445": {
        "title": "workbooth project の workbooth における脆弱性",
        "description": "Vulnerability in Distro Linux Workbooth v2.5 that allows to escalate privileges to the root user by manipulating the network configuration script.",
        "technologies": "workbooth project\nworkbooth 2.5"
    },
    "JVNDB-2024-012581": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix kernel bug due to missing clearing of checked flag Syzbot reported that in directory operations after nilfs2 detects filesystem corruption and degrades to read-only, __block_write_begin_int(), which is called to prepare block writes, may fail the BUG_ON check for accesses exceeding the folio/page size, triggering a kernel bug. This was found to be because the \"checked\" flag of a page/folio was not cleared when it was discarded by nilfs2's own routine, which causes the sanity check of directory entries to be skipped when the directory page/folio is reloaded. So, fix that. This was necessary when the use of nilfs2's own page discard routine was applied to more than just metadata files.",
        "technologies": "Linux\nLinux Kernel 3.10 以上 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012562": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp/dccp: Don't use timer_pending() in reqsk_queue_unlink(). Martin KaFai Lau reported use-after-free [0] in reqsk_timer_handler(). \"\"\" We are seeing a use-after-free from a bpf prog attached to trace_tcp_retransmit_synack. The program passes the req->sk to the bpf_sk_storage_get_tracing kernel helper which does check for null before using it. \"\"\" The commit 83fccfc3940c (\"inet: fix potential deadlock in reqsk_queue_unlink()\") added timer_pending() in reqsk_queue_unlink() not to call del_timer_sync() from reqsk_timer_handler(), but it introduced a small race window. Before the timer is called, expire_timers() calls detach_timer(timer, true) to clear timer->entry.pprev and marks it as not pending. If reqsk_queue_unlink() checks timer_pending() just after expire_timers() calls detach_timer(), TCP will miss del_timer_sync(); the reqsk timer will continue running and send multiple SYN+ACKs until it expires. The reported UAF could happen if req->sk is close()d earlier than the timer expiration, which is 63s by default. The scenario would be 1. inet_csk_complete_hashdance() calls inet_csk_reqsk_queue_drop(), but del_timer_sync() is missed 2. reqsk timer is executed and scheduled again 3. req->sk is accept()ed and reqsk_put() decrements rsk_refcnt, but reqsk timer still has another one, and inet_csk_accept() does not clear req->sk for non-TFO sockets 4. sk is close()d 5. reqsk timer is executed again, and BPF touches req->sk Let's not use timer_pending() by passing the caller context to __inet_csk_reqsk_queue_drop(). Note that reqsk timer is pinned, so the issue does not happen in most use cases. [1] [0] BUG: KFENCE: use-after-free read in bpf_sk_storage_get_tracing+0x2e/0x1b0 Use-after-free read at 0x00000000a891fb3a (in kfence-#1): bpf_sk_storage_get_tracing+0x2e/0x1b0 bpf_prog_5ea3e95db6da0438_tcp_retransmit_synack+0x1d20/0x1dda bpf_trace_run2+0x4c/0xc0 tcp_rtx_synack+0xf9/0x100 reqsk_timer_handler+0xda/0x3d0 run_timer_softirq+0x292/0x8a0 irq_exit_rcu+0xf5/0x320 sysvec_apic_timer_interrupt+0x6d/0x80 asm_sysvec_apic_timer_interrupt+0x16/0x20 intel_idle_irq+0x5a/0xa0 cpuidle_enter_state+0x94/0x273 cpu_startup_entry+0x15e/0x260 start_secondary+0x8a/0x90 secondary_startup_64_no_verify+0xfa/0xfb kfence-#1: 0x00000000a72cc7b6-0x00000000d97616d9, size=2376, cache=TCPv6 allocated by task 0 on cpu 9 at 260507.901592s: sk_prot_alloc+0x35/0x140 sk_clone_lock+0x1f/0x3f0 inet_csk_clone_lock+0x15/0x160 tcp_create_openreq_child+0x1f/0x410 tcp_v6_syn_recv_sock+0x1da/0x700 tcp_check_req+0x1fb/0x510 tcp_v6_rcv+0x98b/0x1420 ipv6_list_rcv+0x2258/0x26e0 napi_complete_done+0x5b1/0x2990 mlx5e_napi_poll+0x2ae/0x8d0 net_rx_action+0x13e/0x590 irq_exit_rcu+0xf5/0x320 common_interrupt+0x80/0x90 asm_common_interrupt+0x22/0x40 cpuidle_enter_state+0xfb/0x273 cpu_startup_entry+0x15e/0x260 start_secondary+0x8a/0x90 secondary_startup_64_no_verify+0xfa/0xfb freed by task 0 on cpu 9 at 260507.927527s: rcu_core_si+0x4ff/0xf10 irq_exit_rcu+0xf5/0x320 sysvec_apic_timer_interrupt+0x6d/0x80 asm_sysvec_apic_timer_interrupt+0x16/0x20 cpuidle_enter_state+0xfb/0x273 cpu_startup_entry+0x15e/0x260 start_secondary+0x8a/0x90 secondary_startup_64_no_verify+0xfa/0xfb",
        "technologies": "Linux\nLinux Kernel 4.1.11 以上 4.2 未満\nLinux Kernel 4.2 以上 5.15.170 未満\nLinux Kernel 5.16 以上 6.1.115 未満\nLinux Kernel 6.2 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012612": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Check if more than chunk-size bytes are written A incorrectly formatted chunk may decompress into more than LZNT_CHUNK_SIZE bytes and a index out of bounds will occur in s_max_off.",
        "technologies": "Linux\nLinux Kernel 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012600": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvmet-auth: assign dh_key to NULL after kfree_sensitive ctrl->dh_key might be used across multiple calls to nvmet_setup_dhgroup() for the same controller. So it's better to nullify it after release on error path in order to avoid double free later in nvmet_destroy_auth(). Found by Linux Verification Center (linuxtesting.org) with Svace.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012615": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Vangogh: Fix kernel memory out of bounds write KASAN reports that the GPU metrics table allocated in vangogh_tables_init() is not large enough for the memset done in smu_cmn_init_soft_gpu_metrics(). Condensed report follows: [ 33.861314] BUG: KASAN: slab-out-of-bounds in smu_cmn_init_soft_gpu_metrics+0x73/0x200 [amdgpu] [ 33.861799] Write of size 168 at addr ffff888129f59500 by task mangoapp/1067 ... [ 33.861808] CPU: 6 UID: 1000 PID: 1067 Comm: mangoapp Tainted: G W 6.12.0-rc4 #356 1a56f59a8b5182eeaf67eb7cb8b13594dd23b544 [ 33.861816] Tainted: [W]=WARN [ 33.861818] Hardware name: Valve Galileo/Galileo, BIOS F7G0107 12/01/2023 [ 33.861822] Call Trace: [ 33.861826] <TASK> [ 33.861829] dump_stack_lvl+0x66/0x90 [ 33.861838] print_report+0xce/0x620 [ 33.861853] kasan_report+0xda/0x110 [ 33.862794] kasan_check_range+0xfd/0x1a0 [ 33.862799] __asan_memset+0x23/0x40 [ 33.862803] smu_cmn_init_soft_gpu_metrics+0x73/0x200 [amdgpu 13b1bc364ec578808f676eba412c20eaab792779] [ 33.863306] vangogh_get_gpu_metrics_v2_4+0x123/0xad0 [amdgpu 13b1bc364ec578808f676eba412c20eaab792779] [ 33.864257] vangogh_common_get_gpu_metrics+0xb0c/0xbc0 [amdgpu 13b1bc364ec578808f676eba412c20eaab792779] [ 33.865682] amdgpu_dpm_get_gpu_metrics+0xcc/0x110 [amdgpu 13b1bc364ec578808f676eba412c20eaab792779] [ 33.866160] amdgpu_get_gpu_metrics+0x154/0x2d0 [amdgpu 13b1bc364ec578808f676eba412c20eaab792779] [ 33.867135] dev_attr_show+0x43/0xc0 [ 33.867147] sysfs_kf_seq_show+0x1f1/0x3b0 [ 33.867155] seq_read_iter+0x3f8/0x1140 [ 33.867173] vfs_read+0x76c/0xc50 [ 33.867198] ksys_read+0xfb/0x1d0 [ 33.867214] do_syscall_64+0x90/0x160 ... [ 33.867353] Allocated by task 378 on cpu 7 at 22.794876s: [ 33.867358] kasan_save_stack+0x33/0x50 [ 33.867364] kasan_save_track+0x17/0x60 [ 33.867367] __kasan_kmalloc+0x87/0x90 [ 33.867371] vangogh_init_smc_tables+0x3f9/0x840 [amdgpu] [ 33.867835] smu_sw_init+0xa32/0x1850 [amdgpu] [ 33.868299] amdgpu_device_init+0x467b/0x8d90 [amdgpu] [ 33.868733] amdgpu_driver_load_kms+0x19/0xf0 [amdgpu] [ 33.869167] amdgpu_pci_probe+0x2d6/0xcd0 [amdgpu] [ 33.869608] local_pci_probe+0xda/0x180 [ 33.869614] pci_device_probe+0x43f/0x6b0 Empirically we can confirm that the former allocates 152 bytes for the table, while the latter memsets the 168 large block. Root cause appears that when GPU metrics tables for v2_4 parts were added it was not considered to enlarge the table to fit. The fix in this patch is rather \"brute force\" and perhaps later should be done in a smarter way, by extracting and consolidating the part version to size logic to a common helper, instead of brute forcing the largest possible allocation. Nevertheless, for now this works and fixes the out of bounds write. v2: * Drop impossible v3_0 case. (Mario) (cherry picked from commit 0880f58f9609f0200483a49429af0f050d281703)",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012611": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cxl/port: Fix use-after-free, permit out-of-order decoder shutdown In support of investigating an initialization failure report [1], cxl_test was updated to register mock memory-devices after the mock root-port/bus device had been registered. That led to cxl_test crashing with a use-after-free bug with the following signature: cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl_switch_uport.0 nr_eps: 1 nr_targets: 1 cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl_switch_uport.0 nr_eps: 2 nr_targets: 1 cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[0] = cxl_switch_dport.0 for mem0:decoder7.0 @ 0 1) cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[1] = cxl_switch_dport.4 for mem4:decoder14.0 @ 1 [..] cxld_unregister: cxl decoder14.0: cxl_region_decode_reset: cxl_region region3: mock_decoder_reset: cxl_port port3: decoder3.0 reset 2) mock_decoder_reset: cxl_port port3: decoder3.0: out of order reset, expected decoder3.1 cxl_endpoint_decoder_release: cxl decoder14.0: [..] cxld_unregister: cxl decoder7.0: 3) cxl_region_decode_reset: cxl_region region3: Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI [..] RIP: 0010:to_cxl_port+0x8/0x60 [cxl_core] [..] Call Trace: <TASK> cxl_region_decode_reset+0x69/0x190 [cxl_core] cxl_region_detach+0xe8/0x210 [cxl_core] cxl_decoder_kill_region+0x27/0x40 [cxl_core] cxld_unregister+0x5d/0x60 [cxl_core] At 1) a region has been established with 2 endpoint decoders (7.0 and 14.0). Those endpoints share a common switch-decoder in the topology (3.0). At teardown, 2), decoder14.0 is the first to be removed and hits the \"out of order reset case\" in the switch decoder. The effect though is that region3 cleanup is aborted leaving it in-tact and referencing decoder14.0. At 3) the second attempt to teardown region3 trips over the stale decoder14.0 object which has long since been deleted. The fix here is to recognize that the CXL specification places no mandate on in-order shutdown of switch-decoders, the driver enforces in-order allocation, and hardware enforces in-order commit. So, rather than fail and leave objects dangling, always remove them. In support of making cxl_region_decode_reset() always succeed, cxl_region_invalidate_memregion() failures are turned into warnings. Crashing the kernel is ok there since system integrity is at risk if caches cannot be managed around physical address mutation events like CXL region destruction. A new device_for_each_child_reverse_from() is added to cleanup port->commit_end after all dependent decoders have been disabled. In other words if decoders are allocated 0->1->2 and disabled 1->2->0 then port->commit_end only decrements from 2 after 2 has been disabled, and it decrements all the way to zero since 1 was disabled previously.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012610": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iov_iter: fix copy_page_from_iter_atomic() if KMAP_LOCAL_FORCE_MAP generic/077 on x86_32 CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP=y with highmem, on huge=always tmpfs, issues a warning and then hangs (interruptibly): WARNING: CPU: 5 PID: 3517 at mm/highmem.c:622 kunmap_local_indexed+0x62/0xc9 CPU: 5 UID: 0 PID: 3517 Comm: cp Not tainted 6.12.0-rc4 #2 ... copy_page_from_iter_atomic+0xa6/0x5ec generic_perform_write+0xf6/0x1b4 shmem_file_write_iter+0x54/0x67 Fix copy_page_from_iter_atomic() by limiting it in that case (include/linux/skbuff.h skb_frag_must_loop() does similar). But going forward, perhaps CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP is too surprising, has outlived its usefulness, and should just be removed?",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012628": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Add rough attr alloc_size check",
        "technologies": "Linux\nLinux Kernel 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012627": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix out-of-bounds write in trie_get_next_key() trie_get_next_key() allocates a node stack with size trie->max_prefixlen, while it writes (trie->max_prefixlen + 1) nodes to the stack when it has full paths from the root to leaves. For example, consider a trie with max_prefixlen is 8, and the nodes with key 0x00/0, 0x00/1, 0x00/2, ... 0x00/8 inserted. Subsequent calls to trie_get_next_key with _key with .prefixlen = 8 make 9 nodes be written on the node stack with size 8.",
        "technologies": "Linux\nLinux Kernel 4.16 以上 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012741": {
        "title": "Linux の Linux Kernel における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlegacy: Clear stale interrupts before resuming device iwl4965 fails upon resume from hibernation on my laptop. The reason seems to be a stale interrupt which isn't being cleared out before interrupts are enabled. We end up with a race beween the resume trying to bring things back up, and the restart work (queued form the interrupt handler) trying to bring things down. Eventually the whole thing blows up. Fix the problem by clearing out any stale interrupts before interrupts get enabled during resume. Here's a debug log of the indicent: [ 12.042589] ieee80211 phy0: il_isr ISR inta 0x00000080, enabled 0xaa00008b, fh 0x00000000 [ 12.042625] ieee80211 phy0: il4965_irq_tasklet inta 0x00000080, enabled 0x00000000, fh 0x00000000 [ 12.042651] iwl4965 0000:10:00.0: RF_KILL bit toggled to enable radio. [ 12.042653] iwl4965 0000:10:00.0: On demand firmware reload [ 12.042690] ieee80211 phy0: il4965_irq_tasklet End inta 0x00000000, enabled 0xaa00008b, fh 0x00000000, flags 0x00000282 [ 12.052207] ieee80211 phy0: il4965_mac_start enter [ 12.052212] ieee80211 phy0: il_prep_station Add STA to driver ID 31: ff:ff:ff:ff:ff:ff [ 12.052244] ieee80211 phy0: il4965_set_hw_ready hardware ready [ 12.052324] ieee80211 phy0: il_apm_init Init card's basic functions [ 12.052348] ieee80211 phy0: il_apm_init L1 Enabled; Disabling L0S [ 12.055727] ieee80211 phy0: il4965_load_bsm Begin load bsm [ 12.056140] ieee80211 phy0: il4965_verify_bsm Begin verify bsm [ 12.058642] ieee80211 phy0: il4965_verify_bsm BSM bootstrap uCode image OK [ 12.058721] ieee80211 phy0: il4965_load_bsm BSM write complete, poll 1 iterations [ 12.058734] ieee80211 phy0: __il4965_up iwl4965 is coming up [ 12.058737] ieee80211 phy0: il4965_mac_start Start UP work done. [ 12.058757] ieee80211 phy0: __il4965_down iwl4965 is going down [ 12.058761] ieee80211 phy0: il_scan_cancel_timeout Scan cancel timeout [ 12.058762] ieee80211 phy0: il_do_scan_abort Not performing scan to abort [ 12.058765] ieee80211 phy0: il_clear_ucode_stations Clearing ucode stations in driver [ 12.058767] ieee80211 phy0: il_clear_ucode_stations No active stations found to be cleared [ 12.058819] ieee80211 phy0: _il_apm_stop Stop card, put in low power state [ 12.058827] ieee80211 phy0: _il_apm_stop_master stop master [ 12.058864] ieee80211 phy0: il4965_clear_free_frames 0 frames on pre-allocated heap on clear. [ 12.058869] ieee80211 phy0: Hardware restart was requested [ 16.132299] iwl4965 0000:10:00.0: START_ALIVE timeout after 4000ms. [ 16.132303] ------------[ cut here ]------------ [ 16.132304] Hardware became unavailable upon resume. This could be a software issue prior to suspend or a hardware issue. [ 16.132338] WARNING: CPU: 0 PID: 181 at net/mac80211/util.c:1826 ieee80211_reconfig+0x8f/0x14b0 [mac80211] [ 16.132390] Modules linked in: ctr ccm sch_fq_codel xt_tcpudp xt_multiport xt_state iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv4 ip_tables x_tables binfmt_misc joydev mousedev btusb btrtl btintel btbcm bluetooth ecdh_generic ecc iTCO_wdt i2c_dev iwl4965 iwlegacy coretemp snd_hda_codec_analog pcspkr psmouse mac80211 snd_hda_codec_generic libarc4 sdhci_pci cqhci sha256_generic sdhci libsha256 firewire_ohci snd_hda_intel snd_intel_dspcfg mmc_core snd_hda_codec snd_hwdep firewire_core led_class iosf_mbi snd_hda_core uhci_hcd lpc_ich crc_itu_t cfg80211 ehci_pci ehci_hcd snd_pcm usbcore mfd_core rfkill snd_timer snd usb_common soundcore video parport_pc parport intel_agp wmi intel_gtt backlight e1000e agpgart evdev [ 16.132456] CPU: 0 UID: 0 PID: 181 Comm: kworker/u8:6 Not tainted 6.11.0-cl+ #143 [ 16.132460] Hardware name: Hewlett-Packard HP Compaq 6910p/30BE, BIOS 68MCU Ver. F.19 07/06/2010 [ 16.132463] Workqueue: async async_run_entry_fn [ 16.132469] RIP: 0010:ieee80211_reconfig+0x8f/0x14b0 [mac80211] [ 16.132501] Code: da 02 00 0 ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-012632": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Fix the double free in scmi_debugfs_common_setup() Clang static checker(scan-build) throws below warning： | drivers/firmware/arm_scmi/driver.c:line 2915, column 2 | Attempt to free released memory. When devm_add_action_or_reset() fails, scmi_debugfs_common_cleanup() will run twice which causes double free of 'dbg->name'. Remove the redundant scmi_debugfs_common_cleanup() to fix this problem.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.59 未満\nLinux Kernel 6.7 以上 6.11.6 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-011382": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-012758": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: clear wdev->cqm_config pointer on free When we free wdev->cqm_config when unregistering, we also need to clear out the pointer since the same wdev/netdev may get re-registered in another network namespace, then destroyed later, running this code again, which results in a double-free.",
        "technologies": "Linux\nLinux Kernel 6.1.57 以上 6.1.116 未満\nLinux Kernel 6.5.7 以上 6.6 未満\nLinux Kernel 6.6 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-015412": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix double free of anonymous device after snapshot creation failure When creating a snapshot we may do a double free of an anonymous device in case there's an error committing the transaction. The second free may result in freeing an anonymous device number that was allocated by some other subsystem in the kernel or another btrfs filesystem. The steps that lead to this: 1) At ioctl.c:create_snapshot() we allocate an anonymous device number and assign it to pending_snapshot->anon_dev; 2) Then we call btrfs_commit_transaction() and end up at transaction.c:create_pending_snapshot(); 3) There we call btrfs_get_new_fs_root() and pass it the anonymous device number stored in pending_snapshot->anon_dev; 4) btrfs_get_new_fs_root() frees that anonymous device number because btrfs_lookup_fs_root() returned a root - someone else did a lookup of the new root already, which could some task doing backref walking; 5) After that some error happens in the transaction commit path, and at ioctl.c:create_snapshot() we jump to the 'fail' label, and after that we free again the same anonymous device number, which in the meanwhile may have been reallocated somewhere else, because pending_snapshot->anon_dev still has the same value as in step 1. Recently syzbot ran into this and reported the following trace: ------------[ cut here ]------------ ida_free called for id=51 which is not allocated. WARNING: CPU: 1 PID: 31038 at lib/idr.c:525 ida_free+0x370/0x420 lib/idr.c:525 Modules linked in: CPU: 1 PID: 31038 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-00410-gc02197fc9076 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 RIP: 0010:ida_free+0x370/0x420 lib/idr.c:525 Code: 10 42 80 3c 28 (...) RSP: 0018:ffffc90015a67300 EFLAGS: 00010246 RAX: be5130472f5dd000 RBX: 0000000000000033 RCX: 0000000000040000 RDX: ffffc90009a7a000 RSI: 000000000003ffff RDI: 0000000000040000 RBP: ffffc90015a673f0 R08: ffffffff81577992 R09: 1ffff92002b4cdb4 R10: dffffc0000000000 R11: fffff52002b4cdb5 R12: 0000000000000246 R13: dffffc0000000000 R14: ffffffff8e256b80 R15: 0000000000000246 FS: 00007fca3f4b46c0(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f167a17b978 CR3: 000000001ed26000 CR4: 0000000000350ef0 Call Trace: <TASK> btrfs_get_root_ref+0xa48/0xaf0 fs/btrfs/disk-io.c:1346 create_pending_snapshot+0xff2/0x2bc0 fs/btrfs/transaction.c:1837 create_pending_snapshots+0x195/0x1d0 fs/btrfs/transaction.c:1931 btrfs_commit_transaction+0xf1c/0x3740 fs/btrfs/transaction.c:2404 create_snapshot+0x507/0x880 fs/btrfs/ioctl.c:848 btrfs_mksubvol+0x5d0/0x750 fs/btrfs/ioctl.c:998 btrfs_mksnapshot+0xb5/0xf0 fs/btrfs/ioctl.c:1044 __btrfs_ioctl_snap_create+0x387/0x4b0 fs/btrfs/ioctl.c:1306 btrfs_ioctl_snap_create_v2+0x1ca/0x400 fs/btrfs/ioctl.c:1393 btrfs_ioctl+0xa74/0xd40 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:871 [inline] __se_sys_ioctl+0xfe/0x170 fs/ioctl.c:857 do_syscall_64+0xfb/0x240 entry_SYSCALL_64_after_hwframe+0x6f/0x77 RIP: 0033:0x7fca3e67dda9 Code: 28 00 00 00 (...) RSP: 002b:00007fca3f4b40c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007fca3e7abf80 RCX: 00007fca3e67dda9 RDX: 00000000200005c0 RSI: 0000000050009417 RDI: 0000000000000003 RBP: 00007fca3e6ca47a R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 000000000000000b R14: 00007fca3e7abf80 R15: 00007fff6bf95658 </TASK> Where we get an explicit message where we attempt to free an anonymous device number that is not currently allocated. It happens in a different code path from the example below, at btrfs_get_root_ref(), so this change may not fix the case triggered by sy ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.10.210 以上 5.11 未満\nLinux Kernel 5.15.149 以上 5.16 未満\nLinux Kernel 6.1.79 以上 6.1.81 未満\nLinux Kernel 6.6.18 以上 6.6.21 未満\nLinux Kernel 6.7.6 以上 6.7.9 未満"
    },
    "JVNDB-2024-015411": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tls: fix use-after-free on failed backlog decryption When the decrypt request goes to the backlog and crypto_aead_decrypt returns -EBUSY, tls_do_decryption will wait until all async decryptions have completed. If one of them fails, tls_do_decryption will return -EBADMSG and tls_decrypt_sg jumps to the error path, releasing all the pages. But the pages have been passed to the async callback, and have already been released by tls_decrypt_done. The only true async case is when crypto_aead_decrypt returns -EINPROGRESS. With -EBUSY, we already waited so we can tell tls_sw_recvmsg that the data is available for immediate copy, but we need to notify tls_decrypt_sg (via the new ->async_done flag) that the memory has already been released.",
        "technologies": "Linux\nLinux Kernel 6.6.18 以上 6.6.21 未満\nLinux Kernel 6.7.6 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-015428": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: edia: dvbdev: fix a use-after-free In dvb_register_device, *pdvbdev is set equal to dvbdev, which is freed in several error-handling paths. However, *pdvbdev is not set to NULL after dvbdev's deallocation, causing use-after-frees in many places, for example, in the following call chain: budget_register |-> dvb_dmxdev_init |-> dvb_register_device |-> dvb_dmxdev_release |-> dvb_unregister_device |-> dvb_remove_device |-> dvb_device_put |-> kref_put When calling dvb_unregister_device, dmxdev->dvbdev (i.e. *pdvbdev in dvb_register_device) could point to memory that had been freed in dvb_register_device. Thereafter, this pointer is transferred to kref_put and triggering a use-after-free.",
        "technologies": "Linux\nLinux Kernel 2.6.21 以上 4.19.311 未満\nLinux Kernel 4.20 以上 5.4.273 未満\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015425": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: Correct the PDO counting in pd_set Off-by-one errors happen because nr_snk_pdo and nr_src_pdo are incorrectly added one. The index of the loop is equal to the number of PDOs to be updated when leaving the loop and it doesn't need to be added one. When doing the power negotiation, TCPM relies on the \"nr_snk_pdo\" as the size of the local sink PDO array to match the Source capabilities of the partner port. If the off-by-one overflow occurs, a wrong RDO might be sent and unexpected power transfer might happen such as over voltage or over current (than expected). \"nr_src_pdo\" is used to set the Rp level when the port is in Source role. It is also the array size of the local Source capabilities when filling up the buffer which will be sent as the Source PDOs (such as in Power Negotiation). If the off-by-one overflow occurs, a wrong Rp level might be set and wrong Source PDOs will be sent to the partner port. This could potentially cause over current or port resets.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015447": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: hibernate: Fix level3 translation fault in swsusp_save() On arm64 machines, swsusp_save() faults if it attempts to access MEMBLOCK_NOMAP memory ranges. This can be reproduced in QEMU using UEFI when booting with rodata=off debug_pagealloc=off and CONFIG_KFENCE=n: Unable to handle kernel paging request at virtual address ffffff8000000000 Mem abort info: ESR = 0x0000000096000007 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x07: level 3 translation fault Data abort info: ISV = 0, ISS = 0x00000007, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 swapper pgtable: 4k pages, 39-bit VAs, pgdp=00000000eeb0b000 [ffffff8000000000] pgd=180000217fff9803, p4d=180000217fff9803, pud=180000217fff9803, pmd=180000217fff8803, pte=0000000000000000 Internal error: Oops: 0000000096000007 [#1] SMP Internal error: Oops: 0000000096000007 [#1] SMP Modules linked in: xt_multiport ipt_REJECT nf_reject_ipv4 xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c iptable_filter bpfilter rfkill at803x snd_hda_codec_hdmi snd_hda_intel snd_intel_dspcfg dwmac_generic stmmac_platform snd_hda_codec stmmac joydev pcs_xpcs snd_hda_core phylink ppdev lp parport ramoops reed_solomon ip_tables x_tables nls_iso8859_1 vfat multipath linear amdgpu amdxcp drm_exec gpu_sched drm_buddy hid_generic usbhid hid radeon video drm_suballoc_helper drm_ttm_helper ttm i2c_algo_bit drm_display_helper cec drm_kms_helper drm CPU: 0 PID: 3663 Comm: systemd-sleep Not tainted 6.6.2+ #76 Source Version: 4e22ed63a0a48e7a7cff9b98b7806d8d4add7dc0 Hardware name: Greatwall GW-XXXXXX-XXX/GW-XXXXXX-XXX, BIOS KunLun BIOS V4.0 01/19/2021 pstate: 600003c5 (nZCv DAIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : swsusp_save+0x280/0x538 lr : swsusp_save+0x280/0x538 sp : ffffffa034a3fa40 x29: ffffffa034a3fa40 x28: ffffff8000001000 x27: 0000000000000000 x26: ffffff8001400000 x25: ffffffc08113e248 x24: 0000000000000000 x23: 0000000000080000 x22: ffffffc08113e280 x21: 00000000000c69f2 x20: ffffff8000000000 x19: ffffffc081ae2500 x18: 0000000000000000 x17: 6666662074736420 x16: 3030303030303030 x15: 3038666666666666 x14: 0000000000000b69 x13: ffffff9f89088530 x12: 00000000ffffffea x11: 00000000ffff7fff x10: 00000000ffff7fff x9 : ffffffc08193f0d0 x8 : 00000000000bffe8 x7 : c0000000ffff7fff x6 : 0000000000000001 x5 : ffffffa0fff09dc8 x4 : 0000000000000000 x3 : 0000000000000027 x2 : 0000000000000000 x1 : 0000000000000000 x0 : 000000000000004e Call trace: swsusp_save+0x280/0x538 swsusp_arch_suspend+0x148/0x190 hibernation_snapshot+0x240/0x39c hibernate+0xc4/0x378 state_store+0xf0/0x10c kobj_attr_store+0x14/0x24 The reason is swsusp_save() -> copy_data_pages() -> page_is_saveable() -> kernel_page_present() assuming that a page is always present when can_set_direct_map() is false (all of rodata_full, debug_pagealloc_enabled() and arm64_kfence_can_set_direct_map() false), irrespective of the MEMBLOCK_NOMAP ranges. Such MEMBLOCK_NOMAP regions should not be saved during hibernation. This problem was introduced by changes to the pfn_valid() logic in commit a7d9f306ba70 (\"arm64: drop pfn_valid_within() and simplify pfn_valid()\"). Similar to other architectures, drop the !can_set_direct_map() check in kernel_page_present() so that page_is_savable() skips such pages. [catalin.marinas@arm.com: rework commit message]",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.157 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015438": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mac802154: fix llsec key resources release in mac802154_llsec_key_del mac802154_llsec_key_del() can free resources of a key directly without following the RCU rules for waiting before the end of a grace period. This may lead to use-after-free in case llsec_lookup_key() is traversing the list of keys in parallel with a key deletion: refcount_t: addition on 0; use-after-free. WARNING: CPU: 4 PID: 16000 at lib/refcount.c:25 refcount_warn_saturate+0x162/0x2a0 Modules linked in: CPU: 4 PID: 16000 Comm: wpan-ping Not tainted 6.7.0 #19 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 RIP: 0010:refcount_warn_saturate+0x162/0x2a0 Call Trace: <TASK> llsec_lookup_key.isra.0+0x890/0x9e0 mac802154_llsec_encrypt+0x30c/0x9c0 ieee802154_subif_start_xmit+0x24/0x1e0 dev_hard_start_xmit+0x13e/0x690 sch_direct_xmit+0x2ae/0xbc0 __dev_queue_xmit+0x11dd/0x3c20 dgram_sendmsg+0x90b/0xd60 __sys_sendto+0x466/0x4c0 __x64_sys_sendto+0xe0/0x1c0 do_syscall_64+0x45/0xf0 entry_SYSCALL_64_after_hwframe+0x6e/0x76 Also, ieee802154_llsec_key_entry structures are not freed by mac802154_llsec_key_del(): unreferenced object 0xffff8880613b6980 (size 64): comm \"iwpan\", pid 2176, jiffies 4294761134 (age 60.475s) hex dump (first 32 bytes): 78 0d 8f 18 80 88 ff ff 22 01 00 00 00 00 ad de x.......\"....... 00 00 00 00 00 00 00 00 03 00 cd ab 00 00 00 00 ................ backtrace: [<ffffffff81dcfa62>] __kmem_cache_alloc_node+0x1e2/0x2d0 [<ffffffff81c43865>] kmalloc_trace+0x25/0xc0 [<ffffffff88968b09>] mac802154_llsec_key_add+0xac9/0xcf0 [<ffffffff8896e41a>] ieee802154_add_llsec_key+0x5a/0x80 [<ffffffff8892adc6>] nl802154_add_llsec_key+0x426/0x5b0 [<ffffffff86ff293e>] genl_family_rcv_msg_doit+0x1fe/0x2f0 [<ffffffff86ff46d1>] genl_rcv_msg+0x531/0x7d0 [<ffffffff86fee7a9>] netlink_rcv_skb+0x169/0x440 [<ffffffff86ff1d88>] genl_rcv+0x28/0x40 [<ffffffff86fec15c>] netlink_unicast+0x53c/0x820 [<ffffffff86fecd8b>] netlink_sendmsg+0x93b/0xe60 [<ffffffff86b91b35>] ____sys_sendmsg+0xac5/0xca0 [<ffffffff86b9c3dd>] ___sys_sendmsg+0x11d/0x1c0 [<ffffffff86b9c65a>] __sys_sendmsg+0xfa/0x1d0 [<ffffffff88eadbf5>] do_syscall_64+0x45/0xf0 [<ffffffff890000ea>] entry_SYSCALL_64_after_hwframe+0x6e/0x76 Handle the proper resource release in the RCU callback function mac802154_llsec_key_del_rcu(). Note that if llsec_lookup_key() finds a key, it gets a refcount via llsec_key_get() and locally copies key id from key_entry (which is a list element). So it's safe to call llsec_key_put() and free the list entry after the RCU grace period elapses. Found by Linux Verification Center (linuxtesting.org).",
        "technologies": "Linux\nLinux Kernel 3.16 以上 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-015429": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix a potential buffer overflow in 'dp_dsc_clock_en_read()' Tell snprintf() to store at most 10 bytes in the output buffer instead of 30. Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_debugfs.c:1508 dp_dsc_clock_en_read() error: snprintf() is printing too much 30 vs 10",
        "technologies": "Linux\nLinux Kernel 5.9 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015448": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bootconfig: use memblock_free_late to free xbc memory to buddy On the time to free xbc memory in xbc_exit(), memblock may has handed over memory to buddy allocator. So it doesn't make sense to free memory back to memblock. memblock_free() called by xbc_exit() even causes UAF bugs on architectures with CONFIG_ARCH_KEEP_MEMBLOCK disabled like x86. Following KASAN logs shows this case. This patch fixes the xbc memory free problem by calling memblock_free() in early xbc init error rewind path and calling memblock_free_late() in xbc exit path to free memory to buddy allocator. [ 9.410890] ================================================================== [ 9.418962] BUG: KASAN: use-after-free in memblock_isolate_range+0x12d/0x260 [ 9.426850] Read of size 8 at addr ffff88845dd30000 by task swapper/0/1 [ 9.435901] CPU: 9 PID: 1 Comm: swapper/0 Tainted: G U 6.9.0-rc3-00208-g586b5dfb51b9 #5 [ 9.446403] Hardware name: Intel Corporation RPLP LP5 (CPU:RaptorLake)/RPLP LP5 (ID:13), BIOS IRPPN02.01.01.00.00.19.015.D-00000000 Dec 28 2023 [ 9.460789] Call Trace: [ 9.463518] <TASK> [ 9.465859] dump_stack_lvl+0x53/0x70 [ 9.469949] print_report+0xce/0x610 [ 9.473944] ? __virt_addr_valid+0xf5/0x1b0 [ 9.478619] ? memblock_isolate_range+0x12d/0x260 [ 9.483877] kasan_report+0xc6/0x100 [ 9.487870] ? memblock_isolate_range+0x12d/0x260 [ 9.493125] memblock_isolate_range+0x12d/0x260 [ 9.498187] memblock_phys_free+0xb4/0x160 [ 9.502762] ? __pfx_memblock_phys_free+0x10/0x10 [ 9.508021] ? mutex_unlock+0x7e/0xd0 [ 9.512111] ? __pfx_mutex_unlock+0x10/0x10 [ 9.516786] ? kernel_init_freeable+0x2d4/0x430 [ 9.521850] ? __pfx_kernel_init+0x10/0x10 [ 9.526426] xbc_exit+0x17/0x70 [ 9.529935] kernel_init+0x38/0x1e0 [ 9.533829] ? _raw_spin_unlock_irq+0xd/0x30 [ 9.538601] ret_from_fork+0x2c/0x50 [ 9.542596] ? __pfx_kernel_init+0x10/0x10 [ 9.547170] ret_from_fork_asm+0x1a/0x30 [ 9.551552] </TASK> [ 9.555649] The buggy address belongs to the physical page: [ 9.561875] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x45dd30 [ 9.570821] flags: 0x200000000000000(node=0|zone=2) [ 9.576271] page_type: 0xffffffff() [ 9.580167] raw: 0200000000000000 ffffea0011774c48 ffffea0012ba1848 0000000000000000 [ 9.588823] raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000 [ 9.597476] page dumped because: kasan: bad access detected [ 9.605362] Memory state around the buggy address: [ 9.610714] ffff88845dd2ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 9.618786] ffff88845dd2ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 9.626857] >ffff88845dd30000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.634930] ^ [ 9.638534] ffff88845dd30080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.646605] ffff88845dd30100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.654675] ==================================================================",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015437": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: qat - resolve race condition during AER recovery During the PCI AER system's error recovery process, the kernel driver may encounter a race condition with freeing the reset_data structure's memory. If the device restart will take more than 10 seconds the function scheduling that restart will exit due to a timeout, and the reset_data structure will be freed. However, this data structure is used for completion notification after the restart is completed, which leads to a UAF bug. This results in a KFENCE bug notice. BUG: KFENCE: use-after-free read in adf_device_reset_worker+0x38/0xa0 [intel_qat] Use-after-free read at 0x00000000bc56fddf (in kfence-#142): adf_device_reset_worker+0x38/0xa0 [intel_qat] process_one_work+0x173/0x340 To resolve this race condition, the memory associated to the container of the work_struct is freed on the worker if the timeout expired, otherwise on the function that schedules the worker. The timeout detection can be done by checking if the caller is still waiting for completion or not by using completion_done() function.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.17 以上 4.19.312 未満\nLinux Kernel 4.20 以上 5.4.274 未満\nLinux Kernel 5.5 以上 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-015427": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/rds: fix WARNING in rds_conn_connect_if_down If connection isn't established yet, get_mr() will fail, trigger connection after get_mr().",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.18.85 以上 3.19 未満\nLinux Kernel 4.1.48 以上 4.2 未満\nLinux Kernel 4.4.103 以上 4.5 未満\nLinux Kernel 4.9.66 以上 4.10 未満\nLinux Kernel 4.11 以上 4.19.310 未満\nLinux Kernel 4.20 以上 5.4.272 未満\nLinux Kernel 5.5 以上 5.10.213 未満\nLinux Kernel 5.11 以上 5.15.152 未満\nLinux Kernel 5.16 以上 6.1.82 未満\nLinux Kernel 6.2 以上 6.6.22 未満\nLinux Kernel 6.7 以上 6.7.10 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-015424": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix OOB in nilfs_set_de_type The size of the nilfs_type_by_mode array in the fs/nilfs2/dir.c file is defined as \"S_IFMT >> S_SHIFT\", but the nilfs_set_de_type() function, which uses this array, specifies the index to read from the array in the same way as \"(mode & S_IFMT) >> S_SHIFT\". static void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode *inode) { umode_t mode = inode->i_mode; de->file_type = nilfs_type_by_mode[(mode & S_IFMT)>>S_SHIFT]; // oob } However, when the index is determined this way, an out-of-bounds (OOB) error occurs by referring to an index that is 1 larger than the array size when the condition \"mode & S_IFMT == S_IFMT\" is satisfied. Therefore, a patch to resize the nilfs_type_by_mode array should be applied to prevent OOB errors.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.30 以上 4.19.313 未満\nLinux Kernel 4.20 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.157 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015452": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfs: fix UAF in direct writes In production we have been hitting the following warning consistently ------------[ cut here ]------------ refcount_t: underflow; use-after-free. WARNING: CPU: 17 PID: 1800359 at lib/refcount.c:28 refcount_warn_saturate+0x9c/0xe0 Workqueue: nfsiod nfs_direct_write_schedule_work [nfs] RIP: 0010:refcount_warn_saturate+0x9c/0xe0 PKRU: 55555554 Call Trace: <TASK> ? __warn+0x9f/0x130 ? refcount_warn_saturate+0x9c/0xe0 ? report_bug+0xcc/0x150 ? handle_bug+0x3d/0x70 ? exc_invalid_op+0x16/0x40 ? asm_exc_invalid_op+0x16/0x20 ? refcount_warn_saturate+0x9c/0xe0 nfs_direct_write_schedule_work+0x237/0x250 [nfs] process_one_work+0x12f/0x4a0 worker_thread+0x14e/0x3b0 ? ZSTD_getCParams_internal+0x220/0x220 kthread+0xdc/0x120 ? __btf_name_valid+0xa0/0xa0 ret_from_fork+0x1f/0x30 This is because we're completing the nfs_direct_request twice in a row. The source of this is when we have our commit requests to submit, we process them and send them off, and then in the completion path for the commit requests we have if (nfs_commit_end(cinfo.mds)) nfs_direct_write_complete(dreq); However since we're submitting asynchronous requests we sometimes have one that completes before we submit the next one, so we end up calling complete on the nfs_direct_request twice. The only other place we use nfs_generic_commit_list() is in __nfs_commit_inode, which wraps this call in a nfs_commit_begin(); nfs_commit_end(); Which is a common pattern for this style of completion handling, one that is also repeated in the direct code with get_dreq()/put_dreq() calls around where we process events as well as in the completion paths. Fix this by using the same pattern for the commit requests. Before with my 200 node rocksdb stress running this warning would pop every 10ish minutes. With my patch the stress test has been running for several hours without popping.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-015410": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: dev-replace: properly validate device names There's a syzbot report that device name buffers passed to device replace are not properly checked for string termination which could lead to a read out of bounds in getname_kernel(). Add a helper that validates both source and target device name buffers. For devid as the source initialize the buffer to empty string in case something tries to read it later. This was originally analyzed and fixed in a different way by Edward Adam Davis (see links).",
        "technologies": "Linux\nLinux Kernel 4.19.309 未満\nLinux Kernel 4.20 以上 5.4.271 未満\nLinux Kernel 5.5 以上 5.10.212 未満\nLinux Kernel 5.11 以上 5.15.151 未満\nLinux Kernel 5.16 以上 6.1.81 未満\nLinux Kernel 6.2 以上 6.6.21 未満\nLinux Kernel 6.7 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-015465": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix potential out-of-bounds access in 'amdgpu_discovery_reg_base_init()' The issue arises when the array 'adev->vcn.vcn_config' is accessed before checking if the index 'adev->vcn.num_vcn_inst' is within the bounds of the array. The fix involves moving the bounds check before the array access. This ensures that 'adev->vcn.num_vcn_inst' is within the bounds of the array before it is used as an index. Fixes the below: drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c:1289 amdgpu_discovery_reg_base_init() error: testing array offset 'adev->vcn.num_vcn_inst' after use.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015459": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix mmhub client id out-of-bounds access Properly handle cid 0x140.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015481": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Check validity of link->type in bpf_link_show_fdinfo() If a newly-added link type doesn't invoke BPF_LINK_TYPE(), accessing bpf_link_type_strs[link->type] may result in an out-of-bounds access. To spot such missed invocations early in the future, checking the validity of link->type in bpf_link_show_fdinfo() and emitting a warning when such invocations are missed.",
        "technologies": "Linux\nLinux Kernel 6.6.62 未満\nLinux Kernel 6.7 以上 6.11.9 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-015456": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: f_ncm: Fix UAF ncm object at re-bind after usb ep transport error When ncm function is working and then stop usb0 interface for link down, eth_stop() is called. At this piont, accidentally if usb transport error should happen in usb_ep_enable(), 'in_ep' and/or 'out_ep' may not be enabled. After that, ncm_disable() is called to disable for ncm unbind but gether_disconnect() is never called since 'in_ep' is not enabled. As the result, ncm object is released in ncm unbind but 'dev->port_usb' associated to 'ncm->port' is not NULL. And when ncm bind again to recover netdev, ncm object is reallocated but usb0 interface is already associated to previous released ncm object. Therefore, once usb0 interface is up and eth_start_xmit() is called, released ncm object is dereferrenced and it might cause use-after-free memory. [function unlink via configfs] usb0: eth_stop dev->port_usb=ffffff9b179c3200 --> error happens in usb_ep_enable(). NCM: ncm_disable: ncm=ffffff9b179c3200 --> no gether_disconnect() since ncm->port.in_ep->enabled is false. NCM: ncm_unbind: ncm unbind ncm=ffffff9b179c3200 NCM: ncm_free: ncm free ncm=ffffff9b179c3200 <-- released ncm [function link via configfs] NCM: ncm_alloc: ncm alloc ncm=ffffff9ac4f8a000 NCM: ncm_bind: ncm bind ncm=ffffff9ac4f8a000 NCM: ncm_set_alt: ncm=ffffff9ac4f8a000 alt=0 usb0: eth_open dev->port_usb=ffffff9b179c3200 <-- previous released ncm usb0: eth_start dev->port_usb=ffffff9b179c3200 <-- eth_start_xmit() --> dev->wrap() Unable to handle kernel paging request at virtual address dead00000000014f This patch addresses the issue by checking if 'ncm->netdev' is not NULL at ncm_disable() to call gether_disconnect() to deassociate 'dev->port_usb'. It's more reasonable to check 'ncm->netdev' to call gether_connect/disconnect rather than check 'ncm->port.in_ep->enabled' since it might not be enabled but the gether connection might be established.",
        "technologies": "Linux\nLinux Kernel 5.15.157 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015478": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/ufence: Prefetch ufence addr to catch bogus address access_ok() only checks for addr overflow so also try to read the addr to catch invalid addr sent from userspace. (cherry picked from commit 9408c4508483ffc60811e910a93d6425b8e63928)",
        "technologies": "Linux\nLinux Kernel 6.11.9 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-015467": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7925e: fix use-after-free in free_irq() From commit a304e1b82808 (\"[PATCH] Debug shared irqs\"), there is a test to make sure the shared irq handler should be able to handle the unexpected event after deregistration. For this case, let's apply MT76_REMOVED flag to indicate the device was removed and do not run into the resource access anymore.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015499": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid use-after-free issue in f2fs_filemap_fault syzbot reports a f2fs bug as below: BUG: KASAN: slab-use-after-free in f2fs_filemap_fault+0xd1/0x2c0 fs/f2fs/file.c:49 Read of size 8 at addr ffff88807bb22680 by task syz-executor184/5058 CPU: 0 PID: 5058 Comm: syz-executor184 Not tainted 6.7.0-syzkaller-09928-g052d534373b7 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:377 [inline] print_report+0x163/0x540 mm/kasan/report.c:488 kasan_report+0x142/0x170 mm/kasan/report.c:601 f2fs_filemap_fault+0xd1/0x2c0 fs/f2fs/file.c:49 __do_fault+0x131/0x450 mm/memory.c:4376 do_shared_fault mm/memory.c:4798 [inline] do_fault mm/memory.c:4872 [inline] do_pte_missing mm/memory.c:3745 [inline] handle_pte_fault mm/memory.c:5144 [inline] __handle_mm_fault+0x23b7/0x72b0 mm/memory.c:5285 handle_mm_fault+0x27e/0x770 mm/memory.c:5450 do_user_addr_fault arch/x86/mm/fault.c:1364 [inline] handle_page_fault arch/x86/mm/fault.c:1507 [inline] exc_page_fault+0x456/0x870 arch/x86/mm/fault.c:1563 asm_exc_page_fault+0x26/0x30 arch/x86/include/asm/idtentry.h:570 The root cause is: in f2fs_filemap_fault(), vmf->vma may be not alive after filemap_fault(), so it may cause use-after-free issue when accessing vmf->vma->vm_flags in trace_f2fs_filemap_fault(). So it needs to keep vm_flags in separated temporary variable for tracepoint use.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015614": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: irqchip/gic-v3-its: Prevent double free on error The error handling path in its_vpe_irq_domain_alloc() causes a double free when its_vpe_init() fails after successfully allocating at least one interrupt. This happens because its_vpe_irq_domain_free() frees the interrupts along with the area bitmap and the vprop_page and its_vpe_irq_domain_alloc() subsequently frees the area bitmap and the vprop_page again. Fix this by unconditionally invoking its_vpe_irq_domain_free() which handles all cases correctly and by removing the bitmap/vprop_page freeing from its_vpe_irq_domain_alloc(). [ tglx: Massaged change log ]",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.14 以上 4.19.313 未満\nLinux Kernel 4.20 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.158 未満\nLinux Kernel 5.16 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-011909": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 2.6.19 以上 5.10.227 未満\nLinux Kernel 5.11 以上 5.15.168 未満\nLinux Kernel 5.16 以上 6.1.113 未満\nLinux Kernel 6.2 以上 6.6.55 未満\nLinux Kernel 6.7 以上 6.10.14 未満\nLinux Kernel 6.11 以上 6.11.3 未満"
    },
    "JVNDB-2024-015616": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: spectrum_acl_tcam: Fix possible use-after-free during activity update The rule activity update delayed work periodically traverses the list of configured rules and queries their activity from the device. As part of this task it accesses the entry pointed by 'ventry->entry', but this entry can be changed concurrently by the rehash delayed work, leading to a use-after-free [1]. Fix by closing the race and perform the activity query under the 'vregion->lock' mutex. [1] BUG: KASAN: slab-use-after-free in mlxsw_sp_acl_tcam_flower_rule_activity_get+0x121/0x140 Read of size 8 at addr ffff8881054ed808 by task kworker/0:18/181 CPU: 0 PID: 181 Comm: kworker/0:18 Not tainted 6.9.0-rc2-custom-00781-gd5ab772d32f7 #2 Hardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019 Workqueue: mlxsw_core mlxsw_sp_acl_rule_activity_update_work Call Trace: <TASK> dump_stack_lvl+0xc6/0x120 print_report+0xce/0x670 kasan_report+0xd7/0x110 mlxsw_sp_acl_tcam_flower_rule_activity_get+0x121/0x140 mlxsw_sp_acl_rule_activity_update_work+0x219/0x400 process_one_work+0x8eb/0x19b0 worker_thread+0x6c9/0xf70 kthread+0x2c9/0x3b0 ret_from_fork+0x4d/0x80 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 1039: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 __kmalloc+0x19c/0x360 mlxsw_sp_acl_tcam_entry_create+0x7b/0x1f0 mlxsw_sp_acl_tcam_vchunk_migrate_all+0x30d/0xb50 mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300 process_one_work+0x8eb/0x19b0 worker_thread+0x6c9/0xf70 kthread+0x2c9/0x3b0 ret_from_fork+0x4d/0x80 ret_from_fork_asm+0x1a/0x30 Freed by task 1039: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 poison_slab_object+0x102/0x170 __kasan_slab_free+0x14/0x30 kfree+0xc1/0x290 mlxsw_sp_acl_tcam_vchunk_migrate_all+0x3d7/0xb50 mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300 process_one_work+0x8eb/0x19b0 worker_thread+0x6c9/0xf70 kthread+0x2c9/0x3b0 ret_from_fork+0x4d/0x80 ret_from_fork_asm+0x1a/0x30",
        "technologies": "Linux\nLinux Kernel 5.1 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.158 未満\nLinux Kernel 5.16 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015619": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: prevent BPF accessing lowat from a subflow socket. Alexei reported the following splat: WARNING: CPU: 32 PID: 3276 at net/mptcp/subflow.c:1430 subflow_data_ready+0x147/0x1c0 Modules linked in: dummy bpf_testmod(O) [last unloaded: bpf_test_no_cfi(O)] CPU: 32 PID: 3276 Comm: test_progs Tainted: GO 6.8.0-12873-g2c43c33bfd23 Call Trace: <TASK> mptcp_set_rcvlowat+0x79/0x1d0 sk_setsockopt+0x6c0/0x1540 __bpf_setsockopt+0x6f/0x90 bpf_sock_ops_setsockopt+0x3c/0x90 bpf_prog_509ce5db2c7f9981_bpf_test_sockopt_int+0xb4/0x11b bpf_prog_dce07e362d941d2b_bpf_test_socket_sockopt+0x12b/0x132 bpf_prog_348c9b5faaf10092_skops_sockopt+0x954/0xe86 __cgroup_bpf_run_filter_sock_ops+0xbc/0x250 tcp_connect+0x879/0x1160 tcp_v6_connect+0x50c/0x870 mptcp_connect+0x129/0x280 __inet_stream_connect+0xce/0x370 inet_stream_connect+0x36/0x50 bpf_trampoline_6442491565+0x49/0xef inet_stream_connect+0x5/0x50 __sys_connect+0x63/0x90 __x64_sys_connect+0x14/0x20 The root cause of the issue is that bpf allows accessing mptcp-level proto_ops from a tcp subflow scope. Fix the issue detecting the problematic call and preventing any action.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015583": {
        "title": "Linux Foundation の software for open networking in the cloud における脆弱性",
        "description": "Software for Open Networking in the Cloud (SONiC) Elevation of Privilege Vulnerability",
        "technologies": "Linux Foundation\nsoftware for open networking in the cloud 202012 以上 20201231.96 未満\nsoftware for open networking in the cloud 201911 以上 20191130.89 未満\nsoftware for open networking in the cloud 201811 以上 20181130.106 未満\nsoftware for open networking in the cloud 202205 以上 20220531.26 未満"
    },
    "JVNDB-2024-015617": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_stats_proc_write() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015621": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Protect against int overflow for stack access size This patch re-introduces protection against the size of access to stack memory being negative; the access size can appear negative as a result of overflowing its signed int representation. This should not actually happen, as there are other protections along the way, but we should protect against it anyway. One code path was missing such protections (fixed in the previous patch in the series), causing out-of-bounds array accesses in check_stack_range_initialized(). This patch causes the verification of a program with such a non-sensical access size to fail. This check used to exist in a more indirect way, but was inadvertendly removed in a833a17aeac7.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.10.209 以上 5.10.215 未満\nLinux Kernel 5.15.148 以上 5.15.154 未満\nLinux Kernel 6.1.75 以上 6.1.85 未満\nLinux Kernel 6.6.14 以上 6.6.26 未満\nLinux Kernel 6.7.2 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015505": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme: host: fix double-free of struct nvme_id_ns in ns_update_nuse() When nvme_identify_ns() fails, it frees the pointer to the struct nvme_id_ns before it returns. However, ns_update_nuse() calls kfree() for the pointer even when nvme_identify_ns() fails. This results in KASAN double-free, which was observed with blktests nvme/045 with proposed patches [1] on the kernel v6.8-rc7. Fix the double-free by skipping kfree() when nvme_identify_ns() fails.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-015648": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ax25: fix use-after-free bugs caused by ax25_ds_del_timer When the ax25 device is detaching, the ax25_dev_device_down() calls ax25_ds_del_timer() to cleanup the slave_timer. When the timer handler is running, the ax25_ds_del_timer() that calls del_timer() in it will return directly. As a result, the use-after-free bugs could happen, one of the scenarios is shown below: (Thread 1) | (Thread 2) | ax25_ds_timeout() ax25_dev_device_down() | ax25_ds_del_timer() | del_timer() | ax25_dev_put() //FREE | | ax25_dev-> //USE In order to mitigate bugs, when the device is detaching, use timer_shutdown_sync() to stop the timer.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015658": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in is_valid_oplock_break() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015695": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: validate user input for expected length I got multiple syzbot reports showing old bugs exposed by BPF after commit 20f2505fb436 (\"bpf: Try to avoid kzalloc in cgroup/{s,g}etsockopt\") setsockopt() @optlen argument should be taken into account before copying data. BUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline] BUG: KASAN: slab-out-of-bounds in do_replace net/ipv4/netfilter/ip_tables.c:1111 [inline] BUG: KASAN: slab-out-of-bounds in do_ipt_set_ctl+0x902/0x3dd0 net/ipv4/netfilter/ip_tables.c:1627 Read of size 96 at addr ffff88802cd73da0 by task syz-executor.4/7238 CPU: 1 PID: 7238 Comm: syz-executor.4 Not tainted 6.9.0-rc2-next-20240403-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189 __asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105 copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] copy_from_sockptr include/linux/sockptr.h:55 [inline] do_replace net/ipv4/netfilter/ip_tables.c:1111 [inline] do_ipt_set_ctl+0x902/0x3dd0 net/ipv4/netfilter/ip_tables.c:1627 nf_setsockopt+0x295/0x2c0 net/netfilter/nf_sockopt.c:101 do_sock_setsockopt+0x3af/0x720 net/socket.c:2311 __sys_setsockopt+0x1ae/0x250 net/socket.c:2334 __do_sys_setsockopt net/socket.c:2343 [inline] __se_sys_setsockopt net/socket.c:2340 [inline] __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340 do_syscall_64+0xfb/0x240 entry_SYSCALL_64_after_hwframe+0x72/0x7a RIP: 0033:0x7fd22067dde9 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fd21f9ff0c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000036 RAX: ffffffffffffffda RBX: 00007fd2207abf80 RCX: 00007fd22067dde9 RDX: 0000000000000040 RSI: 0000000000000000 RDI: 0000000000000003 RBP: 00007fd2206ca47a R08: 0000000000000001 R09: 0000000000000000 R10: 0000000020000880 R11: 0000000000000246 R12: 0000000000000000 R13: 000000000000000b R14: 00007fd2207abf80 R15: 00007ffd2d0170d8 </TASK> Allocated by task 7238: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:370 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:387 kasan_kmalloc include/linux/kasan.h:211 [inline] __do_kmalloc_node mm/slub.c:4069 [inline] __kmalloc_noprof+0x200/0x410 mm/slub.c:4082 kmalloc_noprof include/linux/slab.h:664 [inline] __cgroup_bpf_run_filter_setsockopt+0xd47/0x1050 kernel/bpf/cgroup.c:1869 do_sock_setsockopt+0x6b4/0x720 net/socket.c:2293 __sys_setsockopt+0x1ae/0x250 net/socket.c:2334 __do_sys_setsockopt net/socket.c:2343 [inline] __se_sys_setsockopt net/socket.c:2340 [inline] __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340 do_syscall_64+0xfb/0x240 entry_SYSCALL_64_after_hwframe+0x72/0x7a The buggy address belongs to the object at ffff88802cd73da0 which belongs to the cache kmalloc-8 of size 8 The buggy address is located 0 bytes inside of allocated 1-byte region [ffff88802cd73da0, ffff88802cd73da1) The buggy address belongs to the physical page: page: refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff88802cd73020 pfn:0x2cd73 flags: 0xfff80000000000(node=0|zone=1|lastcpupid=0xfff) page_type: 0xffffefff(slab) raw: 00fff80000000000 ffff888015041280 dead000000000100 dead000000000122 raw: ffff88802cd73020 000000008080007f 00000001ffffefff 00 ---truncated---",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.12 以上 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015662": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: mediatek: vcodec: Fix oops when HEVC init fails The stateless HEVC decoder saves the instance pointer in the context regardless if the initialization worked or not. This caused a use after free, when the pointer is freed in case of a failure in the deinit function. Only store the instance pointer when the initialization was successful, to solve this issue. Hardware name: Acer Tomato (rev3 - 4) board (DT) pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : vcodec_vpu_send_msg+0x4c/0x190 [mtk_vcodec_dec] lr : vcodec_send_ap_ipi+0x78/0x170 [mtk_vcodec_dec] sp : ffff80008750bc20 x29: ffff80008750bc20 x28: ffff1299f6d70000 x27: 0000000000000000 x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000 x23: ffff80008750bc98 x22: 000000000000a003 x21: ffffd45c4cfae000 x20: 0000000000000010 x19: ffff1299fd668310 x18: 000000000000001a x17: 000000040044ffff x16: ffffd45cb15dc648 x15: 0000000000000000 x14: ffff1299c08da1c0 x13: ffffd45cb1f87a10 x12: ffffd45cb2f5fe80 x11: 0000000000000001 x10: 0000000000001b30 x9 : ffffd45c4d12b488 x8 : 1fffe25339380d81 x7 : 0000000000000001 x6 : ffff1299c9c06c00 x5 : 0000000000000132 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000010 x1 : ffff80008750bc98 x0 : 0000000000000000 Call trace: vcodec_vpu_send_msg+0x4c/0x190 [mtk_vcodec_dec] vcodec_send_ap_ipi+0x78/0x170 [mtk_vcodec_dec] vpu_dec_deinit+0x1c/0x30 [mtk_vcodec_dec] vdec_hevc_slice_deinit+0x30/0x98 [mtk_vcodec_dec] vdec_if_deinit+0x38/0x68 [mtk_vcodec_dec] mtk_vcodec_dec_release+0x20/0x40 [mtk_vcodec_dec] fops_vcodec_release+0x64/0x118 [mtk_vcodec_dec] v4l2_release+0x7c/0x100 __fput+0x80/0x2d8 __fput_sync+0x58/0x70 __arm64_sys_close+0x40/0x90 invoke_syscall+0x50/0x128 el0_svc_common.constprop.0+0x48/0xf0 do_el0_svc+0x24/0x38 el0_svc+0x38/0xd8 el0t_64_sync_handler+0xc0/0xc8 el0t_64_sync+0x1a8/0x1b0 Code: d503201f f9401660 b900127f b900227f (f9400400)",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.27 未満\nLinux Kernel 6.7 以上 6.8.6 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015746": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix UAF via mismatching bpf_prog/attachment RCU flavors Uprobes always use bpf_prog_run_array_uprobe() under tasks-trace-RCU protection. But it is possible to attach a non-sleepable BPF program to a uprobe, and non-sleepable BPF programs are freed via normal RCU (see __bpf_prog_put_noref()). This leads to UAF of the bpf_prog because a normal RCU grace period does not imply a tasks-trace-RCU grace period. Fix it by explicitly waiting for a tasks-trace-RCU grace period after removing the attachment of a bpf_prog to a perf_event.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.121 未満\nLinux Kernel 6.2 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015706": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iommu/vt-d: Remove cache tags before disabling ATS The current implementation removes cache tags after disabling ATS, leading to potential memory leaks and kernel crashes. Specifically, CACHE_TAG_DEVTLB type cache tags may still remain in the list even after the domain is freed, causing a use-after-free condition. This issue really shows up when multiple VFs from different PFs passed through to a single user-space process via vfio-pci. In such cases, the kernel may crash with kernel messages like: BUG: kernel NULL pointer dereference, address: 0000000000000014 PGD 19036a067 P4D 1940a3067 PUD 136c9b067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 74 UID: 0 PID: 3183 Comm: testCli Not tainted 6.11.9 #2 RIP: 0010:cache_tag_flush_range+0x9b/0x250 Call Trace: <TASK> ? __die+0x1f/0x60 ? page_fault_oops+0x163/0x590 ? exc_page_fault+0x72/0x190 ? asm_exc_page_fault+0x22/0x30 ? cache_tag_flush_range+0x9b/0x250 ? cache_tag_flush_range+0x5d/0x250 intel_iommu_tlb_sync+0x29/0x40 intel_iommu_unmap_pages+0xfe/0x160 __iommu_unmap+0xd8/0x1a0 vfio_unmap_unpin+0x182/0x340 [vfio_iommu_type1] vfio_remove_dma+0x2a/0xb0 [vfio_iommu_type1] vfio_iommu_type1_ioctl+0xafa/0x18e0 [vfio_iommu_type1] Move cache_tag_unassign_domain() before iommu_disable_pci_caps() to fix it.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015767": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: acpi: nfit: vmalloc-out-of-bounds Read in acpi_nfit_ctl Fix an issue detected by syzbot with KASAN: BUG: KASAN: vmalloc-out-of-bounds in cmd_to_func drivers/acpi/nfit/ core.c:416 [inline] BUG: KASAN: vmalloc-out-of-bounds in acpi_nfit_ctl+0x20e8/0x24a0 drivers/acpi/nfit/core.c:459 The issue occurs in cmd_to_func when the call_pkg->nd_reserved2 array is accessed without verifying that call_pkg points to a buffer that is appropriately sized as a struct nd_cmd_pkg. This can lead to out-of-bounds access and undefined behavior if the buffer does not have sufficient space. To address this, a check was added in acpi_nfit_ctl() to ensure that buf is not NULL and that buf_len is less than sizeof(*call_pkg) before accessing it. This ensures safe access to the members of call_pkg, including the nd_reserved2 array.",
        "technologies": "Linux\nLinux Kernel 4.14.176 以上 4.15 未満\nLinux Kernel 4.19.31 以上 4.20 未満\nLinux Kernel 5.0.4 以上 5.10.232 未満\nLinux Kernel 5.11 以上 5.15.175 未満\nLinux Kernel 5.16 以上 6.1.121 未満\nLinux Kernel 6.2 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015759": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: can: hi311x: hi3110_can_ist(): fix potential use-after-free The commit a22bd630cfff (\"can: hi311x: do not report txerr and rxerr during bus-off\") removed the reporting of rxerr and txerr even in case of correct operation (i. e. not bus-off). The error count information added to the CAN frame after netif_rx() is a potential use after free, since there is no guarantee that the skb is in the same state. It might be freed or reused. Fix the issue by postponing the netif_rx() call in case of txerr and rxerr reporting.",
        "technologies": "Linux\nLinux Kernel 4.14.291 以上 4.15 未満\nLinux Kernel 4.19.256 以上 4.20 未満\nLinux Kernel 5.4.211 以上 5.5 未満\nLinux Kernel 5.10.137 以上 5.11 未満\nLinux Kernel 5.15.61 以上 5.16 未満\nLinux Kernel 5.18.18 以上 5.19 未満\nLinux Kernel 5.19.2 以上 5.20 未満\nLinux Kernel 6.0 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015743": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/reg_sr: Remove register pool That pool implementation doesn't really work: if the krealloc happens to move the memory and return another address, the entries in the xarray become invalid, leading to use-after-free later: BUG: KASAN: slab-use-after-free in xe_reg_sr_apply_mmio+0x570/0x760 [xe] Read of size 4 at addr ffff8881244b2590 by task modprobe/2753 Allocated by task 2753: kasan_save_stack+0x39/0x70 kasan_save_track+0x14/0x40 kasan_save_alloc_info+0x37/0x60 __kasan_kmalloc+0xc3/0xd0 __kmalloc_node_track_caller_noprof+0x200/0x6d0 krealloc_noprof+0x229/0x380 Simplify the code to fix the bug. A better pooling strategy may be added back later if needed. (cherry picked from commit e5283bd4dfecbd3335f43b62a68e24dae23f59e4)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015774": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_stats_proc_show() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-012601": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 4.3 以上 4.19.323 未満\nLinux Kernel 4.20 以上 5.4.285 未満\nLinux Kernel 5.5 以上 5.10.229 未満\nLinux Kernel 5.11 以上 5.15.171 未満\nLinux Kernel 5.16 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.60 未満\nLinux Kernel 6.7 以上 6.11.7 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-015768": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: defer final 'struct net' free in netns dismantle Ilya reported a slab-use-after-free in dst_destroy [1] Issue is in xfrm6_net_init() and xfrm4_net_init() : They copy xfrm[46]_dst_ops_template into net->xfrm.xfrm[46]_dst_ops. But net structure might be freed before all the dst callbacks are called. So when dst_destroy() calls later : if (dst->ops->destroy) dst->ops->destroy(dst); dst->ops points to the old net->xfrm.xfrm[46]_dst_ops, which has been freed. See a relevant issue fixed in : ac888d58869b (\"net: do not delay dst_entries_add() in dst_release()\") A fix is to queue the 'struct net' to be freed after one another cleanup_net() round (and existing rcu_barrier()) [1] BUG: KASAN: slab-use-after-free in dst_destroy (net/core/dst.c:112) Read of size 8 at addr ffff8882137ccab0 by task swapper/37/0 Dec 03 05:46:18 kernel: CPU: 37 UID: 0 PID: 0 Comm: swapper/37 Kdump: loaded Not tainted 6.12.0 #67 Hardware name: Red Hat KVM/RHEL, BIOS 1.16.1-1.el9 04/01/2014 Call Trace: <IRQ> dump_stack_lvl (lib/dump_stack.c:124) print_address_description.constprop.0 (mm/kasan/report.c:378) ? dst_destroy (net/core/dst.c:112) print_report (mm/kasan/report.c:489) ? dst_destroy (net/core/dst.c:112) ? kasan_addr_to_slab (mm/kasan/common.c:37) kasan_report (mm/kasan/report.c:603) ? dst_destroy (net/core/dst.c:112) ? rcu_do_batch (kernel/rcu/tree.c:2567) dst_destroy (net/core/dst.c:112) rcu_do_batch (kernel/rcu/tree.c:2567) ? __pfx_rcu_do_batch (kernel/rcu/tree.c:2491) ? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4339 kernel/locking/lockdep.c:4406) rcu_core (kernel/rcu/tree.c:2825) handle_softirqs (kernel/softirq.c:554) __irq_exit_rcu (kernel/softirq.c:589 kernel/softirq.c:428 kernel/softirq.c:637) irq_exit_rcu (kernel/softirq.c:651) sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1049 arch/x86/kernel/apic/apic.c:1049) </IRQ> <TASK> asm_sysvec_apic_timer_interrupt (./arch/x86/include/asm/idtentry.h:702) RIP: 0010:default_idle (./arch/x86/include/asm/irqflags.h:37 ./arch/x86/include/asm/irqflags.h:92 arch/x86/kernel/process.c:743) Code: 00 4d 29 c8 4c 01 c7 4c 29 c2 e9 6e ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 90 0f 00 2d c7 c9 27 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90 RSP: 0018:ffff888100d2fe00 EFLAGS: 00000246 RAX: 00000000001870ed RBX: 1ffff110201a5fc2 RCX: ffffffffb61a3e46 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffb3d4d123 RBP: 0000000000000000 R08: 0000000000000001 R09: ffffed11c7e1835d R10: ffff888e3f0c1aeb R11: 0000000000000000 R12: 0000000000000000 R13: ffff888100d20000 R14: dffffc0000000000 R15: 0000000000000000 ? ct_kernel_exit.constprop.0 (kernel/context_tracking.c:148) ? cpuidle_idle_call (kernel/sched/idle.c:186) default_idle_call (./include/linux/cpuidle.h:143 kernel/sched/idle.c:118) cpuidle_idle_call (kernel/sched/idle.c:186) ? __pfx_cpuidle_idle_call (kernel/sched/idle.c:168) ? lock_release (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5848) ? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4347 kernel/locking/lockdep.c:4406) ? tsc_verify_tsc_adjust (arch/x86/kernel/tsc_sync.c:59) do_idle (kernel/sched/idle.c:326) cpu_startup_entry (kernel/sched/idle.c:423 (discriminator 1)) start_secondary (arch/x86/kernel/smpboot.c:202 arch/x86/kernel/smpboot.c:282) ? __pfx_start_secondary (arch/x86/kernel/smpboot.c:232) ? soft_restart_cpu (arch/x86/kernel/head_64.S:452) common_startup_64 (arch/x86/kernel/head_64.S:414) </TASK> Dec 03 05:46:18 kernel: Allocated by task 12184: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (./arch/x86/include/asm/current.h:49 mm/kasan/common.c:60 mm/kasan/common.c:69) __kasan_slab_alloc (mm/kasan/common.c:319 mm/kasan/common.c:345) kmem_cache_alloc_noprof (mm/slub.c:4085 mm/slub.c:4134 mm/slub.c:4141) copy_net_ns (net/core/net_namespace.c:421 net/core/net_namespace.c:480) create_new_namespaces ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.12.54 以上 3.13 未満\nLinux Kernel 3.18.27 以上 3.19 未満\nLinux Kernel 4.1.17 以上 4.2 未満\nLinux Kernel 4.3.5 以上 6.1.121 未満\nLinux Kernel 6.2 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015789": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Fix race between element replace and close() Element replace (with a socket different from the one stored) may race with socket's close() link popping & unlinking. __sock_map_delete() unconditionally unrefs the (wrong) element: // set map[0] = s0 map_update_elem(map, 0, s0) // drop fd of s0 close(s0) sock_map_close() lock_sock(sk) (s0!) sock_map_remove_links(sk) link = sk_psock_link_pop() sock_map_unlink(sk, link) sock_map_delete_from_link // replace map[0] with s1 map_update_elem(map, 0, s1) sock_map_update_elem (s1!) lock_sock(sk) sock_map_update_common psock = sk_psock(sk) spin_lock(&stab->lock) osk = stab->sks[idx] sock_map_add_link(..., &stab->sks[idx]) sock_map_unref(osk, &stab->sks[idx]) psock = sk_psock(osk) sk_psock_put(sk, psock) if (refcount_dec_and_test(&psock)) sk_psock_drop(sk, psock) spin_unlock(&stab->lock) unlock_sock(sk) __sock_map_delete spin_lock(&stab->lock) sk = *psk // s1 replaced s0; sk == s1 if (!sk_test || sk_test == sk) // sk_test (s0) != sk (s1); no branch sk = xchg(psk, NULL) if (sk) sock_map_unref(sk, psk) // unref s1; sks[idx] will dangle psock = sk_psock(sk) sk_psock_put(sk, psock) if (refcount_dec_and_test()) sk_psock_drop(sk, psock) spin_unlock(&stab->lock) release_sock(sk) Then close(map) enqueues bpf_map_free_deferred, which finally calls sock_map_free(). This results in some refcount_t warnings along with a KASAN splat [1]. Fix __sock_map_delete(), do not allow sock_map_unref() on elements that may have been replaced. [1]: BUG: KASAN: slab-use-after-free in sock_map_free+0x10e/0x330 Write of size 4 at addr ffff88811f5b9100 by task kworker/u64:12/1063 CPU: 14 UID: 0 PID: 1063 Comm: kworker/u64:12 Not tainted 6.12.0+ #125 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014 Workqueue: events_unbound bpf_map_free_deferred Call Trace: <TASK> dump_stack_lvl+0x68/0x90 print_report+0x174/0x4f6 kasan_report+0xb9/0x190 kasan_check_range+0x10f/0x1e0 sock_map_free+0x10e/0x330 bpf_map_free_deferred+0x173/0x320 process_one_work+0x846/0x1420 worker_thread+0x5b3/0xf80 kthread+0x29e/0x360 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 1202: kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 __kasan_slab_alloc+0x85/0x90 kmem_cache_alloc_noprof+0x131/0x450 sk_prot_alloc+0x5b/0x220 sk_alloc+0x2c/0x870 unix_create1+0x88/0x8a0 unix_create+0xc5/0x180 __sock_create+0x241/0x650 __sys_socketpair+0x1ce/0x420 __x64_sys_socketpair+0x92/0x100 do_syscall_64+0x93/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 46: kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x60 __kasan_slab_free+0x4b/0x70 kmem_cache_free+0x1a1/0x590 __sk_destruct+0x388/0x5a0 sk_psock_destroy+0x73e/0xa50 process_one_work+0x846/0x1420 worker_thread+0x5b3/0xf80 kthread+0x29e/0x360 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x1a/0x30 The bu ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.20 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015775": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock() For the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y and CONFIG_RCU_LAZY=y, the following scenarios will trigger WARN_ON_ONCE() in the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions: CPU2 CPU11 kthread rcu_nocb_cb_kthread ksys_write rcu_do_batch vfs_write rcu_torture_timer_cb proc_sys_write __kmem_cache_free proc_sys_call_handler kmemleak_free drop_caches_sysctl_handler delete_object_full drop_slab __delete_object shrink_slab put_object lazy_rcu_shrink_scan call_rcu rcu_nocb_flush_bypass __call_rcu_commn rcu_nocb_bypass_lock raw_spin_trylock(&rdp->nocb_bypass_lock) fail atomic_inc(&rdp->nocb_lock_contended); rcu_nocb_wait_contended WARN_ON_ONCE(smp_processor_id() != rdp->cpu); WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)) | |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __| Reproduce this bug with \"echo 3 > /proc/sys/vm/drop_caches\". This commit therefore uses rcu_nocb_try_flush_bypass() instead of rcu_nocb_flush_bypass() in lazy_rcu_shrink_scan(). If the nocb_bypass queue is being flushed, then rcu_nocb_try_flush_bypass will return directly.",
        "technologies": "Linux\nLinux Kernel 6.6.27 未満\nLinux Kernel 6.7 以上 6.8.6 未満"
    },
    "JVNDB-2024-015773": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in smb2_is_network_name_deleted() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016056": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xsk: fix OOB map writes when deleting elements Jordy says: \" In the xsk_map_delete_elem function an unsigned integer (map->max_entries) is compared with a user-controlled signed integer (k). Due to implicit type conversion, a large unsigned value for map->max_entries can bypass the intended bounds check: if (k >= map->max_entries) return -EINVAL; This allows k to hold a negative value (between -2147483648 and -2), which is then used as an array index in m->xsk_map[k], which results in an out-of-bounds access. spin_lock_bh(&m->lock); map_entry = &m->xsk_map[k]; // Out-of-bounds map_entry old_xs = unrcu_pointer(xchg(map_entry, NULL)); // Oob write if (old_xs) xsk_map_sock_delete(old_xs, map_entry); spin_unlock_bh(&m->lock); The xchg operation can then be used to cause an out-of-bounds write. Moreover, the invalid map_entry passed to xsk_map_sock_delete can lead to further memory corruption. \" It indeed results in following splat: [76612.897343] BUG: unable to handle page fault for address: ffffc8fc2e461108 [76612.904330] #PF: supervisor write access in kernel mode [76612.909639] #PF: error_code(0x0002) - not-present page [76612.914855] PGD 0 P4D 0 [76612.917431] Oops: Oops: 0002 [#1] PREEMPT SMP [76612.921859] CPU: 11 UID: 0 PID: 10318 Comm: a.out Not tainted 6.12.0-rc1+ #470 [76612.929189] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [76612.939781] RIP: 0010:xsk_map_delete_elem+0x2d/0x60 [76612.944738] Code: 00 00 41 54 55 53 48 63 2e 3b 6f 24 73 38 4c 8d a7 f8 00 00 00 48 89 fb 4c 89 e7 e8 2d bf 05 00 48 8d b4 eb 00 01 00 00 31 ff <48> 87 3e 48 85 ff 74 05 e8 16 ff ff ff 4c 89 e7 e8 3e bc 05 00 31 [76612.963774] RSP: 0018:ffffc9002e407df8 EFLAGS: 00010246 [76612.969079] RAX: 0000000000000000 RBX: ffffc9002e461000 RCX: 0000000000000000 [76612.976323] RDX: 0000000000000001 RSI: ffffc8fc2e461108 RDI: 0000000000000000 [76612.983569] RBP: ffffffff80000001 R08: 0000000000000000 R09: 0000000000000007 [76612.990812] R10: ffffc9002e407e18 R11: ffff888108a38858 R12: ffffc9002e4610f8 [76612.998060] R13: ffff888108a38858 R14: 00007ffd1ae0ac78 R15: ffffc9002e4610c0 [76613.005303] FS: 00007f80b6f59740(0000) GS:ffff8897e0ec0000(0000) knlGS:0000000000000000 [76613.013517] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [76613.019349] CR2: ffffc8fc2e461108 CR3: 000000011e3ef001 CR4: 00000000007726f0 [76613.026595] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [76613.033841] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [76613.041086] PKRU: 55555554 [76613.043842] Call Trace: [76613.046331] <TASK> [76613.048468] ? __die+0x20/0x60 [76613.051581] ? page_fault_oops+0x15a/0x450 [76613.055747] ? search_extable+0x22/0x30 [76613.059649] ? search_bpf_extables+0x5f/0x80 [76613.063988] ? exc_page_fault+0xa9/0x140 [76613.067975] ? asm_exc_page_fault+0x22/0x30 [76613.072229] ? xsk_map_delete_elem+0x2d/0x60 [76613.076573] ? xsk_map_delete_elem+0x23/0x60 [76613.080914] __sys_bpf+0x19b7/0x23c0 [76613.084555] __x64_sys_bpf+0x1a/0x20 [76613.088194] do_syscall_64+0x37/0xb0 [76613.091832] entry_SYSCALL_64_after_hwframe+0x4b/0x53 [76613.096962] RIP: 0033:0x7f80b6d1e88d [76613.100592] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48 [76613.119631] RSP: 002b:00007ffd1ae0ac68 EFLAGS: 00000206 ORIG_RAX: 0000000000000141 [76613.131330] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f80b6d1e88d [76613.142632] RDX: 0000000000000098 RSI: 00007ffd1ae0ad20 RDI: 0000000000000003 [76613.153967] RBP: 00007ffd1ae0adc0 R08: 0000000000000000 R09: 0000000000000000 [76613.166030] R10: 00007f80b6f77040 R11: 0000000000000206 R12: 00007ffd1ae0aed8 [76613.177130] R13: 000055ddf42ce1e9 R14: 000055ddf42d0d98 R15: 00 ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.18 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-015659": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_signal_cifsd_for_reconnect() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
        "technologies": "Linux\nLinux Kernel 6.1.85 未満\nLinux Kernel 6.2 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-015769": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: x_tables: fix LED ID check in led_tg_check() Syzbot has reported the following BUG detected by KASAN: BUG: KASAN: slab-out-of-bounds in strlen+0x58/0x70 Read of size 1 at addr ffff8881022da0c8 by task repro/5879 ... Call Trace: <TASK> dump_stack_lvl+0x241/0x360 ? __pfx_dump_stack_lvl+0x10/0x10 ? __pfx__printk+0x10/0x10 ? _printk+0xd5/0x120 ? __virt_addr_valid+0x183/0x530 ? __virt_addr_valid+0x183/0x530 print_report+0x169/0x550 ? __virt_addr_valid+0x183/0x530 ? __virt_addr_valid+0x183/0x530 ? __virt_addr_valid+0x45f/0x530 ? __phys_addr+0xba/0x170 ? strlen+0x58/0x70 kasan_report+0x143/0x180 ? strlen+0x58/0x70 strlen+0x58/0x70 kstrdup+0x20/0x80 led_tg_check+0x18b/0x3c0 xt_check_target+0x3bb/0xa40 ? __pfx_xt_check_target+0x10/0x10 ? stack_depot_save_flags+0x6e4/0x830 ? nft_target_init+0x174/0xc30 nft_target_init+0x82d/0xc30 ? __pfx_nft_target_init+0x10/0x10 ? nf_tables_newrule+0x1609/0x2980 ? nf_tables_newrule+0x1609/0x2980 ? rcu_is_watching+0x15/0xb0 ? nf_tables_newrule+0x1609/0x2980 ? nf_tables_newrule+0x1609/0x2980 ? __kmalloc_noprof+0x21a/0x400 nf_tables_newrule+0x1860/0x2980 ? __pfx_nf_tables_newrule+0x10/0x10 ? __nla_parse+0x40/0x60 nfnetlink_rcv+0x14e5/0x2ab0 ? __pfx_validate_chain+0x10/0x10 ? __pfx_nfnetlink_rcv+0x10/0x10 ? __lock_acquire+0x1384/0x2050 ? netlink_deliver_tap+0x2e/0x1b0 ? __pfx_lock_release+0x10/0x10 ? netlink_deliver_tap+0x2e/0x1b0 netlink_unicast+0x7f8/0x990 ? __pfx_netlink_unicast+0x10/0x10 ? __virt_addr_valid+0x183/0x530 ? __check_object_size+0x48e/0x900 netlink_sendmsg+0x8e4/0xcb0 ? __pfx_netlink_sendmsg+0x10/0x10 ? aa_sock_msg_perm+0x91/0x160 ? __pfx_netlink_sendmsg+0x10/0x10 __sock_sendmsg+0x223/0x270 ____sys_sendmsg+0x52a/0x7e0 ? __pfx_____sys_sendmsg+0x10/0x10 __sys_sendmsg+0x292/0x380 ? __pfx___sys_sendmsg+0x10/0x10 ? lockdep_hardirqs_on_prepare+0x43d/0x780 ? __pfx_lockdep_hardirqs_on_prepare+0x10/0x10 ? exc_page_fault+0x590/0x8c0 ? do_syscall_64+0xb6/0x230 do_syscall_64+0xf3/0x230 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... </TASK> Since an invalid (without '\\0' byte at all) byte sequence may be passed from userspace, add an extra check to ensure that such a sequence is rejected as possible ID and so never passed to 'kstrdup()' and further.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016371": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: fix double-free on socket dismantle when MPTCP server accepts an incoming connection, it clones its listener socket. However, the pointer to 'inet_opt' for the new socket has the same value as the original one: as a consequence, on program exit it's possible to observe the following splat: BUG: KASAN: double-free in inet_sock_destruct+0x54f/0x8b0 Free of addr ffff888485950880 by task swapper/25/0 CPU: 25 PID: 0 Comm: swapper/25 Kdump: loaded Not tainted 6.8.0-rc1+ #609 Hardware name: Supermicro SYS-6027R-72RF/X9DRH-7TF/7F/iTF/iF, BIOS 3.0 07/26/2013 Call Trace: <IRQ> dump_stack_lvl+0x32/0x50 print_report+0xca/0x620 kasan_report_invalid_free+0x64/0x90 __kasan_slab_free+0x1aa/0x1f0 kfree+0xed/0x2e0 inet_sock_destruct+0x54f/0x8b0 __sk_destruct+0x48/0x5b0 rcu_do_batch+0x34e/0xd90 rcu_core+0x559/0xac0 __do_softirq+0x183/0x5a4 irq_exit_rcu+0x12d/0x170 sysvec_apic_timer_interrupt+0x6b/0x80 </IRQ> <TASK> asm_sysvec_apic_timer_interrupt+0x16/0x20 RIP: 0010:cpuidle_enter_state+0x175/0x300 Code: 30 00 0f 84 1f 01 00 00 83 e8 01 83 f8 ff 75 e5 48 83 c4 18 44 89 e8 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc fb 45 85 ed <0f> 89 60 ff ff ff 48 c1 e5 06 48 c7 43 18 00 00 00 00 48 83 44 2b RSP: 0018:ffff888481cf7d90 EFLAGS: 00000202 RAX: 0000000000000000 RBX: ffff88887facddc8 RCX: 0000000000000000 RDX: 1ffff1110ff588b1 RSI: 0000000000000019 RDI: ffff88887fac4588 RBP: 0000000000000004 R08: 0000000000000002 R09: 0000000000043080 R10: 0009b02ea273363f R11: ffff88887fabf42b R12: ffffffff932592e0 R13: 0000000000000004 R14: 0000000000000000 R15: 00000022c880ec80 cpuidle_enter+0x4a/0xa0 do_idle+0x310/0x410 cpu_startup_entry+0x51/0x60 start_secondary+0x211/0x270 secondary_startup_64_no_verify+0x184/0x18b </TASK> Allocated by task 6853: kasan_save_stack+0x1c/0x40 kasan_save_track+0x10/0x30 __kasan_kmalloc+0xa6/0xb0 __kmalloc+0x1eb/0x450 cipso_v4_sock_setattr+0x96/0x360 netlbl_sock_setattr+0x132/0x1f0 selinux_netlbl_socket_post_create+0x6c/0x110 selinux_socket_post_create+0x37b/0x7f0 security_socket_post_create+0x63/0xb0 __sock_create+0x305/0x450 __sys_socket_create.part.23+0xbd/0x130 __sys_socket+0x37/0xb0 __x64_sys_socket+0x6f/0xb0 do_syscall_64+0x83/0x160 entry_SYSCALL_64_after_hwframe+0x6e/0x76 Freed by task 6858: kasan_save_stack+0x1c/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x12c/0x1f0 kfree+0xed/0x2e0 inet_sock_destruct+0x54f/0x8b0 __sk_destruct+0x48/0x5b0 subflow_ulp_release+0x1f0/0x250 tcp_cleanup_ulp+0x6e/0x110 tcp_v4_destroy_sock+0x5a/0x3a0 inet_csk_destroy_sock+0x135/0x390 tcp_fin+0x416/0x5c0 tcp_data_queue+0x1bc8/0x4310 tcp_rcv_state_process+0x15a3/0x47b0 tcp_v4_do_rcv+0x2c1/0x990 tcp_v4_rcv+0x41fb/0x5ed0 ip_protocol_deliver_rcu+0x6d/0x9f0 ip_local_deliver_finish+0x278/0x360 ip_local_deliver+0x182/0x2c0 ip_rcv+0xb5/0x1c0 __netif_receive_skb_one_core+0x16e/0x1b0 process_backlog+0x1e3/0x650 __napi_poll+0xa6/0x500 net_rx_action+0x740/0xbb0 __do_softirq+0x183/0x5a4 The buggy address belongs to the object at ffff888485950880 which belongs to the cache kmalloc-64 of size 64 The buggy address is located 0 bytes inside of 64-byte region [ffff888485950880, ffff8884859508c0) The buggy address belongs to the physical page: page:0000000056d1e95e refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888485950700 pfn:0x485950 flags: 0x57ffffc0000800(slab|node=1|zone=2|lastcpupid=0x1fffff) page_type: 0xffffffff() raw: 0057ffffc0000800 ffff88810004c640 ffffea00121b8ac0 dead000000000006 raw: ffff888485950700 0000000000200019 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888485950780: fa fb fb ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.212 未満\nLinux Kernel 5.11 以上 5.15.151 未満\nLinux Kernel 5.16 以上 6.1.81 未満\nLinux Kernel 6.2 以上 6.6.21 未満\nLinux Kernel 6.7 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016005": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ublk: detach gendisk from ublk device if add_disk() fails Inside ublk_abort_requests(), gendisk is grabbed for aborting all inflight requests. And ublk_abort_requests() is called when exiting the uring context or handling timeout. If add_disk() fails, the gendisk may have been freed when calling ublk_abort_requests(), so use-after-free can be caused when getting disk's reference in ublk_abort_requests(). Fixes the bug by detaching gendisk from ublk device if add_disk() fails.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.12.8 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016221": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gtp: fix use-after-free and null-ptr-deref in gtp_genl_dump_pdp() The gtp_net_ops pernet operations structure for the subsystem must be registered before registering the generic netlink family. Syzkaller hit 'general protection fault in gtp_genl_dump_pdp' bug: general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017] CPU: 1 PID: 5826 Comm: gtp Not tainted 6.8.0-rc3-std-def-alt1 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-alt1 04/01/2014 RIP: 0010:gtp_genl_dump_pdp+0x1be/0x800 [gtp] Code: c6 89 c6 e8 64 e9 86 df 58 45 85 f6 0f 85 4e 04 00 00 e8 c5 ee 86 df 48 8b 54 24 18 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 de 05 00 00 48 8b 44 24 18 4c 8b 30 4c 39 f0 74 RSP: 0018:ffff888014107220 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000000002 RSI: 0000000000000000 RDI: 0000000000000000 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000 R13: ffff88800fcda588 R14: 0000000000000001 R15: 0000000000000000 FS: 00007f1be4eb05c0(0000) GS:ffff88806ce80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f1be4e766cf CR3: 000000000c33e000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> ? show_regs+0x90/0xa0 ? die_addr+0x50/0xd0 ? exc_general_protection+0x148/0x220 ? asm_exc_general_protection+0x22/0x30 ? gtp_genl_dump_pdp+0x1be/0x800 [gtp] ? __alloc_skb+0x1dd/0x350 ? __pfx___alloc_skb+0x10/0x10 genl_dumpit+0x11d/0x230 netlink_dump+0x5b9/0xce0 ? lockdep_hardirqs_on_prepare+0x253/0x430 ? __pfx_netlink_dump+0x10/0x10 ? kasan_save_track+0x10/0x40 ? __kasan_kmalloc+0x9b/0xa0 ? genl_start+0x675/0x970 __netlink_dump_start+0x6fc/0x9f0 genl_family_rcv_msg_dumpit+0x1bb/0x2d0 ? __pfx_genl_family_rcv_msg_dumpit+0x10/0x10 ? genl_op_from_small+0x2a/0x440 ? cap_capable+0x1d0/0x240 ? __pfx_genl_start+0x10/0x10 ? __pfx_genl_dumpit+0x10/0x10 ? __pfx_genl_done+0x10/0x10 ? security_capable+0x9d/0xe0",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.7 以上 4.19.308 未満\nLinux Kernel 4.20 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.211 未満\nLinux Kernel 5.11 以上 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016150": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: sg: Fix slab-use-after-free read in sg_release() Fix a use-after-free bug in sg_release(), detected by syzbot with KASAN: BUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30 kernel/locking/lockdep.c:5838 __mutex_unlock_slowpath+0xe2/0x750 kernel/locking/mutex.c:912 sg_release+0x1f4/0x2e0 drivers/scsi/sg.c:407 In sg_release(), the function kref_put(&sfp->f_ref, sg_remove_sfp) is called before releasing the open_rel_lock mutex. The kref_put() call may decrement the reference count of sfp to zero, triggering its cleanup through sg_remove_sfp(). This cleanup includes scheduling deferred work via sg_remove_sfp_usercontext(), which ultimately frees sfp. After kref_put(), sg_release() continues to unlock open_rel_lock and may reference sfp or sdp. If sfp has already been freed, this results in a slab-use-after-free error. Move the kref_put(&sfp->f_ref, sg_remove_sfp) call after unlocking the open_rel_lock mutex. This ensures: - No references to sfp or sdp occur after the reference count is decremented. - Cleanup functions such as sg_remove_sfp() and sg_remove_sfp_usercontext() can safely execute without impacting the mutex handling in sg_release(). The fix has been tested and validated by syzbot. This patch closes the bug reported at the following syzkaller link and ensures proper sequencing of resource cleanup and mutex operations, eliminating the risk of use-after-free errors in sg_release().",
        "technologies": "Linux\nLinux Kernel 3.16.85 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016031": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hv_sock: Initializing vsk->trans to NULL to prevent a dangling pointer When hvs is released, there is a possibility that vsk->trans may not be initialized to NULL, which could lead to a dangling pointer. This issue is resolved by initializing vsk->trans to NULL.",
        "technologies": "Linux\nLinux Kernel 4.19.324 未満\nLinux Kernel 4.20 以上 5.4.286 未満\nLinux Kernel 5.5 以上 5.10.230 未満\nLinux Kernel 5.11 以上 5.15.172 未満\nLinux Kernel 5.16 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-016567": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kunit: string-stream: Fix a UAF bug in kunit_init_suite() In kunit_debugfs_create_suite(), if alloc_string_stream() fails in the kunit_suite_for_each_test_case() loop, the \"suite->log = stream\" has assigned before, and the error path only free the suite->log's stream memory but not set it to NULL, so the later string_stream_clear() of suite->log in kunit_init_suite() will cause below UAF bug. Set stream pointer to NULL after free to fix it. Unable to handle kernel paging request at virtual address 006440150000030d Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [006440150000030d] address between user and kernel address ranges Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP Dumping ftrace buffer: (ftrace buffer empty) Modules linked in: iio_test_gts industrialio_gts_helper cfg80211 rfkill ipv6 [last unloaded: iio_test_gts] CPU: 5 UID: 0 PID: 6253 Comm: modprobe Tainted: G B W N 6.12.0-rc4+ #458 Tainted: [B]=BAD_PAGE, [W]=WARN, [N]=TEST Hardware name: linux,dummy-virt (DT) pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : string_stream_clear+0x54/0x1ac lr : string_stream_clear+0x1a8/0x1ac sp : ffffffc080b47410 x29: ffffffc080b47410 x28: 006440550000030d x27: ffffff80c96b5e98 x26: ffffff80c96b5e80 x25: ffffffe461b3f6c0 x24: 0000000000000003 x23: ffffff80c96b5e88 x22: 1ffffff019cdf4fc x21: dfffffc000000000 x20: ffffff80ce6fa7e0 x19: 032202a80000186d x18: 0000000000001840 x17: 0000000000000000 x16: 0000000000000000 x15: ffffffe45c355cb4 x14: ffffffe45c35589c x13: ffffffe45c03da78 x12: ffffffb810168e75 x11: 1ffffff810168e74 x10: ffffffb810168e74 x9 : dfffffc000000000 x8 : 0000000000000004 x7 : 0000000000000003 x6 : 0000000000000001 x5 : ffffffc080b473a0 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000001 x1 : ffffffe462fbf620 x0 : dfffffc000000000 Call trace: string_stream_clear+0x54/0x1ac __kunit_test_suites_init+0x108/0x1d8 kunit_exec_run_tests+0xb8/0x100 kunit_module_notify+0x400/0x55c notifier_call_chain+0xfc/0x3b4 blocking_notifier_call_chain+0x68/0x9c do_init_module+0x24c/0x5c8 load_module+0x4acc/0x4e90 init_module_from_file+0xd4/0x128 idempotent_init_module+0x2d4/0x57c __arm64_sys_finit_module+0xac/0x100 invoke_syscall+0x6c/0x258 el0_svc_common.constprop.0+0x160/0x22c do_el0_svc+0x44/0x5c el0_svc+0x48/0xb8 el0t_64_sync_handler+0x13c/0x158 el0t_64_sync+0x190/0x194 Code: f9400753 d2dff800 f2fbffe0 d343fe7c (38e06b80) ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops: Fatal exception",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.12.4 未満"
    },
    "JVNDB-2024-016566": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix handling of plane refcount [Why] The mechanism to backup and restore plane states doesn't maintain refcount, which can cause issues if the refcount of the plane changes in between backup and restore operations, such as memory leaks if the refcount was supposed to go down, or double frees / invalid memory accesses if the refcount was supposed to go up. [How] Cache and re-apply current refcount when restoring plane states.",
        "technologies": "Linux\nLinux Kernel 6.12.4 未満"
    },
    "JVNDB-2024-016593": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pinctrl: core: delete incorrect free in pinctrl_enable() The \"pctldev\" struct is allocated in devm_pinctrl_register_and_init(). It's a devm_ managed pointer that is freed by devm_pinctrl_dev_release(), so freeing it in pinctrl_enable() will lead to a double free. The devm_pinctrl_dev_release() function frees the pindescs and destroys the mutex as well.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.11 以上 4.19.314 未満\nLinux Kernel 4.20 以上 5.4.276 未満\nLinux Kernel 5.5 以上 5.10.217 未満\nLinux Kernel 5.11 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016009": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: resolve faulty mmap_region() error path behaviour The mmap_region() function is somewhat terrifying, with spaghetti-like control flow and numerous means by which issues can arise and incomplete state, memory leaks and other unpleasantness can occur. A large amount of the complexity arises from trying to handle errors late in the process of mapping a VMA, which forms the basis of recently observed issues with resource leaks and observable inconsistent state. Taking advantage of previous patches in this series we move a number of checks earlier in the code, simplifying things by moving the core of the logic into a static internal function __mmap_region(). Doing this allows us to perform a number of checks up front before we do any real work, and allows us to unwind the writable unmap check unconditionally as required and to perform a CONFIG_DEBUG_VM_MAPLE_TREE validation unconditionally also. We move a number of things here: 1. We preallocate memory for the iterator before we call the file-backed memory hook, allowing us to exit early and avoid having to perform complicated and error-prone close/free logic. We carefully free iterator state on both success and error paths. 2. The enclosing mmap_region() function handles the mapping_map_writable() logic early. Previously the logic had the mapping_map_writable() at the point of mapping a newly allocated file-backed VMA, and a matching mapping_unmap_writable() on success and error paths. We now do this unconditionally if this is a file-backed, shared writable mapping. If a driver changes the flags to eliminate VM_MAYWRITE, however doing so does not invalidate the seal check we just performed, and we in any case always decrement the counter in the wrapper. We perform a debug assert to ensure a driver does not attempt to do the opposite. 3. We also move arch_validate_flags() up into the mmap_region() function. This is only relevant on arm64 and sparc64, and the check is only meaningful for SPARC with ADI enabled. We explicitly add a warning for this arch if a driver invalidates this check, though the code ought eventually to be fixed to eliminate the need for this. With all of these measures in place, we no longer need to explicitly close the VMA on error paths, as we place all checks which might fail prior to a call to any driver mmap hook. This eliminates an entire class of errors, makes the code easier to reason about and more robust.",
        "technologies": "Linux\nLinux Kernel 5.10.150 以上 5.10.231 未満\nLinux Kernel 5.15.75 以上 5.15.174 未満\nLinux Kernel 6.0.3 以上 6.1.119 未満\nLinux Kernel 6.2 以上 6.6.63 未満\nLinux Kernel 6.7 以上 6.12 未満\nLinux Kernel 5.19.17\nLinux Kernel 6.12"
    },
    "JVNDB-2024-016568": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/CPU/AMD: Terminate the erratum_1386_microcode array The erratum_1386_microcode array requires an empty entry at the end. Otherwise x86_match_cpu_with_stepping() will continue iterate the array after it ended. Add an empty entry to erratum_1386_microcode to its end.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016624": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: 9p/xen: fix release of IRQ Kernel logs indicate an IRQ was double-freed. Pass correct device ID during IRQ release. [Dominique: remove confusing variable reset to 0]",
        "technologies": "Linux\nLinux Kernel 4.12 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-015791": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: nl80211: fix NL80211_ATTR_MLO_LINK_ID off-by-one Since the netlink attribute range validation provides inclusive checking, the *max* of attribute NL80211_ATTR_MLO_LINK_ID should be IEEE80211_MLD_MAX_NUM_LINKS - 1 otherwise causing an off-by-one. One crash stack for demonstration: ================================================================== BUG: KASAN: wild-memory-access in ieee80211_tx_control_port+0x3b6/0xca0 net/mac80211/tx.c:5939 Read of size 6 at addr 001102080000000c by task fuzzer.386/9508 CPU: 1 PID: 9508 Comm: syz.1.386 Not tainted 6.1.70 #2 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x177/0x231 lib/dump_stack.c:106 print_report+0xe0/0x750 mm/kasan/report.c:398 kasan_report+0x139/0x170 mm/kasan/report.c:495 kasan_check_range+0x287/0x290 mm/kasan/generic.c:189 memcpy+0x25/0x60 mm/kasan/shadow.c:65 ieee80211_tx_control_port+0x3b6/0xca0 net/mac80211/tx.c:5939 rdev_tx_control_port net/wireless/rdev-ops.h:761 [inline] nl80211_tx_control_port+0x7b3/0xc40 net/wireless/nl80211.c:15453 genl_family_rcv_msg_doit+0x22e/0x320 net/netlink/genetlink.c:756 genl_family_rcv_msg net/netlink/genetlink.c:833 [inline] genl_rcv_msg+0x539/0x740 net/netlink/genetlink.c:850 netlink_rcv_skb+0x1de/0x420 net/netlink/af_netlink.c:2508 genl_rcv+0x24/0x40 net/netlink/genetlink.c:861 netlink_unicast_kernel net/netlink/af_netlink.c:1326 [inline] netlink_unicast+0x74b/0x8c0 net/netlink/af_netlink.c:1352 netlink_sendmsg+0x882/0xb90 net/netlink/af_netlink.c:1874 sock_sendmsg_nosec net/socket.c:716 [inline] __sock_sendmsg net/socket.c:728 [inline] ____sys_sendmsg+0x5cc/0x8f0 net/socket.c:2499 ___sys_sendmsg+0x21c/0x290 net/socket.c:2553 __sys_sendmsg net/socket.c:2582 [inline] __do_sys_sendmsg net/socket.c:2591 [inline] __se_sys_sendmsg+0x19e/0x270 net/socket.c:2589 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x45/0x90 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x63/0xcd Update the policy to ensure correct validation.",
        "technologies": "Linux\nLinux Kernel 5.19.2 以上 5.20 未満\nLinux Kernel 6.0 以上 6.1.121 未満\nLinux Kernel 6.2 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016632": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: ensure the copied buf is NUL terminated Currently, we allocate a count-sized kernel buffer and copy count bytes from userspace to that buffer. Later, we use sscanf on this buffer but we don't ensure that the string is terminated inside the buffer, this can lead to OOB read when using sscanf. Fix this issue by using memdup_user_nul instead of memdup_user.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016675": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: gtp: Fix Use-After-Free in gtp_dellink Since call_rcu, which is called in the hlist_for_each_entry_rcu traversal of gtp_dellink, is not part of the RCU read critical section, it is possible that the RCU grace period will pass during the traversal and the key will be free. To prevent this, it should be changed to hlist_for_each_entry_safe.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.14.162 以上 4.15 未満\nLinux Kernel 4.19.93 以上 4.19.313 未満\nLinux Kernel 5.4.8 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.158 未満\nLinux Kernel 5.16 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016660": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: usb: lan78xx: Fix double free issue with interrupt buffer allocation In lan78xx_probe(), the buffer `buf` was being freed twice: once implicitly through `usb_free_urb(dev->urb_intr)` with the `URB_FREE_BUFFER` flag and again explicitly by `kfree(buf)`. This caused a double free issue. To resolve this, reordered `kmalloc()` and `usb_alloc_urb()` calls to simplify the initialization sequence and removed the redundant `kfree(buf)`. Now, `buf` is allocated after `usb_alloc_urb()`, ensuring it is correctly managed by `usb_fill_int_urb()` and freed by `usb_free_urb()` as intended.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016673": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc() bt_sock_alloc() attaches allocated sk object to the provided sock object. If rfcomm_dlc_alloc() fails, we release the sk object, but leave the dangling pointer in the sock object, which may cause use-after-free. Fix this by swapping calls to bt_sock_alloc() and rfcomm_dlc_alloc().",
        "technologies": "Linux\nLinux Kernel 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016655": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: misc: microchip: pci1xxxx: fix double free in the error handling of gp_aux_bus_probe() When auxiliary_device_add() returns error and then calls auxiliary_device_uninit(), callback function gp_auxiliary_device_release() calls ida_free() and kfree(aux_device_wrapper) to free memory. We should't call them again in the error handling path. Fix this by skipping the redundant cleanup functions.",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-016674": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ubifs: authentication: Fix use-after-free in ubifs_tnc_end_commit After an insertion in TNC, the tree might split and cause a node to change its `znode->parent`. A further deletion of other nodes in the tree (which also could free the nodes), the aforementioned node's `znode->cparent` could still point to a freed node. This `znode->cparent` may not be updated when getting nodes to commit in `ubifs_tnc_start_commit()`. This could then trigger a use-after-free when accessing the `znode->cparent` in `write_index()` in `ubifs_tnc_end_commit()`. This can be triggered by running rm -f /etc/test-file.bin dd if=/dev/urandom of=/etc/test-file.bin bs=1M count=60 conv=fsync in a loop, and with `CONFIG_UBIFS_FS_AUTHENTICATION`. KASAN then reports: BUG: KASAN: use-after-free in ubifs_tnc_end_commit+0xa5c/0x1950 Write of size 32 at addr ffffff800a3af86c by task ubifs_bgt0_20/153 Call trace: dump_backtrace+0x0/0x340 show_stack+0x18/0x24 dump_stack_lvl+0x9c/0xbc print_address_description.constprop.0+0x74/0x2b0 kasan_report+0x1d8/0x1f0 kasan_check_range+0xf8/0x1a0 memcpy+0x84/0xf4 ubifs_tnc_end_commit+0xa5c/0x1950 do_commit+0x4e0/0x1340 ubifs_bg_thread+0x234/0x2e0 kthread+0x36c/0x410 ret_from_fork+0x10/0x20 Allocated by task 401: kasan_save_stack+0x38/0x70 __kasan_kmalloc+0x8c/0xd0 __kmalloc+0x34c/0x5bc tnc_insert+0x140/0x16a4 ubifs_tnc_add+0x370/0x52c ubifs_jnl_write_data+0x5d8/0x870 do_writepage+0x36c/0x510 ubifs_writepage+0x190/0x4dc __writepage+0x58/0x154 write_cache_pages+0x394/0x830 do_writepages+0x1f0/0x5b0 filemap_fdatawrite_wbc+0x170/0x25c file_write_and_wait_range+0x140/0x190 ubifs_fsync+0xe8/0x290 vfs_fsync_range+0xc0/0x1e4 do_fsync+0x40/0x90 __arm64_sys_fsync+0x34/0x50 invoke_syscall.constprop.0+0xa8/0x260 do_el0_svc+0xc8/0x1f0 el0_svc+0x34/0x70 el0t_64_sync_handler+0x108/0x114 el0t_64_sync+0x1a4/0x1a8 Freed by task 403: kasan_save_stack+0x38/0x70 kasan_set_track+0x28/0x40 kasan_set_free_info+0x28/0x4c __kasan_slab_free+0xd4/0x13c kfree+0xc4/0x3a0 tnc_delete+0x3f4/0xe40 ubifs_tnc_remove_range+0x368/0x73c ubifs_tnc_remove_ino+0x29c/0x2e0 ubifs_jnl_delete_inode+0x150/0x260 ubifs_evict_inode+0x1d4/0x2e4 evict+0x1c8/0x450 iput+0x2a0/0x3c4 do_unlinkat+0x2cc/0x490 __arm64_sys_unlinkat+0x90/0x100 invoke_syscall.constprop.0+0xa8/0x260 do_el0_svc+0xc8/0x1f0 el0_svc+0x34/0x70 el0t_64_sync_handler+0x108/0x114 el0t_64_sync+0x1a4/0x1a8 The offending `memcpy()` in `ubifs_copy_hash()` has a use-after-free when a node becomes root in TNC but still has a `cparent` to an already freed node. More specifically, consider the following TNC: zroot / / zp1 / / zn Inserting a new node `zn_new` with a key smaller then `zn` will trigger a split in `tnc_insert()` if `zp1` is full: zroot / \\ / \\ zp1 zp2 / \\ / \\ zn_new zn `zn->parent` has now been moved to `zp2`, *but* `zn->cparent` still points to `zp1`. Now, consider a removal of all the nodes _except_ `zn`. Just when `tnc_delete()` is about to delete `zroot` and `zp2`: zroot \\ \\ zp2 \\ \\ zn `zroot` and `zp2` get freed and the tree collapses: zn `zn` now becomes the new `zroot`. `get_znodes_to_commit()` will now only find `zn`, the new `zroot`, and `write_index()` will check its `znode->cparent` that wrongly points to the already freed `zp1`. `ubifs_copy_hash()` thus gets wrongly called with `znode->cparent->zbranch[znode->iip].hash` that triggers the use-after-free! Fix this by explicitly setting `znode->cparent` to `NULL` in `get_znodes_to_commit()` for the root node. The search for the dirty nodes ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016676": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix double-free of blocks due to wrong extents moved_len In ext4_move_extents(), moved_len is only updated when all moves are successfully executed, and only discards orig_inode and donor_inode preallocations when moved_len is not zero. When the loop fails to exit after successfully moving some extents, moved_len is not updated and remains at 0, so it does not discard the preallocations. If the moved extents overlap with the preallocated extents, the overlapped extents are freed twice in ext4_mb_release_inode_pa() and ext4_process_freed_data() (as described in commit 94d7c16cbbbd (\"ext4: Fix double-free of blocks with EXT4_IOC_MOVE_EXT\")), and bb_free is incremented twice. Hence when trim is executed, a zero-division bug is triggered in mb_update_avg_fragment_size() because bb_free is not zero and bb_fragments is zero. Therefore, update move_len after each extent move to avoid the issue.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.18 以上 4.19.307 未満\nLinux Kernel 4.20 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.79 未満\nLinux Kernel 6.2 以上 6.6.18 未満\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016752": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gpiolib: cdev: Fix use after free in lineinfo_changed_notify The use-after-free issue occurs as follows: when the GPIO chip device file is being closed by invoking gpio_chrdev_release(), watched_lines is freed by bitmap_free(), but the unregistration of lineinfo_changed_nb notifier chain failed due to waiting write rwsem. Additionally, one of the GPIO chip's lines is also in the release process and holds the notifier chain's read rwsem. Consequently, a race condition leads to the use-after-free of watched_lines. Here is the typical stack when issue happened: [free] gpio_chrdev_release() --> bitmap_free(cdev->watched_lines) <-- freed --> blocking_notifier_chain_unregister() --> down_write(&nh->rwsem) <-- waiting rwsem --> __down_write_common() --> rwsem_down_write_slowpath() --> schedule_preempt_disabled() --> schedule() [use] st54spi_gpio_dev_release() --> gpio_free() --> gpiod_free() --> gpiod_free_commit() --> gpiod_line_state_notify() --> blocking_notifier_call_chain() --> down_read(&nh->rwsem); <-- held rwsem --> notifier_call_chain() --> lineinfo_changed_notify() --> test_bit(xxxx, cdev->watched_lines) <-- use after free The side effect of the use-after-free issue is that a GPIO line event is being generated for userspace where it shouldn't. However, since the chrdev is being closed, userspace won't have the chance to read that event anyway. To fix the issue, call the bitmap_free() function after the unregistration of lineinfo_changed_nb notifier chain.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016715": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create() bt_sock_alloc() allocates the sk object and attaches it to the provided sock object. On error l2cap_sock_alloc() frees the sk object, but the dangling pointer is still attached to the sock object, which may create use-after-free in other code.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016755": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm: zynqmp_kms: Unplug DRM device before removal Prevent userspace accesses to the DRM device from causing use-after-frees by unplugging the device before we remove it. This causes any further userspace accesses to result in an error without further calls into this driver's internals.",
        "technologies": "Linux\nLinux Kernel 5.9 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016753": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: binder: fix node UAF in binder_add_freeze_work() In binder_add_freeze_work() we iterate over the proc->nodes with the proc->inner_lock held. However, this lock is temporarily dropped in order to acquire the node->lock first (lock nesting order). This can race with binder_node_release() and trigger a use-after-free: ================================================================== BUG: KASAN: slab-use-after-free in _raw_spin_lock+0xe4/0x19c Write of size 4 at addr ffff53c04c29dd04 by task freeze/640 CPU: 5 UID: 0 PID: 640 Comm: freeze Not tainted 6.11.0-07343-ga727812a8d45 #17 Hardware name: linux,dummy-virt (DT) Call trace: _raw_spin_lock+0xe4/0x19c binder_add_freeze_work+0x148/0x478 binder_ioctl+0x1e70/0x25ac __arm64_sys_ioctl+0x124/0x190 Allocated by task 637: __kmalloc_cache_noprof+0x12c/0x27c binder_new_node+0x50/0x700 binder_transaction+0x35ac/0x6f74 binder_thread_write+0xfb8/0x42a0 binder_ioctl+0x18f0/0x25ac __arm64_sys_ioctl+0x124/0x190 Freed by task 637: kfree+0xf0/0x330 binder_thread_read+0x1e88/0x3a68 binder_ioctl+0x16d8/0x25ac __arm64_sys_ioctl+0x124/0x190 ================================================================== Fix the race by taking a temporary reference on the node before releasing the proc->inner lock. This ensures the node remains alive while in use.",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.4 未満"
    },
    "JVNDB-2024-016714": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: cdns3: fixed memory use after free at cdns3_gadget_ep_disable() ... cdns3_gadget_ep_free_request(&priv_ep->endpoint, &priv_req->request); list_del_init(&priv_req->list); ... 'priv_req' actually free at cdns3_gadget_ep_free_request(). But list_del_init() use priv_req->list after it. [ 1542.642868][ T534] BUG: KFENCE: use-after-free read in __list_del_entry_valid+0x10/0xd4 [ 1542.642868][ T534] [ 1542.653162][ T534] Use-after-free read at 0x000000009ed0ba99 (in kfence-#3): [ 1542.660311][ T534] __list_del_entry_valid+0x10/0xd4 [ 1542.665375][ T534] cdns3_gadget_ep_disable+0x1f8/0x388 [cdns3] [ 1542.671571][ T534] usb_ep_disable+0x44/0xe4 [ 1542.675948][ T534] ffs_func_eps_disable+0x64/0xc8 [ 1542.680839][ T534] ffs_func_set_alt+0x74/0x368 [ 1542.685478][ T534] ffs_func_disable+0x18/0x28 Move list_del_init() before cdns3_gadget_ep_free_request() to resolve this problem.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.211 未満\nLinux Kernel 5.11 以上 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016677": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: ieee802154: do not leave a dangling sk pointer in ieee802154_create() sock_init_data() attaches the allocated sk object to the provided sock object. If ieee802154_create() fails later, the allocated sk object is freed, but the dangling pointer remains in the provided sock object, which may allow use-after-free. Clear the sk pointer in the sock object on error.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016757": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: af_can: do not leave a dangling sk pointer in can_create() On error can_create() frees the allocated sk object, but sock_init_data() has already attached it to the provided sock object. This will leave a dangling sk pointer in the sock object and may cause use-after-free later.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016772": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFSv4.0: Fix a use-after-free problem in the asynchronous open() Yang Erkun reports that when two threads are opening files at the same time, and are forced to abort before a reply is seen, then the call to nfs_release_seqid() in nfs4_opendata_free() can result in a use-after-free of the pointer to the defunct rpc task of the other thread. The fix is to ensure that if the RPC call is aborted before the call to nfs_wait_on_sequence() is complete, then we must call nfs_release_seqid() in nfs4_open_release() before the rpc_task is freed.",
        "technologies": "Linux\nLinux Kernel 2.6.16 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016678": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp: Fix use-after-free of nreq in reqsk_timer_handler(). The cited commit replaced inet_csk_reqsk_queue_drop_and_put() with __inet_csk_reqsk_queue_drop() and reqsk_put() in reqsk_timer_handler(). Then, oreq should be passed to reqsk_put() instead of req; otherwise use-after-free of nreq could happen when reqsk is migrated but the retry attempt failed (e.g. due to timeout). Let's pass oreq to reqsk_put().",
        "technologies": "Linux\nLinux Kernel 5.15.170 以上 5.15.174 未満\nLinux Kernel 6.1.115 以上 6.1.120 未満\nLinux Kernel 6.6.59 以上 6.6.64 未満\nLinux Kernel 6.11.6 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016768": {
        "title": "Linux の Linux Kernel における有効期限後のメモリの解放の欠如に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: devlink: fix possible use-after-free and memory leaks in devlink_init() The pernet operations structure for the subsystem must be registered before registering the generic netlink family. Make an unregister in case of unsuccessful registration.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016797": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: ref-verify: fix use-after-free after invalid ref action At btrfs_ref_tree_mod() after we successfully inserted the new ref entry (local variable 'ref') into the respective block entry's rbtree (local variable 'be'), if we find an unexpected action of BTRFS_DROP_DELAYED_REF, we error out and free the ref entry without removing it from the block entry's rbtree. Then in the error path of btrfs_ref_tree_mod() we call btrfs_free_ref_cache(), which iterates over all block entries and then calls free_block_entry() for each one, and there we will trigger a use-after-free when we are called against the block entry to which we added the freed ref entry to its rbtree, since the rbtree still points to the block entry, as we didn't remove it from the rbtree before freeing it in the error path at btrfs_ref_tree_mod(). Fix this by removing the new ref entry from the rbtree before freeing it. Syzbot report this with the following stack traces: BTRFS error (device loop0 state EA): Ref action 2, root 5, ref_root 0, parent 8564736, owner 0, offset 0, num_refs 18446744073709551615 __btrfs_mod_ref+0x7dd/0xac0 fs/btrfs/extent-tree.c:2523 update_ref_for_cow+0x9cd/0x11f0 fs/btrfs/ctree.c:512 btrfs_force_cow_block+0x9f6/0x1da0 fs/btrfs/ctree.c:594 btrfs_cow_block+0x35e/0xa40 fs/btrfs/ctree.c:754 btrfs_search_slot+0xbdd/0x30d0 fs/btrfs/ctree.c:2116 btrfs_insert_empty_items+0x9c/0x1a0 fs/btrfs/ctree.c:4314 btrfs_insert_empty_item fs/btrfs/ctree.h:669 [inline] btrfs_insert_orphan_item+0x1f1/0x320 fs/btrfs/orphan.c:23 btrfs_orphan_add+0x6d/0x1a0 fs/btrfs/inode.c:3482 btrfs_unlink+0x267/0x350 fs/btrfs/inode.c:4293 vfs_unlink+0x365/0x650 fs/namei.c:4469 do_unlinkat+0x4ae/0x830 fs/namei.c:4533 __do_sys_unlinkat fs/namei.c:4576 [inline] __se_sys_unlinkat fs/namei.c:4569 [inline] __x64_sys_unlinkat+0xcc/0xf0 fs/namei.c:4569 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f BTRFS error (device loop0 state EA): Ref action 1, root 5, ref_root 5, parent 0, owner 260, offset 0, num_refs 1 __btrfs_mod_ref+0x76b/0xac0 fs/btrfs/extent-tree.c:2521 update_ref_for_cow+0x96a/0x11f0 btrfs_force_cow_block+0x9f6/0x1da0 fs/btrfs/ctree.c:594 btrfs_cow_block+0x35e/0xa40 fs/btrfs/ctree.c:754 btrfs_search_slot+0xbdd/0x30d0 fs/btrfs/ctree.c:2116 btrfs_lookup_inode+0xdc/0x480 fs/btrfs/inode-item.c:411 __btrfs_update_delayed_inode+0x1e7/0xb90 fs/btrfs/delayed-inode.c:1030 btrfs_update_delayed_inode fs/btrfs/delayed-inode.c:1114 [inline] __btrfs_commit_inode_delayed_items+0x2318/0x24a0 fs/btrfs/delayed-inode.c:1137 __btrfs_run_delayed_items+0x213/0x490 fs/btrfs/delayed-inode.c:1171 btrfs_commit_transaction+0x8a8/0x3740 fs/btrfs/transaction.c:2313 prepare_to_relocate+0x3c4/0x4c0 fs/btrfs/relocation.c:3586 relocate_block_group+0x16c/0xd40 fs/btrfs/relocation.c:3611 btrfs_relocate_block_group+0x77d/0xd90 fs/btrfs/relocation.c:4081 btrfs_relocate_chunk+0x12c/0x3b0 fs/btrfs/volumes.c:3377 __btrfs_balance+0x1b0f/0x26b0 fs/btrfs/volumes.c:4161 btrfs_balance+0xbdc/0x10c0 fs/btrfs/volumes.c:4538 BTRFS error (device loop0 state EA): Ref action 2, root 5, ref_root 0, parent 8564736, owner 0, offset 0, num_refs 18446744073709551615 __btrfs_mod_ref+0x7dd/0xac0 fs/btrfs/extent-tree.c:2523 update_ref_for_cow+0x9cd/0x11f0 fs/btrfs/ctree.c:512 btrfs_force_cow_block+0x9f6/0x1da0 fs/btrfs/ctree.c:594 btrfs_cow_block+0x35e/0xa40 fs/btrfs/ctree.c:754 btrfs_search_slot+0xbdd/0x30d0 fs/btrfs/ctree.c:2116 btrfs_lookup_inode+0xdc/0x480 fs/btrfs/inode-item.c:411 __btrfs_update_delayed_inode+0x1e7/0xb90 fs/btrfs/delayed-inode.c:1030 btrfs_update_delayed_i ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.15 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.12.4 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016786": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: wilc1000: prevent use-after-free on vif when cleaning up all interfaces wilc_netdev_cleanup currently triggers a KASAN warning, which can be observed on interface registration error path, or simply by removing the module/unbinding device from driver: echo spi0.1 > /sys/bus/spi/drivers/wilc1000_spi/unbind ================================================================== BUG: KASAN: slab-use-after-free in wilc_netdev_cleanup+0x508/0x5cc Read of size 4 at addr c54d1ce8 by task sh/86 CPU: 0 PID: 86 Comm: sh Not tainted 6.8.0-rc1+ #117 Hardware name: Atmel SAMA5 unwind_backtrace from show_stack+0x18/0x1c show_stack from dump_stack_lvl+0x34/0x58 dump_stack_lvl from print_report+0x154/0x500 print_report from kasan_report+0xac/0xd8 kasan_report from wilc_netdev_cleanup+0x508/0x5cc wilc_netdev_cleanup from wilc_bus_remove+0xc8/0xec wilc_bus_remove from spi_remove+0x8c/0xac spi_remove from device_release_driver_internal+0x434/0x5f8 device_release_driver_internal from unbind_store+0xbc/0x108 unbind_store from kernfs_fop_write_iter+0x398/0x584 kernfs_fop_write_iter from vfs_write+0x728/0xf88 vfs_write from ksys_write+0x110/0x1e4 ksys_write from ret_fast_syscall+0x0/0x1c [...] Allocated by task 1: kasan_save_track+0x30/0x5c __kasan_kmalloc+0x8c/0x94 __kmalloc_node+0x1cc/0x3e4 kvmalloc_node+0x48/0x180 alloc_netdev_mqs+0x68/0x11dc alloc_etherdev_mqs+0x28/0x34 wilc_netdev_ifc_init+0x34/0x8ec wilc_cfg80211_init+0x690/0x910 wilc_bus_probe+0xe0/0x4a0 spi_probe+0x158/0x1b0 really_probe+0x270/0xdf4 __driver_probe_device+0x1dc/0x580 driver_probe_device+0x60/0x140 __driver_attach+0x228/0x5d4 bus_for_each_dev+0x13c/0x1a8 bus_add_driver+0x2a0/0x608 driver_register+0x24c/0x578 do_one_initcall+0x180/0x310 kernel_init_freeable+0x424/0x484 kernel_init+0x20/0x148 ret_from_fork+0x14/0x28 Freed by task 86: kasan_save_track+0x30/0x5c kasan_save_free_info+0x38/0x58 __kasan_slab_free+0xe4/0x140 kfree+0xb0/0x238 device_release+0xc0/0x2a8 kobject_put+0x1d4/0x46c netdev_run_todo+0x8fc/0x11d0 wilc_netdev_cleanup+0x1e4/0x5cc wilc_bus_remove+0xc8/0xec spi_remove+0x8c/0xac device_release_driver_internal+0x434/0x5f8 unbind_store+0xbc/0x108 kernfs_fop_write_iter+0x398/0x584 vfs_write+0x728/0xf88 ksys_write+0x110/0x1e4 ret_fast_syscall+0x0/0x1c [...] David Mosberger-Tan initial investigation [1] showed that this use-after-free is due to netdevice unregistration during vif list traversal. When unregistering a net device, since the needs_free_netdev has been set to true during registration, the netdevice object is also freed, and as a consequence, the corresponding vif object too, since it is attached to it as private netdevice data. The next occurrence of the loop then tries to access freed vif pointer to the list to move forward in the list. Fix this use-after-free thanks to two mechanisms: - navigate in the list with list_for_each_entry_safe, which allows to safely modify the list as we go through each element. For each element, remove it from the list with list_del_rcu - make sure to wait for RCU grace period end after each vif removal to make sure it is safe to free the corresponding vif too (through unregister_netdev) Since we are in a RCU \"modifier\" path (not a \"reader\" path), and because such path is expected not to be concurrent to any other modifier (we are using the vif_mutex lock), we do not need to use RCU list API, that's why we can benefit from list_for_each_entry_safe. [1] https://lore.kernel.org/linux-wireless/ab077dbe58b1ea5de0a3b2ca21f275a07af967d2.camel@egauge.net/",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.5 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-016801": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: openvswitch: Fix Use-After-Free in ovs_ct_exit Since kfree_rcu, which is called in the hlist_for_each_entry_rcu traversal of ovs_ct_limit_exit, is not part of the RCU read critical section, it is possible that the RCU grace period will pass during the traversal and the key will be free. To prevent this, it should be changed to hlist_for_each_entry_safe.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.18 以上 4.19.313 未満\nLinux Kernel 4.20 以上 5.4.275 未満\nLinux Kernel 5.5 以上 5.10.216 未満\nLinux Kernel 5.11 以上 5.15.158 未満\nLinux Kernel 5.16 以上 6.1.90 未満\nLinux Kernel 6.2 以上 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.9 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016800": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: misc: ljca: Fix double free in error handling path When auxiliary_device_add() returns error and then calls auxiliary_device_uninit(), callback function ljca_auxdev_release calls kfree(auxdev->dev.platform_data) to free the parameter data of the function ljca_new_client_device. The callers of ljca_new_client_device shouldn't call kfree() again in the error handling path to free the platform data. Fix this by cleaning up the redundant kfree() in all callers and adding kfree() the passed in platform_data on errors which happen before auxiliary_device_init() succeeds .",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-016799": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: bfa: Ensure the copied buf is NUL terminated Currently, we allocate a nbytes-sized kernel buffer and copy nbytes from userspace to that buffer. Later, we use sscanf on this buffer but we don't ensure that the string is terminated inside the buffer, this can lead to OOB read when using sscanf. Fix this issue by using memdup_user_nul instead of memdup_user.",
        "technologies": "Linux\nLinux Kernel 3.19 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-016802": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in SMB request handling A race condition exists between SMB request handling in `ksmbd_conn_handler_loop()` and the freeing of `ksmbd_conn` in the workqueue handler `handle_ksmbd_work()`. This leads to a UAF. - KASAN: slab-use-after-free Read in handle_ksmbd_work - KASAN: slab-use-after-free in rtlock_slowlock_locked This race condition arises as follows: - `ksmbd_conn_handler_loop()` waits for `conn->r_count` to reach zero: `wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0);` - Meanwhile, `handle_ksmbd_work()` decrements `conn->r_count` using `atomic_dec_return(&conn->r_count)`, and if it reaches zero, calls `ksmbd_conn_free()`, which frees `conn`. - However, after `handle_ksmbd_work()` decrements `conn->r_count`, it may still access `conn->r_count_q` in the following line: `waitqueue_active(&conn->r_count_q)` or `wake_up(&conn->r_count_q)` This results in a UAF, as `conn` has already been freed. The discovery of this UAF can be referenced in the following PR for syzkaller's support for SMB requests.",
        "technologies": "Linux\nLinux Kernel 6.6.55 以上 6.6.64 未満\nLinux Kernel 6.10.14 以上 6.11 未満\nLinux Kernel 6.11.3 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016787": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ceph: prevent use-after-free in encode_cap_msg() In fs/ceph/caps.c, in encode_cap_msg(), \"use after free\" error was caught by KASAN at this line - 'ceph_buffer_get(arg->xattr_buf);'. This implies before the refcount could be increment here, it was freed. In same file, in \"handle_cap_grant()\" refcount is decremented by this line - 'ceph_buffer_put(ci->i_xattrs.blob);'. It appears that a race occurred and resource was freed by the latter line before the former line could increment it. encode_cap_msg() is called by __send_cap() and __send_cap() is called by ceph_check_caps() after calling __prep_cap(). __prep_cap() is where arg->xattr_buf is assigned to ci->i_xattrs.blob. This is the spot where the refcount must be increased to prevent \"use after free\" error.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.79 未満\nLinux Kernel 6.2 以上 6.6.18 未満\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-016834": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: PCI: endpoint: Fix PCI domain ID release in pci_epc_destroy() pci_epc_destroy() invokes pci_bus_release_domain_nr() to release the PCI domain ID, but there are two issues: - 'epc->dev' is passed to pci_bus_release_domain_nr() which was already freed by device_unregister(), leading to a use-after-free issue. - Domain ID corresponds to the EPC device parent, so passing 'epc->dev' is also wrong. Fix these issues by passing 'epc->dev.parent' to pci_bus_release_domain_nr() and also do it before device_unregister(). [mani: reworded subject and description]",
        "technologies": "Linux\nLinux Kernel 6.11.4 以上 6.12.4 未満"
    },
    "JVNDB-2024-016840": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free of signing key Customers have reported use-after-free in @ses->auth_key.response with SMB2.1 + sign mounts which occurs due to following race: task A task B cifs_mount() dfs_mount_share() get_session() cifs_mount_get_session() cifs_send_recv() cifs_get_smb_ses() compound_send_recv() cifs_setup_session() smb2_setup_request() kfree_sensitive() smb2_calc_signature() crypto_shash_setkey() *UAF* Fix this by ensuring that we have a valid @ses->auth_key.response by checking whether @ses->ses_status is SES_GOOD or SES_EXITING with @ses->ses_lock held. After commit 24a9799aa8ef (\"smb: client: fix UAF in smb2_reconnect_server()\"), we made sure to call ->logoff() only when @ses was known to be good (e.g. valid ->auth_key.response), so it's safe to access signing key when @ses->ses_status == SES_EXITING.",
        "technologies": "Linux\nLinux Kernel 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.2 未満"
    },
    "JVNDB-2024-016841": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: fix LGR and link use-after-free issue We encountered a LGR/link use-after-free issue, which manifested as the LGR/link refcnt reaching 0 early and entering the clear process, making resource access unsafe. refcount_t: addition on 0; use-after-free. WARNING: CPU: 14 PID: 107447 at lib/refcount.c:25 refcount_warn_saturate+0x9c/0x140 Workqueue: events smc_lgr_terminate_work [smc] Call trace: refcount_warn_saturate+0x9c/0x140 __smc_lgr_terminate.part.45+0x2a8/0x370 [smc] smc_lgr_terminate_work+0x28/0x30 [smc] process_one_work+0x1b8/0x420 worker_thread+0x158/0x510 kthread+0x114/0x118 or refcount_t: underflow; use-after-free. WARNING: CPU: 6 PID: 93140 at lib/refcount.c:28 refcount_warn_saturate+0xf0/0x140 Workqueue: smc_hs_wq smc_listen_work [smc] Call trace: refcount_warn_saturate+0xf0/0x140 smcr_link_put+0x1cc/0x1d8 [smc] smc_conn_free+0x110/0x1b0 [smc] smc_conn_abort+0x50/0x60 [smc] smc_listen_find_device+0x75c/0x790 [smc] smc_listen_work+0x368/0x8a0 [smc] process_one_work+0x1b8/0x420 worker_thread+0x158/0x510 kthread+0x114/0x118 It is caused by repeated release of LGR/link refcnt. One suspect is that smc_conn_free() is called repeatedly because some smc_conn_free() from server listening path are not protected by sock lock. e.g. Calls under socklock | smc_listen_work ------------------------------------------------------- lock_sock(sk) | smc_conn_abort smc_conn_free | \\- smc_conn_free \\- smcr_link_put | \\- smcr_link_put (duplicated) release_sock(sk) So here add sock lock protection in smc_listen_work() path, making it exclusive with other connection operations.",
        "technologies": "Linux\nLinux Kernel 4.18 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-016844": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: fix potential array underflow in ucsi_ccg_sync_control() The \"command\" variable can be controlled by the user via debugfs. The worry is that if con_index is zero then \"&uc->ucsi->connector[con_index - 1]\" would be an array underflow.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016869": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: add a check to prevent array-index-out-of-bounds in dbAdjTree When the value of lp is 0 at the beginning of the for loop, it will become negative in the next assignment and we should bail out.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016872": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block, bfq: fix bfqq uaf in bfq_limit_depth() Set new allocated bfqq to bic or remove freed bfqq from bic are both protected by bfqd->lock, however bfq_limit_depth() is deferencing bfqq from bic without the lock, this can lead to UAF if the io_context is shared by multiple tasks. For example, test bfq with io_uring can trigger following UAF in v6.6: ================================================================== BUG: KASAN: slab-use-after-free in bfqq_group+0x15/0x50 Call Trace: <TASK> dump_stack_lvl+0x47/0x80 print_address_description.constprop.0+0x66/0x300 print_report+0x3e/0x70 kasan_report+0xb4/0xf0 bfqq_group+0x15/0x50 bfqq_request_over_limit+0x130/0x9a0 bfq_limit_depth+0x1b5/0x480 __blk_mq_alloc_requests+0x2b5/0xa00 blk_mq_get_new_requests+0x11d/0x1d0 blk_mq_submit_bio+0x286/0xb00 submit_bio_noacct_nocheck+0x331/0x400 __block_write_full_folio+0x3d0/0x640 writepage_cb+0x3b/0xc0 write_cache_pages+0x254/0x6c0 write_cache_pages+0x254/0x6c0 do_writepages+0x192/0x310 filemap_fdatawrite_wbc+0x95/0xc0 __filemap_fdatawrite_range+0x99/0xd0 filemap_write_and_wait_range.part.0+0x4d/0xa0 blkdev_read_iter+0xef/0x1e0 io_read+0x1b6/0x8a0 io_issue_sqe+0x87/0x300 io_wq_submit_work+0xeb/0x390 io_worker_handle_work+0x24d/0x550 io_wq_worker+0x27f/0x6c0 ret_from_fork_asm+0x1b/0x30 </TASK> Allocated by task 808602: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 __kasan_slab_alloc+0x83/0x90 kmem_cache_alloc_node+0x1b1/0x6d0 bfq_get_queue+0x138/0xfa0 bfq_get_bfqq_handle_split+0xe3/0x2c0 bfq_init_rq+0x196/0xbb0 bfq_insert_request.isra.0+0xb5/0x480 bfq_insert_requests+0x156/0x180 blk_mq_insert_request+0x15d/0x440 blk_mq_submit_bio+0x8a4/0xb00 submit_bio_noacct_nocheck+0x331/0x400 __blkdev_direct_IO_async+0x2dd/0x330 blkdev_write_iter+0x39a/0x450 io_write+0x22a/0x840 io_issue_sqe+0x87/0x300 io_wq_submit_work+0xeb/0x390 io_worker_handle_work+0x24d/0x550 io_wq_worker+0x27f/0x6c0 ret_from_fork+0x2d/0x50 ret_from_fork_asm+0x1b/0x30 Freed by task 808589: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_save_free_info+0x27/0x40 __kasan_slab_free+0x126/0x1b0 kmem_cache_free+0x10c/0x750 bfq_put_queue+0x2dd/0x770 __bfq_insert_request.isra.0+0x155/0x7a0 bfq_insert_request.isra.0+0x122/0x480 bfq_insert_requests+0x156/0x180 blk_mq_dispatch_plug_list+0x528/0x7e0 blk_mq_flush_plug_list.part.0+0xe5/0x590 __blk_flush_plug+0x3b/0x90 blk_finish_plug+0x40/0x60 do_writepages+0x19d/0x310 filemap_fdatawrite_wbc+0x95/0xc0 __filemap_fdatawrite_range+0x99/0xd0 filemap_write_and_wait_range.part.0+0x4d/0xa0 blkdev_read_iter+0xef/0x1e0 io_read+0x1b6/0x8a0 io_issue_sqe+0x87/0x300 io_wq_submit_work+0xeb/0x390 io_worker_handle_work+0x24d/0x550 io_wq_worker+0x27f/0x6c0 ret_from_fork+0x2d/0x50 ret_from_fork_asm+0x1b/0x30 Fix the problem by protecting bic_to_bfqq() with bfqd->lock.",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016845": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix array-index-out-of-bounds in jfs_readdir The stbl might contain some invalid values. Added a check to return error code in that case.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-017015": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: array-index-out-of-bounds fix in dtReadFirst The value of stbl can be sometimes out of bounds due to a bad filesystem. Added a check with appopriate return of error code in that case.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-016927": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/cio: Ensure the copied buf is NUL terminated Currently, we allocate a lbuf-sized kernel buffer and copy lbuf from userspace to that buffer. Later, we use scanf on this buffer but we don't ensure that the string is terminated inside the buffer, this can lead to OOB read when using scanf. Fix this issue by using memdup_user_nul instead.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-017010": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv: kvm: Fix out-of-bounds array access In kvm_riscv_vcpu_sbi_init() the entry->ext_idx can contain an out-of-bound index. This is used as a special marker for the base extensions, that cannot be disabled. However, when traversing the extensions, that special marker is not checked prior indexing the array. Add an out-of-bounds check to the function.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016871": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block: fix uaf for flush rq while iterating tags blk_mq_clear_flush_rq_mapping() is not called during scsi probe, by checking blk_queue_init_done(). However, QUEUE_FLAG_INIT_DONE is cleared in del_gendisk by commit aec89dc5d421 (\"block: keep q_usage_counter in atomic mode after del_gendisk\"), hence for disk like scsi, following blk_mq_destroy_queue() will not clear flush rq from tags->rqs[] as well, cause following uaf that is found by our syzkaller for v6.6: ================================================================== BUG: KASAN: slab-use-after-free in blk_mq_find_and_get_req+0x16e/0x1a0 block/blk-mq-tag.c:261 Read of size 4 at addr ffff88811c969c20 by task kworker/1:2H/224909 CPU: 1 PID: 224909 Comm: kworker/1:2H Not tainted 6.6.0-ga836a5060850 #32 Workqueue: kblockd blk_mq_timeout_work Call Trace: __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x91/0xf0 lib/dump_stack.c:106 print_address_description.constprop.0+0x66/0x300 mm/kasan/report.c:364 print_report+0x3e/0x70 mm/kasan/report.c:475 kasan_report+0xb8/0xf0 mm/kasan/report.c:588 blk_mq_find_and_get_req+0x16e/0x1a0 block/blk-mq-tag.c:261 bt_iter block/blk-mq-tag.c:288 [inline] __sbitmap_for_each_set include/linux/sbitmap.h:295 [inline] sbitmap_for_each_set include/linux/sbitmap.h:316 [inline] bt_for_each+0x455/0x790 block/blk-mq-tag.c:325 blk_mq_queue_tag_busy_iter+0x320/0x740 block/blk-mq-tag.c:534 blk_mq_timeout_work+0x1a3/0x7b0 block/blk-mq.c:1673 process_one_work+0x7c4/0x1450 kernel/workqueue.c:2631 process_scheduled_works kernel/workqueue.c:2704 [inline] worker_thread+0x804/0xe40 kernel/workqueue.c:2785 kthread+0x346/0x450 kernel/kthread.c:388 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1b/0x30 arch/x86/entry/entry_64.S:293 Allocated by task 942: kasan_save_stack+0x22/0x50 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 ____kasan_kmalloc mm/kasan/common.c:374 [inline] __kasan_kmalloc mm/kasan/common.c:383 [inline] __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:380 kasan_kmalloc include/linux/kasan.h:198 [inline] __do_kmalloc_node mm/slab_common.c:1007 [inline] __kmalloc_node+0x69/0x170 mm/slab_common.c:1014 kmalloc_node include/linux/slab.h:620 [inline] kzalloc_node include/linux/slab.h:732 [inline] blk_alloc_flush_queue+0x144/0x2f0 block/blk-flush.c:499 blk_mq_alloc_hctx+0x601/0x940 block/blk-mq.c:3788 blk_mq_alloc_and_init_hctx+0x27f/0x330 block/blk-mq.c:4261 blk_mq_realloc_hw_ctxs+0x488/0x5e0 block/blk-mq.c:4294 blk_mq_init_allocated_queue+0x188/0x860 block/blk-mq.c:4350 blk_mq_init_queue_data block/blk-mq.c:4166 [inline] blk_mq_init_queue+0x8d/0x100 block/blk-mq.c:4176 scsi_alloc_sdev+0x843/0xd50 drivers/scsi/scsi_scan.c:335 scsi_probe_and_add_lun+0x77c/0xde0 drivers/scsi/scsi_scan.c:1189 __scsi_scan_target+0x1fc/0x5a0 drivers/scsi/scsi_scan.c:1727 scsi_scan_channel drivers/scsi/scsi_scan.c:1815 [inline] scsi_scan_channel+0x14b/0x1e0 drivers/scsi/scsi_scan.c:1791 scsi_scan_host_selected+0x2fe/0x400 drivers/scsi/scsi_scan.c:1844 scsi_scan+0x3a0/0x3f0 drivers/scsi/scsi_sysfs.c:151 store_scan+0x2a/0x60 drivers/scsi/scsi_sysfs.c:191 dev_attr_store+0x5c/0x90 drivers/base/core.c:2388 sysfs_kf_write+0x11c/0x170 fs/sysfs/file.c:136 kernfs_fop_write_iter+0x3fc/0x610 fs/kernfs/file.c:338 call_write_iter include/linux/fs.h:2083 [inline] new_sync_write+0x1b4/0x2d0 fs/read_write.c:493 vfs_write+0x76c/0xb00 fs/read_write.c:586 ksys_write+0x127/0x250 fs/read_write.c:639 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x70/0x120 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x78/0xe2 Freed by task 244687: kasan_save_stack+0x22/0x50 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 kasan_save_free_info+0x2b/0x50 mm/kasan/generic.c:522 ____kasan_slab_free mm/kasan/common.c:236 [inline] __kasan_slab_free+0x12a/0x1b0 mm/kasan/common.c:244 kasan_slab_free include/linux/kasan.h:164 [in ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016939": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: Fix slab-use-after-free Read in set_powered_sync This fixes the following crash: ================================================================== BUG: KASAN: slab-use-after-free in set_powered_sync+0x3a/0xc0 net/bluetooth/mgmt.c:1353 Read of size 8 at addr ffff888029b4dd18 by task kworker/u9:0/54 CPU: 1 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-01155-gf723224742fc #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 q kasan_report+0x143/0x180 mm/kasan/report.c:601 set_powered_sync+0x3a/0xc0 net/bluetooth/mgmt.c:1353 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:328 process_one_work kernel/workqueue.c:3231 [inline] process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3312 worker_thread+0x86d/0xd10 kernel/workqueue.c:3389 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 5247: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:370 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:387 kasan_kmalloc include/linux/kasan.h:211 [inline] __kmalloc_cache_noprof+0x19c/0x2c0 mm/slub.c:4193 kmalloc_noprof include/linux/slab.h:681 [inline] kzalloc_noprof include/linux/slab.h:807 [inline] mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269 mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296 set_powered+0x3cd/0x5e0 net/bluetooth/mgmt.c:1394 hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712 hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:745 sock_write_iter+0x2dd/0x400 net/socket.c:1160 new_sync_write fs/read_write.c:497 [inline] vfs_write+0xa72/0xc90 fs/read_write.c:590 ksys_write+0x1a0/0x2c0 fs/read_write.c:643 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 5246: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579 poison_slab_object+0xe0/0x150 mm/kasan/common.c:240 __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256 kasan_slab_free include/linux/kasan.h:184 [inline] slab_free_hook mm/slub.c:2256 [inline] slab_free mm/slub.c:4477 [inline] kfree+0x149/0x360 mm/slub.c:4598 settings_rsp+0x2bc/0x390 net/bluetooth/mgmt.c:1443 mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259 __mgmt_power_off+0x112/0x420 net/bluetooth/mgmt.c:9455 hci_dev_close_sync+0x665/0x11a0 net/bluetooth/hci_sync.c:5191 hci_dev_do_close net/bluetooth/hci_core.c:483 [inline] hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508 sock_do_ioctl+0x158/0x460 net/socket.c:1222 sock_ioctl+0x629/0x8e0 net/socket.c:1341 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83gv entry_SYSCALL_64_after_hwframe+0x77/0x7f",
        "technologies": "Linux\nLinux Kernel 5.17 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-016954": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix usage slab after free [ +0.000021] BUG: KASAN: slab-use-after-free in drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000027] Read of size 8 at addr ffff8881b8605f88 by task amd_pci_unplug/2147 [ +0.000023] CPU: 6 PID: 2147 Comm: amd_pci_unplug Not tainted 6.10.0+ #1 [ +0.000016] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020 [ +0.000016] Call Trace: [ +0.000008] <TASK> [ +0.000009] dump_stack_lvl+0x76/0xa0 [ +0.000017] print_report+0xce/0x5f0 [ +0.000017] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000019] ? srso_return_thunk+0x5/0x5f [ +0.000015] ? kasan_complete_mode_report_info+0x72/0x200 [ +0.000016] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000019] kasan_report+0xbe/0x110 [ +0.000015] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000023] __asan_report_load8_noabort+0x14/0x30 [ +0.000014] drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000020] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? __kasan_check_write+0x14/0x30 [ +0.000016] ? __pfx_drm_sched_entity_flush+0x10/0x10 [gpu_sched] [ +0.000020] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? __kasan_check_write+0x14/0x30 [ +0.000013] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? enable_work+0x124/0x220 [ +0.000015] ? __pfx_enable_work+0x10/0x10 [ +0.000013] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? free_large_kmalloc+0x85/0xf0 [ +0.000016] drm_sched_entity_destroy+0x18/0x30 [gpu_sched] [ +0.000020] amdgpu_vce_sw_fini+0x55/0x170 [amdgpu] [ +0.000735] ? __kasan_check_read+0x11/0x20 [ +0.000016] vce_v4_0_sw_fini+0x80/0x110 [amdgpu] [ +0.000726] amdgpu_device_fini_sw+0x331/0xfc0 [amdgpu] [ +0.000679] ? mutex_unlock+0x80/0xe0 [ +0.000017] ? __pfx_amdgpu_device_fini_sw+0x10/0x10 [amdgpu] [ +0.000662] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? __kasan_check_write+0x14/0x30 [ +0.000013] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? mutex_unlock+0x80/0xe0 [ +0.000016] amdgpu_driver_release_kms+0x16/0x80 [amdgpu] [ +0.000663] drm_minor_release+0xc9/0x140 [drm] [ +0.000081] drm_release+0x1fd/0x390 [drm] [ +0.000082] __fput+0x36c/0xad0 [ +0.000018] __fput_sync+0x3c/0x50 [ +0.000014] __x64_sys_close+0x7d/0xe0 [ +0.000014] x64_sys_call+0x1bc6/0x2680 [ +0.000014] do_syscall_64+0x70/0x130 [ +0.000014] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? irqentry_exit_to_user_mode+0x60/0x190 [ +0.000015] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? irqentry_exit+0x43/0x50 [ +0.000012] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? exc_page_fault+0x7c/0x110 [ +0.000015] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ +0.000014] RIP: 0033:0x7ffff7b14f67 [ +0.000013] Code: ff e8 0d 16 02 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 73 ba f7 ff [ +0.000026] RSP: 002b:00007fffffffe378 EFLAGS: 00000246 ORIG_RAX: 0000000000000003 [ +0.000019] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffff7b14f67 [ +0.000014] RDX: 0000000000000000 RSI: 00007ffff7f6f47a RDI: 0000000000000003 [ +0.000014] RBP: 00007fffffffe3a0 R08: 0000555555569890 R09: 0000000000000000 [ +0.000014] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fffffffe5c8 [ +0.000013] R13: 00005555555552a9 R14: 0000555555557d48 R15: 00007ffff7ffd040 [ +0.000020] </TASK> [ +0.000016] Allocated by task 383 on cpu 7 at 26.880319s: [ +0.000014] kasan_save_stack+0x28/0x60 [ +0.000008] kasan_save_track+0x18/0x70 [ +0.000007] kasan_save_alloc_info+0x38/0x60 [ +0.000007] __kasan_kmalloc+0xc1/0xd0 [ +0.000007] kmalloc_trace_noprof+0x180/0x380 [ +0.000007] drm_sched_init+0x411/0xec0 [gpu_sched] [ +0.000012] amdgpu_device_init+0x695f/0xa610 [amdgpu] [ +0.000658] amdgpu_driver_load_kms+0x1a/0x120 [amdgpu] [ +0.000662] amdgpu_pci_p ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.6.64 未満\nLinux Kernel 6.7 以上 6.12.4 未満"
    },
    "JVNDB-2024-017018": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix Out-of-Bounds Read in ksmbd_vfs_stream_read An offset from client could be a negative value, It could lead to an out-of-bounds read from the stream_buf. Note that this issue is coming when setting 'vfs objects = streams_xattr parameter' in ksmbd.conf.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017016": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix Out-of-Bounds Write in ksmbd_vfs_stream_write An offset from client could be a negative value, It could allows to write data outside the bounds of the allocated buffer. Note that this issue is coming when setting 'vfs objects = streams_xattr parameter' in ksmbd.conf.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017073": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: inet: do not leave a dangling sk pointer in inet_create() sock_init_data() attaches the allocated sk object to the provided sock object. If inet_create() fails later, the sk object is freed, but the sock object retains the dangling pointer, which may create use-after-free later. Clear the sk pointer in the sock object on error.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-017067": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: fix use-after-free in device_for_each_child() Syzbot has reported the following KASAN splat: BUG: KASAN: slab-use-after-free in device_for_each_child+0x18f/0x1a0 Read of size 8 at addr ffff88801f605308 by task kbnepd bnep0/4980 CPU: 0 UID: 0 PID: 4980 Comm: kbnepd bnep0 Not tainted 6.12.0-rc4-00161-gae90f6a6170d #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x100/0x190 ? device_for_each_child+0x18f/0x1a0 print_report+0x13a/0x4cb ? __virt_addr_valid+0x5e/0x590 ? __phys_addr+0xc6/0x150 ? device_for_each_child+0x18f/0x1a0 kasan_report+0xda/0x110 ? device_for_each_child+0x18f/0x1a0 ? __pfx_dev_memalloc_noio+0x10/0x10 device_for_each_child+0x18f/0x1a0 ? __pfx_device_for_each_child+0x10/0x10 pm_runtime_set_memalloc_noio+0xf2/0x180 netdev_unregister_kobject+0x1ed/0x270 unregister_netdevice_many_notify+0x123c/0x1d80 ? __mutex_trylock_common+0xde/0x250 ? __pfx_unregister_netdevice_many_notify+0x10/0x10 ? trace_contention_end+0xe6/0x140 ? __mutex_lock+0x4e7/0x8f0 ? __pfx_lock_acquire.part.0+0x10/0x10 ? rcu_is_watching+0x12/0xc0 ? unregister_netdev+0x12/0x30 unregister_netdevice_queue+0x30d/0x3f0 ? __pfx_unregister_netdevice_queue+0x10/0x10 ? __pfx_down_write+0x10/0x10 unregister_netdev+0x1c/0x30 bnep_session+0x1fb3/0x2ab0 ? __pfx_bnep_session+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? __pfx_woken_wake_function+0x10/0x10 ? __kthread_parkme+0x132/0x200 ? __pfx_bnep_session+0x10/0x10 ? kthread+0x13a/0x370 ? __pfx_bnep_session+0x10/0x10 kthread+0x2b7/0x370 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x48/0x80 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 4974: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 __kmalloc_noprof+0x1d1/0x440 hci_alloc_dev_priv+0x1d/0x2820 __vhci_create_device+0xef/0x7d0 vhci_write+0x2c7/0x480 vfs_write+0x6a0/0xfc0 ksys_write+0x12f/0x260 do_syscall_64+0xc7/0x250 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 4979: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x4f/0x70 kfree+0x141/0x490 hci_release_dev+0x4d9/0x600 bt_host_release+0x6a/0xb0 device_release+0xa4/0x240 kobject_put+0x1ec/0x5a0 put_device+0x1f/0x30 vhci_release+0x81/0xf0 __fput+0x3f6/0xb30 task_work_run+0x151/0x250 do_exit+0xa79/0x2c30 do_group_exit+0xd5/0x2a0 get_signal+0x1fcd/0x2210 arch_do_signal_or_restart+0x93/0x780 syscall_exit_to_user_mode+0x140/0x290 do_syscall_64+0xd4/0x250 entry_SYSCALL_64_after_hwframe+0x77/0x7f In 'hci_conn_del_sysfs()', 'device_unregister()' may be called when an underlying (kobject) reference counter is greater than 1. This means that reparenting (happened when the device is actually freed) is delayed and, during that delay, parent controller device (hciX) may be deleted. Since the latter may create a dangling pointer to freed parent, avoid that scenario by reparenting to NULL explicitly.",
        "technologies": "Linux\nLinux Kernel 4.19.300 以上 4.20 未満\nLinux Kernel 5.4.262 以上 5.5 未満\nLinux Kernel 5.10.202 以上 5.10.231 未満\nLinux Kernel 5.15.140 以上 5.15.174 未満\nLinux Kernel 6.1.64 以上 6.1.120 未満\nLinux Kernel 6.5.13 以上 6.6 未満\nLinux Kernel 6.6.3 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-017019": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: fix OOB devmap writes when deleting elements Jordy reported issue against XSKMAP which also applies to DEVMAP - the index used for accessing map entry, due to being a signed integer, causes the OOB writes. Fix is simple as changing the type from int to u32, however, when compared to XSKMAP case, one more thing needs to be addressed. When map is released from system via dev_map_free(), we iterate through all of the entries and an iterator variable is also an int, which implies OOB accesses. Again, change it to be u32. Example splat below: [ 160.724676] BUG: unable to handle page fault for address: ffffc8fc2c001000 [ 160.731662] #PF: supervisor read access in kernel mode [ 160.736876] #PF: error_code(0x0000) - not-present page [ 160.742095] PGD 0 P4D 0 [ 160.744678] Oops: Oops: 0000 [#1] PREEMPT SMP [ 160.749106] CPU: 1 UID: 0 PID: 520 Comm: kworker/u145:12 Not tainted 6.12.0-rc1+ #487 [ 160.757050] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [ 160.767642] Workqueue: events_unbound bpf_map_free_deferred [ 160.773308] RIP: 0010:dev_map_free+0x77/0x170 [ 160.777735] Code: 00 e8 fd 91 ed ff e8 b8 73 ed ff 41 83 7d 18 19 74 6e 41 8b 45 24 49 8b bd f8 00 00 00 31 db 85 c0 74 48 48 63 c3 48 8d 04 c7 <48> 8b 28 48 85 ed 74 30 48 8b 7d 18 48 85 ff 74 05 e8 b3 52 fa ff [ 160.796777] RSP: 0018:ffffc9000ee1fe38 EFLAGS: 00010202 [ 160.802086] RAX: ffffc8fc2c001000 RBX: 0000000080000000 RCX: 0000000000000024 [ 160.809331] RDX: 0000000000000000 RSI: 0000000000000024 RDI: ffffc9002c001000 [ 160.816576] RBP: 0000000000000000 R08: 0000000000000023 R09: 0000000000000001 [ 160.823823] R10: 0000000000000001 R11: 00000000000ee6b2 R12: dead000000000122 [ 160.831066] R13: ffff88810c928e00 R14: ffff8881002df405 R15: 0000000000000000 [ 160.838310] FS: 0000000000000000(0000) GS:ffff8897e0c40000(0000) knlGS:0000000000000000 [ 160.846528] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 160.852357] CR2: ffffc8fc2c001000 CR3: 0000000005c32006 CR4: 00000000007726f0 [ 160.859604] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 160.866847] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 160.874092] PKRU: 55555554 [ 160.876847] Call Trace: [ 160.879338] <TASK> [ 160.881477] ? __die+0x20/0x60 [ 160.884586] ? page_fault_oops+0x15a/0x450 [ 160.888746] ? search_extable+0x22/0x30 [ 160.892647] ? search_bpf_extables+0x5f/0x80 [ 160.896988] ? exc_page_fault+0xa9/0x140 [ 160.900973] ? asm_exc_page_fault+0x22/0x30 [ 160.905232] ? dev_map_free+0x77/0x170 [ 160.909043] ? dev_map_free+0x58/0x170 [ 160.912857] bpf_map_free_deferred+0x51/0x90 [ 160.917196] process_one_work+0x142/0x370 [ 160.921272] worker_thread+0x29e/0x3b0 [ 160.925082] ? rescuer_thread+0x4b0/0x4b0 [ 160.929157] kthread+0xd4/0x110 [ 160.932355] ? kthread_park+0x80/0x80 [ 160.936079] ret_from_fork+0x2d/0x50 [ 160.943396] ? kthread_park+0x80/0x80 [ 160.950803] ret_from_fork_asm+0x11/0x20 [ 160.958482] </TASK>",
        "technologies": "Linux\nLinux Kernel 4.14 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017080": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: inet6: do not leave a dangling sk pointer in inet6_create() sock_init_data() attaches the allocated sk pointer to the provided sock object. If inet6_create() fails later, the sk object is released, but the sock object retains the dangling sk pointer, which may cause use-after-free later. Clear the sock sk pointer on error.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-017064": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: cdns3: fix memory double free when handle zero packet 829 if (request->complete) { 830 spin_unlock(&priv_dev->lock); 831 usb_gadget_giveback_request(&priv_ep->endpoint, 832 request); 833 spin_lock(&priv_dev->lock); 834 } 835 836 if (request->buf == priv_dev->zlp_buf) 837 cdns3_gadget_ep_free_request(&priv_ep->endpoint, request); Driver append an additional zero packet request when queue a packet, which length mod max packet size is 0. When transfer complete, run to line 831, usb_gadget_giveback_request() will free this requestion. 836 condition is true, so cdns3_gadget_ep_free_request() free this request again. Log: [ 1920.140696][ T150] BUG: KFENCE: use-after-free read in cdns3_gadget_giveback+0x134/0x2c0 [cdns3] [ 1920.140696][ T150] [ 1920.151837][ T150] Use-after-free read at 0x000000003d1cd10b (in kfence-#36): [ 1920.159082][ T150] cdns3_gadget_giveback+0x134/0x2c0 [cdns3] [ 1920.164988][ T150] cdns3_transfer_completed+0x438/0x5f8 [cdns3] Add check at line 829, skip call usb_gadget_giveback_request() if it is additional zero length packet request. Needn't call usb_gadget_giveback_request() because it is allocated in this driver.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.211 未満\nLinux Kernel 5.11 以上 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-017092": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: binder: fix freeze UAF in binder_release_work() When a binder reference is cleaned up, any freeze work queued in the associated process should also be removed. Otherwise, the reference is freed while its ref->freeze.work is still queued in proc->work leading to a use-after-free issue as shown by the following KASAN report: ================================================================== BUG: KASAN: slab-use-after-free in binder_release_work+0x398/0x3d0 Read of size 8 at addr ffff31600ee91488 by task kworker/5:1/211 CPU: 5 UID: 0 PID: 211 Comm: kworker/5:1 Not tainted 6.11.0-rc7-00382-gfc6c92196396 #22 Hardware name: linux,dummy-virt (DT) Workqueue: events binder_deferred_func Call trace: binder_release_work+0x398/0x3d0 binder_deferred_func+0xb60/0x109c process_one_work+0x51c/0xbd4 worker_thread+0x608/0xee8 Allocated by task 703: __kmalloc_cache_noprof+0x130/0x280 binder_thread_write+0xdb4/0x42a0 binder_ioctl+0x18f0/0x25ac __arm64_sys_ioctl+0x124/0x190 invoke_syscall+0x6c/0x254 Freed by task 211: kfree+0xc4/0x230 binder_deferred_func+0xae8/0x109c process_one_work+0x51c/0xbd4 worker_thread+0x608/0xee8 ================================================================== This commit fixes the issue by ensuring any queued freeze work is removed when cleaning up a binder reference.",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.4 未満"
    },
    "JVNDB-2024-017084": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free in btrfs_encoded_read_endio() Shinichiro reported the following use-after free that sometimes is happening in our CI system when running fstests' btrfs/284 on a TCMU runner device: BUG: KASAN: slab-use-after-free in lock_release+0x708/0x780 Read of size 8 at addr ffff888106a83f18 by task kworker/u80:6/219 CPU: 8 UID: 0 PID: 219 Comm: kworker/u80:6 Not tainted 6.12.0-rc6-kts+ #15 Hardware name: Supermicro Super Server/X11SPi-TF, BIOS 3.3 02/21/2020 Workqueue: btrfs-endio btrfs_end_bio_work [btrfs] Call Trace: <TASK> dump_stack_lvl+0x6e/0xa0 ? lock_release+0x708/0x780 print_report+0x174/0x505 ? lock_release+0x708/0x780 ? __virt_addr_valid+0x224/0x410 ? lock_release+0x708/0x780 kasan_report+0xda/0x1b0 ? lock_release+0x708/0x780 ? __wake_up+0x44/0x60 lock_release+0x708/0x780 ? __pfx_lock_release+0x10/0x10 ? __pfx_do_raw_spin_lock+0x10/0x10 ? lock_is_held_type+0x9a/0x110 _raw_spin_unlock_irqrestore+0x1f/0x60 __wake_up+0x44/0x60 btrfs_encoded_read_endio+0x14b/0x190 [btrfs] btrfs_check_read_bio+0x8d9/0x1360 [btrfs] ? lock_release+0x1b0/0x780 ? trace_lock_acquire+0x12f/0x1a0 ? __pfx_btrfs_check_read_bio+0x10/0x10 [btrfs] ? process_one_work+0x7e3/0x1460 ? lock_acquire+0x31/0xc0 ? process_one_work+0x7e3/0x1460 process_one_work+0x85c/0x1460 ? __pfx_process_one_work+0x10/0x10 ? assign_work+0x16c/0x240 worker_thread+0x5e6/0xfc0 ? __pfx_worker_thread+0x10/0x10 kthread+0x2c3/0x3a0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 3661: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 btrfs_encoded_read_regular_fill_pages+0x16c/0x6d0 [btrfs] send_extent_data+0xf0f/0x24a0 [btrfs] process_extent+0x48a/0x1830 [btrfs] changed_cb+0x178b/0x2ea0 [btrfs] btrfs_ioctl_send+0x3bf9/0x5c20 [btrfs] _btrfs_ioctl_send+0x117/0x330 [btrfs] btrfs_ioctl+0x184a/0x60a0 [btrfs] __x64_sys_ioctl+0x12e/0x1a0 do_syscall_64+0x95/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 3661: kasan_save_stack+0x30/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x70 __kasan_slab_free+0x4f/0x70 kfree+0x143/0x490 btrfs_encoded_read_regular_fill_pages+0x531/0x6d0 [btrfs] send_extent_data+0xf0f/0x24a0 [btrfs] process_extent+0x48a/0x1830 [btrfs] changed_cb+0x178b/0x2ea0 [btrfs] btrfs_ioctl_send+0x3bf9/0x5c20 [btrfs] _btrfs_ioctl_send+0x117/0x330 [btrfs] btrfs_ioctl+0x184a/0x60a0 [btrfs] __x64_sys_ioctl+0x12e/0x1a0 do_syscall_64+0x95/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e The buggy address belongs to the object at ffff888106a83f00 which belongs to the cache kmalloc-rnd-07-96 of size 96 The buggy address is located 24 bytes inside of freed 96-byte region [ffff888106a83f00, ffff888106a83f60) The buggy address belongs to the physical page: page: refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888106a83800 pfn:0x106a83 flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff) page_type: f5(slab) raw: 0017ffffc0000000 ffff888100053680 ffffea0004917200 0000000000000004 raw: ffff888106a83800 0000000080200019 00000001f5000000 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888106a83e00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ffff888106a83e80: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc >ffff888106a83f00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ^ ffff888106a83f80: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc ffff888106a84000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ================================================================== Further analyzing the trace and ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.124 未満\nLinux Kernel 6.2 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.4 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017081": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: zoned: fix use-after-free in do_zone_finish() Shinichiro reported the following use-after-free triggered by the device replace operation in fstests btrfs/070. BTRFS info (device nullb1): scrub: finished on devid 1 with status: 0 ================================================================== BUG: KASAN: slab-use-after-free in do_zone_finish+0x91a/0xb90 [btrfs] Read of size 8 at addr ffff8881543c8060 by task btrfs-cleaner/3494007 CPU: 0 PID: 3494007 Comm: btrfs-cleaner Tainted: G W 6.8.0-rc5-kts #1 Hardware name: Supermicro Super Server/X11SPi-TF, BIOS 3.3 02/21/2020 Call Trace: <TASK> dump_stack_lvl+0x5b/0x90 print_report+0xcf/0x670 ? __virt_addr_valid+0x200/0x3e0 kasan_report+0xd8/0x110 ? do_zone_finish+0x91a/0xb90 [btrfs] ? do_zone_finish+0x91a/0xb90 [btrfs] do_zone_finish+0x91a/0xb90 [btrfs] btrfs_delete_unused_bgs+0x5e1/0x1750 [btrfs] ? __pfx_btrfs_delete_unused_bgs+0x10/0x10 [btrfs] ? btrfs_put_root+0x2d/0x220 [btrfs] ? btrfs_clean_one_deleted_snapshot+0x299/0x430 [btrfs] cleaner_kthread+0x21e/0x380 [btrfs] ? __pfx_cleaner_kthread+0x10/0x10 [btrfs] kthread+0x2e3/0x3c0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK> Allocated by task 3493983: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 btrfs_alloc_device+0xb3/0x4e0 [btrfs] device_list_add.constprop.0+0x993/0x1630 [btrfs] btrfs_scan_one_device+0x219/0x3d0 [btrfs] btrfs_control_ioctl+0x26e/0x310 [btrfs] __x64_sys_ioctl+0x134/0x1b0 do_syscall_64+0x99/0x190 entry_SYSCALL_64_after_hwframe+0x6e/0x76 Freed by task 3494056: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3f/0x60 poison_slab_object+0x102/0x170 __kasan_slab_free+0x32/0x70 kfree+0x11b/0x320 btrfs_rm_dev_replace_free_srcdev+0xca/0x280 [btrfs] btrfs_dev_replace_finishing+0xd7e/0x14f0 [btrfs] btrfs_dev_replace_by_ioctl+0x1286/0x25a0 [btrfs] btrfs_ioctl+0xb27/0x57d0 [btrfs] __x64_sys_ioctl+0x134/0x1b0 do_syscall_64+0x99/0x190 entry_SYSCALL_64_after_hwframe+0x6e/0x76 The buggy address belongs to the object at ffff8881543c8000 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 96 bytes inside of freed 1024-byte region [ffff8881543c8000, ffff8881543c8400) The buggy address belongs to the physical page: page:00000000fe2c1285 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1543c8 head:00000000fe2c1285 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0 flags: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff) page_type: 0xffffffff() raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002 raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb This UAF happens because we're accessing stale zone information of a already removed btrfs_device in do_zone_finish(). The sequence of events is as follows: btrfs_dev_replace_start btrfs_scrub_dev btrfs_dev_replace_finishing btrfs_dev_replace_update_device_in_mapping_tree <-- devices replaced btrfs_rm_dev_replace_free_srcdev btrfs_free_device <-- device freed cleaner_kthread btrfs_delete_unused_bgs btrfs_zone_finish do_zone_finish <-- refers the freed device The reason for this is that we're using a ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-017082": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sh: intc: Fix use-after-free bug in register_intc_controller() In the error handling for this function, d is freed without ever removing it from intc_list which would lead to a use after free. To fix this, let's only add it to the list after everything has succeeded.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-017093": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7921e: fix use-after-free in free_irq() From commit a304e1b82808 (\"[PATCH] Debug shared irqs\"), there is a test to make sure the shared irq handler should be able to handle the unexpected event after deregistration. For this case, let's apply MT76_REMOVED flag to indicate the device was removed and do not run into the resource access anymore. BUG: KASAN: use-after-free in mt7921_irq_handler+0xd8/0x100 [mt7921e] Read of size 8 at addr ffff88824a7d3b78 by task rmmod/11115 CPU: 28 PID: 11115 Comm: rmmod Tainted: G W L 5.17.0 #10 Hardware name: Micro-Star International Co., Ltd. MS-7D73/MPG B650I EDGE WIFI (MS-7D73), BIOS 1.81 01/05/2024 Call Trace: <TASK> dump_stack_lvl+0x6f/0xa0 print_address_description.constprop.0+0x1f/0x190 ? mt7921_irq_handler+0xd8/0x100 [mt7921e] ? mt7921_irq_handler+0xd8/0x100 [mt7921e] kasan_report.cold+0x7f/0x11b ? mt7921_irq_handler+0xd8/0x100 [mt7921e] mt7921_irq_handler+0xd8/0x100 [mt7921e] free_irq+0x627/0xaa0 devm_free_irq+0x94/0xd0 ? devm_request_any_context_irq+0x160/0x160 ? kobject_put+0x18d/0x4a0 mt7921_pci_remove+0x153/0x190 [mt7921e] pci_device_remove+0xa2/0x1d0 __device_release_driver+0x346/0x6e0 driver_detach+0x1ef/0x2c0 bus_remove_driver+0xe7/0x2d0 ? __check_object_size+0x57/0x310 pci_unregister_driver+0x26/0x250 __do_sys_delete_module+0x307/0x510 ? free_module+0x6a0/0x6a0 ? fpregs_assert_state_consistent+0x4b/0xb0 ? rcu_read_lock_sched_held+0x10/0x70 ? syscall_enter_from_user_mode+0x20/0x70 ? trace_hardirqs_on+0x1c/0x130 do_syscall_64+0x5c/0x80 ? trace_hardirqs_on_prepare+0x72/0x160 ? do_syscall_64+0x68/0x80 ? trace_hardirqs_on_prepare+0x72/0x160 entry_SYSCALL_64_after_hwframe+0x44/0xae",
        "technologies": "Linux\nLinux Kernel 6.2.15 以上 6.3 未満\nLinux Kernel 6.3.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-017131": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm: adv7511: Fix use-after-free in adv7533_attach_dsi() The host_node pointer was assigned and freed in adv7533_parse_dt(), and later, adv7533_attach_dsi() uses the same. Fix this use-after-free issue by dropping of_node_put() in adv7533_parse_dt() and calling of_node_put() in error path of probe() and also in the remove().",
        "technologies": "Linux\nLinux Kernel 4.8 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017202": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ila: serialize calls to nf_register_net_hooks() syzbot found a race in ila_add_mapping() [1] commit 031ae72825ce (\"ila: call nf_unregister_net_hooks() sooner\") attempted to fix a similar issue. Looking at the syzbot repro, we have concurrent ILA_CMD_ADD commands. Add a mutex to make sure at most one thread is calling nf_register_net_hooks(). [1] BUG: KASAN: slab-use-after-free in rht_key_hashfn include/linux/rhashtable.h:159 [inline] BUG: KASAN: slab-use-after-free in __rhashtable_lookup.constprop.0+0x426/0x550 include/linux/rhashtable.h:604 Read of size 4 at addr ffff888028f40008 by task dhcpcd/5501 CPU: 1 UID: 0 PID: 5501 Comm: dhcpcd Not tainted 6.13.0-rc4-syzkaller-00054-gd6ef8b40d075 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <IRQ> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0xc3/0x620 mm/kasan/report.c:489 kasan_report+0xd9/0x110 mm/kasan/report.c:602 rht_key_hashfn include/linux/rhashtable.h:159 [inline] __rhashtable_lookup.constprop.0+0x426/0x550 include/linux/rhashtable.h:604 rhashtable_lookup include/linux/rhashtable.h:646 [inline] rhashtable_lookup_fast include/linux/rhashtable.h:672 [inline] ila_lookup_wildcards net/ipv6/ila/ila_xlat.c:127 [inline] ila_xlat_addr net/ipv6/ila/ila_xlat.c:652 [inline] ila_nf_input+0x1ee/0x620 net/ipv6/ila/ila_xlat.c:185 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xbb/0x200 net/netfilter/core.c:626 nf_hook.constprop.0+0x42e/0x750 include/linux/netfilter.h:269 NF_HOOK include/linux/netfilter.h:312 [inline] ipv6_rcv+0xa4/0x680 net/ipv6/ip6_input.c:309 __netif_receive_skb_one_core+0x12e/0x1e0 net/core/dev.c:5672 __netif_receive_skb+0x1d/0x160 net/core/dev.c:5785 process_backlog+0x443/0x15f0 net/core/dev.c:6117 __napi_poll.constprop.0+0xb7/0x550 net/core/dev.c:6883 napi_poll net/core/dev.c:6952 [inline] net_rx_action+0xa94/0x1010 net/core/dev.c:7074 handle_softirqs+0x213/0x8f0 kernel/softirq.c:561 __do_softirq kernel/softirq.c:595 [inline] invoke_softirq kernel/softirq.c:435 [inline] __irq_exit_rcu+0x109/0x170 kernel/softirq.c:662 irq_exit_rcu+0x9/0x30 kernel/softirq.c:678 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline] sysvec_apic_timer_interrupt+0xa4/0xc0 arch/x86/kernel/apic/apic.c:1049",
        "technologies": "Linux\nLinux Kernel 4.5 以上 5.4.289 未満\nLinux Kernel 5.5 以上 5.10.233 未満\nLinux Kernel 5.11 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.124 未満\nLinux Kernel 6.2 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017205": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Skip restore TC rules for vport rep without loaded flag During driver unload, unregister_netdev is called after unloading vport rep. So, the mlx5e_rep_priv is already freed while trying to get rpriv->netdev, or walk rpriv->tc_ht, which results in use-after-free. So add the checking to make sure access the data of vport rep which is still loaded.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017094": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: raid1: fix use-after-free for original bio in raid1_write_request() r1_bio->bios[] is used to record new bios that will be issued to underlying disks, however, in raid1_write_request(), r1_bio->bios[] will set to the original bio temporarily. Meanwhile, if blocked rdev is set, free_r1bio() will be called causing that all r1_bio->bios[] to be freed: raid1_write_request() r1_bio = alloc_r1bio(mddev, bio); -> r1_bio->bios[] is NULL for (i = 0; i < disks; i++) -> for each rdev in conf // first rdev is normal r1_bio->bios[0] = bio; -> set to original bio // second rdev is blocked if (test_bit(Blocked, &rdev->flags)) break if (blocked_rdev) free_r1bio() put_all_bios() bio_put(r1_bio->bios[0]) -> original bio is freed Test scripts: mdadm -CR /dev/md0 -l1 -n4 /dev/sd[abcd] --assume-clean fio -filename=/dev/md0 -ioengine=libaio -rw=write -bs=4k -numjobs=1 \\ -iodepth=128 -name=test -direct=1 echo blocked > /sys/block/md0/md/rd2/state Test result: BUG bio-264 (Not tainted): Object already free ----------------------------------------------------------------------------- Allocated in mempool_alloc_slab+0x24/0x50 age=1 cpu=1 pid=869 kmem_cache_alloc+0x324/0x480 mempool_alloc_slab+0x24/0x50 mempool_alloc+0x6e/0x220 bio_alloc_bioset+0x1af/0x4d0 blkdev_direct_IO+0x164/0x8a0 blkdev_write_iter+0x309/0x440 aio_write+0x139/0x2f0 io_submit_one+0x5ca/0xb70 __do_sys_io_submit+0x86/0x270 __x64_sys_io_submit+0x22/0x30 do_syscall_64+0xb1/0x210 entry_SYSCALL_64_after_hwframe+0x6c/0x74 Freed in mempool_free_slab+0x1f/0x30 age=1 cpu=1 pid=869 kmem_cache_free+0x28c/0x550 mempool_free_slab+0x1f/0x30 mempool_free+0x40/0x100 bio_free+0x59/0x80 bio_put+0xf0/0x220 free_r1bio+0x74/0xb0 raid1_make_request+0xadf/0x1150 md_handle_request+0xc7/0x3b0 md_submit_bio+0x76/0x130 __submit_bio+0xd8/0x1d0 submit_bio_noacct_nocheck+0x1eb/0x5c0 submit_bio_noacct+0x169/0xd40 submit_bio+0xee/0x1d0 blkdev_direct_IO+0x322/0x8a0 blkdev_write_iter+0x309/0x440 aio_write+0x139/0x2f0 Since that bios for underlying disks are not allocated yet, fix this problem by using mempool_free() directly to free the r1_bio.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.28 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-017217": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: fix slab-use-after-free due to dangling pointer dqi_priv When mounting ocfs2 and then remounting it as read-only, a slab-use-after-free occurs after the user uses a syscall to quota_getnextquota. Specifically, sb_dqinfo(sb, type)->dqi_priv is the dangling pointer. During the remounting process, the pointer dqi_priv is freed but is never set as null leaving it to be accessed. Additionally, the read-only option for remounting sets the DQUOT_SUSPENDED flag instead of setting the DQUOT_USAGE_ENABLED flags. Moreover, later in the process of getting the next quota, the function ocfs2_get_next_id is called and only checks the quota usage flags and not the quota suspended flags. To fix this, I set dqi_priv to null when it is freed after remounting with read-only and put a check for DQUOT_SUSPENDED in ocfs2_get_next_id. [akpm@linux-foundation.org: coding-style cleanups]",
        "technologies": "Linux\nLinux Kernel 4.6 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017218": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: flush delalloc workers queue before stopping cleaner kthread during unmount During the unmount path, at close_ctree(), we first stop the cleaner kthread, using kthread_stop() which frees the associated task_struct, and then stop and destroy all the work queues. However after we stopped the cleaner we may still have a worker from the delalloc_workers queue running inode.c:submit_compressed_extents(), which calls btrfs_add_delayed_iput(), which in turn tries to wake up the cleaner kthread - which was already destroyed before, resulting in a use-after-free on the task_struct. Syzbot reported this with the following stack traces: BUG: KASAN: slab-use-after-free in __lock_acquire+0x78/0x2100 kernel/locking/lockdep.c:5089 Read of size 8 at addr ffff8880259d2818 by task kworker/u8:3/52 CPU: 1 UID: 0 PID: 52 Comm: kworker/u8:3 Not tainted 6.13.0-rc1-syzkaller-00002-gcdd30ebb1b9f #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: btrfs-delalloc btrfs_work_helper Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 __lock_acquire+0x78/0x2100 kernel/locking/lockdep.c:5089 lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline] _raw_spin_lock_irqsave+0xd5/0x120 kernel/locking/spinlock.c:162 class_raw_spinlock_irqsave_constructor include/linux/spinlock.h:551 [inline] try_to_wake_up+0xc2/0x1470 kernel/sched/core.c:4205 submit_compressed_extents+0xdf/0x16e0 fs/btrfs/inode.c:1615 run_ordered_work fs/btrfs/async-thread.c:288 [inline] btrfs_work_helper+0x96f/0xc40 fs/btrfs/async-thread.c:324 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 2: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 unpoison_slab_object mm/kasan/common.c:319 [inline] __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:345 kasan_slab_alloc include/linux/kasan.h:250 [inline] slab_post_alloc_hook mm/slub.c:4104 [inline] slab_alloc_node mm/slub.c:4153 [inline] kmem_cache_alloc_node_noprof+0x1d9/0x380 mm/slub.c:4205 alloc_task_struct_node kernel/fork.c:180 [inline] dup_task_struct+0x57/0x8c0 kernel/fork.c:1113 copy_process+0x5d1/0x3d50 kernel/fork.c:2225 kernel_clone+0x223/0x870 kernel/fork.c:2807 kernel_thread+0x1bc/0x240 kernel/fork.c:2869 create_kthread kernel/kthread.c:412 [inline] kthreadd+0x60d/0x810 kernel/kthread.c:767 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 Freed by task 24: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2338 [inline] slab_free mm/slub.c:4598 [inline] kmem_cache_free+0x195/0x410 mm/slub.c:4700 put_task_struct include/linux/sched/task.h:144 [inline] delayed_put_task_struct+0x125/0x300 kernel/exit.c:227 rcu_do_batch kernel/rcu/tree.c:2567 [inline] rcu_core+0xaaa/0x17a0 kernel/rcu/tree.c:2823 handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:554 run_ksoftirqd+0xca/0x130 kernel/softirq.c:943 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.10.233 未満\nLinux Kernel 5.11 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.124 未満\nLinux Kernel 6.2 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017559": {
        "title": "Linux Foundation の Magma における古典的バッファオーバーフローの脆弱性",
        "description": "The Linux Foundation Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) was discovered to contain a buffer overflow in the decode_pdn_address function at /nas/ies/PdnAddress.cpp. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-017253": {
        "title": "Linux Foundation の ONNX 等複数ベンダの製品におけるパストラバーサルの脆弱性",
        "description": "Versions of the package onnx before and including 1.15.0 are vulnerable to Directory Traversal as the external_data field of the tensor proto can have a path to the file which is outside the model current directory or user-provided directory. The vulnerability occurs as a bypass for the patch added for CVE-2022-25882.",
        "technologies": "Fedora Project\nFedora 39\nFedora 40\nLinux Foundation\nONNX 1.16.0 未満"
    },
    "JVNDB-2024-017546": {
        "title": "Linux Foundation の Magma における境界外読み取りに関する脆弱性",
        "description": "The Linux Foundation Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) was discovered to contain a buffer overflow in the decode_protocol_configuration_options function at /3gpp/3gpp_24.008_sm_ies.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-017236": {
        "title": "Linux Foundation の ONNX 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "Versions of the package onnx before and including 1.15.0 are vulnerable to Out-of-bounds Read as the ONNX_ASSERT and ONNX_ASSERTM functions have an off by one string copy.",
        "technologies": "Fedora Project\nFedora 39\nFedora 40\nLinux Foundation\nONNX 1.16.0 未満"
    },
    "JVNDB-2024-019119": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: imu: kmx61: fix information leak in triggered buffer The 'buffer' local array is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the array to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 4.0 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017585": {
        "title": "Linux Foundation の Magma における古典的バッファオーバーフローの脆弱性",
        "description": "The Linux Foundation Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) was discovered to contain a buffer overflow in the decode_access_point_name_ie function at /3gpp/3gpp_24.008_sm_ies.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-017573": {
        "title": "Linux Foundation の Magma における古典的バッファオーバーフローの脆弱性",
        "description": "The Linux Foundation Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) was discovered to contain a buffer overflow in the decode_traffic_flow_template_packet_filter function at /3gpp/3gpp_24.008_sm_ies.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-019118": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: rockchip_saradc: fix information leak in triggered buffer The 'data' local struct is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the struct to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 5.9 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-019135": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: light: bh1745: fix information leak in triggered buffer The 'scan' local struct is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the struct to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-019229": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: ti-ads1119: fix information leak in triggered buffer The 'scan' local struct is used to push data to user space from a triggered buffer, but it has a hole between the sample (unsigned int) and the timestamp. This hole is never initialized. Initialize the struct to zero before using it to avoid pushing uninitialized information to userspace.",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-017616": {
        "title": "Linux Foundation の Magma における境界外書き込みに関する脆弱性",
        "description": "The Linux Foundation Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) was discovered to contain a stack overflow in the decode_protocol_configuration_options function at /3gpp/3gpp_24.008_sm_ies.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-019633": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: DPLL, Fix possible use after free after delayed work timer triggers I managed to hit following use after free warning recently: [ 2169.711665] ================================================================== [ 2169.714009] BUG: KASAN: slab-use-after-free in __run_timers.part.0+0x179/0x4c0 [ 2169.716293] Write of size 8 at addr ffff88812b326a70 by task swapper/4/0 [ 2169.719022] CPU: 4 PID: 0 Comm: swapper/4 Not tainted 6.8.0-rc2jiri+ #2 [ 2169.720974] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [ 2169.722457] Call Trace: [ 2169.722756] <IRQ> [ 2169.723024] dump_stack_lvl+0x58/0xb0 [ 2169.723417] print_report+0xc5/0x630 [ 2169.723807] ? __virt_addr_valid+0x126/0x2b0 [ 2169.724268] kasan_report+0xbe/0xf0 [ 2169.724667] ? __run_timers.part.0+0x179/0x4c0 [ 2169.725116] ? __run_timers.part.0+0x179/0x4c0 [ 2169.725570] __run_timers.part.0+0x179/0x4c0 [ 2169.726003] ? call_timer_fn+0x320/0x320 [ 2169.726404] ? lock_downgrade+0x3a0/0x3a0 [ 2169.726820] ? kvm_clock_get_cycles+0x14/0x20 [ 2169.727257] ? ktime_get+0x92/0x150 [ 2169.727630] ? lapic_next_deadline+0x35/0x60 [ 2169.728069] run_timer_softirq+0x40/0x80 [ 2169.728475] __do_softirq+0x1a1/0x509 [ 2169.728866] irq_exit_rcu+0x95/0xc0 [ 2169.729241] sysvec_apic_timer_interrupt+0x6b/0x80 [ 2169.729718] </IRQ> [ 2169.729993] <TASK> [ 2169.730259] asm_sysvec_apic_timer_interrupt+0x16/0x20 [ 2169.730755] RIP: 0010:default_idle+0x13/0x20 [ 2169.731190] Code: c0 08 00 00 00 4d 29 c8 4c 01 c7 4c 29 c2 e9 72 ff ff ff cc cc cc cc 8b 05 9a 7f 1f 02 85 c0 7e 07 0f 00 2d cf 69 43 00 fb f4 <fa> c3 66 66 2e 0f 1f 84 00 00 00 00 00 65 48 8b 04 25 c0 93 04 00 [ 2169.732759] RSP: 0018:ffff888100dbfe10 EFLAGS: 00000242 [ 2169.733264] RAX: 0000000000000001 RBX: ffff888100d9c200 RCX: ffffffff8241bd62 [ 2169.733925] RDX: ffffed109a848b15 RSI: 0000000000000004 RDI: ffffffff8127ac55 [ 2169.734566] RBP: 0000000000000004 R08: 0000000000000000 R09: ffffed109a848b14 [ 2169.735200] R10: ffff8884d42458a3 R11: 000000000000ba7e R12: ffffffff83d7d3a0 [ 2169.735835] R13: 1ffff110201b7fc6 R14: 0000000000000000 R15: ffff888100d9c200 [ 2169.736478] ? ct_kernel_exit.constprop.0+0xa2/0xc0 [ 2169.736954] ? do_idle+0x285/0x290 [ 2169.737323] default_idle_call+0x63/0x90 [ 2169.737730] do_idle+0x285/0x290 [ 2169.738089] ? arch_cpu_idle_exit+0x30/0x30 [ 2169.738511] ? mark_held_locks+0x1a/0x80 [ 2169.738917] ? lockdep_hardirqs_on_prepare+0x12e/0x200 [ 2169.739417] cpu_startup_entry+0x30/0x40 [ 2169.739825] start_secondary+0x19a/0x1c0 [ 2169.740229] ? set_cpu_sibling_map+0xbd0/0xbd0 [ 2169.740673] secondary_startup_64_no_verify+0x15d/0x16b [ 2169.741179] </TASK> [ 2169.741686] Allocated by task 1098: [ 2169.742058] kasan_save_stack+0x1c/0x40 [ 2169.742456] kasan_save_track+0x10/0x30 [ 2169.742852] __kasan_kmalloc+0x83/0x90 [ 2169.743246] mlx5_dpll_probe+0xf5/0x3c0 [mlx5_dpll] [ 2169.743730] auxiliary_bus_probe+0x62/0xb0 [ 2169.744148] really_probe+0x127/0x590 [ 2169.744534] __driver_probe_device+0xd2/0x200 [ 2169.744973] device_driver_attach+0x6b/0xf0 [ 2169.745402] bind_store+0x90/0xe0 [ 2169.745761] kernfs_fop_write_iter+0x1df/0x2a0 [ 2169.746210] vfs_write+0x41f/0x790 [ 2169.746579] ksys_write+0xc7/0x160 [ 2169.746947] do_syscall_64+0x6f/0x140 [ 2169.747333] entry_SYSCALL_64_after_hwframe+0x46/0x4e [ 2169.748049] Freed by task 1220: [ 2169.748393] kasan_save_stack+0x1c/0x40 [ 2169.748789] kasan_save_track+0x10/0x30 [ 2169.749188] kasan_save_free_info+0x3b/0x50 [ 2169.749621] poison_slab_object+0x106/0x180 [ 2169.750044] __kasan_slab_free+0x14/0x50 [ 2169.750451] kfree+0x118/0x330 [ 2169.750792] mlx5_dpll_remove+0xf5/0x110 [mlx5_dpll] [ 2169.751271] auxiliary_bus_remove+0x2e/0x40 [ 2169.751694] device_release_driver_internal+0x24b/0x2e0 [ 2169.752191] unbind_store+0xa6/0xb0 [ 2169.752563] kernfs_fo ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-019851": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Use dynamic allocation for CU occupancy array in 'kfd_get_cu_occupancy()' The `kfd_get_cu_occupancy` function previously declared a large `cu_occupancy` array as a local variable, which could lead to stack overflows due to excessive stack usage. This commit replaces the static array allocation with dynamic memory allocation using `kcalloc`, thereby reducing the stack size. This change avoids the risk of stack overflows in kernel space, in scenarios where `AMDGPU_MAX_QUEUES` is large. The allocated memory is freed using `kfree` before the function returns to prevent memory leaks. Fixes the below with gcc W=1: drivers/gpu/drm/amd/amdgpu/../amdkfd/kfd_process.c: In function ‘kfd_get_cu_occupancy’: drivers/gpu/drm/amd/amdgpu/../amdkfd/kfd_process.c:322:1: warning: the frame size of 1056 bytes is larger than 1024 bytes [-Wframe-larger-than=] 322 | } | ^",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-019886": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: mpt3sas: Avoid test/set_bit() operating in non-allocated memory There is a potential out-of-bounds access when using test_bit() on a single word. The test_bit() and set_bit() functions operate on long values, and when testing or setting a single word, they can exceed the word boundary. KASAN detects this issue and produces a dump: BUG: KASAN: slab-out-of-bounds in _scsih_add_device.constprop.0 (./arch/x86/include/asm/bitops.h:60 ./include/asm-generic/bitops/instrumented-atomic.h:29 drivers/scsi/mpt3sas/mpt3sas_scsih.c:7331) mpt3sas Write of size 8 at addr ffff8881d26e3c60 by task kworker/u1536:2/2965 For full log, please look at [1]. Make the allocation at least the size of sizeof(unsigned long) so that set_bit() and test_bit() have sufficient room for read/write operations without overwriting unallocated memory. [1] Link: https://lore.kernel.org/all/ZkNcALr3W3KGYYJG@gmail.com/",
        "technologies": "Linux\nLinux Kernel 4.10 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-019472": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix a missing return value check bug In the smb2_send_interim_resp(), if ksmbd_alloc_work_struct() fails to allocate a node, it returns a NULL pointer to the in_work pointer. This can lead to an illegal memory write of in_work->response_buf when allocate_interim_rsp_buf() attempts to perform a kzalloc() on it. To address this issue, incorporating a check for the return value of ksmbd_alloc_work_struct() ensures that the function returns immediately upon allocation failure, thereby preventing the aforementioned illegal memory access.",
        "technologies": "Linux\nLinux Kernel 5.15.145 以上 5.16 未満\nLinux Kernel 6.1.71 以上 6.1.125 未満\nLinux Kernel 6.6 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-019594": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix array-index-out-of-bounds in dcn35_clkmgr [Why] There is a potential memory access violation while iterating through array of dcn35 clks. [How] Limit iteration per array size.",
        "technologies": "Linux\nLinux Kernel 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-019650": {
        "title": "Linux の Linux Kernel における初期化されていないポインタのアクセスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: exfat: fix the new buffer was not zeroed before writing Before writing, if a buffer_head marked as new, its data must be zeroed, otherwise uninitialized data in the page cache will be written. So this commit uses folio_zero_new_buffers() to zero the new buffers before ->write_end().",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-020001": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm: nv04: Fix out of bounds access When Output Resource (dcb->or) value is assigned in fabricate_dcb_output(), there may be out of bounds access to dac_users array in case dcb->or is zero because ffs(dcb->or) is used as index there. The 'or' argument of fabricate_dcb_output() must be interpreted as a number of bit to set, not value. Utilize macros from 'enum nouveau_or' in calls instead of hardcoding. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 2.6.38 以上 5.15.157 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-019853": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: sun8i-ce - Fix use after free in unprepare sun8i_ce_cipher_unprepare should be called before crypto_finalize_skcipher_request, because client callbacks may immediately free memory, that isn't needed anymore. But it will be used by unprepare after free. Before removing prepare/unprepare callbacks it was handled by crypto engine in crypto_finalize_request. Usually that results in a pointer dereference problem during a in crypto selftest. Unable to handle kernel NULL pointer dereference at virtual address 0000000000000030 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 user pgtable: 4k pages, 48-bit VAs, pgdp=000000004716d000 [0000000000000030] pgd=0000000000000000, p4d=0000000000000000 Internal error: Oops: 0000000096000004 [#1] SMP This problem is detected by KASAN as well. ================================================================== BUG: KASAN: slab-use-after-free in sun8i_ce_cipher_do_one+0x6e8/0xf80 [sun8i_ce] Read of size 8 at addr ffff00000dcdc040 by task 1c15000.crypto-/373 Hardware name: Pine64 PinePhone (1.2) (DT) Call trace: dump_backtrace+0x9c/0x128 show_stack+0x20/0x38 dump_stack_lvl+0x48/0x60 print_report+0xf8/0x5d8 kasan_report+0x90/0xd0 __asan_load8+0x9c/0xc0 sun8i_ce_cipher_do_one+0x6e8/0xf80 [sun8i_ce] crypto_pump_work+0x354/0x620 [crypto_engine] kthread_worker_fn+0x244/0x498 kthread+0x168/0x178 ret_from_fork+0x10/0x20 Allocated by task 379: kasan_save_stack+0x3c/0x68 kasan_set_track+0x2c/0x40 kasan_save_alloc_info+0x24/0x38 __kasan_kmalloc+0xd4/0xd8 __kmalloc+0x74/0x1d0 alg_test_skcipher+0x90/0x1f0 alg_test+0x24c/0x830 cryptomgr_test+0x38/0x60 kthread+0x168/0x178 ret_from_fork+0x10/0x20 Freed by task 379: kasan_save_stack+0x3c/0x68 kasan_set_track+0x2c/0x40 kasan_save_free_info+0x38/0x60 __kasan_slab_free+0x100/0x170 slab_free_freelist_hook+0xd4/0x1e8 __kmem_cache_free+0x15c/0x290 kfree+0x74/0x100 kfree_sensitive+0x80/0xb0 alg_test_skcipher+0x12c/0x1f0 alg_test+0x24c/0x830 cryptomgr_test+0x38/0x60 kthread+0x168/0x178 ret_from_fork+0x10/0x20 The buggy address belongs to the object at ffff00000dcdc000 which belongs to the cache kmalloc-256 of size 256 The buggy address is located 64 bytes inside of freed 256-byte region [ffff00000dcdc000, ffff00000dcdc100)",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-019887": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xfs: add bounds checking to xlog_recover_process_data There is a lack of verification of the space occupied by fixed members of xlog_op_header in the xlog_recover_process_data. We can create a crafted image to trigger an out of bounds read by following these steps: 1) Mount an image of xfs, and do some file operations to leave records 2) Before umounting, copy the image for subsequent steps to simulate abnormal exit. Because umount will ensure that tail_blk and head_blk are the same, which will result in the inability to enter xlog_recover_process_data 3) Write a tool to parse and modify the copied image in step 2 4) Make the end of the xlog_op_header entries only 1 byte away from xlog_rec_header->h_size 5) xlog_rec_header->h_num_logops++ 6) Modify xlog_rec_header->h_crc Fix: Add a check to make sure there is sufficient space to access fixed members of xlog_op_header.",
        "technologies": "Linux\nLinux Kernel 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11 未満"
    },
    "JVNDB-2024-019982": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Add a timeout to acquire the command queue semaphore Prevent forced completion handling on an entry that has not yet been assigned an index, causing an out of bounds access on idx = -22. Instead of waiting indefinitely for the sem, blocking flow now waits for index to be allocated or a sem acquisition timeout before beginning the timer for FW completion. Kernel log example: mlx5_core 0000:06:00.0: wait_func_handle_exec_timeout:1128:(pid 185911): cmd[-22]: CREATE_UCTX(0xa04) No done completion",
        "technologies": "Linux\nLinux Kernel 5.4.174 以上 5.5 未満\nLinux Kernel 5.10.94 以上 5.11 未満\nLinux Kernel 5.15.17 以上 5.16 未満\nLinux Kernel 5.16.3 から 6.1.93\nLinux Kernel 6.2 から 6.6.33\nLinux Kernel 6.7 から 6.8.12\nLinux Kernel 6.9 から 6.9.3"
    },
    "JVNDB-2024-020041": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Fix shift issue in ufshcd_clear_cmd() When task_tag >= 32 (in MCQ mode) and sizeof(unsigned int) == 4, 1U << task_tag will out of bounds for a u32 mask. Fix this up to prevent SHIFT_ISSUE (bitwise shifts that are out of bounds for their data type). [name:debug_monitors&]Unexpected kernel BRK exception at EL1 [name:traps&]Internal error: BRK handler: 00000000f2005514 [#1] PREEMPT SMP [name:mediatek_cpufreq_hw&]cpufreq stop DVFS log done [name:mrdump&]Kernel Offset: 0x1ba5800000 from 0xffffffc008000000 [name:mrdump&]PHYS_OFFSET: 0x80000000 [name:mrdump&]pstate: 22400005 (nzCv daif +PAN -UAO) [name:mrdump&]pc : [0xffffffdbaf52bb2c] ufshcd_clear_cmd+0x280/0x288 [name:mrdump&]lr : [0xffffffdbaf52a774] ufshcd_wait_for_dev_cmd+0x3e4/0x82c [name:mrdump&]sp : ffffffc0081471b0 <snip> Workqueue: ufs_eh_wq_0 ufshcd_err_handler Call trace: dump_backtrace+0xf8/0x144 show_stack+0x18/0x24 dump_stack_lvl+0x78/0x9c dump_stack+0x18/0x44 mrdump_common_die+0x254/0x480 [mrdump] ipanic_die+0x20/0x30 [mrdump] notify_die+0x15c/0x204 die+0x10c/0x5f8 arm64_notify_die+0x74/0x13c do_debug_exception+0x164/0x26c el1_dbg+0x64/0x80 el1h_64_sync_handler+0x3c/0x90 el1h_64_sync+0x68/0x6c ufshcd_clear_cmd+0x280/0x288 ufshcd_wait_for_dev_cmd+0x3e4/0x82c ufshcd_exec_dev_cmd+0x5bc/0x9ac ufshcd_verify_dev_init+0x84/0x1c8 ufshcd_probe_hba+0x724/0x1ce0 ufshcd_host_reset_and_restore+0x260/0x574 ufshcd_reset_and_restore+0x138/0xbd0 ufshcd_err_handler+0x1218/0x2f28 process_one_work+0x5fc/0x1140 worker_thread+0x7d8/0xe20 kthread+0x25c/0x468 ret_from_fork+0x10/0x20",
        "technologies": "Linux\nLinux Kernel 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020019": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jffs2: Prevent rtime decompress memory corruption The rtime decompression routine does not fully check bounds during the entirety of the decompression pass and can corrupt memory outside the decompression buffer if the compressed data is corrupted. This adds the required check to prevent this failure mode.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-020050": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: virtio/akcipher - Fix stack overflow on memcpy sizeof(struct virtio_crypto_akcipher_session_para) is less than sizeof(struct virtio_crypto_op_ctrl_req::u), copying more bytes from stack variable leads stack overflow. Clang reports this issue by commands: make -j CC=clang-14 mrproper >/dev/null 2>&1 make -j O=/tmp/crypto-build CC=clang-14 allmodconfig >/dev/null 2>&1 make -j O=/tmp/crypto-build W=1 CC=clang-14 drivers/crypto/virtio/ virtio_crypto_akcipher_algs.o",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.10.209 以上 5.10.212 未満\nLinux Kernel 5.18 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020043": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/srpt: Do not register event handler until srpt device is fully setup Upon rare occasions, KASAN reports a use-after-free Write in srpt_refresh_port(). This seems to be because an event handler is registered before the srpt device is fully setup and a race condition upon error may leave a partially setup event handler in place. Instead, only register the event handler after srpt device initialization is complete.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 3.3 以上 5.10.214 未満\nLinux Kernel 5.11 以上 5.15.153 未満\nLinux Kernel 5.16 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-020004": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sparx5: Fix use after free inside sparx5_del_mact_entry Based on the static analyzis of the code it looks like when an entry from the MAC table was removed, the entry was still used after being freed. More precise the vid of the mac_entry was used after calling devm_kfree on the mac_entry. The fix consists in first using the vid of the mac_entry to delete the entry from the HW and after that to free it.",
        "technologies": "Linux\nLinux Kernel 5.14 以上 5.15.152 未満\nLinux Kernel 5.16 以上 6.1.82 未満\nLinux Kernel 6.2 以上 6.6.22 未満\nLinux Kernel 6.7 以上 6.7.10 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020141": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hfsplus: don't query the device logical block size multiple times Devices block sizes may change. One of these cases is a loop device by using ioctl LOOP_SET_BLOCK_SIZE. While this may cause other issues like IO being rejected, in the case of hfsplus, it will allocate a block by using that size and potentially write out-of-bounds when hfsplus_read_wrapper calls hfsplus_submit_bio and the latter function reads a different io_size. Using a new min_io_size initally set to sb_min_blocksize works for the purposes of the original fix, since it will be set to the max between HFSPLUS_SECTOR_SIZE and the first seen logical block size. We still use the max between HFSPLUS_SECTOR_SIZE and min_io_size in case the latter is not initialized. Tested by mounting an hfsplus filesystem with loop block sizes 512, 1024 and 4096. The produced KASAN report before the fix looks like this: [ 419.944641] ================================================================== [ 419.945655] BUG: KASAN: slab-use-after-free in hfsplus_read_wrapper+0x659/0xa0a [ 419.946703] Read of size 2 at addr ffff88800721fc00 by task repro/10678 [ 419.947612] [ 419.947846] CPU: 0 UID: 0 PID: 10678 Comm: repro Not tainted 6.12.0-rc5-00008-gdf56e0f2f3ca #84 [ 419.949007] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 [ 419.950035] Call Trace: [ 419.950384] <TASK> [ 419.950676] dump_stack_lvl+0x57/0x78 [ 419.951212] ? hfsplus_read_wrapper+0x659/0xa0a [ 419.951830] print_report+0x14c/0x49e [ 419.952361] ? __virt_addr_valid+0x267/0x278 [ 419.952979] ? kmem_cache_debug_flags+0xc/0x1d [ 419.953561] ? hfsplus_read_wrapper+0x659/0xa0a [ 419.954231] kasan_report+0x89/0xb0 [ 419.954748] ? hfsplus_read_wrapper+0x659/0xa0a [ 419.955367] hfsplus_read_wrapper+0x659/0xa0a [ 419.955948] ? __pfx_hfsplus_read_wrapper+0x10/0x10 [ 419.956618] ? do_raw_spin_unlock+0x59/0x1a9 [ 419.957214] ? _raw_spin_unlock+0x1a/0x2e [ 419.957772] hfsplus_fill_super+0x348/0x1590 [ 419.958355] ? hlock_class+0x4c/0x109 [ 419.958867] ? __pfx_hfsplus_fill_super+0x10/0x10 [ 419.959499] ? __pfx_string+0x10/0x10 [ 419.960006] ? lock_acquire+0x3e2/0x454 [ 419.960532] ? bdev_name.constprop.0+0xce/0x243 [ 419.961129] ? __pfx_bdev_name.constprop.0+0x10/0x10 [ 419.961799] ? pointer+0x3f0/0x62f [ 419.962277] ? __pfx_pointer+0x10/0x10 [ 419.962761] ? vsnprintf+0x6c4/0xfba [ 419.963178] ? __pfx_vsnprintf+0x10/0x10 [ 419.963621] ? setup_bdev_super+0x376/0x3b3 [ 419.964029] ? snprintf+0x9d/0xd2 [ 419.964344] ? __pfx_snprintf+0x10/0x10 [ 419.964675] ? lock_acquired+0x45c/0x5e9 [ 419.965016] ? set_blocksize+0x139/0x1c1 [ 419.965381] ? sb_set_blocksize+0x6d/0xae [ 419.965742] ? __pfx_hfsplus_fill_super+0x10/0x10 [ 419.966179] mount_bdev+0x12f/0x1bf [ 419.966512] ? __pfx_mount_bdev+0x10/0x10 [ 419.966886] ? vfs_parse_fs_string+0xce/0x111 [ 419.967293] ? __pfx_vfs_parse_fs_string+0x10/0x10 [ 419.967702] ? __pfx_hfsplus_mount+0x10/0x10 [ 419.968073] legacy_get_tree+0x104/0x178 [ 419.968414] vfs_get_tree+0x86/0x296 [ 419.968751] path_mount+0xba3/0xd0b [ 419.969157] ? __pfx_path_mount+0x10/0x10 [ 419.969594] ? kmem_cache_free+0x1e2/0x260 [ 419.970311] do_mount+0x99/0xe0 [ 419.970630] ? __pfx_do_mount+0x10/0x10 [ 419.971008] __do_sys_mount+0x199/0x1c9 [ 419.971397] do_syscall_64+0xd0/0x135 [ 419.971761] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 419.972233] RIP: 0033:0x7c3cb812972e [ 419.972564] Code: 48 8b 0d f5 46 0d 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d c2 46 0d 00 f7 d8 64 89 01 48 [ 419.974371] RSP: 002b:00007ffe30632548 EFLAGS: 00000286 ORIG_RAX: 00000000000000a5 [ 419.975048] RAX: ffffffffffffffda RBX: 00007ffe306328d8 RCX: 00007c3cb812972e [ 419.975701] RDX: 0000000020000000 RSI: 0000000020000c80 RDI: ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.0.8 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020137": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: qat/qat_4xxx - fix off by one in uof_get_name() The fw_objs[] array has \"num_objs\" elements so the > needs to be >= to prevent an out of bounds read.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020210": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: rk3288 - Fix use after free in unprepare The unprepare call must be carried out before the finalize call as the latter can free the request.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020222": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: soc: qcom: socinfo: Avoid out of bounds read of serial number On MSM8916 devices, the serial number exposed in sysfs is constant and does not change across individual devices. It's always: db410c:/sys/devices/soc0$ cat serial_number 2644893864 The firmware used on MSM8916 exposes SOCINFO_VERSION(0, 8), which does not have support for the serial_num field in the socinfo struct. There is an existing check to avoid exposing the serial number in that case, but it's not correct: When checking the item_size returned by SMEM, we need to make sure the *end* of the serial_num is within bounds, instead of comparing with the *start* offset. The serial_number currently exposed on MSM8916 devices is just an out of bounds read of whatever comes after the socinfo struct in SMEM. Fix this by changing offsetof() to offsetofend(), so that the size of the field is also taken into account.",
        "technologies": "Linux\nLinux Kernel 5.4 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2024-020145": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Remove dangling pointers When an async control is written, we copy a pointer to the file handle that started the operation. That pointer will be used when the device is done. Which could be anytime in the future. If the user closes that file descriptor, its structure will be freed, and there will be one dangling pointer per pending async control, that the driver will try to use. Clean all the dangling pointers during release(). To avoid adding a performance penalty in the most common case (no async operation), a counter has been introduced with some logic to make sure that it is properly handled.",
        "technologies": "Linux\nLinux Kernel 4.19 以上 6.6.80 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2024-020135": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: check A-MSDU format more carefully If it looks like there's another subframe in the A-MSDU but the header isn't fully there, we can end up reading data out of bounds, only to discard later. Make this a bit more careful and check if the subframe header can even be present.",
        "technologies": "Linux\nLinux Kernel 6.6.27 未満\nLinux Kernel 6.7 以上 6.8.6 未満"
    },
    "JVNDB-2024-020149": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tunnels: fix out of bounds access when building IPv6 PMTU error If the ICMPv6 error is built from a non-linear skb we get the following splat, BUG: KASAN: slab-out-of-bounds in do_csum+0x220/0x240 Read of size 4 at addr ffff88811d402c80 by task netperf/820 CPU: 0 PID: 820 Comm: netperf Not tainted 6.8.0-rc1+ #543 ... kasan_report+0xd8/0x110 do_csum+0x220/0x240 csum_partial+0xc/0x20 skb_tunnel_check_pmtu+0xeb9/0x3280 vxlan_xmit_one+0x14c2/0x4080 vxlan_xmit+0xf61/0x5c00 dev_hard_start_xmit+0xfb/0x510 __dev_queue_xmit+0x7cd/0x32a0 br_dev_queue_push_xmit+0x39d/0x6a0 Use skb_checksum instead of csum_partial who cannot deal with non-linear SKBs.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.9 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.78 未満\nLinux Kernel 6.2 以上 6.6.17 未満\nLinux Kernel 6.7 以上 6.7.5 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020062": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: guard against invalid STA ID on removal Guard against invalid station IDs in iwl_mvm_mld_rm_sta_id as that would result in out-of-bounds array accesses. This prevents issues should the driver get into a bad state during error handling.",
        "technologies": "Linux\nLinux Kernel 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-020226": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Fix double free in error path If the uvc_status_init() function fails to allocate the int_urb, it will free the dev->status pointer but doesn't reset the pointer to NULL. This results in the kfree() call in uvc_status_cleanup() trying to double-free the memory. Fix it by resetting the dev->status pointer to NULL after freeing it. Reviewed by: Ricardo Ribalda <ribalda@chromium.org>",
        "technologies": "Linux\nLinux Kernel 2.6.28 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020255": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: binder: fix OOB in binder_add_freeze_work() In binder_add_freeze_work() we iterate over the proc->nodes with the proc->inner_lock held. However, this lock is temporarily dropped to acquire the node->lock first (lock nesting order). This can race with binder_deferred_release() which removes the nodes from the proc->nodes rbtree and adds them into binder_dead_nodes list. This leads to a broken iteration in binder_add_freeze_work() as rb_next() will use data from binder_dead_nodes, triggering an out-of-bounds access: ================================================================== BUG: KASAN: global-out-of-bounds in rb_next+0xfc/0x124 Read of size 8 at addr ffffcb84285f7170 by task freeze/660 CPU: 8 UID: 0 PID: 660 Comm: freeze Not tainted 6.11.0-07343-ga727812a8d45 #18 Hardware name: linux,dummy-virt (DT) Call trace: rb_next+0xfc/0x124 binder_add_freeze_work+0x344/0x534 binder_ioctl+0x1e70/0x25ac __arm64_sys_ioctl+0x124/0x190 The buggy address belongs to the variable: binder_dead_nodes+0x10/0x40 [...] ================================================================== This is possible because proc->nodes (rbtree) and binder_dead_nodes (list) share entries in binder_node through a union: struct binder_node { [...] union { struct rb_node rb_node; struct hlist_node dead_node; }; Fix the race by checking that the proc is still alive. If not, simply break out of the iteration.",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.4 未満"
    },
    "JVNDB-2024-020303": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: qat - validate slices count returned by FW The function adf_send_admin_tl_start() enables the telemetry (TL) feature on a QAT device by sending the ICP_QAT_FW_TL_START message to the firmware. This triggers the FW to start writing TL data to a DMA buffer in memory and returns an array containing the number of accelerators of each type (slices) supported by this HW. The pointer to this array is stored in the adf_tl_hw_data data structure called slice_cnt. The array slice_cnt is then used in the function tl_print_dev_data() to report in debugfs only statistics about the supported accelerators. An incorrect value of the elements in slice_cnt might lead to an out of bounds memory read. At the moment, there isn't an implementation of FW that returns a wrong value, but for robustness validate the slice count array returned by FW.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-020306": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Prevent out of bounds access in performance query extensions Check that the number of perfmons userspace is passing in the copy and reset extensions is not greater than the internal kernel storage where the ids will be copied into. (cherry picked from commit f32b5128d2c440368b5bf3a7a356823e235caabb)",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.10.4 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-020304": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: toshiba_acpi: Fix array out-of-bounds access In order to use toshiba_dmi_quirks[] together with the standard DMI matching functions, it must be terminated by a empty entry. Since this entry is missing, an array out-of-bounds access occurs every time the quirk list is processed. Fix this by adding the terminating empty entry.",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.1.100 未満\nLinux Kernel 6.2 以上 6.6.41 未満\nLinux Kernel 6.7 以上 6.9.10 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-020372": {
        "title": "Linux の Linux Kernel における境界条件の判定に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7925: fix off by one in mt7925_load_clc() This comparison should be >= instead of > to prevent an out of bounds read and write.",
        "technologies": "Linux\nLinux Kernel 6.10.13 以上 6.11 未満\nLinux Kernel 6.11.2 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020398": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mailbox: th1520: Fix memory corruption due to incorrect array size The functions th1520_mbox_suspend_noirq and th1520_mbox_resume_noirq are intended to save and restore the interrupt mask registers in the MBOX ICU0. However, the array used to store these registers was incorrectly sized, leading to memory corruption when accessing all four registers. This commit corrects the array size to accommodate all four interrupt mask registers, preventing memory corruption during suspend and resume operations.",
        "technologies": "Linux\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020489": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: cachestat: fix folio read-after-free in cache walk In cachestat, we access the folio from the page cache's xarray to compute its page offset, and check for its dirty and writeback flags. However, we do not hold a reference to the folio before performing these actions, which means the folio can concurrently be released and reused as another folio/page/slab. Get around this altogether by just using xarray's existing machinery for the folio page offsets and dirty/writeback states. This changes behavior for tmpfs files to now always report zeroes in their dirty and writeback counters. This is okay as tmpfs doesn't follow conventional writeback cache behavior: its pages get \"cleaned\" during swapout, after which they're no longer resident etc.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.21 未満\nLinux Kernel 6.7 以上 6.7.9 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020399": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix read pointer after free in ath12k_mac_assign_vif_to_vdev() In ath12k_mac_assign_vif_to_vdev(), if arvif is created on a different radio, it gets deleted from that radio through a call to ath12k_mac_unassign_link_vif(). This action frees the arvif pointer. Subsequently, there is a check involving arvif, which will result in a read-after-free scenario. Fix this by moving this check after arvif is again assigned via call to ath12k_mac_assign_link_vif(). Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.13.2 未満"
    },
    "JVNDB-2024-020391": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xfrm: state: fix out-of-bounds read during lookup lookup and resize can run in parallel. The xfrm_state_hash_generation seqlock ensures a retry, but the hash functions can observe a hmask value that is too large for the new hlist array. rehash does: rcu_assign_pointer(net->xfrm.state_bydst, ndst) [..] net->xfrm.state_hmask = nhashmask; While state lookup does: h = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family); hlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) { This is only safe in case the update to state_bydst is larger than net->xfrm.xfrm_state_hmask (or if the lookup function gets serialized via state spinlock again). Fix this by prefetching state_hmask and the associated pointers. The xfrm_state_hash_generation seqlock retry will ensure that the pointer and the hmask will be consistent. The existing helpers, like xfrm_dst_hash(), are now unsafe for RCU side, add lockdep assertions to document that they are only safe for insert side. xfrm_state_lookup_byaddr() uses the spinlock rather than RCU. AFAICS this is an oversight from back when state lookup was converted to RCU, this lock should be replaced with RCU in a future patch.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020470": {
        "title": "Linux の Linux Kernel におけるリソースのロックに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix racy issue from session lookup and expire Increment the session reference count within the lock for lookup to avoid racy issue with session expire.",
        "technologies": "Linux\nLinux Kernel 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.121 未満\nLinux Kernel 6.2 以上 6.6.67 未満\nLinux Kernel 6.7 以上 6.12.6 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-020384": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab-out-of-bounds in smb_strndup_from_utf16() If ->NameOffset of smb2_create_req is smaller than Buffer offset of smb2_create_req, slab-out-of-bounds read can happen from smb2_open. This patch set the minimum value of the name offset to the buffer offset to validate name length of smb2_create_req().",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.119 未満\nLinux Kernel 6.2 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-020382": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Squashfs: check the inode number is not the invalid value of zero Syskiller has produced an out of bounds access in fill_meta_index(). That out of bounds access is ultimately caused because the inode has an inode number with the invalid value of zero, which was not checked. The reason this causes the out of bounds access is due to following sequence of events: 1. Fill_meta_index() is called to allocate (via empty_meta_index()) and fill a metadata index. It however suffers a data read error and aborts, invalidating the newly returned empty metadata index. It does this by setting the inode number of the index to zero, which means unused (zero is not a valid inode number). 2. When fill_meta_index() is subsequently called again on another read operation, locate_meta_index() returns the previous index because it matches the inode number of 0. Because this index has been returned it is expected to have been filled, and because it hasn't been, an out of bounds access is performed. This patch adds a sanity check which checks that the inode number is not zero when the inode is created and returns -EINVAL if it is. [phillip@squashfs.org.uk: whitespace fix]",
        "technologies": "Linux\nLinux Kernel 6.6.30 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-020610": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (nct6775) Fix access to temperature configuration registers The number of temperature configuration registers does not always match the total number of temperature registers. This can result in access errors reported if KASAN is enabled. BUG: KASAN: global-out-of-bounds in nct6775_probe+0x5654/0x6fe9 nct6775_core",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.6.19\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020604": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_ct: sanitize layer 3 and 4 protocol number in custom expectations - Disallow families other than NFPROTO_{IPV4,IPV6,INET}. - Disallow layer 4 protocol with no ports, since destination port is a mandatory attribute for this object.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 5.3 以上 5.4.269 未満\nLinux Kernel 5.5 以上 5.10.210 未満\nLinux Kernel 5.11 以上 5.15.149 未満\nLinux Kernel 5.16 以上 6.1.77 未満\nLinux Kernel 6.2 以上 6.6.16 未満\nLinux Kernel 6.7 以上 6.7.4 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020624": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/lib: Revert to _ASM_EXTABLE_UA() for {get,put}_user() fixups During memory error injection test on kernels >= v6.4, the kernel panics like below. However, this issue couldn't be reproduced on kernels <= v6.3. mce: [Hardware Error]: CPU 296: Machine Check Exception: f Bank 1: bd80000000100134 mce: [Hardware Error]: RIP 10:<ffffffff821b9776> {__get_user_nocheck_4+0x6/0x20} mce: [Hardware Error]: TSC 411a93533ed ADDR 346a8730040 MISC 86 mce: [Hardware Error]: PROCESSOR 0:a06d0 TIME 1706000767 SOCKET 1 APIC 211 microcode 80001490 mce: [Hardware Error]: Run the above through 'mcelog --ascii' mce: [Hardware Error]: Machine check: Data load in unrecoverable area of kernel Kernel panic - not syncing: Fatal local machine check The MCA code can recover from an in-kernel #MC if the fixup type is EX_TYPE_UACCESS, explicitly indicating that the kernel is attempting to access userspace memory. However, if the fixup type is EX_TYPE_DEFAULT the only thing that is raised for an in-kernel #MC is a panic. ex_handler_uaccess() would warn if users gave a non-canonical addresses (with bit 63 clear) to {get, put}_user(), which was unexpected. Therefore, commit b19b74bc99b1 (\"x86/mm: Rework address range check in get_user() and put_user()\") replaced _ASM_EXTABLE_UA() with _ASM_EXTABLE() for {get, put}_user() fixups. However, the new fixup type EX_TYPE_DEFAULT results in a panic. Commit 6014bc27561f (\"x86-64: make access_ok() independent of LAM\") added the check gp_fault_address_ok() right before the WARN_ONCE() in ex_handler_uaccess() to not warn about non-canonical user addresses due to LAM. With that in place, revert back to _ASM_EXTABLE_UA() for {get,put}_user() exception fixups in order to be able to handle in-kernel MCEs correctly again. [ bp: Massage commit message. ]",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.17 未満\nLinux Kernel 6.7 以上 6.7.5 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020615": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm-crypt: don't modify the data when using authenticated encryption It was said that authenticated encryption could produce invalid tag when the data that is being encrypted is modified [1]. So, fix this problem by copying the data into the clone bio first and then encrypt them inside the clone bio. This may reduce performance, but it is needed to prevent the user from corrupting the device by writing data with O_DIRECT and modifying them at the same time. [1] https://lore.kernel.org/all/20240207004723.GA35324@sol.localdomain/T/",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19.308 未満\nLinux Kernel 4.20 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.211 未満\nLinux Kernel 5.11 以上 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020612": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: afs: Increase buffer size in afs_update_volume_status() The max length of volume->vid value is 20 characters. So increase idbuf[] size up to 24 to avoid overflow. Found by Linux Verification Center (linuxtesting.org) with SVACE. [DH: Actually, it's 20 + NUL, so increase it to 24 and use snprintf()]",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.15 以上 5.4.270 未満\nLinux Kernel 5.5 以上 5.10.211 未満\nLinux Kernel 5.11 以上 5.15.150 未満\nLinux Kernel 5.16 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020668": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: hwmon: (coretemp) Fix out-of-bounds memory access Fix a bug that pdata->cpu_map[] is set before out-of-bounds check. The problem might be triggered on systems with more than 128 cores per package.",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19.264 以上 4.19.307 未満\nLinux Kernel 5.4.221 以上 5.4.269 未満\nLinux Kernel 5.10.152 以上 5.10.210 未満\nLinux Kernel 6.1 以上 6.1.78 未満\nLinux Kernel 6.2 以上 6.6.17 未満\nLinux Kernel 6.7 以上 6.7.5 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020726": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: memory: tegra20-emc: fix an OF node reference bug in tegra_emc_find_node_by_ram_code() As of_find_node_by_name() release the reference of the argument device node, tegra_emc_find_node_by_ram_code() releases some device nodes while still in use, resulting in possible UAFs. According to the bindings and the in-tree DTS files, the \"emc-tables\" node is always device's child node with the property \"nvidia,use-ram-code\", and the \"lpddr2\" node is a child of the \"emc-tables\" node. Thus utilize the for_each_child_of_node() macro and of_get_child_by_name() instead of of_find_node_by_name() to simplify the code. This bug was found by an experimental verification tool that I am developing. [krzysztof: applied v1, adjust the commit msg to incorporate v2 parts]",
        "technologies": "Linux\nLinux Kernel 5.0 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020744": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Add some bounds checking to firmware data Smatch complains about \"head->full_size - head->header_size\" can underflow. To some extent, we're always going to have to trust the firmware a bit. However, it's easy enough to add a check for negatives, and let's add a upper bounds check as well.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.83 未満\nLinux Kernel 6.2 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-020743": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/ipv6: avoid possible UAF in ip6_route_mpath_notify() syzbot found another use-after-free in ip6_route_mpath_notify() [1] Commit f7225172f25a (\"net/ipv6: prevent use after free in ip6_route_mpath_notify\") was not able to fix the root cause. We need to defer the fib6_info_release() calls after ip6_route_mpath_notify(), in the cleanup phase. [1] BUG: KASAN: slab-use-after-free in rt6_fill_node+0x1460/0x1ac0 Read of size 4 at addr ffff88809a07fc64 by task syz-executor.2/23037 CPU: 0 PID: 23037 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-01035-gea7f3cfaa588 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x1e7/0x2e0 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:377 [inline] print_report+0x167/0x540 mm/kasan/report.c:488 kasan_report+0x142/0x180 mm/kasan/report.c:601 rt6_fill_node+0x1460/0x1ac0 inet6_rt_notify+0x13b/0x290 net/ipv6/route.c:6184 ip6_route_mpath_notify net/ipv6/route.c:5198 [inline] ip6_route_multipath_add net/ipv6/route.c:5404 [inline] inet6_rtm_newroute+0x1d0f/0x2300 net/ipv6/route.c:5517 rtnetlink_rcv_msg+0x885/0x1040 net/core/rtnetlink.c:6597 netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543 netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline] netlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367 netlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:745 ____sys_sendmsg+0x525/0x7d0 net/socket.c:2584 ___sys_sendmsg net/socket.c:2638 [inline] __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667 do_syscall_64+0xf9/0x240 entry_SYSCALL_64_after_hwframe+0x6f/0x77 RIP: 0033:0x7f73dd87dda9 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f73de6550c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f73dd9ac050 RCX: 00007f73dd87dda9 RDX: 0000000000000000 RSI: 0000000020000140 RDI: 0000000000000005 RBP: 00007f73dd8ca47a R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 000000000000006e R14: 00007f73dd9ac050 R15: 00007ffdbdeb7858 </TASK> Allocated by task 23037: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:372 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:389 kasan_kmalloc include/linux/kasan.h:211 [inline] __do_kmalloc_node mm/slub.c:3981 [inline] __kmalloc+0x22e/0x490 mm/slub.c:3994 kmalloc include/linux/slab.h:594 [inline] kzalloc include/linux/slab.h:711 [inline] fib6_info_alloc+0x2e/0xf0 net/ipv6/ip6_fib.c:155 ip6_route_info_create+0x445/0x12b0 net/ipv6/route.c:3758 ip6_route_multipath_add net/ipv6/route.c:5298 [inline] inet6_rtm_newroute+0x744/0x2300 net/ipv6/route.c:5517 rtnetlink_rcv_msg+0x885/0x1040 net/core/rtnetlink.c:6597 netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543 netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline] netlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367 netlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:745 ____sys_sendmsg+0x525/0x7d0 net/socket.c:2584 ___sys_sendmsg net/socket.c:2638 [inline] __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667 do_syscall_64+0xf9/0x240 entry_SYSCALL_64_after_hwframe+0x6f/0x77 Freed by task 16: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x4e/0x60 mm/kasan/generic.c:640 poison_slab_object+0xa6/0xe0 m ---truncated---",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.11 以上 4.19.310 未満\nLinux Kernel 4.20 以上 5.4.272 未満\nLinux Kernel 5.5 以上 5.10.213 未満\nLinux Kernel 5.11 以上 5.15.152 未満\nLinux Kernel 5.16 以上 6.1.82 未満\nLinux Kernel 6.2 以上 6.6.22 未満\nLinux Kernel 6.7 以上 6.7.10 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020857": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fsnotify: Fix ordering of iput() and watched_objects decrement Ensure the superblock is kept alive until we're done with iput(). Holding a reference to an inode is not allowed unless we ensure the superblock stays alive, which fsnotify does by keeping the watched_objects count elevated, so iput() must happen before the watched_objects decrement. This can lead to a UAF of something like sb->s_fs_info in tmpfs, but the UAF is hard to hit because race orderings that oops are more likely, thanks to the CHECK_DATA_CORRUPTION() block in generic_shutdown_super(). Also, ensure that fsnotify_put_sb_watched_objects() doesn't call fsnotify_sb_watched_objects() on a superblock that may have already been freed, which would cause a UAF read of sb->s_fsnotify_info.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020784": {
        "title": "Linux の Linux Kernel における NULL ポインタデリファレンスに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ice: fix uninitialized dplls mutex usage The pf->dplls.lock mutex is initialized too late, after its first use. Move it to the top of ice_dpll_init. Note that the \"err_exit\" error path destroys the mutex. And the mutex is the last thing destroyed in ice_dpll_deinit. This fixes the following warning with CONFIG_DEBUG_MUTEXES: ice 0000:10:00.0: The DDP package was successfully loaded: ICE OS Default Package version 1.3.36.0 ice 0000:10:00.0: 252.048 Gb/s available PCIe bandwidth (16.0 GT/s PCIe x16 link) ice 0000:10:00.0: PTP init successful ------------[ cut here ]------------ DEBUG_LOCKS_WARN_ON(lock->magic != lock) WARNING: CPU: 0 PID: 410 at kernel/locking/mutex.c:587 __mutex_lock+0x773/0xd40 Modules linked in: crct10dif_pclmul crc32_pclmul crc32c_intel polyval_clmulni polyval_generic ice(+) nvme nvme_c> CPU: 0 PID: 410 Comm: kworker/0:4 Not tainted 6.8.0-rc5+ #3 Hardware name: HPE ProLiant DL110 Gen10 Plus/ProLiant DL110 Gen10 Plus, BIOS U56 10/19/2023 Workqueue: events work_for_cpu_fn RIP: 0010:__mutex_lock+0x773/0xd40 Code: c0 0f 84 1d f9 ff ff 44 8b 35 0d 9c 69 01 45 85 f6 0f 85 0d f9 ff ff 48 c7 c6 12 a2 a9 85 48 c7 c7 12 f1 a> RSP: 0018:ff7eb1a3417a7ae0 EFLAGS: 00010286 RAX: 0000000000000000 RBX: 0000000000000002 RCX: 0000000000000000 RDX: 0000000000000002 RSI: ffffffff85ac2bff RDI: 00000000ffffffff RBP: ff7eb1a3417a7b80 R08: 0000000000000000 R09: 00000000ffffbfff R10: ff7eb1a3417a7978 R11: ff32b80f7fd2e568 R12: 0000000000000000 R13: 0000000000000000 R14: 0000000000000000 R15: ff32b7f02c50e0d8 FS: 0000000000000000(0000) GS:ff32b80efe800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055b5852cc000 CR3: 000000003c43a004 CR4: 0000000000771ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> ? __warn+0x84/0x170 ? __mutex_lock+0x773/0xd40 ? report_bug+0x1c7/0x1d0 ? prb_read_valid+0x1b/0x30 ? handle_bug+0x42/0x70 ? exc_invalid_op+0x18/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? __mutex_lock+0x773/0xd40 ? rcu_is_watching+0x11/0x50 ? __kmalloc_node_track_caller+0x346/0x490 ? ice_dpll_lock_status_get+0x28/0x50 [ice] ? __pfx_ice_dpll_lock_status_get+0x10/0x10 [ice] ? ice_dpll_lock_status_get+0x28/0x50 [ice] ice_dpll_lock_status_get+0x28/0x50 [ice] dpll_device_get_one+0x14f/0x2e0 dpll_device_event_send+0x7d/0x150 dpll_device_register+0x124/0x180 ice_dpll_init_dpll+0x7b/0xd0 [ice] ice_dpll_init+0x224/0xa40 [ice] ? _dev_info+0x70/0x90 ice_load+0x468/0x690 [ice] ice_probe+0x75b/0xa10 [ice] ? _raw_spin_unlock_irqrestore+0x4f/0x80 ? process_one_work+0x1a3/0x500 local_pci_probe+0x47/0xa0 work_for_cpu_fn+0x17/0x30 process_one_work+0x20d/0x500 worker_thread+0x1df/0x3e0 ? __pfx_worker_thread+0x10/0x10 kthread+0x103/0x140 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK> irq event stamp: 125197 hardirqs last enabled at (125197): [<ffffffff8416409d>] finish_task_switch.isra.0+0x12d/0x3d0 hardirqs last disabled at (125196): [<ffffffff85134044>] __schedule+0xea4/0x19f0 softirqs last enabled at (105334): [<ffffffff84e1e65a>] napi_get_frags_check+0x1a/0x60 softirqs last disabled at (105332): [<ffffffff84e1e65a>] napi_get_frags_check+0x1a/0x60 ---[ end trace 0000000000000000 ]---",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.7.10 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020790": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: flower: Fix chain template offload When a qdisc is deleted from a net device the stack instructs the underlying driver to remove its flow offload callback from the associated filter block using the 'FLOW_BLOCK_UNBIND' command. The stack then continues to replay the removal of the filters in the block for this driver by iterating over the chains in the block and invoking the 'reoffload' operation of the classifier being used. In turn, the classifier in its 'reoffload' operation prepares and emits a 'FLOW_CLS_DESTROY' command for each filter. However, the stack does not do the same for chain templates and the underlying driver never receives a 'FLOW_CLS_TMPLT_DESTROY' command when a qdisc is deleted. This results in a memory leak [1] which can be reproduced using [2]. Fix by introducing a 'tmplt_reoffload' operation and have the stack invoke it with the appropriate arguments as part of the replay. Implement the operation in the sole classifier that supports chain templates (flower) by emitting the 'FLOW_CLS_TMPLT_{CREATE,DESTROY}' command based on whether a flow offload callback is being bound to a filter block or being unbound from one. As far as I can tell, the issue happens since cited commit which reordered tcf_block_offload_unbind() before tcf_block_flush_all_chains() in __tcf_block_put(). The order cannot be reversed as the filter block is expected to be freed after flushing all the chains. [1] unreferenced object 0xffff888107e28800 (size 2048): comm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s) hex dump (first 32 bytes): b1 a6 7c 11 81 88 ff ff e0 5b b3 10 81 88 ff ff ..|......[...... 01 00 00 00 00 00 00 00 e0 aa b0 84 ff ff ff ff ................ backtrace: [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320 [<ffffffff81ab374e>] __kmalloc+0x4e/0x90 [<ffffffff832aec6d>] mlxsw_sp_acl_ruleset_get+0x34d/0x7a0 [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180 [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280 [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340 [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0 [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170 [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0 [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440 [<ffffffff83ac6270>] netlink_unicast+0x540/0x820 [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0 [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80 [<ffffffff8379d29a>] ___sys_sendmsg+0x13a/0x1e0 [<ffffffff8379d50c>] __sys_sendmsg+0x11c/0x1f0 [<ffffffff843b9ce0>] do_syscall_64+0x40/0xe0 unreferenced object 0xffff88816d2c0400 (size 1024): comm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s) hex dump (first 32 bytes): 40 00 00 00 00 00 00 00 57 f6 38 be 00 00 00 00 @.......W.8..... 10 04 2c 6d 81 88 ff ff 10 04 2c 6d 81 88 ff ff ..,m......,m.... backtrace: [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320 [<ffffffff81ab36c1>] __kmalloc_node+0x51/0x90 [<ffffffff81a8ed96>] kvmalloc_node+0xa6/0x1f0 [<ffffffff82827d03>] bucket_table_alloc.isra.0+0x83/0x460 [<ffffffff82828d2b>] rhashtable_init+0x43b/0x7c0 [<ffffffff832aed48>] mlxsw_sp_acl_ruleset_get+0x428/0x7a0 [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180 [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280 [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340 [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0 [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170 [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0 [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440 [<ffffffff83ac6270>] netlink_unicast+0x540/0x820 [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0 [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80 [2] # tc qdisc add dev swp1 clsact # tc chain add dev swp1 ingress proto ip chain 1 flower dst_ip 0.0.0.0/32 # tc qdisc del dev ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.1 以上 6.6.15 未満\nLinux Kernel 6.7 以上 6.7.3 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020799": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: smartpqi: Fix disable_managed_interrupts Correct blk-mq registration issue with module parameter disable_managed_interrupts enabled. When we turn off the default PCI_IRQ_AFFINITY flag, the driver needs to register with blk-mq using blk_mq_map_queues(). The driver is currently calling blk_mq_pci_map_queues() which results in a stack trace and possibly undefined behavior. Stack Trace: [ 7.860089] scsi host2: smartpqi [ 7.871934] WARNING: CPU: 0 PID: 238 at block/blk-mq-pci.c:52 blk_mq_pci_map_queues+0xca/0xd0 [ 7.889231] Modules linked in: sd_mod t10_pi sg uas smartpqi(+) crc32c_intel scsi_transport_sas usb_storage dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler fuse [ 7.924755] CPU: 0 PID: 238 Comm: kworker/0:3 Not tainted 4.18.0-372.88.1.el8_6_smartpqi_test.x86_64 #1 [ 7.944336] Hardware name: HPE ProLiant DL380 Gen10/ProLiant DL380 Gen10, BIOS U30 03/08/2022 [ 7.963026] Workqueue: events work_for_cpu_fn [ 7.978275] RIP: 0010:blk_mq_pci_map_queues+0xca/0xd0 [ 7.978278] Code: 48 89 de 89 c7 e8 f6 0f 4f 00 3b 05 c4 b7 8e 01 72 e1 5b 31 c0 5d 41 5c 41 5d 41 5e 41 5f e9 7d df 73 00 31 c0 e9 76 df 73 00 <0f> 0b eb bc 90 90 0f 1f 44 00 00 41 57 49 89 ff 41 56 41 55 41 54 [ 7.978280] RSP: 0018:ffffa95fc3707d50 EFLAGS: 00010216 [ 7.978283] RAX: 00000000ffffffff RBX: 0000000000000000 RCX: 0000000000000010 [ 7.978284] RDX: 0000000000000004 RSI: 0000000000000000 RDI: ffff9190c32d4310 [ 7.978286] RBP: 0000000000000000 R08: ffffa95fc3707d38 R09: ffff91929b81ac00 [ 7.978287] R10: 0000000000000001 R11: ffffa95fc3707ac0 R12: 0000000000000000 [ 7.978288] R13: ffff9190c32d4000 R14: 00000000ffffffff R15: ffff9190c4c950a8 [ 7.978290] FS: 0000000000000000(0000) GS:ffff9193efc00000(0000) knlGS:0000000000000000 [ 7.978292] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 8.172814] CR2: 000055d11166c000 CR3: 00000002dae10002 CR4: 00000000007706f0 [ 8.172816] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 8.172817] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 8.172818] PKRU: 55555554 [ 8.172819] Call Trace: [ 8.172823] blk_mq_alloc_tag_set+0x12e/0x310 [ 8.264339] scsi_add_host_with_dma.cold.9+0x30/0x245 [ 8.279302] pqi_ctrl_init+0xacf/0xc8e [smartpqi] [ 8.294085] ? pqi_pci_probe+0x480/0x4c8 [smartpqi] [ 8.309015] pqi_pci_probe+0x480/0x4c8 [smartpqi] [ 8.323286] local_pci_probe+0x42/0x80 [ 8.337855] work_for_cpu_fn+0x16/0x20 [ 8.351193] process_one_work+0x1a7/0x360 [ 8.364462] ? create_worker+0x1a0/0x1a0 [ 8.379252] worker_thread+0x1ce/0x390 [ 8.392623] ? create_worker+0x1a0/0x1a0 [ 8.406295] kthread+0x10a/0x120 [ 8.418428] ? set_kthread_struct+0x50/0x50 [ 8.431532] ret_from_fork+0x1f/0x40 [ 8.444137] ---[ end trace 1bf0173d39354506 ]---",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.80 未満\nLinux Kernel 6.2 以上 6.6.19 未満\nLinux Kernel 6.7 以上 6.7.7 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020789": {
        "title": "Linux の Linux Kernel におけるゼロ除算に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: iaa - Fix nr_cpus < nr_iaa case If nr_cpus < nr_iaa, the calculated cpus_per_iaa will be 0, which causes a divide-by-0 in rebalance_wq_table(). Make sure cpus_per_iaa is 1 in that case, and also in the nr_iaa == 0 case, even though cpus_per_iaa is never used if nr_iaa == 0, for paranoia.",
        "technologies": "Linux\nLinux Kernel 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-020860": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/siw: Remove direct link to net_device Do not manage a per device direct link to net_device. Rely on associated ib_devices net_device management, not doubling the effort locally. A badly managed local link to net_device was causing a 'KASAN: slab-use-after-free' exception during siw_query_port() call.",
        "technologies": "Linux\nLinux Kernel 5.3 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-020859": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: release svc_expkey/svc_export with rcu_work The last reference for `cache_head` can be reduced to zero in `c_show` and `e_show`(using `rcu_read_lock` and `rcu_read_unlock`). Consequently, `svc_export_put` and `expkey_put` will be invoked, leading to two issues: 1. The `svc_export_put` will directly free ex_uuid. However, `e_show`/`c_show` will access `ex_uuid` after `cache_put`, which can trigger a use-after-free issue, shown below. ================================================================== BUG: KASAN: slab-use-after-free in svc_export_show+0x362/0x430 [nfsd] Read of size 1 at addr ff11000010fdc120 by task cat/870 CPU: 1 UID: 0 PID: 870 Comm: cat Not tainted 6.12.0-rc3+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x53/0x70 print_address_description.constprop.0+0x2c/0x3a0 print_report+0xb9/0x280 kasan_report+0xae/0xe0 svc_export_show+0x362/0x430 [nfsd] c_show+0x161/0x390 [sunrpc] seq_read_iter+0x589/0x770 seq_read+0x1e5/0x270 proc_reg_read+0xe1/0x140 vfs_read+0x125/0x530 ksys_read+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Allocated by task 830: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 __kmalloc_node_track_caller_noprof+0x1bc/0x400 kmemdup_noprof+0x22/0x50 svc_export_parse+0x8a9/0xb80 [nfsd] cache_do_downcall+0x71/0xa0 [sunrpc] cache_write_procfs+0x8e/0xd0 [sunrpc] proc_reg_write+0xe1/0x140 vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 868: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x37/0x50 kfree+0xf3/0x3e0 svc_export_put+0x87/0xb0 [nfsd] cache_purge+0x17f/0x1f0 [sunrpc] nfsd_destroy_serv+0x226/0x2d0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e 2. We cannot sleep while using `rcu_read_lock`/`rcu_read_unlock`. However, `svc_export_put`/`expkey_put` will call path_put, which subsequently triggers a sleeping operation due to the following `dput`. ============================= WARNING: suspicious RCU usage 5.10.0-dirty #141 Not tainted ----------------------------- ... Call Trace: dump_stack+0x9a/0xd0 ___might_sleep+0x231/0x240 dput+0x39/0x600 path_put+0x1b/0x30 svc_export_put+0x17/0x80 e_show+0x1c9/0x200 seq_read_iter+0x63f/0x7c0 seq_read+0x226/0x2d0 vfs_read+0x113/0x2c0 ksys_read+0xc9/0x170 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Fix these issues by using `rcu_work` to help release `svc_expkey`/`svc_export`. This approach allows for an asynchronous context to invoke `path_put` and also facilitates the freeing of `uuid/exp/key` after an RCU grace period.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020871": {
        "title": "Linux の Linux Kernel 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/zcrypt: fix reference counting on zcrypt card objects Tests with hot-plugging crytpo cards on KVM guests with debug kernel build revealed an use after free for the load field of the struct zcrypt_card. The reason was an incorrect reference handling of the zcrypt card object which could lead to a free of the zcrypt card object while it was still in use. This is an example of the slab message: kernel: 0x00000000885a7512-0x00000000885a7513 @offset=1298. First byte 0x68 instead of 0x6b kernel: Allocated in zcrypt_card_alloc+0x36/0x70 [zcrypt] age=18046 cpu=3 pid=43 kernel: kmalloc_trace+0x3f2/0x470 kernel: zcrypt_card_alloc+0x36/0x70 [zcrypt] kernel: zcrypt_cex4_card_probe+0x26/0x380 [zcrypt_cex4] kernel: ap_device_probe+0x15c/0x290 kernel: really_probe+0xd2/0x468 kernel: driver_probe_device+0x40/0xf0 kernel: __device_attach_driver+0xc0/0x140 kernel: bus_for_each_drv+0x8c/0xd0 kernel: __device_attach+0x114/0x198 kernel: bus_probe_device+0xb4/0xc8 kernel: device_add+0x4d2/0x6e0 kernel: ap_scan_adapter+0x3d0/0x7c0 kernel: ap_scan_bus+0x5a/0x3b0 kernel: ap_scan_bus_wq_callback+0x40/0x60 kernel: process_one_work+0x26e/0x620 kernel: worker_thread+0x21c/0x440 kernel: Freed in zcrypt_card_put+0x54/0x80 [zcrypt] age=9024 cpu=3 pid=43 kernel: kfree+0x37e/0x418 kernel: zcrypt_card_put+0x54/0x80 [zcrypt] kernel: ap_device_remove+0x4c/0xe0 kernel: device_release_driver_internal+0x1c4/0x270 kernel: bus_remove_device+0x100/0x188 kernel: device_del+0x164/0x3c0 kernel: device_unregister+0x30/0x90 kernel: ap_scan_adapter+0xc8/0x7c0 kernel: ap_scan_bus+0x5a/0x3b0 kernel: ap_scan_bus_wq_callback+0x40/0x60 kernel: process_one_work+0x26e/0x620 kernel: worker_thread+0x21c/0x440 kernel: kthread+0x150/0x168 kernel: __ret_from_fork+0x3c/0x58 kernel: ret_from_fork+0xa/0x30 kernel: Slab 0x00000372022169c0 objects=20 used=18 fp=0x00000000885a7c88 flags=0x3ffff00000000a00(workingset|slab|node=0|zone=1|lastcpupid=0x1ffff) kernel: Object 0x00000000885a74b8 @offset=1208 fp=0x00000000885a7c88 kernel: Redzone 00000000885a74b0: bb bb bb bb bb bb bb bb ........ kernel: Object 00000000885a74b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel: Object 00000000885a74c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel: Object 00000000885a74d8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel: Object 00000000885a74e8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel: Object 00000000885a74f8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk kernel: Object 00000000885a7508: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 68 4b 6b 6b 6b a5 kkkkkkkkkkhKkkk. kernel: Redzone 00000000885a7518: bb bb bb bb bb bb bb bb ........ kernel: Padding 00000000885a756c: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZ kernel: CPU: 0 PID: 387 Comm: systemd-udevd Not tainted 6.8.0-HF #2 kernel: Hardware name: IBM 3931 A01 704 (KVM/Linux) kernel: Call Trace: kernel: [<00000000ca5ab5b8>] dump_stack_lvl+0x90/0x120 kernel: [<00000000c99d78bc>] check_bytes_and_report+0x114/0x140 kernel: [<00000000c99d53cc>] check_object+0x334/0x3f8 kernel: [<00000000c99d820c>] alloc_debug_processing+0xc4/0x1f8 kernel: [<00000000c99d852e>] get_partial_node.part.0+0x1ee/0x3e0 kernel: [<00000000c99d94ec>] ___slab_alloc+0xaf4/0x13c8 kernel: [<00000000c99d9e38>] __slab_alloc.constprop.0+0x78/0xb8 kernel: [<00000000c99dc8dc>] __kmalloc+0x434/0x590 kernel: [<00000000c9b4c0ce>] ext4_htree_store_dirent+0x4e/0x1c0 kernel: [<00000000c9b908a2>] htree_dirblock_to_tree+0x17a/0x3f0 kernel: ---truncated---",
        "technologies": "Debian\nDebian GNU/Linux 10.0\nLinux\nLinux Kernel 4.19.312 未満\nLinux Kernel 4.20 以上 5.4.274 未満\nLinux Kernel 5.5 以上 5.10.215 未満\nLinux Kernel 5.11 以上 5.15.154 未満\nLinux Kernel 5.16 以上 6.1.84 未満\nLinux Kernel 6.2 以上 6.6.24 未満\nLinux Kernel 6.7 以上 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満"
    },
    "JVNDB-2024-020862": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Reject struct_ops registration that uses module ptr and the module btf_id is missing There is a UAF report in the bpf_struct_ops when CONFIG_MODULES=n. In particular, the report is on tcp_congestion_ops that has a \"struct module *owner\" member. For struct_ops that has a \"struct module *owner\" member, it can be extended either by the regular kernel module or by the bpf_struct_ops. bpf_try_module_get() will be used to do the refcounting and different refcount is done based on the owner pointer. When CONFIG_MODULES=n, the btf_id of the \"struct module\" is missing: WARN: resolve_btfids: unresolved symbol module Thus, the bpf_try_module_get() cannot do the correct refcounting. Not all subsystem's struct_ops requires the \"struct module *owner\" member. e.g. the recent sched_ext_ops. This patch is to disable bpf_struct_ops registration if the struct_ops has the \"struct module *\" member and the \"struct module\" btf_id is missing. The btf_type_is_fwd() helper is moved to the btf.h header file for this test. This has happened since the beginning of bpf_struct_ops which has gone through many changes. The Fixes tag is set to a recent commit that this patch can apply cleanly. Considering CONFIG_MODULES=n is not common and the age of the issue, targeting for bpf-next also.",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020861": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: Fix slab-use-after-free Read in mgmt_remove_adv_monitor_sync This fixes the following crash: ================================================================== BUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543 Read of size 8 at addr ffff88814128f898 by task kworker/u9:4/5961 CPU: 1 UID: 0 PID: 5961 Comm: kworker/u9:4 Not tainted 6.12.0-syzkaller-10684-gf1cd565ce577 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 16026: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269 mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296 remove_adv_monitor+0x102/0x1b0 net/bluetooth/mgmt.c:5568 hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712 hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832 sock_sendmsg_nosec net/socket.c:711 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:726 sock_write_iter+0x2d7/0x3f0 net/socket.c:1147 new_sync_write fs/read_write.c:586 [inline] vfs_write+0xaeb/0xd30 fs/read_write.c:679 ksys_write+0x18f/0x2b0 fs/read_write.c:731 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 16022: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2338 [inline] slab_free mm/slub.c:4598 [inline] kfree+0x196/0x420 mm/slub.c:4746 mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259 __mgmt_power_off+0x183/0x430 net/bluetooth/mgmt.c:9550 hci_dev_close_sync+0x6c4/0x11c0 net/bluetooth/hci_sync.c:5208 hci_dev_do_close net/bluetooth/hci_core.c:483 [inline] hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508 sock_do_ioctl+0x158/0x460 net/socket.c:1209 sock_ioctl+0x626/0x8e0 net/socket.c:1328 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
        "technologies": "Linux\nLinux Kernel 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2024-020892": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/tracing: Fix a potential TP_printk UAF The commit afd2627f727b (\"tracing: Check \"%s\" dereference via the field and not the TP_printk format\") exposes potential UAFs in the xe_bo_move trace event. Fix those by avoiding dereferencing the xe_mem_type_to_name[] array at TP_printk time. Since some code refactoring has taken place, explicit backporting may be needed for kernels older than 6.10.",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満"
    },
    "JVNDB-2024-020895": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Revert \"block, bfq: merge bfq_release_process_ref() into bfq_put_cooperator()\" This reverts commit bc3b1e9e7c50e1de0f573eea3871db61dd4787de. The bic is associated with sync_bfqq, and bfq_release_process_ref cannot be put into bfq_put_cooperator. kasan report: [ 400.347277] ================================================================== [ 400.347287] BUG: KASAN: slab-use-after-free in bic_set_bfqq+0x200/0x230 [ 400.347420] Read of size 8 at addr ffff88881cab7d60 by task dockerd/5800 [ 400.347430] [ 400.347436] CPU: 24 UID: 0 PID: 5800 Comm: dockerd Kdump: loaded Tainted: G E 6.12.0 #32 [ 400.347450] Tainted: [E]=UNSIGNED_MODULE [ 400.347454] Hardware name: VMware, Inc. VMware20,1/440BX Desktop Reference Platform, BIOS VMW201.00V.20192059.B64.2207280713 07/28/2022 [ 400.347460] Call Trace: [ 400.347464] <TASK> [ 400.347468] dump_stack_lvl+0x5d/0x80 [ 400.347490] print_report+0x174/0x505 [ 400.347521] kasan_report+0xe0/0x160 [ 400.347541] bic_set_bfqq+0x200/0x230 [ 400.347549] bfq_bic_update_cgroup+0x419/0x740 [ 400.347560] bfq_bio_merge+0x133/0x320 [ 400.347584] blk_mq_submit_bio+0x1761/0x1e20 [ 400.347625] __submit_bio+0x28b/0x7b0 [ 400.347664] submit_bio_noacct_nocheck+0x6b2/0xd30 [ 400.347690] iomap_readahead+0x50c/0x680 [ 400.347731] read_pages+0x17f/0x9c0 [ 400.347785] page_cache_ra_unbounded+0x366/0x4a0 [ 400.347795] filemap_fault+0x83d/0x2340 [ 400.347819] __xfs_filemap_fault+0x11a/0x7d0 [xfs] [ 400.349256] __do_fault+0xf1/0x610 [ 400.349270] do_fault+0x977/0x11a0 [ 400.349281] __handle_mm_fault+0x5d1/0x850 [ 400.349314] handle_mm_fault+0x1f8/0x560 [ 400.349324] do_user_addr_fault+0x324/0x970 [ 400.349337] exc_page_fault+0x76/0xf0 [ 400.349350] asm_exc_page_fault+0x26/0x30 [ 400.349360] RIP: 0033:0x55a480d77375 [ 400.349384] Code: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 49 3b 66 10 0f 86 ae 02 00 00 55 48 89 e5 48 83 ec 58 48 8b 10 <83> 7a 10 00 0f 84 27 02 00 00 44 0f b6 42 28 44 0f b6 4a 29 41 80 [ 400.349392] RSP: 002b:00007f18c37fd8b8 EFLAGS: 00010216 [ 400.349401] RAX: 00007f18c37fd9d0 RBX: 0000000000000000 RCX: 0000000000000000 [ 400.349407] RDX: 000055a484407d38 RSI: 000000c000e8b0c0 RDI: 0000000000000000 [ 400.349412] RBP: 00007f18c37fd910 R08: 000055a484017f60 R09: 000055a484066f80 [ 400.349417] R10: 0000000000194000 R11: 0000000000000005 R12: 0000000000000008 [ 400.349422] R13: 0000000000000000 R14: 000000c000476a80 R15: 0000000000000000 [ 400.349430] </TASK> [ 400.349452] [ 400.349454] Allocated by task 5800: [ 400.349459] kasan_save_stack+0x30/0x50 [ 400.349469] kasan_save_track+0x14/0x30 [ 400.349475] __kasan_slab_alloc+0x89/0x90 [ 400.349482] kmem_cache_alloc_node_noprof+0xdc/0x2a0 [ 400.349492] bfq_get_queue+0x1ef/0x1100 [ 400.349502] __bfq_get_bfqq_handle_split+0x11a/0x510 [ 400.349511] bfq_insert_requests+0xf55/0x9030 [ 400.349519] blk_mq_flush_plug_list+0x446/0x14c0 [ 400.349527] __blk_flush_plug+0x27c/0x4e0 [ 400.349534] blk_finish_plug+0x52/0xa0 [ 400.349540] _xfs_buf_ioapply+0x739/0xc30 [xfs] [ 400.350246] __xfs_buf_submit+0x1b2/0x640 [xfs] [ 400.350967] xfs_buf_read_map+0x306/0xa20 [xfs] [ 400.351672] xfs_trans_read_buf_map+0x285/0x7d0 [xfs] [ 400.352386] xfs_imap_to_bp+0x107/0x270 [xfs] [ 400.353077] xfs_iget+0x70d/0x1eb0 [xfs] [ 400.353786] xfs_lookup+0x2ca/0x3a0 [xfs] [ 400.354506] xfs_vn_lookup+0x14e/0x1a0 [xfs] [ 400.355197] __lookup_slow+0x19c/0x340 [ 400.355204] lookup_one_unlocked+0xfc/0x120 [ 400.355211] ovl_lookup_single+0x1b3/0xcf0 [overlay] [ 400.355255] ovl_lookup_layer+0x316/0x490 [overlay] [ 400.355295] ovl_lookup+0x844/0x1fd0 [overlay] [ 400.355351] lookup_one_qstr_excl+0xef/0x150 [ 400.355357] do_unlinkat+0x22a/0x620 [ 400.355366] __x64_sys_unlinkat+0x109/0x1e0 [ 400.355375] do_syscall_64+0x82/0x160 [ 400.355384] entry_SYSCALL_64_after_hwframe+0x76/0x7 ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020896": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix race in concurrent f2fs_stop_gc_thread In my test case, concurrent calls to f2fs shutdown report the following stack trace: Oops: general protection fault, probably for non-canonical address 0xc6cfff63bb5513fc: 0000 [#1] PREEMPT SMP PTI CPU: 0 UID: 0 PID: 678 Comm: f2fs_rep_shutdo Not tainted 6.12.0-rc5-next-20241029-g6fb2fa9805c5-dirty #85 Call Trace: <TASK> ? show_regs+0x8b/0xa0 ? __die_body+0x26/0xa0 ? die_addr+0x54/0x90 ? exc_general_protection+0x24b/0x5c0 ? asm_exc_general_protection+0x26/0x30 ? kthread_stop+0x46/0x390 f2fs_stop_gc_thread+0x6c/0x110 f2fs_do_shutdown+0x309/0x3a0 f2fs_ioc_shutdown+0x150/0x1c0 __f2fs_ioctl+0xffd/0x2ac0 f2fs_ioctl+0x76/0xe0 vfs_ioctl+0x23/0x60 __x64_sys_ioctl+0xce/0xf0 x64_sys_call+0x2b1b/0x4540 do_syscall_64+0xa7/0x240 entry_SYSCALL_64_after_hwframe+0x76/0x7e The root cause is a race condition in f2fs_stop_gc_thread() called from different f2fs shutdown paths: [CPU0] [CPU1] ---------------------- ----------------------- f2fs_stop_gc_thread f2fs_stop_gc_thread gc_th = sbi->gc_thread gc_th = sbi->gc_thread kfree(gc_th) sbi->gc_thread = NULL < gc_th != NULL > kthread_stop(gc_th->f2fs_gc_task) //UAF The commit c7f114d864ac (\"f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()\") attempted to fix this issue by using a read semaphore to prevent races between shutdown and remount threads, but it fails to prevent all race conditions. Fix it by converting to write lock of s_umount in f2fs_do_shutdown().",
        "technologies": "Linux\nLinux Kernel 4.16 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020893": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm cache: fix flushing uninitialized delayed_work on cache_ctr error An unexpected WARN_ON from flush_work() may occur when cache creation fails, caused by destroying the uninitialized delayed_work waker in the error path of cache_create(). For example, the warning appears on the superblock checksum error. Reproduce steps: dmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\" dmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\" dmsetup create corig --table \"0 524288 linear /dev/sdc 262144\" dd if=/dev/urandom of=/dev/mapper/cmeta bs=4k count=1 oflag=direct dmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\" Kernel logs: (snip) WARNING: CPU: 0 PID: 84 at kernel/workqueue.c:4178 __flush_work+0x5d4/0x890 Fix by pulling out the cancel_delayed_work_sync() from the constructor's error path. This patch doesn't affect the use-after-free fix for concurrent dm_resume and dm_destroy (commit 6a459d8edbdb (\"dm cache: Fix UAF in destroy()\")) as cache_dtr is not changed.",
        "technologies": "Linux\nLinux Kernel 4.9.337 以上 4.10 未満\nLinux Kernel 4.14.303 以上 4.15 未満\nLinux Kernel 4.19.270 以上 4.20 未満\nLinux Kernel 5.4.229 以上 5.5 未満\nLinux Kernel 5.10.163 以上 5.11 未満\nLinux Kernel 5.15.87 以上 5.16 未満\nLinux Kernel 6.0.18 以上 6.1 未満\nLinux Kernel 6.1.4 以上 6.1.117 未満\nLinux Kernel 6.2 以上 6.6.61 未満\nLinux Kernel 6.7 以上 6.11.8 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-020897": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: bsg: Set bsg_queue to NULL after removal Currently, this does not cause any issues, but I believe it is necessary to set bsg_queue to NULL after removing it to prevent potential use-after-free (UAF) access.",
        "technologies": "Linux\nLinux Kernel 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満"
    },
    "JVNDB-2024-020894": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: Fix use-after-free of network namespace. Recently, we got a customer report that CIFS triggers oops while reconnecting to a server. [0] The workload runs on Kubernetes, and some pods mount CIFS servers in non-root network namespaces. The problem rarely happened, but it was always while the pod was dying. The root cause is wrong reference counting for network namespace. CIFS uses kernel sockets, which do not hold refcnt of the netns that the socket belongs to. That means CIFS must ensure the socket is always freed before its netns; otherwise, use-after-free happens. The repro steps are roughly: 1. mount CIFS in a non-root netns 2. drop packets from the netns 3. destroy the netns 4. unmount CIFS We can reproduce the issue quickly with the script [1] below and see the splat [2] if CONFIG_NET_NS_REFCNT_TRACKER is enabled. When the socket is TCP, it is hard to guarantee the netns lifetime without holding refcnt due to async timers. Let's hold netns refcnt for each socket as done for SMC in commit 9744d2bf1976 (\"smc: Fix use-after-free in tcp_write_timer_handler().\"). Note that we need to move put_net() from cifs_put_tcp_session() to clean_demultiplex_info(); otherwise, __sock_create() still could touch a freed netns while cifsd tries to reconnect from cifs_demultiplex_thread(). Also, maybe_get_net() cannot be put just before __sock_create() because the code is not under RCU and there is a small chance that the same address happened to be reallocated to another netns. [0]: CIFS: VFS: \\\\XXXXXXXXXXX has not responded in 15 seconds. Reconnecting... CIFS: Serverclose failed 4 times, giving up Unable to handle kernel paging request at virtual address 14de99e461f84a07 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004 CM = 0, WnR = 0 [14de99e461f84a07] address between user and kernel address ranges Internal error: Oops: 0000000096000004 [#1] SMP Modules linked in: cls_bpf sch_ingress nls_utf8 cifs cifs_arc4 cifs_md4 dns_resolver tcp_diag inet_diag veth xt_state xt_connmark nf_conntrack_netlink xt_nat xt_statistic xt_MASQUERADE xt_mark xt_addrtype ipt_REJECT nf_reject_ipv4 nft_chain_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xt_comment nft_compat nf_tables nfnetlink overlay nls_ascii nls_cp437 sunrpc vfat fat aes_ce_blk aes_ce_cipher ghash_ce sm4_ce_cipher sm4 sm3_ce sm3 sha3_ce sha512_ce sha512_arm64 sha1_ce ena button sch_fq_codel loop fuse configfs dmi_sysfs sha2_ce sha256_arm64 dm_mirror dm_region_hash dm_log dm_mod dax efivarfs CPU: 5 PID: 2690970 Comm: cifsd Not tainted 6.1.103-109.184.amzn2023.aarch64 #1 Hardware name: Amazon EC2 r7g.4xlarge/, BIOS 1.0 11/1/2018 pstate: 00400005 (nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : fib_rules_lookup+0x44/0x238 lr : __fib_lookup+0x64/0xbc sp : ffff8000265db790 x29: ffff8000265db790 x28: 0000000000000000 x27: 000000000000bd01 x26: 0000000000000000 x25: ffff000b4baf8000 x24: ffff00047b5e4580 x23: ffff8000265db7e0 x22: 0000000000000000 x21: ffff00047b5e4500 x20: ffff0010e3f694f8 x19: 14de99e461f849f7 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 x14: 0000000000000000 x13: 0000000000000000 x12: 3f92800abd010002 x11: 0000000000000001 x10: ffff0010e3f69420 x9 : ffff800008a6f294 x8 : 0000000000000000 x7 : 0000000000000006 x6 : 0000000000000000 x5 : 0000000000000001 x4 : ffff001924354280 x3 : ffff8000265db7e0 x2 : 0000000000000000 x1 : ffff0010e3f694f8 x0 : ffff00047b5e4500 Call trace: fib_rules_lookup+0x44/0x238 __fib_lookup+0x64/0xbc ip_route_output_key_hash_rcu+0x2c4/0x398 ip_route_output_key_hash+0x60/0x8c tcp_v4_connect+0x290/0x488 __inet_stream_connect+0x108/0x3d0 inet_stream_connect+0x50/0x78 kernel_connect+0x6c/0xac generic_ip_conne ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.2 以上 6.6.62 未満\nLinux Kernel 6.7 以上 6.11.9 未満\nLinux Kernel 6.12"
    },
    "JVNDB-2024-020899": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/rxe: Remove the direct link to net_device The similar patch in siw is in the link: https://git.kernel.org/rdma/rdma/c/16b87037b48889 This problem also occurred in RXE. The following analyze this problem. In the following Call Traces: \" BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 net/core/dev.c:8782 Read of size 4 at addr ffff8880554640b0 by task kworker/1:4/5295 CPU: 1 UID: 0 PID: 5295 Comm: kworker/1:4 Not tainted 6.12.0-rc3-syzkaller-00399-g9197b73fd7bb #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: infiniband ib_cache_event_task Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 dev_get_flags+0x188/0x1d0 net/core/dev.c:8782 rxe_query_port+0x12d/0x260 drivers/infiniband/sw/rxe/rxe_verbs.c:60 __ib_query_port drivers/infiniband/core/device.c:2111 [inline] ib_query_port+0x168/0x7d0 drivers/infiniband/core/device.c:2143 ib_cache_update+0x1a9/0xb80 drivers/infiniband/core/cache.c:1494 ib_cache_event_task+0xf3/0x1e0 drivers/infiniband/core/cache.c:1568 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f2/0x390 kernel/kthread.c:389 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> \" 1). In the link [1], \" infiniband syz2: set down \" This means that on 839.350575, the event ib_cache_event_task was sent andi queued in ib_wq. 2). In the link [1], \" team0 (unregistering): Port device team_slave_0 removed \" It indicates that before 843.251853, the net device should be freed. 3). In the link [1], \" BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 \" This means that on 850.559070, this slab-use-after-free problem occurred. In all, on 839.350575, the event ib_cache_event_task was sent and queued in ib_wq, before 843.251853, the net device veth was freed. on 850.559070, this event was executed, and the mentioned freed net device was called. Thus, the above call trace occurred. [1] https://syzkaller.appspot.com/x/log.txt?x=12e7025f980000",
        "technologies": "Linux\nLinux Kernel 4.8 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-020900": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: i3c: dw: Fix use-after-free in dw_i3c_master driver due to race condition In dw_i3c_common_probe, &master->hj_work is bound with dw_i3c_hj_work. And dw_i3c_master_irq_handler can call dw_i3c_master_irq_handle_ibis function to start the work. If we remove the module which will call dw_i3c_common_remove to make cleanup, it will free master->base through i3c_master_unregister while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | dw_i3c_hj_work dw_i3c_common_remove | i3c_master_unregister(&master->base) | device_unregister(&master->dev) | device_release | //free master->base | | i3c_master_do_daa(&master->base) | //use master->base Fix it by ensuring that the work is canceled before proceeding with the cleanup in dw_i3c_common_remove.",
        "technologies": "Linux\nLinux Kernel 5.0 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020898": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/mm/fault: Fix kfence page fault reporting copy_from_kernel_nofault() can be called when doing read of /proc/kcore. /proc/kcore can have some unmapped kfence objects which when read via copy_from_kernel_nofault() can cause page faults. Since *_nofault() functions define their own fixup table for handling fault, use that instead of asking kfence to handle such faults. Hence we search the exception tables for the nip which generated the fault. If there is an entry then we let the fixup table handler handle the page fault by returning an error from within ___do_page_fault(). This can be easily triggered if someone tries to do dd from /proc/kcore. eg. dd if=/proc/kcore of=/dev/null bs=1M Some example false negatives: =============================== BUG: KFENCE: invalid read in copy_from_kernel_nofault+0x9c/0x1a0 Invalid read at 0xc0000000fdff0000: copy_from_kernel_nofault+0x9c/0x1a0 0xc00000000665f950 read_kcore_iter+0x57c/0xa04 proc_reg_read_iter+0xe4/0x16c vfs_read+0x320/0x3ec ksys_read+0x90/0x154 system_call_exception+0x120/0x310 system_call_vectored_common+0x15c/0x2ec BUG: KFENCE: use-after-free read in copy_from_kernel_nofault+0x9c/0x1a0 Use-after-free read at 0xc0000000fe050000 (in kfence-#2): copy_from_kernel_nofault+0x9c/0x1a0 0xc00000000665f950 read_kcore_iter+0x57c/0xa04 proc_reg_read_iter+0xe4/0x16c vfs_read+0x320/0x3ec ksys_read+0x90/0x154 system_call_exception+0x120/0x310 system_call_vectored_common+0x15c/0x2ec",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020937": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rtc: pcf85063: fix potential OOB write in PCF85063 NVMEM read The nvmem interface supports variable buffer sizes, while the regmap interface operates with fixed-size storage. If an nvmem client uses a buffer size less than 4 bytes, regmap_read will write out of bounds as it expects the buffer to point at an unsigned int. Fix this by using an intermediary unsigned int to hold the value.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2024-020941": {
        "title": "Linux の Linux Kernel における制限またはスロットリング無しのリソースの割り当てに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: compress: fix to cover {reserve,release}_compress_blocks() w/ cp_rwsem lock It needs to cover {reserve,release}_compress_blocks() w/ cp_rwsem lock to avoid racing with checkpoint, otherwise, filesystem metadata including blkaddr in dnode, inode fields and .total_valid_block_count may be corrupted after SPO case.",
        "technologies": "Linux\nLinux Kernel 5.8 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-020940": {
        "title": "カスペルスキーの Linux Mail Server 用 Kaspersky Security 8 for Linux Mail Server における脆弱性",
        "description": "Kaspersky has fixed a security issue in the Kaspersky Security 8.0 for Linux Mail Server. The issue was that an attacker could potentially force an administrator to click on a malicious link to perform unauthorized actions.",
        "technologies": "カスペルスキー\nKaspersky Security 8 for Linux Mail Server 8.0 から 8.0.3.30"
    },
    "JVNDB-2024-020968": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: clk: bcm: dvp: Assign ->num before accessing ->hws Commit f316cdff8d67 (\"clk: Annotate struct clk_hw_onecell_data with __counted_by\") annotated the hws member of 'struct clk_hw_onecell_data' with __counted_by, which informs the bounds sanitizer about the number of elements in hws, so that it can warn when hws is accessed out of bounds. As noted in that change, the __counted_by member must be initialized with the number of elements before the first array access happens, otherwise there will be a warning from each access prior to the initialization because the number of elements is zero. This occurs in clk_dvp_probe() due to ->num being assigned after ->hws has been accessed: UBSAN: array-index-out-of-bounds in drivers/clk/bcm/clk-bcm2711-dvp.c:59:2 index 0 is out of range for type 'struct clk_hw *[] __counted_by(num)' (aka 'struct clk_hw *[]') Move the ->num initialization to before the first access of ->hws, which clears up the warning.",
        "technologies": "Linux\nLinux Kernel 6.6 以上 6.6.34 未満\nLinux Kernel 6.7 以上 6.9.5 未満"
    },
    "JVNDB-2024-020942": {
        "title": "Linux の Linux Kernel における未チェックの戻り値に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mailbox: mtk-cmdq: Fix pm_runtime_get_sync() warning in mbox shutdown The return value of pm_runtime_get_sync() in cmdq_mbox_shutdown() will return 1 when pm runtime state is active, and we don't want to get the warning message in this case. So we change the return value < 0 for WARN_ON().",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-020944": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block: avoid to reuse `hctx` not removed from cpuhp callback list If the 'hctx' isn't removed from cpuhp callback list, we can't reuse it, otherwise use-after-free may be triggered.",
        "technologies": "Linux\nLinux Kernel 6.12.6\nLinux Kernel 6.13"
    },
    "JVNDB-2024-020967": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Use variable length array instead of fixed size Should fix smatch warning: ntfs_set_label() error: __builtin_memcpy() 'uni->name' too small (20 vs 256)",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-020966": {
        "title": "Linux の Linux Kernel におけるリソースの枯渇に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: blk-cgroup: fix list corruption from reorder of WRITE ->lqueued __blkcg_rstat_flush() can be run anytime, especially when blk_cgroup_bio_start is being executed. If WRITE of `->lqueued` is re-ordered with READ of 'bisc->lnode.next' in the loop of __blkcg_rstat_flush(), `next_bisc` can be assigned with one stat instance being added in blk_cgroup_bio_start(), then the local list in __blkcg_rstat_flush() could be corrupted. Fix the issue by adding one barrier.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-020042": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 6.7.12 未満\nLinux Kernel 6.8 以上 6.8.3 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-020946": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: PCI: Fix use-after-free of slot->bus on hot remove Dennis reports a boot crash on recent Lenovo laptops with a USB4 dock. Since commit 0fc70886569c (\"thunderbolt: Reset USB4 v2 host router\") and commit 59a54c5f3dbd (\"thunderbolt: Reset topology created by the boot firmware\"), USB4 v2 and v1 Host Routers are reset on probe of the thunderbolt driver. The reset clears the Presence Detect State and Data Link Layer Link Active bits at the USB4 Host Router's Root Port and thus causes hot removal of the dock. The crash occurs when pciehp is unbound from one of the dock's Downstream Ports: pciehp creates a pci_slot on bind and destroys it on unbind. The pci_slot contains a pointer to the pci_bus below the Downstream Port, but a reference on that pci_bus is never acquired. The pci_bus is destroyed before the pci_slot, so a use-after-free ensues when pci_slot_release() accesses slot->bus. In principle this should not happen because pci_stop_bus_device() unbinds pciehp (and therefore destroys the pci_slot) before the pci_bus is destroyed by pci_remove_bus_device(). However the stacktrace provided by Dennis shows that pciehp is unbound from pci_remove_bus_device() instead of pci_stop_bus_device(). To understand the significance of this, one needs to know that the PCI core uses a two step process to remove a portion of the hierarchy: It first unbinds all drivers in the sub-hierarchy in pci_stop_bus_device() and then actually removes the devices in pci_remove_bus_device(). There is no precaution to prevent driver binding in-between pci_stop_bus_device() and pci_remove_bus_device(). In Dennis' case, it seems removal of the hierarchy by pciehp races with driver binding by pci_bus_add_devices(). pciehp is bound to the Downstream Port after pci_stop_bus_device() has run, so it is unbound by pci_remove_bus_device() instead of pci_stop_bus_device(). Because the pci_bus has already been destroyed at that point, accesses to it result in a use-after-free. One might conclude that driver binding needs to be prevented after pci_stop_bus_device() has run. However it seems risky that pci_slot points to pci_bus without holding a reference. Solely relying on correct ordering of driver unbind versus pci_bus destruction is certainly not defensive programming. If pci_slot has a need to access data in pci_bus, it ought to acquire a reference. Amend pci_create_slot() accordingly. Dennis reports that the crash is not reproducible with this change. Abridged stacktrace: pcieport 0000:00:07.0: PME: Signaling with IRQ 156 pcieport 0000:00:07.0: pciehp: Slot #12 AttnBtn- PwrCtrl- MRL- AttnInd- PwrInd- HotPlug+ Surprise+ Interlock- NoCompl+ IbPresDis- LLActRep+ pci_bus 0000:20: dev 00, created physical slot 12 pcieport 0000:00:07.0: pciehp: Slot(12): Card not present ... pcieport 0000:21:02.0: pciehp: pcie_disable_notification: SLOTCTRL d8 write cmd 0 Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI CPU: 13 UID: 0 PID: 134 Comm: irq/156-pciehp Not tainted 6.11.0-devel+ #1 RIP: 0010:dev_driver_string+0x12/0x40 pci_destroy_slot pciehp_remove pcie_port_remove_service device_release_driver_internal bus_remove_device device_del device_unregister remove_iter device_for_each_child pcie_portdrv_remove pci_device_remove device_release_driver_internal bus_remove_device device_del pci_remove_bus_device (recursive invocation) pci_remove_bus_device pciehp_unconfigure_device pciehp_disable_slot pciehp_handle_presence_or_link_change pciehp_ist",
        "technologies": "Linux\nLinux Kernel 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-020998": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: SUNRPC: make sure cache entry active before cache_show The function `c_show` was called with protection from RCU. This only ensures that `cp` will not be freed. Therefore, the reference count for `cp` can drop to zero, which will trigger a refcount use-after-free warning when `cache_get` is called. To resolve this issue, use `cache_get_rcu` to ensure that `cp` remains active. ------------[ cut here ]------------ refcount_t: addition on 0; use-after-free. WARNING: CPU: 7 PID: 822 at lib/refcount.c:25 refcount_warn_saturate+0xb1/0x120 CPU: 7 UID: 0 PID: 822 Comm: cat Not tainted 6.12.0-rc3+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 RIP: 0010:refcount_warn_saturate+0xb1/0x120 Call Trace: <TASK> c_show+0x2fc/0x380 [sunrpc] seq_read_iter+0x589/0x770 seq_read+0x1e5/0x270 proc_reg_read+0xe1/0x140 vfs_read+0x125/0x530 ksys_read+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-024309": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における証明書検証に関する脆弱性",
        "description": "In gnss service, there is a possible escalation of privilege due to improper certificate validation. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS08720039; Issue ID: MSV-1424.",
        "technologies": "Google\nAndroid 13.0\nAndroid 14.0\nLinux Foundation\nYocto 2.6\nYocto 3.3\nYocto 4.0\nRDK Management, LLC\nrdk-b 2022q3"
    },
    "JVNDB-2024-024949": {
        "title": "Linux Foundation の Python 用 pytorch における解放済みメモリの使用に関する脆弱性",
        "description": "Pytorch before version v2.2.0 was discovered to contain a use-after-free vulnerability in torch/csrc/jit/mobile/interpreter.cpp.",
        "technologies": "Linux Foundation\npytorch 2.2.0 未満"
    },
    "JVNDB-2024-022841": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix RCU use in TDLS fast-xmit This looks up the link under RCU protection, but isn't guaranteed to actually have protection. Fix that.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.17 未満\nLinux Kernel 6.7 以上 6.7.5 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-020969": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix potential out-of-bounds memory access in nilfs_find_entry() Syzbot reported that when searching for records in a directory where the inode's i_size is corrupted and has a large value, memory access outside the folio/page range may occur, or a use-after-free bug may be detected if KASAN is enabled. This is because nilfs_last_byte(), which is called by nilfs_find_entry() and others to calculate the number of valid bytes of directory data in a page from i_size and the page index, loses the upper 32 bits of the 64-bit size information due to an inappropriate type of local variable to which the i_size value is assigned. This caused a large byte offset value due to underflow in the end address calculation in the calling nilfs_find_entry(), resulting in memory access that exceeds the folio/page size. Fix this issue by changing the type of the local variable causing the bit loss from \"unsigned int\" to \"u64\". The return value of nilfs_last_byte() is also of type \"unsigned int\", but it is truncated so as not to exceed PAGE_SIZE and no bit loss occurs, so no change is required.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 から 6.6.66\nLinux Kernel 6.7 から 6.12.5\nLinux Kernel 6.13"
    },
    "JVNDB-2024-022831": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In wlan firmware, there is a possible out of bounds write due to improper input validation. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS08360153 (for MT6XXX chipsets) / WCNCR00363530 (for MT79XX chipsets); Issue ID: MSV-979.",
        "technologies": "Google\nAndroid 12.0\nAndroid 13.0\nAndroid 14.0\nLinux\nLinux Kernel 4.19\nLinux Foundation\nYocto 3.3\nYocto 4.0\nOpenWrt Project\nOpenWrt 19.07.0\nOpenWrt 21.02.0\nRDK Management, LLC\nrdk-b 2022q3"
    },
    "JVNDB-2024-025696": {
        "title": "Linux Foundation の Magma における到達可能なアサーションに関する脆弱性",
        "description": "A reachable assertion in the decode_linked_ti_ie function of Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) allows attackers to cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-026313": {
        "title": "Linux Foundation の onos-kpimon における境界外書き込みに関する脆弱性",
        "description": "Open Networking Foundation SD-RAN onos-kpimon 0.4.7 allows out-of-bounds array access in the processIndicationFormat1 function.",
        "technologies": "Linux Foundation\nonos-kpimon 0.4.7"
    },
    "JVNDB-2024-026312": {
        "title": "Linux Foundation の onos-lib-go における境界外読み取りに関する脆弱性",
        "description": "Open Networking Foundation SD-RAN ONOS onos-lib-go 0.10.25 allows an index out-of-range condition in parseAlignBits.",
        "technologies": "Linux Foundation\nonos-lib-go 0.10.25"
    },
    "JVNDB-2024-026256": {
        "title": "Linux Foundation の Python 用 pytorch における信頼できないデータのデシリアライゼーションに関する脆弱性",
        "description": "In PyTorch <=2.4.1, the RemoteModule has Deserialization RCE. NOTE: this is disputed by multiple parties because this is intended behavior in PyTorch distributed computing.",
        "technologies": "Linux Foundation\npytorch 2.4.1 およびそれ以前"
    },
    "JVNDB-2024-025768": {
        "title": "Linux Foundation の Magma におけるコードインジェクションの脆弱性",
        "description": "A type confusion in the nas_message_decode function of Magma <= 1.8.0 (fixed in v1.9 commit 08472ba98b8321f802e95f5622fa90fec2dea486) allows attackers to execute arbitrary code or cause a Denial of Service (DoS) via a crafted NAS packet.",
        "technologies": "Linux Foundation\nMagma 1.8.0 およびそれ以前"
    },
    "JVNDB-2024-027916": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ecryptfs: Fix buffer size for tag 66 packet The 'TAG 66 Packet Format' description is missing the cipher code and checksum fields that are packed into the message packet. As a result, the buffer allocated for the packet is 3 bytes too small and write_tag_66_packet() will write up to 3 bytes past the end of the buffer. Fix this by increasing the size of the allocation so the whole packet will always fit in the buffer. This fixes the below kasan slab-out-of-bounds bug: BUG: KASAN: slab-out-of-bounds in ecryptfs_generate_key_packet_set+0x7d6/0xde0 Write of size 1 at addr ffff88800afbb2a5 by task touch/181 CPU: 0 PID: 181 Comm: touch Not tainted 6.6.13-gnu #1 4c9534092be820851bb687b82d1f92a426598dc6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2/GNU Guix 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x4c/0x70 print_report+0xc5/0x610 ? ecryptfs_generate_key_packet_set+0x7d6/0xde0 ? kasan_complete_mode_report_info+0x44/0x210 ? ecryptfs_generate_key_packet_set+0x7d6/0xde0 kasan_report+0xc2/0x110 ? ecryptfs_generate_key_packet_set+0x7d6/0xde0 __asan_store1+0x62/0x80 ecryptfs_generate_key_packet_set+0x7d6/0xde0 ? __pfx_ecryptfs_generate_key_packet_set+0x10/0x10 ? __alloc_pages+0x2e2/0x540 ? __pfx_ovl_open+0x10/0x10 [overlay 30837f11141636a8e1793533a02e6e2e885dad1d] ? dentry_open+0x8f/0xd0 ecryptfs_write_metadata+0x30a/0x550 ? __pfx_ecryptfs_write_metadata+0x10/0x10 ? ecryptfs_get_lower_file+0x6b/0x190 ecryptfs_initialize_file+0x77/0x150 ecryptfs_create+0x1c2/0x2f0 path_openat+0x17cf/0x1ba0 ? __pfx_path_openat+0x10/0x10 do_filp_open+0x15e/0x290 ? __pfx_do_filp_open+0x10/0x10 ? __kasan_check_write+0x18/0x30 ? _raw_spin_lock+0x86/0xf0 ? __pfx__raw_spin_lock+0x10/0x10 ? __kasan_check_write+0x18/0x30 ? alloc_fd+0xf4/0x330 do_sys_openat2+0x122/0x160 ? __pfx_do_sys_openat2+0x10/0x10 __x64_sys_openat+0xef/0x170 ? __pfx___x64_sys_openat+0x10/0x10 do_syscall_64+0x60/0xd0 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 RIP: 0033:0x7f00a703fd67 Code: 25 00 00 41 00 3d 00 00 41 00 74 37 64 8b 04 25 18 00 00 00 85 c0 75 5b 44 89 e2 48 89 ee bf 9c ff ff ff b8 01 01 00 00 0f 05 <48> 3d 00 f0 ff ff 0f 87 85 00 00 00 48 83 c4 68 5d 41 5c c3 0f 1f RSP: 002b:00007ffc088e30b0 EFLAGS: 00000246 ORIG_RAX: 0000000000000101 RAX: ffffffffffffffda RBX: 00007ffc088e3368 RCX: 00007f00a703fd67 RDX: 0000000000000941 RSI: 00007ffc088e48d7 RDI: 00000000ffffff9c RBP: 00007ffc088e48d7 R08: 0000000000000001 R09: 0000000000000000 R10: 00000000000001b6 R11: 0000000000000246 R12: 0000000000000941 R13: 0000000000000000 R14: 00007ffc088e48d7 R15: 00007f00a7180040 </TASK> Allocated by task 181: kasan_save_stack+0x2f/0x60 kasan_set_track+0x29/0x40 kasan_save_alloc_info+0x25/0x40 __kasan_kmalloc+0xc5/0xd0 __kmalloc+0x66/0x160 ecryptfs_generate_key_packet_set+0x6d2/0xde0 ecryptfs_write_metadata+0x30a/0x550 ecryptfs_initialize_file+0x77/0x150 ecryptfs_create+0x1c2/0x2f0 path_openat+0x17cf/0x1ba0 do_filp_open+0x15e/0x290 do_sys_openat2+0x122/0x160 __x64_sys_openat+0xef/0x170 do_syscall_64+0x60/0xd0 entry_SYSCALL_64_after_hwframe+0x6e/0xd8",
        "technologies": "Linux\nLinux Kernel 2.6.21 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-027918": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix potential kernel bug due to lack of writeback flag waiting Destructive writes to a block device on which nilfs2 is mounted can cause a kernel bug in the folio/page writeback start routine or writeback end routine (__folio_start_writeback in the log below): kernel BUG at mm/page-writeback.c:3070! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI ... RIP: 0010:__folio_start_writeback+0xbaa/0x10e0 Code: 25 ff 0f 00 00 0f 84 18 01 00 00 e8 40 ca c6 ff e9 17 f6 ff ff e8 36 ca c6 ff 4c 89 f7 48 c7 c6 80 c0 12 84 e8 e7 b3 0f 00 90 <0f> 0b e8 1f ca c6 ff 4c 89 f7 48 c7 c6 a0 c6 12 84 e8 d0 b3 0f 00 ... Call Trace: <TASK> nilfs_segctor_do_construct+0x4654/0x69d0 [nilfs2] nilfs_segctor_construct+0x181/0x6b0 [nilfs2] nilfs_segctor_thread+0x548/0x11c0 [nilfs2] kthread+0x2f0/0x390 ret_from_fork+0x4b/0x80 ret_from_fork_asm+0x1a/0x30 </TASK> This is because when the log writer starts a writeback for segment summary blocks or a super root block that use the backing device's page cache, it does not wait for the ongoing folio/page writeback, resulting in an inconsistent writeback state. Fix this issue by waiting for ongoing writebacks when putting folios/pages on the backing device into writeback state.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.5 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-027939": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drivers/virt/acrn: fix PFNMAP PTE checks in acrn_vm_ram_map() Patch series \"mm: follow_pte() improvements and acrn follow_pte() fixes\". Patch #1 fixes a bunch of issues I spotted in the acrn driver. It compiles, that's all I know. I'll appreciate some review and testing from acrn folks. Patch #2+#3 improve follow_pte(), passing a VMA instead of the MM, adding more sanity checks, and improving the documentation. Gave it a quick test on x86-64 using VM_PAT that ends up using follow_pte(). This patch (of 3): We currently miss handling various cases, resulting in a dangerous follow_pte() (previously follow_pfn()) usage. (1) We're not checking PTE write permissions. Maybe we should simply always require pte_write() like we do for pin_user_pages_fast(FOLL_WRITE)? Hard to tell, so let's check for ACRN_MEM_ACCESS_WRITE for now. (2) We're not rejecting refcounted pages. As we are not using MMU notifiers, messing with refcounted pages is dangerous and can result in use-after-free. Let's make sure to reject them. (3) We are only looking at the first PTE of a bigger range. We only lookup a single PTE, but memmap->len may span a larger area. Let's loop over all involved PTEs and make sure the PFN range is actually contiguous. Reject everything else: it couldn't have worked either way, and rather made use access PFNs we shouldn't be accessing.",
        "technologies": "Linux\nLinux Kernel 5.15.33 以上 5.15.161 未満\nLinux Kernel 5.16.19 以上 5.17 未満\nLinux Kernel 5.17.2 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-027937": {
        "title": "Linux の Linux Kernel における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vmci: prevent speculation leaks by sanitizing event in event_deliver() Coverity spotted that event_msg is controlled by user-space, event_msg->event_data.event is passed to event_deliver() and used as an index without sanitization. This change ensures that the event index is sanitized to mitigate any possibility of speculative information leaks. This bug was discovered and resolved using Coverity Static Analysis Security Testing (SAST) by Synopsys, Inc. Only compile tested, no access to HW.",
        "technologies": "Linux\nLinux Kernel 3.9 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満"
    },
    "JVNDB-2024-027948": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: wwan: iosm: Fix tainted pointer delete is case of region creation fail In case of region creation fail in ipc_devlink_create_region(), previously created regions delete process starts from tainted pointer which actually holds error code value. Fix this bug by decreasing region index before delete. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-027868": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix incorrect mpc_combine array size [why] MAX_SURFACES is per stream, while MAX_PLANES is per asic. The mpc_combine is an array that records all the planes per asic. Therefore MAX_PLANES should be used as the array size. Using MAX_SURFACES causes array overflow when there are more than 3 planes. [how] Use the MAX_PLANES for the mpc_combine array size.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 6.7.6 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-027973": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: stk1160: fix bounds checking in stk1160_copy_video() The subtract in this condition is reversed. The ->length is the length of the buffer. The ->bytesused is how many bytes we have copied thus far. When the condition is reversed that means the result of the subtraction is always negative but since it's unsigned then the result is a very high positive value. That means the overflow check is never true. Additionally, the ->bytesused doesn't actually work for this purpose because we're not writing to \"buf->mem + buf->bytesused\". Instead, the math to calculate the destination where we are writing is a bit involved. You calculate the number of full lines already written, multiply by two, skip a line if necessary so that we start on an odd numbered line, and add the offset into the line. To fix this buffer overflow, just take the actual destination where we are writing, if the offset is already out of bounds print an error and return. Otherwise, write up to buf->length bytes.",
        "technologies": "Linux\nLinux Kernel 3.7 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-027947": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: qedi: Fix crash while reading debugfs attribute The qedi_dbg_do_not_recover_cmd_read() function invokes sprintf() directly on a __user pointer, which results into the crash. To fix this issue, use a small local stack buffer for sprintf() and then call simple_read_from_buffer(), which in turns make the copy_to_user() call. BUG: unable to handle page fault for address: 00007f4801111000 PGD 8000000864df6067 P4D 8000000864df6067 PUD 864df7067 PMD 846028067 PTE 0 Oops: 0002 [#1] PREEMPT SMP PTI Hardware name: HPE ProLiant DL380 Gen10/ProLiant DL380 Gen10, BIOS U30 06/15/2023 RIP: 0010:memcpy_orig+0xcd/0x130 RSP: 0018:ffffb7a18c3ffc40 EFLAGS: 00010202 RAX: 00007f4801111000 RBX: 00007f4801111000 RCX: 000000000000000f RDX: 000000000000000f RSI: ffffffffc0bfd7a0 RDI: 00007f4801111000 RBP: ffffffffc0bfd7a0 R08: 725f746f6e5f6f64 R09: 3d7265766f636572 R10: ffffb7a18c3ffd08 R11: 0000000000000000 R12: 00007f4881110fff R13: 000000007fffffff R14: ffffb7a18c3ffca0 R15: ffffffffc0bfd7af FS: 00007f480118a740(0000) GS:ffff98e38af00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f4801111000 CR3: 0000000864b8e001 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> ? __die_body+0x1a/0x60 ? page_fault_oops+0x183/0x510 ? exc_page_fault+0x69/0x150 ? asm_exc_page_fault+0x22/0x30 ? memcpy_orig+0xcd/0x130 vsnprintf+0x102/0x4c0 sprintf+0x51/0x80 qedi_dbg_do_not_recover_cmd_read+0x2f/0x50 [qedi 6bcfdeeecdea037da47069eca2ba717c84a77324] full_proxy_read+0x50/0x80 vfs_read+0xa5/0x2e0 ? folio_add_new_anon_rmap+0x44/0xa0 ? set_pte_at+0x15/0x30 ? do_pte_missing+0x426/0x7f0 ksys_read+0xa5/0xe0 do_syscall_64+0x58/0x80 ? __count_memcg_events+0x46/0x90 ? count_memcg_event_mm+0x3d/0x60 ? handle_mm_fault+0x196/0x2f0 ? do_user_addr_fault+0x267/0x890 ? exc_page_fault+0x69/0x150 entry_SYSCALL_64_after_hwframe+0x72/0xdc RIP: 0033:0x7f4800f20b4d",
        "technologies": "Linux\nLinux Kernel 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満"
    },
    "JVNDB-2024-027951": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: remove requests from xarray during flushing requests Even with CACHEFILES_DEAD set, we can still read the requests, so in the following concurrency the request may be used after it has been freed: mount | daemon_thread1 | daemon_thread2 ------------------------------------------------------------ cachefiles_ondemand_init_object cachefiles_ondemand_send_req REQ_A = kzalloc(sizeof(*req) + data_len) wait_for_completion(&REQ_A->done) cachefiles_daemon_read cachefiles_ondemand_daemon_read // close dev fd cachefiles_flush_reqs complete(&REQ_A->done) kfree(REQ_A) xa_lock(&cache->reqs); cachefiles_ondemand_select_req req->msg.opcode != CACHEFILES_OP_READ // req use-after-free !!! xa_unlock(&cache->reqs); xa_destroy(&cache->reqs) Hence remove requests from cache->reqs when flushing them to avoid accessing freed requests.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-027949": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: flush all requests after setting CACHEFILES_DEAD In ondemand mode, when the daemon is processing an open request, if the kernel flags the cache as CACHEFILES_DEAD, the cachefiles_daemon_write() will always return -EIO, so the daemon can't pass the copen to the kernel. Then the kernel process that is waiting for the copen triggers a hung_task. Since the DEAD state is irreversible, it can only be exited by closing /dev/cachefiles. Therefore, after calling cachefiles_io_error() to mark the cache as CACHEFILES_DEAD, if in ondemand mode, flush all requests to avoid the above hungtask. We may still be able to read some of the cached data before closing the fd of /dev/cachefiles. Note that this relies on the patch that adds reference counting to the req, otherwise it may UAF.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-027950": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: mst: fix suspicious rcu usage in br_mst_set_state I converted br_mst_set_state to RCU to avoid a vlan use-after-free but forgot to change the vlan group dereference helper. Switch to vlan group RCU deref helper to fix the suspicious rcu usage warning.",
        "technologies": "Linux\nLinux Kernel 6.1.93 以上 6.1.95 未満\nLinux Kernel 6.6.33 以上 6.6.35 未満\nLinux Kernel 6.8.12 以上 6.9 未満\nLinux Kernel 6.9.3 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-027975": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on i_xattr_nid in sanity_check_inode() syzbot reports a kernel bug as below: F2FS-fs (loop0): Mounted with checkpoint version = 48b305e4 ================================================================== BUG: KASAN: slab-out-of-bounds in f2fs_test_bit fs/f2fs/f2fs.h:2933 [inline] BUG: KASAN: slab-out-of-bounds in current_nat_addr fs/f2fs/node.h:213 [inline] BUG: KASAN: slab-out-of-bounds in f2fs_get_node_info+0xece/0x1200 fs/f2fs/node.c:600 Read of size 1 at addr ffff88807a58c76c by task syz-executor280/5076 CPU: 1 PID: 5076 Comm: syz-executor280 Not tainted 6.9.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 f2fs_test_bit fs/f2fs/f2fs.h:2933 [inline] current_nat_addr fs/f2fs/node.h:213 [inline] f2fs_get_node_info+0xece/0x1200 fs/f2fs/node.c:600 f2fs_xattr_fiemap fs/f2fs/data.c:1848 [inline] f2fs_fiemap+0x55d/0x1ee0 fs/f2fs/data.c:1925 ioctl_fiemap fs/ioctl.c:220 [inline] do_vfs_ioctl+0x1c07/0x2e50 fs/ioctl.c:838 __do_sys_ioctl fs/ioctl.c:902 [inline] __se_sys_ioctl+0x81/0x170 fs/ioctl.c:890 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The root cause is we missed to do sanity check on i_xattr_nid during f2fs_iget(), so that in fiemap() path, current_nat_addr() will access nat_bitmap w/ offset from invalid i_xattr_nid, result in triggering kasan bug report, fix it.",
        "technologies": "Linux\nLinux Kernel 3.8 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.94 未満\nLinux Kernel 6.2 以上 6.6.34 未満\nLinux Kernel 6.7 以上 6.9.5 未満"
    },
    "JVNDB-2024-027974": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: soundwire: cadence: fix invalid PDI offset For some reason, we add an offset to the PDI, presumably to skip the PDI0 and PDI1 which are reserved for BPT. This code is however completely wrong and leads to an out-of-bounds access. We were just lucky so far since we used only a couple of PDIs and remained within the PDI array bounds. A Fixes: tag is not provided since there are no known platforms where the out-of-bounds would be accessed, and the initial code had problems as well. A follow-up patch completely removes this useless offset.",
        "technologies": "Linux\nLinux Kernel 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-028016": {
        "title": "Linux の Linux Kernel における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: qca: fix info leak when fetching fw build id Add the missing sanity checks and move the 255-byte build-id buffer off the stack to avoid leaking stack data through debugfs in case the build-info reply is malformed.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028014": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: use timestamp to check for set element timeout Add a timestamp field at the beginning of the transaction, store it in the nftables per-netns area. Update set backend .insert, .deactivate and sync gc path to use the timestamp, this avoids that an element expires while control plane transaction is still unfinished. .lookup and .update, which are used from packet path, still use the current time to check if the element has expired. And .get path and dump also since this runs lockless under rcu read size lock. Then, there is async gc which also needs to check the current time since it runs asynchronously from a workqueue.",
        "technologies": "Linux\nLinux Kernel 4.1 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.7.5 未満\nLinux Kernel 6.8"
    },
    "JVNDB-2024-027983": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ionic: fix use after netif_napi_del() When queues are started, netif_napi_add() and napi_enable() are called. If there are 4 queues and only 3 queues are used for the current configuration, only 3 queues' napi should be registered and enabled. The ionic_qcq_enable() checks whether the .poll pointer is not NULL for enabling only the using queue' napi. Unused queues' napi will not be registered by netif_napi_add(), so the .poll pointer indicates NULL. But it couldn't distinguish whether the napi was unregistered or not because netif_napi_del() doesn't reset the .poll pointer to NULL. So, ionic_qcq_enable() calls napi_enable() for the queue, which was unregistered by netif_napi_del(). Reproducer: ethtool -L <interface name> rx 1 tx 1 combined 0 ethtool -L <interface name> rx 0 tx 0 combined 1 ethtool -L <interface name> rx 0 tx 0 combined 4 Splat looks like: kernel BUG at net/core/dev.c:6666! Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 3 PID: 1057 Comm: kworker/3:3 Not tainted 6.10.0-rc2+ #16 Workqueue: events ionic_lif_deferred_work [ionic] RIP: 0010:napi_enable+0x3b/0x40 Code: 48 89 c2 48 83 e2 f6 80 b9 61 09 00 00 00 74 0d 48 83 bf 60 01 00 00 00 74 03 80 ce 01 f0 4f RSP: 0018:ffffb6ed83227d48 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff97560cda0828 RCX: 0000000000000029 RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff97560cda0a28 RBP: ffffb6ed83227d50 R08: 0000000000000400 R09: 0000000000000001 R10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000 R13: ffff97560ce3c1a0 R14: 0000000000000000 R15: ffff975613ba0a20 FS: 0000000000000000(0000) GS:ffff975d5f780000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f8f734ee200 CR3: 0000000103e50000 CR4: 00000000007506f0 PKRU: 55555554 Call Trace: <TASK> ? die+0x33/0x90 ? do_trap+0xd9/0x100 ? napi_enable+0x3b/0x40 ? do_error_trap+0x83/0xb0 ? napi_enable+0x3b/0x40 ? napi_enable+0x3b/0x40 ? exc_invalid_op+0x4e/0x70 ? napi_enable+0x3b/0x40 ? asm_exc_invalid_op+0x16/0x20 ? napi_enable+0x3b/0x40 ionic_qcq_enable+0xb7/0x180 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8] ionic_start_queues+0xc4/0x290 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8] ionic_link_status_check+0x11c/0x170 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8] ionic_lif_deferred_work+0x129/0x280 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8] process_one_work+0x145/0x360 worker_thread+0x2bb/0x3d0 ? __pfx_worker_thread+0x10/0x10 kthread+0xcc/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2d/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30",
        "technologies": "Linux\nLinux Kernel 5.4 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028024": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jffs2: prevent xattr node from overflowing the eraseblock Add a check to make sure that the requested xattr node size is no larger than the eraseblock minus the cleanmarker. Unlike the usual inode nodes, the xattr nodes aren't split into parts and spread across multiple eraseblocks, which means that a xattr node must not occupy more than one eraseblock. If the requested xattr value is too large, the xattr node can spill onto the next eraseblock, overwriting the nodes and causing errors such as: jffs2: argh. node added in wrong place at 0x0000b050(2) jffs2: nextblock 0x0000a000, expected at 0000b00c jffs2: error: (823) do_verify_xattr_datum: node CRC failed at 0x01e050, read=0xfc892c93, calc=0x000000 jffs2: notice: (823) jffs2_get_inode_nodes: Node header CRC failed at 0x01e00c. {848f,2fc4,0fef511f,59a3d171} jffs2: Node at 0x0000000c with length 0x00001044 would run over the end of the erase block jffs2: Perhaps the file system was created with the wrong erase size? jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000010: 0x1044 instead This breaks the filesystem and can lead to KASAN crashes such as: BUG: KASAN: slab-out-of-bounds in jffs2_sum_add_kvec+0x125e/0x15d0 Read of size 4 at addr ffff88802c31e914 by task repro/830 CPU: 0 PID: 830 Comm: repro Not tainted 6.9.0-rc3+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0xc6/0x120 print_report+0xc4/0x620 ? __virt_addr_valid+0x308/0x5b0 kasan_report+0xc1/0xf0 ? jffs2_sum_add_kvec+0x125e/0x15d0 ? jffs2_sum_add_kvec+0x125e/0x15d0 jffs2_sum_add_kvec+0x125e/0x15d0 jffs2_flash_direct_writev+0xa8/0xd0 jffs2_flash_writev+0x9c9/0xef0 ? __x64_sys_setxattr+0xc4/0x160 ? do_syscall_64+0x69/0x140 ? entry_SYSCALL_64_after_hwframe+0x76/0x7e [...] Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
        "technologies": "Linux\nLinux Kernel 2.6.18 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-028018": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ppdev: Add an error check in register_device In register_device, the return value of ida_simple_get is unchecked, in witch ida_simple_get will use an invalid index value. To address this issue, index should be checked after ida_simple_get. When the index value is abnormal, a warning message should be printed, the port should be dropped, and the value should be recorded.",
        "technologies": "Linux\nLinux Kernel 4.9.22 以上 4.10 未満\nLinux Kernel 4.10.7 以上 4.11 未満\nLinux Kernel 4.11.1 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満\nLinux Kernel 4.11"
    },
    "JVNDB-2024-028008": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix writeback data corruption cifs writeback doesn't correctly handle the case where cifs_extend_writeback() hits a point where it is considering an additional folio, but this would overrun the wsize - at which point it drops out of the xarray scanning loop and calls xas_pause(). The problem is that xas_pause() advances the loop counter - thereby skipping that page. What needs to happen is for xas_reset() to be called any time we decide we don't want to process the page we're looking at, but rather send the request we are building and start a new one. Fix this by copying and adapting the netfslib writepages code as a temporary measure, with cifs writeback intending to be offloaded to netfslib in the near future. This also fixes the issue with the use of filemap_get_folios_tag() causing retry of a bunch of pages which the extender already dealt with. This can be tested by creating, say, a 64K file somewhere not on cifs (otherwise copy-offload may get underfoot), mounting a cifs share with a wsize of 64000, copying the file to it and then comparing the original file and the copy: dd if=/dev/urandom of=/tmp/64K bs=64k count=1 mount //192.168.6.1/test /mnt -o user=...,pass=...,wsize=64000 cp /tmp/64K /mnt/64K cmp /tmp/64K /mnt/64K Without the fix, the cmp fails at position 64000 (or shortly thereafter).",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.23 未満\nLinux Kernel 6.7 以上 6.7.11 未満\nLinux Kernel 6.8 以上 6.8.2 未満"
    },
    "JVNDB-2024-027987": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix tainted pointer delete is case of flow rules creation fail In case of flow rule creation fail in mlx5_lag_create_port_sel_table(), instead of previously created rules, the tainted pointer is deleted deveral times. Fix this bug by using correct flow rules pointers. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028017": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: zoned: do not flag ZEROOUT on non-dirty extent buffer Btrfs clears the content of an extent buffer marked as EXTENT_BUFFER_ZONED_ZEROOUT before the bio submission. This mechanism is introduced to prevent a write hole of an extent buffer, which is once allocated, marked dirty, but turns out unnecessary and cleaned up within one transaction operation. Currently, btrfs_clear_buffer_dirty() marks the extent buffer as EXTENT_BUFFER_ZONED_ZEROOUT, and skips the entry function. If this call happens while the buffer is under IO (with the WRITEBACK flag set, without the DIRTY flag), we can add the ZEROOUT flag and clear the buffer's content just before a bio submission. As a result: 1) it can lead to adding faulty delayed reference item which leads to a FS corrupted (EUCLEAN) error, and 2) it writes out cleared tree node on disk The former issue is previously discussed in [1]. The corruption happens when it runs a delayed reference update. So, on-disk data is safe. [1] https://lore.kernel.org/linux-btrfs/3f4f2a0ff1a6c818050434288925bdcf3cd719e5.1709124777.git.naohiro.aota@wdc.com/ The latter one can reach on-disk data. But, as that node is already processed by btrfs_clear_buffer_dirty(), that will be invalidated in the next transaction commit anyway. So, the chance of hitting the corruption is relatively small. Anyway, we should skip flagging ZEROOUT on a non-DIRTY extent buffer, to keep the content under IO intact.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-027981": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix out-of-bound access of qmi_invoke_handler() Currently, there is no terminator entry for ath12k_qmi_msg_handlers hence facing below KASAN warning, ================================================================== BUG: KASAN: global-out-of-bounds in qmi_invoke_handler+0xa4/0x148 Read of size 8 at addr ffffffd00a6428d8 by task kworker/u8:2/1273 CPU: 0 PID: 1273 Comm: kworker/u8:2 Not tainted 5.4.213 #0 Workqueue: qmi_msg_handler qmi_data_ready_work Call trace: dump_backtrace+0x0/0x20c show_stack+0x14/0x1c dump_stack+0xe0/0x138 print_address_description.isra.5+0x30/0x330 __kasan_report+0x16c/0x1bc kasan_report+0xc/0x14 __asan_load8+0xa8/0xb0 qmi_invoke_handler+0xa4/0x148 qmi_handle_message+0x18c/0x1bc qmi_data_ready_work+0x4ec/0x528 process_one_work+0x2c0/0x440 worker_thread+0x324/0x4b8 kthread+0x210/0x228 ret_from_fork+0x10/0x18 The address belongs to the variable: ath12k_mac_mon_status_filter_default+0x4bd8/0xfffffffffffe2300 [ath12k] [...] ================================================================== Add a dummy terminator entry at the end to assist the qmi_invoke_handler() in traversing up to the terminator entry without accessing an out-of-boundary index. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-028039": {
        "title": "Linux の Linux Kernel における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: qca: fix info leak when fetching board id Add the missing sanity check when fetching the board id to avoid leaking slab data when later requesting the firmware.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-027978": {
        "title": "Linux の Linux Kernel における不正な認証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracefs: Reset permissions on remount if permissions are options There's an inconsistency with the way permissions are handled in tracefs. Because the permissions are generated when accessed, they default to the root inode's permission if they were never set by the user. If the user sets the permissions, then a flag is set and the permissions are saved via the inode (for tracefs files) or an internal attribute field (for eventfs). But if a remount happens that specify the permissions, all the files that were not changed by the user gets updated, but the ones that were are not. If the user were to remount the file system with a given permission, then all files and directories within that file system should be updated. This can cause security issues if a file's permission was updated but the admin forgot about it. They could incorrectly think that remounting with permissions set would update all files, but miss some. For example: # cd /sys/kernel/tracing # chgrp 1002 current_tracer # ls -l [..] -rw-r----- 1 root root 0 May 1 21:25 buffer_size_kb -rw-r----- 1 root root 0 May 1 21:25 buffer_subbuf_size_kb -r--r----- 1 root root 0 May 1 21:25 buffer_total_size_kb -rw-r----- 1 root lkp 0 May 1 21:25 current_tracer -rw-r----- 1 root root 0 May 1 21:25 dynamic_events -r--r----- 1 root root 0 May 1 21:25 dyn_ftrace_total_info -r--r----- 1 root root 0 May 1 21:25 enabled_functions Where current_tracer now has group \"lkp\". # mount -o remount,gid=1001 . # ls -l -rw-r----- 1 root tracing 0 May 1 21:25 buffer_size_kb -rw-r----- 1 root tracing 0 May 1 21:25 buffer_subbuf_size_kb -r--r----- 1 root tracing 0 May 1 21:25 buffer_total_size_kb -rw-r----- 1 root lkp 0 May 1 21:25 current_tracer -rw-r----- 1 root tracing 0 May 1 21:25 dynamic_events -r--r----- 1 root tracing 0 May 1 21:25 dyn_ftrace_total_info -r--r----- 1 root tracing 0 May 1 21:25 enabled_functions Everything changed but the \"current_tracer\". Add a new link list that keeps track of all the tracefs_inodes which has the permission flags that tell if the file/dir should use the root inode's permission or not. Then on remount, clear all the flags so that the default behavior of using the root inode's permission is done for all files and directories.",
        "technologies": "Linux\nLinux Kernel 6.6.18 以上 6.6.31 未満\nLinux Kernel 6.7.4 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028045": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: r8169: Fix possible ring buffer corruption on fragmented Tx packets. An issue was found on the RTL8125b when transmitting small fragmented packets, whereby invalid entries were inserted into the transmit ring buffer, subsequently leading to calls to dma_unmap_single() with a null address. This was caused by rtl8169_start_xmit() not noticing changes to nr_frags which may occur when small packets are padded (to work around hardware quirks) in rtl8169_tso_csum_v2(). To fix this, postpone inspecting nr_frags until after any padding has been applied.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-028042": {
        "title": "Linux の Linux Kernel における初期化されていないリソースの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gpiolib: cdev: fix uninitialised kfifo If a line is requested with debounce, and that results in debouncing in software, and the line is subsequently reconfigured to enable edge detection then the allocation of the kfifo to contain edge events is overlooked. This results in events being written to and read from an uninitialised kfifo. Read events are returned to userspace. Initialise the kfifo in the case where the software debounce is already active.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028087": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: RFCOMM: Fix not validating setsockopt user input syzbot reported rfcomm_sock_setsockopt_old() is copying data without checking user input length. BUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline] BUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old net/bluetooth/rfcomm/sock.c:632 [inline] BUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70 net/bluetooth/rfcomm/sock.c:673 Read of size 4 at addr ffff8880209a8bc3 by task syz-executor632/5064",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 5.10.234 未満\nLinux Kernel 5.11 以上 5.15.178 未満\nLinux Kernel 5.16 以上 6.1.107 未満\nLinux Kernel 6.2 以上 6.6.47 未満\nLinux Kernel 6.7 以上 6.8.7 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028124": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: kobject_uevent: Fix OOB access within zap_modalias_env() zap_modalias_env() wrongly calculates size of memory block to move, so will cause OOB memory access issue if variable MODALIAS is not the last one within its @env parameter, fixed by correcting size to memmove.",
        "technologies": "Linux\nLinux Kernel 4.15.1 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満\nLinux Kernel 4.15"
    },
    "JVNDB-2024-028134": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: check n_ssids before accessing the ssids In some versions of cfg80211, the ssids poinet might be a valid one even though n_ssids is 0. Accessing the pointer in this case will cuase an out-of-bound access. Fix this by checking n_ssids first.",
        "technologies": "Linux\nLinux Kernel 4.17 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028099": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vfio/pci: Properly hide first-in-list PCIe extended capability There are cases where a PCIe extended capability should be hidden from the user. For example, an unknown capability (i.e., capability with ID greater than PCI_EXT_CAP_ID_MAX) or a capability that is intentionally chosen to be hidden from the user. Hiding a capability is done by virtualizing and modifying the 'Next Capability Offset' field of the previous capability so it points to the capability after the one that should be hidden. The special case where the first capability in the list should be hidden is handled differently because there is no previous capability that can be modified. In this case, the capability ID and version are zeroed while leaving the next pointer intact. This hides the capability and leaves an anchor for the rest of the capability list. However, today, hiding the first capability in the list is not done properly if the capability is unknown, as struct vfio_pci_core_device->pci_config_map is set to the capability ID during initialization but the capability ID is not properly checked later when used in vfio_config_do_rw(). This leads to the following warning [1] and to an out-of-bounds access to ecap_perms array. Fix it by checking cap_id in vfio_config_do_rw(), and if it is greater than PCI_EXT_CAP_ID_MAX, use an alternative struct perm_bits for direct read only access instead of the ecap_perms array. Note that this is safe since the above is the only case where cap_id can exceed PCI_EXT_CAP_ID_MAX (except for the special capabilities, which are already checked before). [1] WARNING: CPU: 118 PID: 5329 at drivers/vfio/pci/vfio_pci_config.c:1900 vfio_pci_config_rw+0x395/0x430 [vfio_pci_core] CPU: 118 UID: 0 PID: 5329 Comm: simx-qemu-syste Not tainted 6.12.0+ #1 (snip) Call Trace: <TASK> ? show_regs+0x69/0x80 ? __warn+0x8d/0x140 ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core] ? report_bug+0x18f/0x1a0 ? handle_bug+0x63/0xa0 ? exc_invalid_op+0x19/0x70 ? asm_exc_invalid_op+0x1b/0x20 ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core] ? vfio_pci_config_rw+0x244/0x430 [vfio_pci_core] vfio_pci_rw+0x101/0x1b0 [vfio_pci_core] vfio_pci_core_read+0x1d/0x30 [vfio_pci_core] vfio_device_fops_read+0x27/0x40 [vfio] vfs_read+0xbd/0x340 ? vfio_device_fops_unl_ioctl+0xbb/0x740 [vfio] ? __rseq_handle_notify_resume+0xa4/0x4b0 __x64_sys_pread64+0x96/0xc0 x64_sys_call+0x1c3d/0x20d0 do_syscall_64+0x4d/0x120 entry_SYSCALL_64_after_hwframe+0x76/0x7e",
        "technologies": "Linux\nLinux Kernel 3.6 以上 4.19.325 未満\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-028041": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: uvc: use correct buffer size when parsing configfs lists This commit fixes uvc gadget support on 32-bit platforms. Commit 0df28607c5cb (\"usb: gadget: uvc: Generalise helper functions for reuse\") introduced a helper function __uvcg_iter_item_entries() to aid with parsing lists of items on configfs attributes stores. This function is a generalization of another very similar function, which used a stack-allocated temporary buffer of fixed size for each item in the list and used the sizeof() operator to check for potential buffer overruns. The new function was changed to allocate the now variably sized temp buffer on heap, but wasn't properly updated to also check for max buffer size using the computed size instead of sizeof() operator. As a result, the maximum item size was 7 (plus null terminator) on 64-bit platforms, and 3 on 32-bit ones. While 7 is accidentally just barely enough, 3 is definitely too small for some of UVC configfs attributes. For example, dwFrameInteval, specified in 100ns units, usually has 6-digit item values, e.g. 166666 for 60fps.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028093": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: igb: Fix potential invalid memory access in igb_init_module() The pci_register_driver() can fail and when this happened, the dca_notifier needs to be unregistered, otherwise the dca_notifier can be called when igb fails to install, resulting to invalid memory access.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 2.6.29\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028101": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ima: fix buffer overrun in ima_eventdigest_init_common Function ima_eventdigest_init() calls ima_eventdigest_init_common() with HASH_ALGO__LAST which is then used to access the array hash_digest_size[] leading to buffer overrun. Have a conditional statement to handle this.",
        "technologies": "Linux\nLinux Kernel 5.19.1 以上 6.1.119 未満\nLinux Kernel 6.2 以上 6.6.63 未満\nLinux Kernel 6.7 以上 6.11.10 未満\nLinux Kernel 5.19\nLinux Kernel 6.12"
    },
    "JVNDB-2024-028131": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: defer exposing anon_fd until after copy_to_user() succeeds After installing the anonymous fd, we can now see it in userland and close it. However, at this point we may not have gotten the reference count of the cache, but we will put it during colse fd, so this may cause a cache UAF. So grab the cache reference count before fd_install(). In addition, by kernel convention, fd is taken over by the user land after fd_install(), and the kernel should not call close_fd() after that, i.e., it should call fd_install() after everything is ready, thus fd_install() is called after copy_to_user() succeeds.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028133": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xhci: Handle TD clearing for multiple streams case When multiple streams are in use, multiple TDs might be in flight when an endpoint is stopped. We need to issue a Set TR Dequeue Pointer for each, to ensure everything is reset properly and the caches cleared. Change the logic so that any N>1 TDs found active for different streams are deferred until after the first one is processed, calling xhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() to queue another command until we are done with all of them. Also change the error/\"should never happen\" paths to ensure we at least clear any affected TDs, even if we can't issue a command to clear the hardware cache, and complain loudly with an xhci_warn() if this ever happens. This problem case dates back to commit e9df17eb1408 (\"USB: xhci: Correct assumptions about number of rings per endpoint.\") early on in the XHCI driver's life, when stream support was first added. It was then identified but not fixed nor made into a warning in commit 674f8438c121 (\"xhci: split handling halted endpoints into two steps\"), which added a FIXME comment for the problem case (without materially changing the behavior as far as I can tell, though the new logic made the problem more obvious). Then later, in commit 94f339147fc3 (\"xhci: Fix failure to give back some cached cancelled URBs.\"), it was acknowledged again. [Mathias: commit 94f339147fc3 (\"xhci: Fix failure to give back some cached cancelled URBs.\") was a targeted regression fix to the previously mentioned patch. Users reported issues with usb stuck after unmounting/disconnecting UAS devices. This rolled back the TD clearing of multiple streams to its original state.] Apparently the commit author was aware of the problem (yet still chose to submit it): It was still mentioned as a FIXME, an xhci_dbg() was added to log the problem condition, and the remaining issue was mentioned in the commit description. The choice of making the log type xhci_dbg() for what is, at this point, a completely unhandled and known broken condition is puzzling and unfortunate, as it guarantees that no actual users would see the log in production, thereby making it nigh undebuggable (indeed, even if you turn on DEBUG, the message doesn't really hint at there being a problem at all). It took me *months* of random xHC crashes to finally find a reliable repro and be able to do a deep dive debug session, which could all have been avoided had this unhandled, broken condition been actually reported with a warning, as it should have been as a bug intentionally left in unfixed (never mind that it shouldn't have been left in at all). > Another fix to solve clearing the caches of all stream rings with > cancelled TDs is needed, but not as urgent. 3 years after that statement and 14 years after the original bug was introduced, I think it's finally time to fix it. And maybe next time let's not leave bugs unfixed (that are actually worse than the original bug), and let's actually get people to review kernel commits please. Fixes xHC crashes and IOMMU faults with UAS devices when handling errors/faults. Easiest repro is to use `hdparm` to mark an early sector (e.g. 1024) on a disk as bad, then `cat /dev/sdX > /dev/null` in a loop. At least in the case of JMicron controllers, the read errors end up having to cancel two TDs (for two queued requests to different streams) and the one that didn't get cleared properly ends up faulting the xHC entirely when it tries to access DMA pages that have since been unmapped, referred to by the stale TDs. This normally happens quickly (after two or three loops). After this fix, I left the `cat` in a loop running overnight and experienced no xHC failures, with all read errors recovered properly. Repro'd and tested on an Apple M1 Mac Mini (dwc3 host). On systems without an IOMMU, this bug would instead silently corrupt freed memory, making this a ---truncated---",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028107": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: Fix race between namespace cleanup and gc in the list:set type Lion Ackermann reported that there is a race condition between namespace cleanup in ipset and the garbage collection of the list:set type. The namespace cleanup can destroy the list:set type of sets while the gc of the set type is waiting to run in rcu cleanup. The latter uses data from the destroyed set which thus leads use after free. The patch contains the following parts: - When destroying all sets, first remove the garbage collectors, then wait if needed and then destroy the sets. - Fix the badly ordered \"wait then remove gc\" for the destroy a single set case. - Fix the missing rcu locking in the list:set type in the userspace test case. - Use proper RCU list handlings in the list:set type. The patch depends on c1193d9bbbd3 (netfilter: ipset: Add list flush to cancel_gc).",
        "technologies": "Linux\nLinux Kernel 5.4.269 以上 5.4.279 未満\nLinux Kernel 5.10.210 以上 5.10.221 未満\nLinux Kernel 5.15.149 以上 5.15.162 未満\nLinux Kernel 6.1.79 以上 6.1.95 未満\nLinux Kernel 6.6.18 以上 6.6.35 未満\nLinux Kernel 6.7.6 以上 6.8 未満\nLinux Kernel 6.8.1 以上 6.9.6 未満\nLinux Kernel 6.8\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028158": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: regmap: maple: Fix cache corruption in regcache_maple_drop() When keeping the upper end of a cache block entry, the entry[] array must be indexed by the offset from the base register of the block, i.e. max - mas.index. The code was indexing entry[] by only the register address, leading to an out-of-bounds access that copied some part of the kernel memory over the cache contents. This bug was not detected by the regmap KUnit test because it only tests with a block of registers starting at 0, so mas.index == 0.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.26 未満\nLinux Kernel 6.7 以上 6.8.5 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028144": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: validate request buffer size in smb2_allocate_rsp_buf() The response buffer should be allocated in smb2_allocate_rsp_buf before validating request. But the fields in payload as well as smb2 header is used in smb2_allocate_rsp_buf(). This patch add simple buffer size validation to avoid potencial out-of-bounds in request buffer.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.88 未満\nLinux Kernel 6.2 以上 6.6.29 未満\nLinux Kernel 6.7 以上 6.8.8 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028398": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: wait for ondemand_object_worker to finish when dropping object When queuing ondemand_object_worker() to re-open the object, cachefiles_object is not pinned. The cachefiles_object may be freed when the pending read request is completed intentionally and the related erofs is umounted. If ondemand_object_worker() runs after the object is freed, it will incur use-after-free problem as shown below. process A processs B process C process D cachefiles_ondemand_send_req() // send a read req X // wait for its completion // close ondemand fd cachefiles_ondemand_fd_release() // set object as CLOSE cachefiles_ondemand_daemon_read() // set object as REOPENING queue_work(fscache_wq, &info->ondemand_work) // close /dev/cachefiles cachefiles_daemon_release cachefiles_flush_reqs complete(&req->done) // read req X is completed // umount the erofs fs cachefiles_put_object() // object will be freed cachefiles_ondemand_deinit_obj_info() kmem_cache_free(object) // both info and object are freed ondemand_object_worker() When dropping an object, it is no longer necessary to reopen the object, so use cancel_work_sync() to cancel or wait for ondemand_object_worker() to finish.",
        "technologies": "Linux\nLinux Kernel 6.1.95 以上 6.1.100 未満\nLinux Kernel 6.6.35 以上 6.6.41 未満\nLinux Kernel 6.8 以上 6.9.10 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028125": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dma-mapping: benchmark: fix node id validation While validating node ids in map_benchmark_ioctl(), node_possible() may be provided with invalid argument outside of [0,MAX_NUMNODES-1] range leading to: BUG: KASAN: wild-memory-access in map_benchmark_ioctl (kernel/dma/map_benchmark.c:214) Read of size 8 at addr 1fffffff8ccb6398 by task dma_map_benchma/971 CPU: 7 PID: 971 Comm: dma_map_benchma Not tainted 6.9.0-rc6 #37 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:117) kasan_report (mm/kasan/report.c:603) kasan_check_range (mm/kasan/generic.c:189) variable_test_bit (arch/x86/include/asm/bitops.h:227) [inline] arch_test_bit (arch/x86/include/asm/bitops.h:239) [inline] _test_bit at (include/asm-generic/bitops/instrumented-non-atomic.h:142) [inline] node_state (include/linux/nodemask.h:423) [inline] map_benchmark_ioctl (kernel/dma/map_benchmark.c:214) full_proxy_unlocked_ioctl (fs/debugfs/file.c:333) __x64_sys_ioctl (fs/ioctl.c:890) do_syscall_64 (arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) Compare node ids with sane bounds first. NUMA_NO_NODE is considered a special valid case meaning that benchmarking kthreads won't be bound to a cpuset of a given node. Found by Linux Verification Center (linuxtesting.org).",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028381": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mm: use aligned address in clear_gigantic_page() In current kernel, hugetlb_no_page() calls folio_zero_user() with the fault address. Where the fault address may be not aligned with the huge page size. Then, folio_zero_user() may call clear_gigantic_page() with the address, while clear_gigantic_page() requires the address to be huge page size aligned. So, this may cause memory corruption or information leak, addtional, use more obvious naming 'addr_hint' instead of 'addr' for clear_gigantic_page().",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.12.7 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028162": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ARM: 9381/1: kasan: clear stale stack poison We found below OOB crash: [ 33.452494] ================================================================== [ 33.453513] BUG: KASAN: stack-out-of-bounds in refresh_cpu_vm_stats.constprop.0+0xcc/0x2ec [ 33.454660] Write of size 164 at addr c1d03d30 by task swapper/0/0 [ 33.455515] [ 33.455767] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G O 6.1.25-mainline #1 [ 33.456880] Hardware name: Generic DT based system [ 33.457555] unwind_backtrace from show_stack+0x18/0x1c [ 33.458326] show_stack from dump_stack_lvl+0x40/0x4c [ 33.459072] dump_stack_lvl from print_report+0x158/0x4a4 [ 33.459863] print_report from kasan_report+0x9c/0x148 [ 33.460616] kasan_report from kasan_check_range+0x94/0x1a0 [ 33.461424] kasan_check_range from memset+0x20/0x3c [ 33.462157] memset from refresh_cpu_vm_stats.constprop.0+0xcc/0x2ec [ 33.463064] refresh_cpu_vm_stats.constprop.0 from tick_nohz_idle_stop_tick+0x180/0x53c [ 33.464181] tick_nohz_idle_stop_tick from do_idle+0x264/0x354 [ 33.465029] do_idle from cpu_startup_entry+0x20/0x24 [ 33.465769] cpu_startup_entry from rest_init+0xf0/0xf4 [ 33.466528] rest_init from arch_post_acpi_subsys_init+0x0/0x18 [ 33.467397] [ 33.467644] The buggy address belongs to stack of task swapper/0/0 [ 33.468493] and is located at offset 112 in frame: [ 33.469172] refresh_cpu_vm_stats.constprop.0+0x0/0x2ec [ 33.469917] [ 33.470165] This frame has 2 objects: [ 33.470696] [32, 76) 'global_zone_diff' [ 33.470729] [112, 276) 'global_node_diff' [ 33.471294] [ 33.472095] The buggy address belongs to the physical page: [ 33.472862] page:3cd72da8 refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x41d03 [ 33.473944] flags: 0x1000(reserved|zone=0) [ 33.474565] raw: 00001000 ed741470 ed741470 00000000 00000000 00000000 ffffffff 00000001 [ 33.475656] raw: 00000000 [ 33.476050] page dumped because: kasan: bad access detected [ 33.476816] [ 33.477061] Memory state around the buggy address: [ 33.477732] c1d03c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 33.478630] c1d03c80: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 00 00 [ 33.479526] >c1d03d00: 00 04 f2 f2 f2 f2 00 00 00 00 00 00 f1 f1 f1 f1 [ 33.480415] ^ [ 33.481195] c1d03d80: 00 00 00 00 00 00 00 00 00 00 04 f3 f3 f3 f3 f3 [ 33.482088] c1d03e00: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 [ 33.482978] ================================================================== We find the root cause of this OOB is that arm does not clear stale stack poison in the case of cpuidle. This patch refer to arch/arm64/kernel/sleep.S to resolve this issue. From cited commit [1] that explain the problem Functions which the compiler has instrumented for KASAN place poison on the stack shadow upon entry and remove this poison prior to returning. In the case of cpuidle, CPUs exit the kernel a number of levels deep in C code. Any instrumented functions on this critical path will leave portions of the stack shadow poisoned. If CPUs lose context and return to the kernel via a cold path, we restore a prior context saved in __cpu_suspend_enter are forgotten, and we never remove the poison they placed in the stack shadow area by functions calls between this and the actual exit of the kernel. Thus, (depending on stackframe layout) subsequent calls to instrumented functions may hit this stale poison, resulting in (spurious) KASAN splats to the console. To avoid this, clear any stale poison from the idle thread for a CPU prior to bringing a CPU online. From cited commit [2] Extend to check for CONFIG_KASAN_STACK [1] commit 0d97e6d8024c (\"arm64: kasan: clear stale stack poison\") [2] commit d56a9ef84bd0 (\"kasan, arm64: unpoison stack only with CONFIG_KASAN_STACK\")",
        "technologies": "Linux\nLinux Kernel 5.11 以上 5.15.159 未満\nLinux Kernel 5.16 以上 6.1.91 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028163": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Skip on writeback when it's not applicable [WHY] dynamic memory safety error detector (KASAN) catches and generates error messages \"BUG: KASAN: slab-out-of-bounds\" as writeback connector does not support certain features which are not initialized. [HOW] Skip them when connector type is DRM_MODE_CONNECTOR_WRITEBACK.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 6.1.116 未満\nLinux Kernel 6.2 以上 6.6.31 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028164": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfc: llcp: fix nfc_llcp_setsockopt() unsafe copies syzbot reported unsafe calls to copy_from_sockptr() [1] Use copy_safe_from_sockptr() instead. [1] BUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline] BUG: KASAN: slab-out-of-bounds in nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255 Read of size 4 at addr ffff88801caa1ec3 by task syz-executor459/5078 CPU: 0 PID: 5078 Comm: syz-executor459 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] copy_from_sockptr include/linux/sockptr.h:55 [inline] nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255 do_sock_setsockopt+0x3b1/0x720 net/socket.c:2311 __sys_setsockopt+0x1ae/0x250 net/socket.c:2334 __do_sys_setsockopt net/socket.c:2343 [inline] __se_sys_setsockopt net/socket.c:2340 [inline] __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340 do_syscall_64+0xfd/0x240 entry_SYSCALL_64_after_hwframe+0x6d/0x75 RIP: 0033:0x7f7fac07fd89 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 91 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fff660eb788 EFLAGS: 00000246 ORIG_RAX: 0000000000000036 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f7fac07fd89 RDX: 0000000000000000 RSI: 0000000000000118 RDI: 0000000000000004 RBP: 0000000000000000 R08: 0000000000000002 R09: 0000000000000000 R10: 0000000020000a80 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000",
        "technologies": "Linux\nLinux Kernel 6.1.119 未満\nLinux Kernel 6.2 以上 6.6.47 未満\nLinux Kernel 6.7 以上 6.8.10 未満\nLinux Kernel 6.9"
    },
    "JVNDB-2024-028443": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: cyclic allocation of msg_id to avoid reuse Reusing the msg_id after a maliciously completed reopen request may cause a read request to remain unprocessed and result in a hung, as shown below: t1 | t2 | t3 ------------------------------------------------- cachefiles_ondemand_select_req cachefiles_ondemand_object_is_close(A) cachefiles_ondemand_set_object_reopening(A) queue_work(fscache_object_wq, &info->work) ondemand_object_worker cachefiles_ondemand_init_object(A) cachefiles_ondemand_send_req(OPEN) // get msg_id 6 wait_for_completion(&req_A->done) cachefiles_ondemand_daemon_read // read msg_id 6 req_A cachefiles_ondemand_get_fd copy_to_user // Malicious completion msg_id 6 copen 6,-1 cachefiles_ondemand_copen complete(&req_A->done) // will not set the object to close // because ondemand_id && fd is valid. // ondemand_object_worker() is done // but the object is still reopening. // new open req_B cachefiles_ondemand_init_object(B) cachefiles_ondemand_send_req(OPEN) // reuse msg_id 6 process_open_req copen 6,A.size // The expected failed copen was executed successfully Expect copen to fail, and when it does, it closes fd, which sets the object to close, and then close triggers reopen again. However, due to msg_id reuse resulting in a successful copen, the anonymous fd is not closed until the daemon exits. Therefore read requests waiting for reopen to complete may trigger hung task. To avoid this issue, allocate the msg_id cyclically to avoid reusing the msg_id for a very short duration of time.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.100 未満\nLinux Kernel 6.2 以上 6.6.41 未満\nLinux Kernel 6.7 以上 6.9.10 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028165": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tools/nolibc/stdlib: fix memory error in realloc() Pass user_p_len to memcpy() instead of heap->len to prevent realloc() from copying an extra sizeof(heap) bytes from beyond the allocated region.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.8.12 未満\nLinux Kernel 6.9 以上 6.9.3 未満"
    },
    "JVNDB-2024-028444": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Defer work in bpf_timer_cancel_and_free Currently, the same case as previous patch (two timer callbacks trying to cancel each other) can be invoked through bpf_map_update_elem as well, or more precisely, freeing map elements containing timers. Since this relies on hrtimer_cancel as well, it is prone to the same deadlock situation as the previous patch. It would be sufficient to use hrtimer_try_to_cancel to fix this problem, as the timer cannot be enqueued after async_cancel_and_free. Once async_cancel_and_free has been done, the timer must be reinitialized before it can be armed again. The callback running in parallel trying to arm the timer will fail, and freeing bpf_hrtimer without waiting is sufficient (given kfree_rcu), and bpf_timer_cb will return HRTIMER_NORESTART, preventing the timer from being rearmed again. However, there exists a UAF scenario where the callback arms the timer before entering this function, such that if cancellation fails (due to timer callback invoking this routine, or the target timer callback running concurrently). In such a case, if the timer expiration is significantly far in the future, the RCU grace period expiration happening before it will free the bpf_hrtimer state and along with it the struct hrtimer, that is enqueued. Hence, it is clear cancellation needs to occur after async_cancel_and_free, and yet it cannot be done inline due to deadlock issues. We thus modify bpf_timer_cancel_and_free to defer work to the global workqueue, adding a work_struct alongside rcu_head (both used at _different_ points of time, so can share space). Update existing code comments to reflect the new state of affairs.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.9.10 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028139": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/pseries: Enforce hcall result buffer validity and size plpar_hcall(), plpar_hcall9(), and related functions expect callers to provide valid result buffers of certain minimum size. Currently this is communicated only through comments in the code and the compiler has no idea. For example, if I write a bug like this: long retbuf[PLPAR_HCALL_BUFSIZE]; // should be PLPAR_HCALL9_BUFSIZE plpar_hcall9(H_ALLOCATE_VAS_WINDOW, retbuf, ...); This compiles with no diagnostics emitted, but likely results in stack corruption at runtime when plpar_hcall9() stores results past the end of the array. (To be clear this is a contrived example and I have not found a real instance yet.) To make this class of error less likely, we can use explicitly-sized array parameters instead of pointers in the declarations for the hcall APIs. When compiled with -Warray-bounds[1], the code above now provokes a diagnostic like this: error: array argument is too small; is of size 32, callee requires at least 72 [-Werror,-Warray-bounds] 60 | plpar_hcall9(H_ALLOCATE_VAS_WINDOW, retbuf, | ^ ~~~~~~ [1] Enabled for LLVM builds but not GCC for now. See commit 0da6e5fd6c37 (\"gcc: disable '-Warray-bounds' for gcc-13 too\") and related changes.",
        "technologies": "Linux\nLinux Kernel 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満"
    },
    "JVNDB-2024-028441": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tap: add missing verification for short frame The cited commit missed to check against the validity of the frame length in the tap_get_user_xdp() path, which could cause a corrupted skb to be sent downstack. Even before the skb is transmitted, the tap_get_user_xdp()-->skb_set_network_header() may assume the size is more than ETH_HLEN. Once transmitted, this could either cause out-of-bound access beyond the actual length, or confuse the underlayer with incorrect or inconsistent header length in the skb metadata. In the alternative path, tap_get_user() already prohibits short frame which has the length less than Ethernet header size from being transmitted. This is to drop any frame shorter than the Ethernet header size just like how tap_get_user() does. CVE: CVE-2024-41090",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.281 未満\nLinux Kernel 5.5 以上 5.10.223 未満\nLinux Kernel 5.11 以上 5.15.164 未満\nLinux Kernel 5.16 以上 6.1.102 未満\nLinux Kernel 6.2 以上 6.6.43 未満\nLinux Kernel 6.7 以上 6.9.12 未満\nLinux Kernel 6.10 以上 6.10.2 未満"
    },
    "JVNDB-2024-028405": {
        "title": "Linux Foundation の containerd 等複数ベンダの製品における整数オーバーフローの脆弱性",
        "description": "containerd is an open-source container runtime. A bug was found in containerd prior to versions 1.6.38, 1.7.27, and 2.0.4 where containers launched with a User set as a `UID:GID` larger than the maximum 32-bit signed integer can cause an overflow condition where the container ultimately runs as root (UID 0). This could cause unexpected behavior for environments that require containers to run as a non-root user. This bug has been fixed in containerd 1.6.38, 1.7.27, and 2.04. As a workaround, ensure that only trusted images are used and that only trusted users have permissions to import images.",
        "technologies": "Debian\nDebian GNU/Linux 11.0\nLinux Foundation\ncontainerd 1.6.38 未満\ncontainerd 1.7.0 以上 1.7.27 未満\ncontainerd 2.0.0 以上 2.0.4 未満"
    },
    "JVNDB-2024-028448": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: chemical: bme680: Fix overflows in compensate() functions There are cases in the compensate functions of the driver that there could be overflows of variables due to bit shifting ops. These implications were initially discussed here [1] and they were mentioned in log message of Commit 1b3bd8592780 (\"iio: chemical: Add support for Bosch BME680 sensor\"). [1]: https://lore.kernel.org/linux-iio/20180728114028.3c1bbe81@archlinux/",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028447": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cachefiles: Set object to close if ondemand_id < 0 in copen If copen is maliciously called in the user mode, it may delete the request corresponding to the random id. And the request may have not been read yet. Note that when the object is set to reopen, the open request will be done with the still reopen state in above case. As a result, the request corresponding to this object is always skipped in select_req function, so the read request is never completed and blocks other process. Fix this issue by simply set object to close if its id < 0 in copen.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028451": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix inode number range checks Patch series \"nilfs2: fix potential issues related to reserved inodes\". This series fixes one use-after-free issue reported by syzbot, caused by nilfs2's internal inode being exposed in the namespace on a corrupted filesystem, and a couple of flaws that cause problems if the starting number of non-reserved inodes written in the on-disk super block is intentionally (or corruptly) changed from its default value. This patch (of 3): In the current implementation of nilfs2, \"nilfs->ns_first_ino\", which gives the first non-reserved inode number, is read from the superblock, but its lower limit is not checked. As a result, if a number that overlaps with the inode number range of reserved inodes such as the root directory or metadata files is set in the super block parameter, the inode number test macros (NILFS_MDT_INODE and NILFS_VALID_INODE) will not function properly. In addition, these test macros use left bit-shift calculations using with the inode number as the shift count via the BIT macro, but the result of a shift calculation that exceeds the bit width of an integer is undefined in the C specification, so if \"ns_first_ino\" is set to a large value other than the default value NILFS_USER_INO (=11), the macros may potentially malfunction depending on the environment. Fix these issues by checking the lower bound of \"nilfs->ns_first_ino\" and by preventing bit shifts equal to or greater than the NILFS_USER_INO constant in the inode number test macros. Also, change the type of \"ns_first_ino\" from signed integer to unsigned integer to avoid the need for type casting in comparisons such as the lower bound check introduced this time.",
        "technologies": "Linux\nLinux Kernel 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028459": {
        "title": "Linux の Linux Kernel におけるバッファサイズの計算の誤りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix incorrect size calculation for loop [WHY] fe_clk_en has size of 5 but sizeof(fe_clk_en) has byte size 20 which is lager than the array size. [HOW] Divide byte size 20 by its element size. This fixes 2 OVERRUN issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 6.10.9 未満"
    },
    "JVNDB-2024-028466": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: pci: ivtv: Add check for DMA map result In case DMA fails, 'dma->SG_length' is 0. This value is later used to access 'dma->SGarray[dma->SG_length - 1]', which will cause out of bounds access. Add check to return early on invalid value. Adjust warnings accordingly. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-028586": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Skip finding free audio for unknown engine_id [WHY] ENGINE_ID_UNKNOWN = -1 and can not be used as an array index. Plus, it also means it is uninitialized and does not need free audio. [HOW] Skip and return NULL. This fixes 2 OVERRUN issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 4.19.318 未満\nLinux Kernel 4.20 以上 5.4.280 未満\nLinux Kernel 5.5 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-028648": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: topology: Fix references to freed memory Most users after parsing a topology file, release memory used by it, so having pointer references directly into topology file contents is wrong. Use devm_kmemdup(), to allocate memory as needed.",
        "technologies": "Linux\nLinux Kernel 6.1.101 未満\nLinux Kernel 6.2 以上 6.6.42 未満\nLinux Kernel 6.7 以上 6.9.11 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028541": {
        "title": "Linux の Linux Kernel における有効期限後または解放後のリソースの操作に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dm array: fix releasing a faulty array block twice in dm_array_cursor_end When dm_bm_read_lock() fails due to locking or checksum errors, it releases the faulty block implicitly while leaving an invalid output pointer behind. The caller of dm_bm_read_lock() should not operate on this invalid dm_block pointer, or it will lead to undefined result. For example, the dm_array_cursor incorrectly caches the invalid pointer on reading a faulty array block, causing a double release in dm_array_cursor_end(), then hitting the BUG_ON in dm-bufio cache_put(). Reproduce steps: 1. initialize a cache device dmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\" dmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\" dmsetup create corig --table \"0 524288 linear /dev/sdc $262144\" dd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 dmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\" 2. wipe the second array block offline dmsteup remove cache cmeta cdata corig mapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \\ 2>/dev/null | hexdump -e '1/8 \"%u\\n\"') ablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \\ 2>/dev/null | hexdump -e '1/8 \"%u\\n\"') dd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock 3. try reopen the cache device dmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\" dmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\" dmsetup create corig --table \"0 524288 linear /dev/sdc $262144\" dmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\" Kernel logs: (snip) device-mapper: array: array_block_check failed: blocknr 0 != wanted 10 device-mapper: block manager: array validator check failed for block 10 device-mapper: array: get_ablock failed device-mapper: cache metadata: dm_array_cursor_next for mapping failed ------------[ cut here ]------------ kernel BUG at drivers/md/dm-bufio.c:638! Fix by setting the cached block pointer to NULL on errors. In addition to the reproducer described above, this fix can be verified using the \"array_cursor/damaged\" test in dm-unit: dm-unit run /pdata/array_cursor/damaged --kernel-dir <KERNEL_DIR>",
        "technologies": "Linux\nLinux Kernel 4.9 以上 5.4.290 未満\nLinux Kernel 5.5 以上 5.10.234 未満\nLinux Kernel 5.11 以上 5.15.177 未満\nLinux Kernel 5.16 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028452": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: gpio: davinci: Validate the obtained number of IRQs Value of pdata->gpio_unbanked is taken from Device Tree. In case of broken DT due to any error this value can be any. Without this value validation there can be out of chips->irqs array boundaries access in davinci_gpio_probe(). Validate the obtained nirq value so that it won't exceed the maximum number of IRQs per bank. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.97 未満\nLinux Kernel 6.2 以上 6.6.37 未満\nLinux Kernel 6.7 以上 6.9.8 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028464": {
        "title": "Linux の Linux Kernel における誤った領域へのリソースの漏えいに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: change DMA direction while mapping reinjected packets For fragmented packets, ath12k reassembles each fragment as a normal packet and then reinjects it into HW ring. In this case, the DMA direction should be DMA_TO_DEVICE, not DMA_FROM_DEVICE. Otherwise, an invalid payload may be reinjected into the HW and subsequently delivered to the host. Given that arbitrary memory can be allocated to the skb buffer, knowledge about the data contained in the reinjected buffer is lacking. Consequently, there’s a risk of private information being leaked. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.1.1-00209-QCAHKSWPL_SILICONZ-1",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-028458": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: perf/aux: Fix AUX buffer serialization Ole reported that event->mmap_mutex is strictly insufficient to serialize the AUX buffer, add a per RB mutex to fully serialize it. Note that in the lock order comment the perf_event::mmap_mutex order was already wrong, that is, it nesting under mmap_lock is not new with this patch.",
        "technologies": "Linux\nLinux Kernel 4.1 以上 5.10.226 未満\nLinux Kernel 5.11 以上 5.15.167 未満\nLinux Kernel 5.16 以上 6.1.110 未満\nLinux Kernel 6.2 以上 6.6.51 未満\nLinux Kernel 6.7 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-028460": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix double put of @cfile in smb2_rename_path() If smb2_set_path_attr() is called with a valid @cfile and returned -EINVAL, we need to call cifs_get_writable_path() again as the reference of @cfile was already dropped by previous smb2_compound_op() call.",
        "technologies": "Linux\nLinux Kernel 6.6.32 以上 6.6.51 未満\nLinux Kernel 6.9 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-028471": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfs: Fix enomem handling in buffered reads If netfs_read_to_pagecache() gets an error from either ->prepare_read() or from netfs_prepare_read_iterator(), it needs to decrement ->nr_outstanding, cancel the subrequest and break out of the issuing loop. Currently, it only does this for two of the cases, but there are two more that aren't handled. Fix this by moving the handling to a common place and jumping to it from all four places. This is in preference to inserting a wrapper around netfs_prepare_read_iterator() as proposed by Dmitry Antipov[1].",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028542": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: riscv: mm: Fix the out of bound issue of vmemmap address In sparse vmemmap model, the virtual address of vmemmap is calculated as: ((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT)). And the struct page's va can be calculated with an offset: (vmemmap + (pfn)). However, when initializing struct pages, kernel actually starts from the first page from the same section that phys_ram_base belongs to. If the first page's physical address is not (phys_ram_base >> PAGE_SHIFT), then we get an va below VMEMMAP_START when calculating va for it's struct page. For example, if phys_ram_base starts from 0x82000000 with pfn 0x82000, the first page in the same section is actually pfn 0x80000. During init_unavailable_range(), we will initialize struct page for pfn 0x80000 with virtual address ((struct page *)VMEMMAP_START - 0x2000), which is below VMEMMAP_START as well as PCI_IO_END. This commit fixes this bug by introducing a new variable 'vmemmap_start_pfn' which is aligned with memory section size and using it to calculate vmemmap address instead of phys_ram_base.",
        "technologies": "Linux\nLinux Kernel 5.10.212 以上 5.11 未満\nLinux Kernel 5.15.151 以上 5.16 未満\nLinux Kernel 6.1.81 以上 6.1.140 未満\nLinux Kernel 6.6.21 以上 6.6.72 未満\nLinux Kernel 6.7.9 以上 6.8 未満\nLinux Kernel 6.8.1 以上 6.12.10 未満\nLinux Kernel 6.8\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028571": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Do not return negative stream id for array [WHY] resource_stream_to_stream_idx returns an array index and it return -1 when not found; however, -1 is not a valid array index number. [HOW] When this happens, call ASSERT(), and return a zero instead. This fixes an OVERRUN and an NEGATIVE_RETURNS issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 6.9.9 未満"
    },
    "JVNDB-2024-028457": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xfrm: Fix input error path memory access When there is a misconfiguration of input state slow path KASAN report error. Fix this error. west login: [ 52.987278] eth1: renamed from veth11 [ 53.078814] eth1: renamed from veth21 [ 53.181355] eth1: renamed from veth31 [ 54.921702] ================================================================== [ 54.922602] BUG: KASAN: wild-memory-access in xfrmi_rcv_cb+0x2d/0x295 [ 54.923393] Read of size 8 at addr 6b6b6b6b00000000 by task ping/512 [ 54.924169] [ 54.924386] CPU: 0 PID: 512 Comm: ping Not tainted 6.9.0-08574-gcd29a4313a1b #25 [ 54.925290] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 54.926401] Call Trace: [ 54.926731] <IRQ> [ 54.927009] dump_stack_lvl+0x2a/0x3b [ 54.927478] kasan_report+0x84/0xa6 [ 54.927930] ? xfrmi_rcv_cb+0x2d/0x295 [ 54.928410] xfrmi_rcv_cb+0x2d/0x295 [ 54.928872] ? xfrm4_rcv_cb+0x3d/0x5e [ 54.929354] xfrm4_rcv_cb+0x46/0x5e [ 54.929804] xfrm_rcv_cb+0x7e/0xa1 [ 54.930240] xfrm_input+0x1b3a/0x1b96 [ 54.930715] ? xfrm_offload+0x41/0x41 [ 54.931182] ? raw_rcv+0x292/0x292 [ 54.931617] ? nf_conntrack_confirm+0xa2/0xa2 [ 54.932158] ? skb_sec_path+0xd/0x3f [ 54.932610] ? xfrmi_input+0x90/0xce [ 54.933066] xfrm4_esp_rcv+0x33/0x54 [ 54.933521] ip_protocol_deliver_rcu+0xd7/0x1b2 [ 54.934089] ip_local_deliver_finish+0x110/0x120 [ 54.934659] ? ip_protocol_deliver_rcu+0x1b2/0x1b2 [ 54.935248] NF_HOOK.constprop.0+0xf8/0x138 [ 54.935767] ? ip_sublist_rcv_finish+0x68/0x68 [ 54.936317] ? secure_tcpv6_ts_off+0x23/0x168 [ 54.936859] ? ip_protocol_deliver_rcu+0x1b2/0x1b2 [ 54.937454] ? __xfrm_policy_check2.constprop.0+0x18d/0x18d [ 54.938135] NF_HOOK.constprop.0+0xf8/0x138 [ 54.938663] ? ip_sublist_rcv_finish+0x68/0x68 [ 54.939220] ? __xfrm_policy_check2.constprop.0+0x18d/0x18d [ 54.939904] ? ip_local_deliver_finish+0x120/0x120 [ 54.940497] __netif_receive_skb_one_core+0xc9/0x107 [ 54.941121] ? __netif_receive_skb_list_core+0x1c2/0x1c2 [ 54.941771] ? blk_mq_start_stopped_hw_queues+0xc7/0xf9 [ 54.942413] ? blk_mq_start_stopped_hw_queue+0x38/0x38 [ 54.943044] ? virtqueue_get_buf_ctx+0x295/0x46b [ 54.943618] process_backlog+0xb3/0x187 [ 54.944102] __napi_poll.constprop.0+0x57/0x1a7 [ 54.944669] net_rx_action+0x1cb/0x380 [ 54.945150] ? __napi_poll.constprop.0+0x1a7/0x1a7 [ 54.945744] ? vring_new_virtqueue+0x17a/0x17a [ 54.946300] ? note_interrupt+0x2cd/0x367 [ 54.946805] handle_softirqs+0x13c/0x2c9 [ 54.947300] do_softirq+0x5f/0x7d [ 54.947727] </IRQ> [ 54.948014] <TASK> [ 54.948300] __local_bh_enable_ip+0x48/0x62 [ 54.948832] __neigh_event_send+0x3fd/0x4ca [ 54.949361] neigh_resolve_output+0x1e/0x210 [ 54.949896] ip_finish_output2+0x4bf/0x4f0 [ 54.950410] ? __ip_finish_output+0x171/0x1b8 [ 54.950956] ip_send_skb+0x25/0x57 [ 54.951390] raw_sendmsg+0xf95/0x10c0 [ 54.951850] ? check_new_pages+0x45/0x71 [ 54.952343] ? raw_hash_sk+0x21b/0x21b [ 54.952815] ? kernel_init_pages+0x42/0x51 [ 54.953337] ? prep_new_page+0x44/0x51 [ 54.953811] ? get_page_from_freelist+0x72b/0x915 [ 54.954390] ? signal_pending_state+0x77/0x77 [ 54.954936] ? preempt_count_sub+0x14/0xb3 [ 54.955450] ? __might_resched+0x8a/0x240 [ 54.955951] ? __might_sleep+0x25/0xa0 [ 54.956424] ? first_zones_zonelist+0x2c/0x43 [ 54.956977] ? __rcu_read_lock+0x2d/0x3a [ 54.957476] ? __pte_offset_map+0x32/0xa4 [ 54.957980] ? __might_resched+0x8a/0x240 [ 54.958483] ? __might_sleep+0x25/0xa0 [ 54.958963] ? inet_send_prepare+0x54/0x54 [ 54.959478] ? sock_sendmsg_nosec+0x42/0x6c [ 54.960000] sock_sendmsg_nosec+0x42/0x6c [ 54.960502] __sys_sendto+0x15d/0x1cc [ 54.960966] ? __x64_sys_getpeername+0x44/0x44 [ 54.961522] ? __handle_mm_fault+0x679/0xae4 [ 54.962068] ? find_vma+0x6b/0x ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.10.3 未満"
    },
    "JVNDB-2024-028536": {
        "title": "Linux の Linux Kernel における二重解放に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/pci: Fix potential double remove of hotplug slot In commit 6ee600bfbe0f (\"s390/pci: remove hotplug slot when releasing the device\") the zpci_exit_slot() was moved from zpci_device_reserved() to zpci_release_device() with the intention of keeping the hotplug slot around until the device is actually removed. Now zpci_release_device() is only called once all references are dropped. Since the zPCI subsystem only drops its reference once the device is in the reserved state it follows that zpci_release_device() must only deal with devices in the reserved state. Despite that it contains code to tear down from both configured and standby state. For the standby case this already includes the removal of the hotplug slot so would cause a double removal if a device was ever removed in either configured or standby state. Instead of causing a potential double removal in a case that should never happen explicitly WARN_ON() if a device in non-reserved state is released and get rid of the dead code cases.",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-028537": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/dp_mst: Fix resetting msg rx state after topology removal If the MST topology is removed during the reception of an MST down reply or MST up request sideband message, the drm_dp_mst_topology_mgr::up_req_recv/down_rep_recv states could be reset from one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with the reading/parsing of the message from another thread via drm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is possible since the reader/parser doesn't hold any lock while accessing the reception state. This in turn can lead to a memory corruption in the reader/parser as described by commit bd2fccac61b4 (\"drm/dp_mst: Fix MST sideband message body length check\"). Fix the above by resetting the message reception state if needed before reading/parsing a message. Another solution would be to hold the drm_dp_mst_topology_mgr::lock for the whole duration of the message reception/parsing in drm_dp_mst_handle_down_rep() and drm_dp_mst_handle_up_req(), however this would require a bigger change. Since the fix is also needed for stable, opting for the simpler solution in this patch.",
        "technologies": "Linux\nLinux Kernel 5.10.173 以上 5.11 未満\nLinux Kernel 5.15.100 以上 5.16 未満\nLinux Kernel 6.1.18 以上 6.1.120 未満\nLinux Kernel 6.2.5 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028659": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: txgbe: free isb resources at the right time When using MSI/INTx interrupt, the shared interrupts are still being handled in the device remove routine, before free IRQs. So isb memory is still read after it is freed. Thus move wx_free_isb_resources() from txgbe_close() to txgbe_remove(). And fix the improper isb free action in txgbe_open() error handling path.",
        "technologies": "Linux\nLinux Kernel 6.8.12 以上 6.9 未満\nLinux Kernel 6.9 以上 6.9.9 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028591": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: taprio: always validate TCA_TAPRIO_ATTR_PRIOMAP If one TCA_TAPRIO_ATTR_PRIOMAP attribute has been provided, taprio_parse_mqprio_opt() must validate it, or userspace can inject arbitrary data to the kernel, the second time taprio_change() is called. First call (with valid attributes) sets dev->num_tc to a non zero value. Second call (with arbitrary mqprio attributes) returns early from taprio_parse_mqprio_opt() and bad things can happen.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.6 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028660": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check pipe offset before setting vblank pipe_ctx has a size of MAX_PIPES so checking its index before accessing the array. This fixes an OVERRUN issue reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-028706": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ovl: Filter invalid inodes with missing lookup function Add a check to the ovl_dentry_weird() function to prevent the processing of directory inodes that lack the lookup function. This is important because such inodes can cause errors in overlayfs when passed to the lowerstack.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.64 未満\nLinux Kernel 6.7 以上 6.12.4 未満"
    },
    "JVNDB-2024-028713": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: Add architecture specific huge_pte_clear() When executing mm selftests run_vmtests.sh, there is such an error: BUG: Bad page state in process uffd-unit-tests pfn:00000 page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x0 flags: 0xffff0000002000(reserved|node=0|zone=0|lastcpupid=0xffff) raw: 00ffff0000002000 ffffbf0000000008 ffffbf0000000008 0000000000000000 raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set Modules linked in: snd_seq_dummy snd_seq snd_seq_device rfkill vfat fat virtio_balloon efi_pstore virtio_net pstore net_failover failover fuse nfnetlink virtio_scsi virtio_gpu virtio_dma_buf dm_multipath efivarfs CPU: 2 UID: 0 PID: 1913 Comm: uffd-unit-tests Not tainted 6.12.0 #184 Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022 Stack : 900000047c8ac000 0000000000000000 9000000000223a7c 900000047c8ac000 900000047c8af690 900000047c8af698 0000000000000000 900000047c8af7d8 900000047c8af7d0 900000047c8af7d0 900000047c8af5b0 0000000000000001 0000000000000001 900000047c8af698 10b3c7d53da40d26 0000010000000000 0000000000000022 0000000fffffffff fffffffffe000000 ffff800000000000 000000000000002f 0000800000000000 000000017a6d4000 90000000028f8940 0000000000000000 0000000000000000 90000000025aa5e0 9000000002905000 0000000000000000 90000000028f8940 ffff800000000000 0000000000000000 0000000000000000 0000000000000000 9000000000223a94 000000012001839c 00000000000000b0 0000000000000004 0000000000000000 0000000000071c1d ... Call Trace: [<9000000000223a94>] show_stack+0x5c/0x180 [<9000000001c3fd64>] dump_stack_lvl+0x6c/0xa0 [<900000000056aa08>] bad_page+0x1a0/0x1f0 [<9000000000574978>] free_unref_folios+0xbf0/0xd20 [<90000000004e65cc>] folios_put_refs+0x1a4/0x2b8 [<9000000000599a0c>] free_pages_and_swap_cache+0x164/0x260 [<9000000000547698>] tlb_batch_pages_flush+0xa8/0x1c0 [<9000000000547f30>] tlb_finish_mmu+0xa8/0x218 [<9000000000543cb8>] exit_mmap+0x1a0/0x360 [<9000000000247658>] __mmput+0x78/0x200 [<900000000025583c>] do_exit+0x43c/0xde8 [<9000000000256490>] do_group_exit+0x68/0x110 [<9000000000256554>] sys_exit_group+0x1c/0x20 [<9000000001c413b4>] do_syscall+0x94/0x130 [<90000000002216d8>] handle_syscall+0xb8/0x158 Disabling lock debugging due to kernel taint BUG: non-zero pgtables_bytes on freeing mm: -16384 On LoongArch system, invalid huge pte entry should be invalid_pte_table or a single _PAGE_HUGE bit rather than a zero value. And it should be the same with invalid pmd entry, since pmd_none() is called by function free_pgd_range() and pmd_none() return 0 by huge_pte_clear(). So single _PAGE_HUGE bit is also treated as a valid pte table and free_pte_range() will be called in free_pmd_range(). free_pmd_range() pmd = pmd_offset(pud, addr); do { next = pmd_addr_end(addr, end); if (pmd_none_or_clear_bad(pmd)) continue; free_pte_range(tlb, pmd, addr); } while (pmd++, addr = next, addr != end); Here invalid_pte_table is used for both invalid huge pte entry and pmd entry.",
        "technologies": "Linux\nLinux Kernel 5.19 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028702": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix nilfs_empty_dir() misjudgment and long loop on I/O errors The error handling in nilfs_empty_dir() when a directory folio/page read fails is incorrect, as in the old ext2 implementation, and if the folio/page cannot be read or nilfs_check_folio() fails, it will falsely determine the directory as empty and corrupt the file system. In addition, since nilfs_empty_dir() does not immediately return on a failed folio/page read, but continues to loop, this can cause a long loop with I/O if i_size of the directory's inode is also corrupted, causing the log writer thread to wait and hang, as reported by syzbot. Fix these issues by making nilfs_empty_dir() immediately return a false value (0) if it fails to get a directory folio/page.",
        "technologies": "Linux\nLinux Kernel 2.6.30 以上 4.19.317 未満\nLinux Kernel 4.20 以上 5.4.279 未満\nLinux Kernel 5.5 以上 5.10.221 未満\nLinux Kernel 5.11 以上 5.15.162 未満\nLinux Kernel 5.16 以上 6.1.95 未満\nLinux Kernel 6.2 以上 6.6.35 未満\nLinux Kernel 6.7 以上 6.9.5 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028718": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: mailbox: mtk-cmdq: fix wrong use of sizeof in cmdq_get_clocks() It should be size of the struct clk_bulk_data, not data pointer pass to devm_kcalloc().",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.11.11 未満\nLinux Kernel 6.12 以上 6.12.2 未満"
    },
    "JVNDB-2024-028711": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw88: use ieee80211_purge_tx_queue() to purge TX skb When removing kernel modules by: rmmod rtw88_8723cs rtw88_8703b rtw88_8723x rtw88_sdio rtw88_core Driver uses skb_queue_purge() to purge TX skb, but not report tx status causing \"Have pending ack frames!\" warning. Use ieee80211_purge_tx_queue() to correct this. Since ieee80211_purge_tx_queue() doesn't take locks, to prevent racing between TX work and purge TX queue, flush and destroy TX work in advance. wlan0: deauthenticating from aa:f5:fd:60:4c:a8 by local choice (Reason: 3=DEAUTH_LEAVING) ------------[ cut here ]------------ Have pending ack frames! WARNING: CPU: 3 PID: 9232 at net/mac80211/main.c:1691 ieee80211_free_ack_frame+0x5c/0x90 [mac80211] CPU: 3 PID: 9232 Comm: rmmod Tainted: G C 6.10.1-200.fc40.aarch64 #1 Hardware name: pine64 Pine64 PinePhone Braveheart (1.1)/Pine64 PinePhone Braveheart (1.1), BIOS 2024.01 01/01/2024 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : ieee80211_free_ack_frame+0x5c/0x90 [mac80211] lr : ieee80211_free_ack_frame+0x5c/0x90 [mac80211] sp : ffff80008c1b37b0 x29: ffff80008c1b37b0 x28: ffff000003be8000 x27: 0000000000000000 x26: 0000000000000000 x25: ffff000003dc14b8 x24: ffff80008c1b37d0 x23: ffff000000ff9f80 x22: 0000000000000000 x21: 000000007fffffff x20: ffff80007c7e93d8 x19: ffff00006e66f400 x18: 0000000000000000 x17: ffff7ffffd2b3000 x16: ffff800083fc0000 x15: 0000000000000000 x14: 0000000000000000 x13: 2173656d61726620 x12: 6b636120676e6964 x11: 0000000000000000 x10: 000000000000005d x9 : ffff8000802af2b0 x8 : ffff80008c1b3430 x7 : 0000000000000001 x6 : 0000000000000001 x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000003be8000 Call trace: ieee80211_free_ack_frame+0x5c/0x90 [mac80211] idr_for_each+0x74/0x110 ieee80211_free_hw+0x44/0xe8 [mac80211] rtw_sdio_remove+0x9c/0xc0 [rtw88_sdio] sdio_bus_remove+0x44/0x180 device_remove+0x54/0x90 device_release_driver_internal+0x1d4/0x238 driver_detach+0x54/0xc0 bus_remove_driver+0x78/0x108 driver_unregister+0x38/0x78 sdio_unregister_driver+0x2c/0x40 rtw_8723cs_driver_exit+0x18/0x1000 [rtw88_8723cs] __do_sys_delete_module.isra.0+0x190/0x338 __arm64_sys_delete_module+0x1c/0x30 invoke_syscall+0x74/0x100 el0_svc_common.constprop.0+0x48/0xf0 do_el0_svc+0x24/0x38 el0_svc+0x3c/0x158 el0t_64_sync_handler+0x120/0x138 el0t_64_sync+0x194/0x198 ---[ end trace 0000000000000000 ]---",
        "technologies": "Linux\nLinux Kernel 5.2 以上 6.1.136 未満\nLinux Kernel 6.2 以上 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-028714": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tcp_bpf: Fix the sk_mem_uncharge logic in tcp_bpf_sendmsg The current sk memory accounting logic in __SK_REDIRECT is pre-uncharging tosend bytes, which is either msg->sg.size or a smaller value apply_bytes. Potential problems with this strategy are as follows: - If the actual sent bytes are smaller than tosend, we need to charge some bytes back, as in line 487, which is okay but seems not clean. - When tosend is set to apply_bytes, as in line 417, and (ret < 0), we may miss uncharging (msg->sg.size - apply_bytes) bytes. [...] 415 tosend = msg->sg.size; 416 if (psock->apply_bytes && psock->apply_bytes < tosend) 417 tosend = psock->apply_bytes; [...] 443 sk_msg_return(sk, msg, tosend); 444 release_sock(sk); 446 origsize = msg->sg.size; 447 ret = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress, 448 msg, tosend, flags); 449 sent = origsize - msg->sg.size; [...] 454 lock_sock(sk); 455 if (unlikely(ret < 0)) { 456 int free = sk_msg_free_nocharge(sk, msg); 458 if (!cork) 459 *copied -= free; 460 } [...] 487 if (eval == __SK_REDIRECT) 488 sk_mem_charge(sk, tosend - sent); [...] When running the selftest test_txmsg_redir_wait_sndmem with txmsg_apply, the following warning will be reported: ------------[ cut here ]------------ WARNING: CPU: 6 PID: 57 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x190/0x1a0 Modules linked in: CPU: 6 UID: 0 PID: 57 Comm: kworker/6:0 Not tainted 6.12.0-rc1.bm.1-amd64+ #43 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 Workqueue: events sk_psock_destroy RIP: 0010:inet_sock_destruct+0x190/0x1a0 RSP: 0018:ffffad0a8021fe08 EFLAGS: 00010206 RAX: 0000000000000011 RBX: ffff9aab4475b900 RCX: ffff9aab481a0800 RDX: 0000000000000303 RSI: 0000000000000011 RDI: ffff9aab4475b900 RBP: ffff9aab4475b990 R08: 0000000000000000 R09: ffff9aab40050ec0 R10: 0000000000000000 R11: ffff9aae6fdb1d01 R12: ffff9aab49c60400 R13: ffff9aab49c60598 R14: ffff9aab49c60598 R15: dead000000000100 FS: 0000000000000000(0000) GS:ffff9aae6fd80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffec7e47bd8 CR3: 00000001a1a1c004 CR4: 0000000000770ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> ? __warn+0x89/0x130 ? inet_sock_destruct+0x190/0x1a0 ? report_bug+0xfc/0x1e0 ? handle_bug+0x5c/0xa0 ? exc_invalid_op+0x17/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? inet_sock_destruct+0x190/0x1a0 __sk_destruct+0x25/0x220 sk_psock_destroy+0x2b2/0x310 process_scheduled_works+0xa3/0x3e0 worker_thread+0x117/0x240 ? __pfx_worker_thread+0x10/0x10 kthread+0xcf/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x40 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> ---[ end trace 0000000000000000 ]--- In __SK_REDIRECT, a more concise way is delaying the uncharging after sent bytes are finalized, and uncharge this value. When (ret < 0), we shall invoke sk_msg_free. Same thing happens in case __SK_DROP, when tosend is set to apply_bytes, we may miss uncharging (msg->sg.size - apply_bytes) bytes. The same warning will be reported in selftest. [...] 468 case __SK_DROP: 469 default: 470 sk_msg_free_partial(sk, msg, tosend); 471 sk_msg_apply_bytes(psock, tosend); 472 *copied -= (tosend + delta); 473 return -EACCES; [...] So instead of sk_msg_free_partial we can do sk_msg_free here.",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028759": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: Disassociate vcpus from redistributor region on teardown When tearing down a redistributor region, make sure we don't have any dangling pointer to that region stored in a vcpu.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 6.1.96 未満\nLinux Kernel 6.2 以上 6.6.36 未満\nLinux Kernel 6.7 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028865": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: prefer nft_chain_validate nft_chain_validate already performs loop detection because a cycle will result in a call stack overflow (ctx->level >= NFT_JUMP_STACK_SIZE). It also follows maps via ->validate callback in nft_lookup, so there appears no reason to iterate the maps again. nf_tables_check_loops() and all its helper functions can be removed. This improves ruleset load time significantly, from 23s down to 12s. This also fixes a crash bug. Old loop detection code can result in unbounded recursion: BUG: TASK stack guard page was hit at .... Oops: stack guard page: 0000 [#1] PREEMPT SMP KASAN CPU: 4 PID: 1539 Comm: nft Not tainted 6.10.0-rc5+ #1 [..] with a suitable ruleset during validation of register stores. I can't see any actual reason to attempt to check for this from nft_validate_register_store(), at this point the transaction is still in progress, so we don't have a full picture of the rule graph. For nf-next it might make sense to either remove it or make this depend on table->validate_state in case we could catch an error earlier (for improved error reporting to userspace).",
        "technologies": "Linux\nLinux Kernel 3.13 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.105 未満\nLinux Kernel 6.2 以上 6.6.46 未満\nLinux Kernel 6.7 以上 6.9.10 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028862": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix reg_set_min_max corruption of fake_reg Juan reported that after doing some changes to buzzer [0] and implementing a new fuzzing strategy guided by coverage, they noticed the following in one of the probes: [...] 13: (79) r6 = *(u64 *)(r0 +0) ; R0=map_value(ks=4,vs=8) R6_w=scalar() 14: (b7) r0 = 0 ; R0_w=0 15: (b4) w0 = -1 ; R0_w=0xffffffff 16: (74) w0 >>= 1 ; R0_w=0x7fffffff 17: (5c) w6 &= w0 ; R0_w=0x7fffffff R6_w=scalar(smin=smin32=0,smax=umax=umax32=0x7fffffff,var_off=(0x0; 0x7fffffff)) 18: (44) w6 |= 2 ; R6_w=scalar(smin=umin=smin32=umin32=2,smax=umax=umax32=0x7fffffff,var_off=(0x2; 0x7ffffffd)) 19: (56) if w6 != 0x7ffffffd goto pc+1 REG INVARIANTS VIOLATION (true_reg2): range bounds violation u64=[0x7fffffff, 0x7ffffffd] s64=[0x7fffffff, 0x7ffffffd] u32=[0x7fffffff, 0x7ffffffd] s32=[0x7fffffff, 0x7ffffffd] var_off=(0x7fffffff, 0x0) REG INVARIANTS VIOLATION (false_reg1): range bounds violation u64=[0x7fffffff, 0x7ffffffd] s64=[0x7fffffff, 0x7ffffffd] u32=[0x7fffffff, 0x7ffffffd] s32=[0x7fffffff, 0x7ffffffd] var_off=(0x7fffffff, 0x0) REG INVARIANTS VIOLATION (false_reg2): const tnum out of sync with range bounds u64=[0x0, 0xffffffffffffffff] s64=[0x8000000000000000, 0x7fffffffffffffff] u32=[0x0, 0xffffffff] s32=[0x80000000, 0x7fffffff] var_off=(0x7fffffff, 0x0) 19: R6_w=0x7fffffff 20: (95) exit from 19 to 21: R0=0x7fffffff R6=scalar(smin=umin=smin32=umin32=2,smax=umax=smax32=umax32=0x7ffffffe,var_off=(0x2; 0x7ffffffd)) R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm 21: R0=0x7fffffff R6=scalar(smin=umin=smin32=umin32=2,smax=umax=smax32=umax32=0x7ffffffe,var_off=(0x2; 0x7ffffffd)) R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm 21: (14) w6 -= 2147483632 ; R6_w=scalar(smin=umin=umin32=2,smax=umax=0xffffffff,smin32=0x80000012,smax32=14,var_off=(0x2; 0xfffffffd)) 22: (76) if w6 s>= 0xe goto pc+1 ; R6_w=scalar(smin=umin=umin32=2,smax=umax=0xffffffff,smin32=0x80000012,smax32=13,var_off=(0x2; 0xfffffffd)) 23: (95) exit from 22 to 24: R0=0x7fffffff R6_w=14 R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm 24: R0=0x7fffffff R6_w=14 R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm 24: (14) w6 -= 14 ; R6_w=0 [...] What can be seen here is a register invariant violation on line 19. After the binary-or in line 18, the verifier knows that bit 2 is set but knows nothing about the rest of the content which was loaded from a map value, meaning, range is [2,0x7fffffff] with var_off=(0x2; 0x7ffffffd). When in line 19 the verifier analyzes the branch, it splits the register states in reg_set_min_max() into the registers of the true branch (true_reg1, true_reg2) and the registers of the false branch (false_reg1, false_reg2). Since the test is w6 != 0x7ffffffd, the src_reg is a known constant. Internally, the verifier creates a \"fake\" register initialized as scalar to the value of 0x7ffffffd, and then passes it onto reg_set_min_max(). Now, for line 19, it is mathematically impossible to take the false branch of this program, yet the verifier analyzes it. It is impossible because the second bit of r6 will be set due to the prior or operation and the constant in the condition has that bit unset (hex(fd) == binary(1111 1101). When the verifier first analyzes the false / fall-through branch, it will compute an intersection between the var_off of r6 and of the constant. This is because the verifier creates a \"fake\" register initialized to the value of the constant. The intersection result later refines both registers in regs_refine_cond_op(): [...] t = tnum_intersect(tnum_subreg(reg1->var_off), tnum_subreg(reg2->var_off)); reg1->var_o ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.9.7 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028716": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_inner: incorrect percpu area handling under softirq Softirq can interrupt ongoing packet from process context that is walking over the percpu area that contains inner header offsets. Disable bh and perform three checks before restoring the percpu inner header offsets to validate that the percpu area is valid for this skbuff: 1) If the NFT_PKTINFO_INNER_FULL flag is set on, then this skbuff has already been parsed before for inner header fetching to register. 2) Validate that the percpu area refers to this skbuff using the skbuff pointer as a cookie. If there is a cookie mismatch, then this skbuff needs to be parsed again. 3) Finally, validate if the percpu area refers to this tunnel type. Only after these three checks the percpu area is restored to a on-stack copy and bh is enabled again. After inner header fetching, the on-stack copy is stored back to the percpu area.",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028871": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: mediatek: mt8195: Add platform entry for ETDM1_OUT_BE dai link Commit e70b8dd26711 (\"ASoC: mediatek: mt8195: Remove afe-dai component and rework codec link\") removed the codec entry for the ETDM1_OUT_BE dai link entirely instead of replacing it with COMP_EMPTY(). This worked by accident as the remaining COMP_EMPTY() platform entry became the codec entry, and the platform entry became completely empty, effectively the same as COMP_DUMMY() since snd_soc_fill_dummy_dai() doesn't do anything for platform entries. This causes a KASAN out-of-bounds warning in mtk_soundcard_common_probe() in sound/soc/mediatek/common/mtk-soundcard-driver.c: for_each_card_prelinks(card, i, dai_link) { if (adsp_node && !strncmp(dai_link->name, \"AFE_SOF\", strlen(\"AFE_SOF\"))) dai_link->platforms->of_node = adsp_node; else if (!dai_link->platforms->name && !dai_link->platforms->of_node) dai_link->platforms->of_node = platform_node; } where the code expects the platforms array to have space for at least one entry. Add an COMP_EMPTY() entry so that dai_link->platforms has space.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.9.8 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028917": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: add check for invalid name in btf_name_valid_section() If the length of the name string is 1 and the value of name[0] is NULL byte, an OOB vulnerability occurs in btf_name_valid_section() and the return value is true, so the invalid name passes the check. To solve this, you need to check if the first position is NULL byte and if the first character is printable.",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.10.10 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-028939": {
        "title": "Linux の Linux Kernel における入力で指定された数量の不適切な検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: enic: Validate length of nl attributes in enic_set_vf_port enic_set_vf_port assumes that the nl attribute IFLA_PORT_PROFILE is of length PORT_PROFILE_MAX and that the nl attributes IFLA_PORT_INSTANCE_UUID, IFLA_PORT_HOST_UUID are of length PORT_UUID_MAX. These attributes are validated (in the function do_setlink in rtnetlink.c) using the nla_policy ifla_port_policy. The policy defines IFLA_PORT_PROFILE as NLA_STRING, IFLA_PORT_INSTANCE_UUID as NLA_BINARY and IFLA_PORT_HOST_UUID as NLA_STRING. That means that the length validation using the policy is for the max size of the attributes and not on exact size so the length of these attributes might be less than the sizes that enic_set_vf_port expects. This might cause an out of bands read access in the memcpys of the data of these attributes in enic_set_vf_port.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 4.19.316 未満\nLinux Kernel 4.20 以上 5.4.278 未満\nLinux Kernel 5.5 以上 5.10.219 未満\nLinux Kernel 5.11 以上 5.15.161 未満\nLinux Kernel 5.16 以上 6.1.93 未満\nLinux Kernel 6.2 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満\nLinux Kernel 6.10"
    },
    "JVNDB-2024-028873": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: ASSERT when failing to find index by plane/stream id [WHY] find_disp_cfg_idx_by_plane_id and find_disp_cfg_idx_by_stream_id returns an array index and they return -1 when not found; however, -1 is not a valid index number. [HOW] When this happens, call ASSERT(), and return a positive number (which is fewer than callers' array size) instead. This fixes 4 OVERRUN and 2 NEGATIVE_RETURNS issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-028878": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: xfs: don't walk off the end of a directory data block This adds sanity checks for xfs_dir2_data_unused and xfs_dir2_data_entry to make sure don't stray beyond valid memory region. Before patching, the loop simply checks that the start offset of the dup and dep is within the range. So in a crafted image, if last entry is xfs_dir2_data_unused, we can change dup->length to dup->length-1 and leave 1 byte of space. In the next traversal, this space will be considered as dup or dep. We may encounter an out of bound read when accessing the fixed members. In the patch, we make sure that the remaining bytes large enough to hold an unused entry before accessing xfs_dir2_data_unused and xfs_dir2_data_unused is XFS_DIR2_DATA_ALIGN byte aligned. We also make sure that the remaining bytes large enough to hold a dirent with a single-byte name before accessing xfs_dir2_data_entry.",
        "technologies": "Linux\nLinux Kernel 6.1.142 未満\nLinux Kernel 6.2 以上 6.6.68 未満\nLinux Kernel 6.7 以上 6.11 未満"
    },
    "JVNDB-2024-028922": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/cpum_sf: Handle CPU hotplug remove during sampling CPU hotplug remove handling triggers the following function call sequence: CPUHP_AP_PERF_S390_SF_ONLINE --> s390_pmu_sf_offline_cpu() ... CPUHP_AP_PERF_ONLINE --> perf_event_exit_cpu() The s390 CPUMF sampling CPU hotplug handler invokes: s390_pmu_sf_offline_cpu() +--> cpusf_pmu_setup() +--> setup_pmc_cpu() +--> deallocate_buffers() This function de-allocates all sampling data buffers (SDBs) allocated for that CPU at event initialization. It also clears the PMU_F_RESERVED bit. The CPU is gone and can not be sampled. With the event still being active on the removed CPU, the CPU event hotplug support in kernel performance subsystem triggers the following function calls on the removed CPU: perf_event_exit_cpu() +--> perf_event_exit_cpu_context() +--> __perf_event_exit_context() +--> __perf_remove_from_context() +--> event_sched_out() +--> cpumsf_pmu_del() +--> cpumsf_pmu_stop() +--> hw_perf_event_update() to stop and remove the event. During removal of the event, the sampling device driver tries to read out the remaining samples from the sample data buffers (SDBs). But they have already been freed (and may have been re-assigned). This may lead to a use after free situation in which case the samples are most likely invalid. In the best case the memory has not been reassigned and still contains valid data. Remedy this situation and check if the CPU is still in reserved state (bit PMU_F_RESERVED set). In this case the SDBs have not been released an contain valid data. This is always the case when the event is removed (and no CPU hotplug off occured). If the PMU_F_RESERVED bit is not set, the SDB buffers are gone.",
        "technologies": "Linux\nLinux Kernel 5.4.287 未満\nLinux Kernel 5.5 以上 5.10.231 未満\nLinux Kernel 5.11 以上 5.15.174 未満\nLinux Kernel 5.16 以上 6.1.120 未満\nLinux Kernel 6.2 以上 6.6.66 未満\nLinux Kernel 6.7 以上 6.12.5 未満"
    },
    "JVNDB-2024-028866": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tun: add missing verification for short frame The cited commit missed to check against the validity of the frame length in the tun_xdp_one() path, which could cause a corrupted skb to be sent downstack. Even before the skb is transmitted, the tun_xdp_one-->eth_type_trans() may access the Ethernet header although it can be less than ETH_HLEN. Once transmitted, this could either cause out-of-bound access beyond the actual length, or confuse the underlayer with incorrect or inconsistent header length in the skb metadata. In the alternative path, tun_get_user() already prohibits short frame which has the length less than Ethernet header size from being transmitted for IFF_TAP. This is to drop any frame shorter than the Ethernet header size just like how tun_get_user() does. CVE: CVE-2024-41091",
        "technologies": "Linux\nLinux Kernel 4.20 以上 5.4.281 未満\nLinux Kernel 5.5 以上 5.10.223 未満\nLinux Kernel 5.11 以上 5.15.164 未満\nLinux Kernel 5.16 以上 6.1.102 未満\nLinux Kernel 6.2 以上 6.6.43 未満\nLinux Kernel 6.7 以上 6.9.12 未満\nLinux Kernel 6.10 以上 6.10.2 未満"
    },
    "JVNDB-2024-028962": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: vhci-hcd: Do not drop references before new references are gained At a few places the driver carries stale pointers to references that can still be used. Make sure that does not happen. This strictly speaking closes ZDI-CAN-22273, though there may be similar races in the driver.",
        "technologies": "Linux\nLinux Kernel 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.105 未満\nLinux Kernel 6.2 以上 6.6.46 未満\nLinux Kernel 6.7 以上 6.10.5 未満\nLinux Kernel 6.11"
    },
    "JVNDB-2024-029091": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: check return value of sock_recvmsg when draining clc data When receiving clc msg, the field length in smc_clc_msg_hdr indicates the length of msg should be received from network and the value should not be fully trusted as it is from the network. Once the value of length exceeds the value of buflen in function smc_clc_wait_msg it may run into deadloop when trying to drain the remaining data exceeding buflen. This patch checks the return value of sock_recvmsg when draining data in case of deadloop in draining.",
        "technologies": "Linux\nLinux Kernel 5.8.1 以上 5.10.233 未満\nLinux Kernel 5.11 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.122 未満\nLinux Kernel 6.2 以上 6.6.68 未満\nLinux Kernel 6.7 以上 6.12.7 未満\nLinux Kernel 5.8\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028976": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check index msg_id before read or write [WHAT] msg_id is used as an array index and it cannot be a negative value, and therefore cannot be equal to MOD_HDCP_MESSAGE_ID_INVALID (-1). [HOW] Check whether msg_id is valid before reading and setting. This fixes 4 OVERRUN issues reported by Coverity.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 5.10.222 未満\nLinux Kernel 5.11 以上 5.15.163 未満\nLinux Kernel 5.16 以上 6.1.98 未満\nLinux Kernel 6.2 以上 6.6.39 未満\nLinux Kernel 6.7 以上 6.9.9 未満"
    },
    "JVNDB-2024-029181": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFS: Fix potential buffer overflowin nfs_sysfs_link_rpc_client() name is char[64] where the size of clnt->cl_program->name remains unknown. Invoking strcat() directly will also lead to potential buffer overflow. Change them to strscpy() and strncat() to fix potential issues.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満"
    },
    "JVNDB-2024-029164": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Fix for out-of bound access error Selfgen stats are placed in a buffer using print_array_to_buf_index() function. Array length parameter passed to the function is too big, resulting in possible out-of bound memory error. Decreasing buffer size by one fixes faulty upper bound of passed array. Discovered in coverity scan, CID 1600742 and CID 1600758",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.13.3 未満"
    },
    "JVNDB-2024-029098": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: topology: Keep the cpumask unchanged when printing cpumap During fuzz testing, the following warning was discovered: different return values (15 and 11) from vsnprintf(\"%*pbl \", ...) test:keyward is WARNING in kvasprintf WARNING: CPU: 55 PID: 1168477 at lib/kasprintf.c:30 kvasprintf+0x121/0x130 Call Trace: kvasprintf+0x121/0x130 kasprintf+0xa6/0xe0 bitmap_print_to_buf+0x89/0x100 core_siblings_list_read+0x7e/0xb0 kernfs_file_read_iter+0x15b/0x270 new_sync_read+0x153/0x260 vfs_read+0x215/0x290 ksys_read+0xb9/0x160 do_syscall_64+0x56/0x100 entry_SYSCALL_64_after_hwframe+0x78/0xe2 The call trace shows that kvasprintf() reported this warning during the printing of core_siblings_list. kvasprintf() has several steps: (1) First, calculate the length of the resulting formatted string. (2) Allocate a buffer based on the returned length. (3) Then, perform the actual string formatting. (4) Check whether the lengths of the formatted strings returned in steps (1) and (2) are consistent. If the core_cpumask is modified between steps (1) and (3), the lengths obtained in these two steps may not match. Indeed our test includes cpu hotplugging, which should modify core_cpumask while printing. To fix this issue, cache the cpumask into a temporary variable before calling cpumap_print_{list, cpumask}_to_buf(), to keep it unchanged during the printing process.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.177 未満\nLinux Kernel 5.16 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-029113": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: leds: trigger: Unregister sysfs attributes before calling deactivate() Triggers which have trigger specific sysfs attributes typically store related data in trigger-data allocated by the activate() callback and freed by the deactivate() callback. Calling device_remove_groups() after calling deactivate() leaves a window where the sysfs attributes show/store functions could be called after deactivation and then operate on the just freed trigger-data. Move the device_remove_groups() call to before deactivate() to close this race window. This also makes the deactivation path properly do things in reverse order of the activation path which calls the activate() callback before calling device_add_groups().",
        "technologies": "Linux\nLinux Kernel 4.19 以上 4.19.320 未満\nLinux Kernel 4.20 以上 5.4.282 未満\nLinux Kernel 5.5 以上 5.10.224 未満\nLinux Kernel 5.11 以上 5.15.165 未満\nLinux Kernel 5.16 以上 6.1.103 未満\nLinux Kernel 6.2 以上 6.6.44 未満\nLinux Kernel 6.7 以上 6.10.3 未満"
    },
    "JVNDB-2024-029106": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix mbss changed flags corruption on 32 bit systems On 32-bit systems, the size of an unsigned long is 4 bytes, while a u64 is 8 bytes. Therefore, when using or_each_set_bit(bit, &bits, sizeof(changed) * BITS_PER_BYTE), the code is incorrectly searching for a bit in a 32-bit variable that is expected to be 64 bits in size, leading to incorrect bit finding. Solution: Ensure that the size of the bits variable is correctly adjusted for each architecture. Call Trace: ? show_regs+0x54/0x58 ? __warn+0x6b/0xd4 ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211] ? report_bug+0x113/0x150 ? exc_overflow+0x30/0x30 ? handle_bug+0x27/0x44 ? exc_invalid_op+0x18/0x50 ? handle_exception+0xf6/0xf6 ? exc_overflow+0x30/0x30 ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211] ? exc_overflow+0x30/0x30 ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211] ? ieee80211_mesh_work+0xff/0x260 [mac80211] ? cfg80211_wiphy_work+0x72/0x98 [cfg80211] ? process_one_work+0xf1/0x1fc ? worker_thread+0x2c0/0x3b4 ? kthread+0xc7/0xf0 ? mod_delayed_work_on+0x4c/0x4c ? kthread_complete_and_exit+0x14/0x14 ? ret_from_fork+0x24/0x38 ? kthread_complete_and_exit+0x14/0x14 ? ret_from_fork_asm+0xf/0x14 ? entry_INT80_32+0xf0/0xf0 [restore no-op path for no changes]",
        "technologies": "Linux\nLinux Kernel 6.6.70 未満\nLinux Kernel 6.7 以上 6.12.9 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-001390": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipvlan: Fix use-after-free in ipvlan_get_iflink(). syzbot presented an use-after-free report [0] regarding ipvlan and linkwatch. ipvlan does not hold a refcnt of the lower device unlike vlan and macvlan. If the linkwatch work is triggered for the ipvlan dev, the lower dev might have already been freed, resulting in UAF of ipvlan->phy_dev in ipvlan_get_iflink(). We can delay the lower dev unregistration like vlan and macvlan by holding the lower dev's refcnt in dev->netdev_ops->ndo_init() and releasing it in dev->priv_destructor(). Jakub pointed out calling .ndo_XXX after unregister_netdevice() has returned is error prone and suggested [1] addressing this UAF in the core by taking commit 750e51603395 (\"net: avoid potential UAF in default_operstate()\") further. Let's assume unregistering devices DOWN and use RCU protection in default_operstate() not to race with the device unregistration. [0]: BUG: KASAN: slab-use-after-free in ipvlan_get_iflink+0x84/0x88 drivers/net/ipvlan/ipvlan_main.c:353 Read of size 4 at addr ffff0000d768c0e0 by task kworker/u8:35/6944 CPU: 0 UID: 0 PID: 6944 Comm: kworker/u8:35 Not tainted 6.13.0-rc2-g9bc5c9515b48 #12 4c3cb9e8b4565456f6a355f312ff91f4f29b3c47 Hardware name: linux,dummy-virt (DT) Workqueue: events_unbound linkwatch_event Call trace: show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:484 (C) __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x16c/0x6f0 mm/kasan/report.c:489 kasan_report+0xc0/0x120 mm/kasan/report.c:602 __asan_report_load4_noabort+0x20/0x30 mm/kasan/report_generic.c:380 ipvlan_get_iflink+0x84/0x88 drivers/net/ipvlan/ipvlan_main.c:353 dev_get_iflink+0x7c/0xd8 net/core/dev.c:674 default_operstate net/core/link_watch.c:45 [inline] rfc2863_policy+0x144/0x360 net/core/link_watch.c:72 linkwatch_do_dev+0x60/0x228 net/core/link_watch.c:175 __linkwatch_run_queue+0x2f4/0x5b8 net/core/link_watch.c:239 linkwatch_event+0x64/0xa8 net/core/link_watch.c:282 process_one_work+0x700/0x1398 kernel/workqueue.c:3229 process_scheduled_works kernel/workqueue.c:3310 [inline] worker_thread+0x8c4/0xe10 kernel/workqueue.c:3391 kthread+0x2b0/0x360 kernel/kthread.c:389 ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:862 Allocated by task 9303: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x30/0x68 mm/kasan/common.c:68 kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4283 [inline] __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4289 __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:650 alloc_netdev_mqs+0xb4/0x1118 net/core/dev.c:11209 rtnl_create_link+0x2b8/0xb60 net/core/rtnetlink.c:3595 rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3771 __rtnl_newlink net/core/rtnetlink.c:3896 [inline] rtnl_newlink+0x122c/0x15c0 net/core/rtnetlink.c:4011 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6901 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2542 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6928 netlink_unicast_kernel net/netlink/af_netlink.c:1321 [inline] netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1347 netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1891 sock_sendmsg_nosec net/socket.c:711 [inline] __sock_sendmsg net/socket.c:726 [inline] __sys_sendto+0x2ec/0x438 net/socket.c:2197 __do_sys_sendto net/socket.c:2204 [inline] __se_sys_sendto net/socket.c:2200 [inline] __arm64_sys_sendto+0xe4/0x110 net/socket.c:2200 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132 do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151 el ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-029097": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: power: supply: gpio-charger: Fix set charge current limits Fix set charge current limits for devices which allow to set the lowest charge current limit to be greater zero. If requested charge current limit is below lowest limit, the index equals current_limit_map_size which leads to accessing memory beyond allocated memory.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 5.10.233 未満\nLinux Kernel 5.11 以上 5.15.176 未満\nLinux Kernel 5.16 以上 6.1.123 未満\nLinux Kernel 6.2 以上 6.6.69 未満\nLinux Kernel 6.7 以上 6.12.8 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-028941": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: dmaengine: idxd: Avoid unnecessary destruction of file_ida file_ida is allocated during cdev open and is freed accordingly during cdev release. This sequence is guaranteed by driver file operations. Therefore, there is no need to destroy an already empty file_ida when the WQ cdev is removed. Worse, ida_free() in cdev release may happen after destruction of file_ida per WQ cdev. This can lead to accessing an id in file_ida after it has been destroyed, resulting in a kernel panic. Remove ida_destroy(&file_ida) to address these issues.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.33 未満\nLinux Kernel 6.7 以上 6.9.4 未満"
    },
    "JVNDB-2024-029093": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: at91: call input_free_device() on allocated iio_dev Current implementation of at91_ts_register() calls input_free_deivce() on st->ts_input, however, the err label can be reached before the allocated iio_dev is stored to st->ts_input. Thus call input_free_device() on input instead of st->ts_input.",
        "technologies": "Linux\nLinux Kernel 3.16 以上 5.4.290 未満\nLinux Kernel 5.5 以上 5.10.234 未満\nLinux Kernel 5.11 以上 5.15.177 未満\nLinux Kernel 5.16 以上 6.1.125 未満\nLinux Kernel 6.2 以上 6.6.72 未満\nLinux Kernel 6.7 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-001327": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: zram: fix potential UAF of zram table If zram_meta_alloc failed early, it frees allocated zram->table without setting it NULL. Which will potentially cause zram_meta_free to access the table if user reset an failed and uninitialized device.",
        "technologies": "Linux\nLinux Kernel 6.1.122 以上 6.1.127 未満\nLinux Kernel 6.6.68 以上 6.6.74 未満\nLinux Kernel 6.12.7 以上 6.12.11 未満"
    },
    "JVNDB-2025-001027": {
        "title": "Linux Ratfor におけるスタックベースのバッファオーバーフローの脆弱性",
        "description": "Stack-based buffer overflow vulnerability exists in Linux Ratfor 1.06 and earlier. When the software processes a file which is specially crafted by an attacker, arbitrary code may be executed. As a result, the attacker may obtain or alter information of the user environment or cause the user environment to become unusable.",
        "technologies": "The Dimensional Gate Co.\nLinux Ratfor 1.06 およびそれ以前"
    },
    "JVNDB-2025-001342": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: block, bfq: fix waker_bfqq UAF after bfq_split_bfqq() Our syzkaller report a following UAF for v6.6: BUG: KASAN: slab-use-after-free in bfq_init_rq+0x175d/0x17a0 block/bfq-iosched.c:6958 Read of size 8 at addr ffff8881b57147d8 by task fsstress/232726 CPU: 2 PID: 232726 Comm: fsstress Not tainted 6.6.0-g3629d1885222 #39 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x91/0xf0 lib/dump_stack.c:106 print_address_description.constprop.0+0x66/0x300 mm/kasan/report.c:364 print_report+0x3e/0x70 mm/kasan/report.c:475 kasan_report+0xb8/0xf0 mm/kasan/report.c:588 hlist_add_head include/linux/list.h:1023 [inline] bfq_init_rq+0x175d/0x17a0 block/bfq-iosched.c:6958 bfq_insert_request.isra.0+0xe8/0xa20 block/bfq-iosched.c:6271 bfq_insert_requests+0x27f/0x390 block/bfq-iosched.c:6323 blk_mq_insert_request+0x290/0x8f0 block/blk-mq.c:2660 blk_mq_submit_bio+0x1021/0x15e0 block/blk-mq.c:3143 __submit_bio+0xa0/0x6b0 block/blk-core.c:639 __submit_bio_noacct_mq block/blk-core.c:718 [inline] submit_bio_noacct_nocheck+0x5b7/0x810 block/blk-core.c:747 submit_bio_noacct+0xca0/0x1990 block/blk-core.c:847 __ext4_read_bh fs/ext4/super.c:205 [inline] ext4_read_bh+0x15e/0x2e0 fs/ext4/super.c:230 __read_extent_tree_block+0x304/0x6f0 fs/ext4/extents.c:567 ext4_find_extent+0x479/0xd20 fs/ext4/extents.c:947 ext4_ext_map_blocks+0x1a3/0x2680 fs/ext4/extents.c:4182 ext4_map_blocks+0x929/0x15a0 fs/ext4/inode.c:660 ext4_iomap_begin_report+0x298/0x480 fs/ext4/inode.c:3569 iomap_iter+0x3dd/0x1010 fs/iomap/iter.c:91 iomap_fiemap+0x1f4/0x360 fs/iomap/fiemap.c:80 ext4_fiemap+0x181/0x210 fs/ext4/extents.c:5051 ioctl_fiemap.isra.0+0x1b4/0x290 fs/ioctl.c:220 do_vfs_ioctl+0x31c/0x11a0 fs/ioctl.c:811 __do_sys_ioctl fs/ioctl.c:869 [inline] __se_sys_ioctl+0xae/0x190 fs/ioctl.c:857 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x70/0x120 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x78/0xe2 Allocated by task 232719: kasan_save_stack+0x22/0x50 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 __kasan_slab_alloc+0x87/0x90 mm/kasan/common.c:328 kasan_slab_alloc include/linux/kasan.h:188 [inline] slab_post_alloc_hook mm/slab.h:768 [inline] slab_alloc_node mm/slub.c:3492 [inline] kmem_cache_alloc_node+0x1b8/0x6f0 mm/slub.c:3537 bfq_get_queue+0x215/0x1f00 block/bfq-iosched.c:5869 bfq_get_bfqq_handle_split+0x167/0x5f0 block/bfq-iosched.c:6776 bfq_init_rq+0x13a4/0x17a0 block/bfq-iosched.c:6938 bfq_insert_request.isra.0+0xe8/0xa20 block/bfq-iosched.c:6271 bfq_insert_requests+0x27f/0x390 block/bfq-iosched.c:6323 blk_mq_insert_request+0x290/0x8f0 block/blk-mq.c:2660 blk_mq_submit_bio+0x1021/0x15e0 block/blk-mq.c:3143 __submit_bio+0xa0/0x6b0 block/blk-core.c:639 __submit_bio_noacct_mq block/blk-core.c:718 [inline] submit_bio_noacct_nocheck+0x5b7/0x810 block/blk-core.c:747 submit_bio_noacct+0xca0/0x1990 block/blk-core.c:847 __ext4_read_bh fs/ext4/super.c:205 [inline] ext4_read_bh_nowait+0x15a/0x240 fs/ext4/super.c:217 ext4_read_bh_lock+0xac/0xd0 fs/ext4/super.c:242 ext4_bread_batch+0x268/0x500 fs/ext4/inode.c:958 __ext4_find_entry+0x448/0x10f0 fs/ext4/namei.c:1671 ext4_lookup_entry fs/ext4/namei.c:1774 [inline] ext4_lookup.part.0+0x359/0x6f0 fs/ext4/namei.c:1842 ext4_lookup+0x72/0x90 fs/ext4/namei.c:1839 __lookup_slow+0x257/0x480 fs/namei.c:1696 lookup_slow fs/namei.c:1713 [inline] walk_component+0x454/0x5c0 fs/namei.c:2004 link_path_walk.part.0+0x773/0xda0 fs/namei.c:2331 link_path_walk fs/namei.c:3826 [inline] path_openat+0x1b9/0x520 fs/namei.c:3826 do_filp_open+0x1b7/0x400 fs/namei.c:3857 do_sys_openat2+0x5dc/0x6e0 fs/open.c:1428 do_sys_open fs/open.c:1443 [inline] __do_sys_openat fs/open.c:1459 [inline] __se_sys_openat fs/open.c:1454 [inline] __x64_sys_openat+0x148/0x200 fs/open.c:1454 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_6 ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.15.168 以上 5.15.177 未満\nLinux Kernel 6.1.113 以上 6.1.125 未満\nLinux Kernel 6.6.54 以上 6.6.72 未満\nLinux Kernel 6.10.13 以上 6.11 未満\nLinux Kernel 6.11.2 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-001392": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pktgen: Avoid out-of-bounds access in get_imix_entries Passing a sufficient amount of imix entries leads to invalid access to the pkt_dev->imix_entries array because of the incorrect boundary check. UBSAN: array-index-out-of-bounds in net/core/pktgen.c:874:24 index 20 is out of range for type 'imix_pkt [20]' CPU: 2 PID: 1210 Comm: bash Not tainted 6.10.0-rc1 #121 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) Call Trace: <TASK> dump_stack_lvl lib/dump_stack.c:117 __ubsan_handle_out_of_bounds lib/ubsan.c:429 get_imix_entries net/core/pktgen.c:874 pktgen_if_write net/core/pktgen.c:1063 pde_write fs/proc/inode.c:334 proc_reg_write fs/proc/inode.c:346 vfs_write fs/read_write.c:593 ksys_write fs/read_write.c:644 do_syscall_64 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe arch/x86/entry/entry_64.S:130 Found by Linux Verification Center (linuxtesting.org) with SVACE. [ fp: allow to fill the array completely; minor changelog cleanup ]",
        "technologies": "Linux\nLinux Kernel 5.15 以上 5.15.177 未満\nLinux Kernel 5.16 以上 6.1.127 未満\nLinux Kernel 6.2 以上 6.6.74 未満\nLinux Kernel 6.7 以上 6.12.11 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-001709": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vfio/platform: check the bounds of read/write syscalls count and offset are passed from user space and not checked, only offset is capped to 40 bits, which can be used to read/write out of bounds of the device.",
        "technologies": "Linux\nLinux Kernel 4.1 以上 5.4.290 未満\nLinux Kernel 5.5 以上 5.10.234 未満\nLinux Kernel 5.11 以上 5.15.178 未満\nLinux Kernel 5.16 以上 6.1.128 未満\nLinux Kernel 6.2 以上 6.6.75 未満\nLinux Kernel 6.7 以上 6.12.12 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2024-029185": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: media: intel/ipu6: remove cpu latency qos request on error Fix cpu latency qos list corruption like below. It happens when we do not remove cpu latency request on error path and free corresponding memory. [ 30.634378] l7 kernel: list_add corruption. prev->next should be next (ffffffff9645e960), but was 0000000100100001. (prev=ffff8e9e877e20a8). [ 30.634388] l7 kernel: WARNING: CPU: 2 PID: 2008 at lib/list_debug.c:32 __list_add_valid_or_report+0x83/0xa0 <snip> [ 30.634640] l7 kernel: Call Trace: [ 30.634650] l7 kernel: <TASK> [ 30.634659] l7 kernel: ? __list_add_valid_or_report+0x83/0xa0 [ 30.634669] l7 kernel: ? __warn.cold+0x93/0xf6 [ 30.634678] l7 kernel: ? __list_add_valid_or_report+0x83/0xa0 [ 30.634690] l7 kernel: ? report_bug+0xff/0x140 [ 30.634702] l7 kernel: ? handle_bug+0x58/0x90 [ 30.634712] l7 kernel: ? exc_invalid_op+0x17/0x70 [ 30.634723] l7 kernel: ? asm_exc_invalid_op+0x1a/0x20 [ 30.634733] l7 kernel: ? __list_add_valid_or_report+0x83/0xa0 [ 30.634742] l7 kernel: plist_add+0xdd/0x140 [ 30.634754] l7 kernel: pm_qos_update_target+0xa0/0x1f0 [ 30.634764] l7 kernel: cpu_latency_qos_update_request+0x61/0xc0 [ 30.634773] l7 kernel: intel_dp_aux_xfer+0x4c7/0x6e0 [i915 1f824655ed04687c2b0d23dbce759fa785f6d033]",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2025-002164": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: NFC: nci: Add bounds checking in nci_hci_create_pipe() The \"pipe\" variable is a u8 which comes from the network. If it's more than 127, then it results in memory corruption in the caller, nci_hci_connect_gate().",
        "technologies": "Linux\nLinux Kernel 4.4 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2025-002093": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: orangefs: fix a oob in orangefs_debug_write I got a syzbot report: slab-out-of-bounds Read in orangefs_debug_write... several people suggested fixes, I tested Al Viro's suggestion and made this patch.",
        "technologies": "Linux\nLinux Kernel 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満"
    },
    "JVNDB-2025-002190": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: csum: Fix OoB access in IP checksum code for negative lengths Commit 69e3a6aa6be2 (\"LoongArch: Add checksum optimization for 64-bit system\") would cause an undefined shift and an out-of-bounds read. Commit 8bd795fedb84 (\"arm64: csum: Fix OoB access in IP checksum code for negative lengths\") fixes the same issue on ARM64.",
        "technologies": "Linux\nLinux Kernel 6.4 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002260": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usbnet: ipheth: fix DPE OoB read Fix an out-of-bounds DPE read, limit the number of processed DPEs to the amount that fits into the fixed-size NDP16 header.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2025-001780": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: sched: fix ets qdisc OOB Indexing Haowei Yan <g1042620637@gmail.com> found that ets_class_from_arg() can index an Out-Of-Bound class in ets_class_from_arg() when passed clid of 0. The overflow may cause local privilege escalation. [ 18.852298] ------------[ cut here ]------------ [ 18.853271] UBSAN: array-index-out-of-bounds in net/sched/sch_ets.c:93:20 [ 18.853743] index 18446744073709551615 is out of range for type 'ets_class [16]' [ 18.854254] CPU: 0 UID: 0 PID: 1275 Comm: poc Not tainted 6.12.6-dirty #17 [ 18.854821] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 [ 18.856532] Call Trace: [ 18.857441] <TASK> [ 18.858227] dump_stack_lvl+0xc2/0xf0 [ 18.859607] dump_stack+0x10/0x20 [ 18.860908] __ubsan_handle_out_of_bounds+0xa7/0xf0 [ 18.864022] ets_class_change+0x3d6/0x3f0 [ 18.864322] tc_ctl_tclass+0x251/0x910 [ 18.864587] ? lock_acquire+0x5e/0x140 [ 18.865113] ? __mutex_lock+0x9c/0xe70 [ 18.866009] ? __mutex_lock+0xa34/0xe70 [ 18.866401] rtnetlink_rcv_msg+0x170/0x6f0 [ 18.866806] ? __lock_acquire+0x578/0xc10 [ 18.867184] ? __pfx_rtnetlink_rcv_msg+0x10/0x10 [ 18.867503] netlink_rcv_skb+0x59/0x110 [ 18.867776] rtnetlink_rcv+0x15/0x30 [ 18.868159] netlink_unicast+0x1c3/0x2b0 [ 18.868440] netlink_sendmsg+0x239/0x4b0 [ 18.868721] ____sys_sendmsg+0x3e2/0x410 [ 18.869012] ___sys_sendmsg+0x88/0xe0 [ 18.869276] ? rseq_ip_fixup+0x198/0x260 [ 18.869563] ? rseq_update_cpu_node_id+0x10a/0x190 [ 18.869900] ? trace_hardirqs_off+0x5a/0xd0 [ 18.870196] ? syscall_exit_to_user_mode+0xcc/0x220 [ 18.870547] ? do_syscall_64+0x93/0x150 [ 18.870821] ? __memcg_slab_free_hook+0x69/0x290 [ 18.871157] __sys_sendmsg+0x69/0xd0 [ 18.871416] __x64_sys_sendmsg+0x1d/0x30 [ 18.871699] x64_sys_call+0x9e2/0x2670 [ 18.871979] do_syscall_64+0x87/0x150 [ 18.873280] ? do_syscall_64+0x93/0x150 [ 18.874742] ? lock_release+0x7b/0x160 [ 18.876157] ? do_user_addr_fault+0x5ce/0x8f0 [ 18.877833] ? irqentry_exit_to_user_mode+0xc2/0x210 [ 18.879608] ? irqentry_exit+0x77/0xb0 [ 18.879808] ? clear_bhb_loop+0x15/0x70 [ 18.880023] ? clear_bhb_loop+0x15/0x70 [ 18.880223] ? clear_bhb_loop+0x15/0x70 [ 18.880426] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 18.880683] RIP: 0033:0x44a957 [ 18.880851] Code: ff ff e8 fc 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 8974 24 10 [ 18.881766] RSP: 002b:00007ffcdd00fad8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e [ 18.882149] RAX: ffffffffffffffda RBX: 00007ffcdd010db8 RCX: 000000000044a957 [ 18.882507] RDX: 0000000000000000 RSI: 00007ffcdd00fb70 RDI: 0000000000000003 [ 18.885037] RBP: 00007ffcdd010bc0 R08: 000000000703c770 R09: 000000000703c7c0 [ 18.887203] R10: 0000000000000080 R11: 0000000000000246 R12: 0000000000000001 [ 18.888026] R13: 00007ffcdd010da8 R14: 00000000004ca7d0 R15: 0000000000000001 [ 18.888395] </TASK> [ 18.888610] ---[ end trace ]---",
        "technologies": "Linux\nLinux Kernel 5.6 以上 5.10.234 未満\nLinux Kernel 5.11 以上 5.15.178 未満\nLinux Kernel 5.16 以上 6.1.128 未満\nLinux Kernel 6.2 以上 6.6.75 未満\nLinux Kernel 6.7 以上 6.12.12 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-002209": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: fixed hclge_fetch_pf_reg accesses bar space out of bounds issue The TQP BAR space is divided into two segments. TQPs 0-1023 and TQPs 1024-1279 are in different BAR space addresses. However, hclge_fetch_pf_reg does not distinguish the tqp space information when reading the tqp space information. When the number of TQPs is greater than 1024, access bar space overwriting occurs. The problem of different segments has been considered during the initialization of tqp.io_base. Therefore, tqp.io_base is directly used when the queue is read in hclge_fetch_pf_reg. The error message: Unable to handle kernel paging request at virtual address ffff800037200000 pc : hclge_fetch_pf_reg+0x138/0x250 [hclge] lr : hclge_get_regs+0x84/0x1d0 [hclge] Call trace: hclge_fetch_pf_reg+0x138/0x250 [hclge] hclge_get_regs+0x84/0x1d0 [hclge] hns3_get_regs+0x2c/0x50 [hns3] ethtool_get_regs+0xf4/0x270 dev_ethtool+0x674/0x8a0 dev_ioctl+0x270/0x36c sock_do_ioctl+0x110/0x2a0 sock_ioctl+0x2ac/0x530 __arm64_sys_ioctl+0xa8/0x100 invoke_syscall+0x4c/0x124 el0_svc_common.constprop.0+0x140/0x15c do_el0_svc+0x30/0xd0 el0_svc+0x1c/0x2c el0_sync_handler+0xb0/0xb4 el0_sync+0x168/0x180",
        "technologies": "Linux\nLinux Kernel 6.4.16 以上 6.5 未満\nLinux Kernel 6.5.3 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-002287": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table() It malicious user provides a small pptable through sysfs and then a bigger pptable, it may cause buffer overflow attack in function smu_sys_set_pp_table().",
        "technologies": "Linux\nLinux Kernel 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002318": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usbnet: ipheth: use static NDP16 location in URB Original code allowed for the start of NDP16 to be anywhere within the URB based on the `wNdpIndex` value in NTH16. Only the start position of NDP16 was checked, so it was possible for even the fixed-length part of NDP16 to extend past the end of URB, leading to an out-of-bounds read. On iOS devices, the NDP16 header always directly follows NTH16. Rely on and check for this specific format. This, along with NCM-specific minimal URB length check that already exists, will ensure that the fixed-length part of NDP16 plus a set amount of DPEs fit within the URB. Note that this commit alone does not fully address the OoB read. The limit on the amount of DPEs needs to be enforced separately.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2025-002372": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: rose: fix timer races against user threads Rose timers only acquire the socket spinlock, without checking if the socket is owned by one user thread. Add a check and rearm the timers if needed. BUG: KASAN: slab-use-after-free in rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174 Read of size 2 at addr ffff88802f09b82a by task swapper/0/0 CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.13.0-rc5-syzkaller-00172-gd1bf27c4e176 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <IRQ> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174 call_timer_fn+0x187/0x650 kernel/time/timer.c:1793 expire_timers kernel/time/timer.c:1844 [inline] __run_timers kernel/time/timer.c:2418 [inline] __run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2430 run_timer_base kernel/time/timer.c:2439 [inline] run_timer_softirq+0xb7/0x170 kernel/time/timer.c:2449 handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561 __do_softirq kernel/softirq.c:595 [inline] invoke_softirq kernel/softirq.c:435 [inline] __irq_exit_rcu+0xf7/0x220 kernel/softirq.c:662 irq_exit_rcu+0x9/0x30 kernel/softirq.c:678 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline] sysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1049 </IRQ>",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002340": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: cacheinfo: Avoid out-of-bounds write to cacheinfo array The loop that detects/populates cache information already has a bounds check on the array size but does not account for cache levels with separate data/instructions cache. Fix this by incrementing the index for any populated leaf (instead of any populated level).",
        "technologies": "Linux\nLinux Kernel 4.0 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002337": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: hid-thrustmaster: fix stack-out-of-bounds read in usb_check_int_endpoints() Syzbot[1] has detected a stack-out-of-bounds read of the ep_addr array from hid-thrustmaster driver. This array is passed to usb_check_int_endpoints function from usb.c core driver, which executes a for loop that iterates over the elements of the passed array. Not finding a null element at the end of the array, it tries to read the next, non-existent element, crashing the kernel. To fix this, a 0 element was added at the end of the array to break the for loop. [1] https://syzkaller.appspot.com/bug?extid=9c9179ac46169c56c1ad",
        "technologies": "Linux\nLinux Kernel 6.6.76 以上 6.6.79 未満\nLinux Kernel 6.12.13 以上 6.12.16 未満\nLinux Kernel 6.13.2 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002338": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usbnet: ipheth: fix possible overflow in DPE length check Originally, it was possible for the DPE length check to overflow if wDatagramIndex + wDatagramLength > U16_MAX. This could lead to an OoB read. Move the wDatagramIndex term to the other side of the inequality. An existing condition ensures that wDatagramIndex < urb->actual_length.",
        "technologies": "Linux\nLinux Kernel 6.5 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満"
    },
    "JVNDB-2025-002433": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: geneve: Fix use-after-free in geneve_find_dev(). syzkaller reported a use-after-free in geneve_find_dev() [0] without repro. geneve_configure() links struct geneve_dev.next to net_generic(net, geneve_net_id)->geneve_list. The net here could differ from dev_net(dev) if IFLA_NET_NS_PID, IFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set. When dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally calls unregister_netdevice_queue() for each dev in the netns, and later the dev is freed. However, its geneve_dev.next is still linked to the backend UDP socket netns. Then, use-after-free will occur when another geneve dev is created in the netns. Let's call geneve_dellink() instead in geneve_destroy_tunnels(). [0]: BUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline] BUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343 Read of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441 CPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d Hardware name: linux,dummy-virt (DT) Call trace: show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C) __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x16c/0x6f0 mm/kasan/report.c:489 kasan_report+0xc0/0x120 mm/kasan/report.c:602 __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379 geneve_find_dev drivers/net/geneve.c:1295 [inline] geneve_configure+0x234/0x858 drivers/net/geneve.c:1343 geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634 rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795 __rtnl_newlink net/core/rtnetlink.c:3906 [inline] rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938 netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline] netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348 netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892 sock_sendmsg_nosec net/socket.c:713 [inline] __sock_sendmsg net/socket.c:728 [inline] ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568 ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622 __sys_sendmsg net/socket.c:2654 [inline] __do_sys_sendmsg net/socket.c:2659 [inline] __se_sys_sendmsg net/socket.c:2657 [inline] __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132 do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151 el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762 el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600 Allocated by task 13247: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x30/0x68 mm/kasan/common.c:68 kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4298 [inline] __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304 __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645 alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470 rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604 rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780 __rtnl_newlink net/core/rtnetlink.c:3906 [inline] rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938 netlink_unicast_kernel net/netlink/af_n ---truncated---",
        "technologies": "Linux\nLinux Kernel 4.2 以上 6.1.130 未満\nLinux Kernel 6.2 以上 6.6.80 未満\nLinux Kernel 6.7 以上 6.12.17 未満\nLinux Kernel 6.13 以上 6.13.5 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002434": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ibmvnic: Don't reference skb after sending to VIOS Previously, after successfully flushing the xmit buffer to VIOS, the tx_bytes stat was incremented by the length of the skb. It is invalid to access the skb memory after sending the buffer to the VIOS because, at any point after sending, the VIOS can trigger an interrupt to free this memory. A race between reading skb->len and freeing the skb is possible (especially during LPM) and will result in use-after-free: ================================================================== BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic] Read of size 4 at addr c00000024eb48a70 by task hxecom/14495 <...> Call Trace: [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable) [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0 [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8 [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0 [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic] [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358 <...> Freed by task 0: kasan_save_stack+0x34/0x68 kasan_save_track+0x2c/0x50 kasan_save_free_info+0x64/0x108 __kasan_mempool_poison_object+0x148/0x2d4 napi_skb_cache_put+0x5c/0x194 net_tx_action+0x154/0x5b8 handle_softirqs+0x20c/0x60c do_softirq_own_stack+0x6c/0x88 <...> The buggy address belongs to the object at c00000024eb48a00 which belongs to the cache skbuff_head_cache of size 224 ==================================================================",
        "technologies": "Linux\nLinux Kernel 4.5 以上 6.1.130 未満\nLinux Kernel 6.2 以上 6.6.80 未満\nLinux Kernel 6.7 以上 6.12.17 未満\nLinux Kernel 6.13 以上 6.13.5 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002416": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: corsair-void: Add missing delayed work cancel for headset status The cancel_delayed_work_sync() call was missed, causing a use-after-free in corsair_void_remove().",
        "technologies": "Linux\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002496": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ax25: rcu protect dev->ax25_ptr syzbot found a lockdep issue [1]. We should remove ax25 RTNL dependency in ax25_setsockopt() This should also fix a variety of possible UAF in ax25. [1] WARNING: possible circular locking dependency detected 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted ------------------------------------------------------ syz.5.1818/12806 is trying to acquire lock: ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680 but task is already holding lock: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline] ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #1 (sk_lock-AF_AX25){+.+.}-{0:0}: lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 lock_sock_nested+0x48/0x100 net/core/sock.c:3642 lock_sock include/net/sock.h:1618 [inline] ax25_kill_by_device net/ax25/af_ax25.c:101 [inline] ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146 notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85 __dev_notify_flags+0x207/0x400 dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026 dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563 dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820 sock_do_ioctl+0x240/0x460 net/socket.c:1234 sock_ioctl+0x626/0x8e0 net/socket.c:1339 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f -> #0 (rtnl_mutex){+.+.}-{4:4}: check_prev_add kernel/locking/lockdep.c:3161 [inline] check_prevs_add kernel/locking/lockdep.c:3280 [inline] validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904 __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226 lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735 ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680 do_sock_setsockopt+0x3af/0x720 net/socket.c:2324 __sys_setsockopt net/socket.c:2349 [inline] __do_sys_setsockopt net/socket.c:2355 [inline] __se_sys_setsockopt net/socket.c:2352 [inline] __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f other info that might help us debug this: Possible unsafe locking scenario: CPU0 CPU1 ---- ---- lock(sk_lock-AF_AX25); lock(rtnl_mutex); lock(sk_lock-AF_AX25); lock(rtnl_mutex); *** DEADLOCK *** 1 lock held by syz.5.1818/12806: #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline] #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574 stack backtrace: CPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074 check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206 check_prev_add kernel/locking/lockdep.c:3161 [inline] check_prevs_add kernel/lockin ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.18.132 以上 3.19 未満\nLinux Kernel 4.4.170 以上 4.5 未満\nLinux Kernel 4.9.149 以上 4.10 未満\nLinux Kernel 4.14.92 以上 4.15 未満\nLinux Kernel 4.19.14 以上 4.20 未満\nLinux Kernel 4.20.1 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-002502": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: workqueue: Put the pwq after detaching the rescuer from the pool The commit 68f83057b913(\"workqueue: Reap workers via kthread_stop() and remove detach_completion\") adds code to reap the normal workers but mistakenly does not handle the rescuer and also removes the code waiting for the rescuer in put_unbound_pool(), which caused a use-after-free bug reported by Cheung Wall. To avoid the use-after-free bug, the pool’s reference must be held until the detachment is complete. Therefore, move the code that puts the pwq after detaching the rescuer from the pool.",
        "technologies": "Linux\nLinux Kernel 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満"
    },
    "JVNDB-2025-002497": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: neighbour: use RCU protection in __neigh_notify() __neigh_notify() can be called without RTNL or RCU protection. Use RCU protection to avoid potential UAF.",
        "technologies": "Linux\nLinux Kernel 2.6.25 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002409": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring: prevent opcode speculation sqe->opcode is used for different tables, make sure we santitise it against speculations.",
        "technologies": "Linux\nLinux Kernel 5.6 以上 6.6.80 未満\nLinux Kernel 6.7 以上 6.12.17 未満\nLinux Kernel 6.13 以上 6.13.5 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002503": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: clear acl_access/acl_default after releasing them If getting acl_default fails, acl_access and acl_default will be released simultaneously. However, acl_access will still retain a pointer pointing to the released posix_acl, which will trigger a WARNING in nfs3svc_release_getacl like this: ------------[ cut here ]------------ refcount_t: underflow; use-after-free. WARNING: CPU: 26 PID: 3199 at lib/refcount.c:28 refcount_warn_saturate+0xb5/0x170 Modules linked in: CPU: 26 UID: 0 PID: 3199 Comm: nfsd Not tainted 6.12.0-rc6-00079-g04ae226af01f-dirty #8 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 RIP: 0010:refcount_warn_saturate+0xb5/0x170 Code: cc cc 0f b6 1d b3 20 a5 03 80 fb 01 0f 87 65 48 d8 00 83 e3 01 75 e4 48 c7 c7 c0 3b 9b 85 c6 05 97 20 a5 03 01 e8 fb 3e 30 ff <0f> 0b eb cd 0f b6 1d 8a3 RSP: 0018:ffffc90008637cd8 EFLAGS: 00010282 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff83904fde RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88871ed36380 RBP: ffff888158beeb40 R08: 0000000000000001 R09: fffff520010c6f56 R10: ffffc90008637ab7 R11: 0000000000000001 R12: 0000000000000001 R13: ffff888140e77400 R14: ffff888140e77408 R15: ffffffff858b42c0 FS: 0000000000000000(0000) GS:ffff88871ed00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000562384d32158 CR3: 000000055cc6a000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? refcount_warn_saturate+0xb5/0x170 ? __warn+0xa5/0x140 ? refcount_warn_saturate+0xb5/0x170 ? report_bug+0x1b1/0x1e0 ? handle_bug+0x53/0xa0 ? exc_invalid_op+0x17/0x40 ? asm_exc_invalid_op+0x1a/0x20 ? tick_nohz_tick_stopped+0x1e/0x40 ? refcount_warn_saturate+0xb5/0x170 ? refcount_warn_saturate+0xb5/0x170 nfs3svc_release_getacl+0xc9/0xe0 svc_process_common+0x5db/0xb60 ? __pfx_svc_process_common+0x10/0x10 ? __rcu_read_unlock+0x69/0xa0 ? __pfx_nfsd_dispatch+0x10/0x10 ? svc_xprt_received+0xa1/0x120 ? xdr_init_decode+0x11d/0x190 svc_process+0x2a7/0x330 svc_handle_xprt+0x69d/0x940 svc_recv+0x180/0x2d0 nfsd+0x168/0x200 ? __pfx_nfsd+0x10/0x10 kthread+0x1a2/0x1e0 ? kthread+0xf4/0x1e0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x34/0x60 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Kernel panic - not syncing: kernel: panic_on_warn set ... Clear acl_access/acl_default after posix_acl_release is called to prevent UAF from being triggered.",
        "technologies": "Linux\nLinux Kernel 2.6.13 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002411": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vrf: use RCU protection in l3mdev_l3_out() l3mdev_l3_out() can be called without RCU being held: raw_sendmsg() ip_push_pending_frames() ip_send_skb() ip_local_out() __ip_local_out() l3mdev_ip_out() Add rcu_read_lock() / rcu_read_unlock() pair to avoid a potential UAF.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002405": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: s390/ism: add release function for struct device According to device_release() in /drivers/base/core.c, a device without a release function is a broken device and must be fixed. The current code directly frees the device after calling device_add() without waiting for other kernel parts to release their references. Thus, a reference could still be held to a struct device, e.g., by sysfs, leading to potential use-after-free issues if a proper release function is not set.",
        "technologies": "Linux\nLinux Kernel 6.3 以上 6.6.80 未満\nLinux Kernel 6.7 以上 6.12.17 未満\nLinux Kernel 6.13 以上 6.13.5 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003549": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in ksmbd_free_work_struct ->interim_entry of ksmbd_work could be deleted after oplock is freed. We don't need to manage it with linked list. The interim request could be immediately sent whenever a oplock break wait is needed.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003503": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched/fair: Fix potential memory corruption in child_cfs_rq_on_list child_cfs_rq_on_list attempts to convert a 'prev' pointer to a cfs_rq. This 'prev' pointer can originate from struct rq's leaf_cfs_rq_list, making the conversion invalid and potentially leading to memory corruption. Depending on the relative positions of leaf_cfs_rq_list and the task group (tg) pointer within the struct, this can cause a memory fault or access garbage data. The issue arises in list_add_leaf_cfs_rq, where both cfs_rq->leaf_cfs_rq_list and rq->leaf_cfs_rq_list are added to the same leaf list. Also, rq->tmp_alone_branch can be set to rq->leaf_cfs_rq_list. This adds a check `if (prev == &rq->leaf_cfs_rq_list)` after the main conditional in child_cfs_rq_on_list. This ensures that the container_of operation will convert a correct cfs_rq struct. This check is sufficient because only cfs_rqs on the same CPU are added to the list, so verifying the 'prev' pointer against the current rq's list head is enough. Fixes a potential memory corruption issue that due to current struct layout might not be manifesting as a crash but could lead to unpredictable behavior when the layout changes.",
        "technologies": "Linux\nLinux Kernel 5.13 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003521": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: limit printed string from FW file There's no guarantee here that the file is always with a NUL-termination, so reading the string may read beyond the end of the TLV. If that's the last TLV in the file, it can perhaps even read beyond the end of the file buffer. Fix that by limiting the print format to the size of the buffer we have.",
        "technologies": "Linux\nLinux Kernel 5.2 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003487": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: cancel wiphy_work before freeing wiphy A wiphy_work can be queued from the moment the wiphy is allocated and initialized (i.e. wiphy_new_nm). When a wiphy_work is queued, the rdev::wiphy_work is getting queued. If wiphy_free is called before the rdev::wiphy_work had a chance to run, the wiphy memory will be freed, and then when it eventally gets to run it'll use invalid memory. Fix this by canceling the work before freeing the wiphy.",
        "technologies": "Linux\nLinux Kernel 6.1.57 以上 6.1.132 未満\nLinux Kernel 6.5 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003595": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd After the hci sync command releases l2cap_conn, the hci receive data work queue references the released l2cap_conn when sending to the upper layer. Add hci dev lock to the hci receive data work queue to synchronize the two. [1] BUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954 Read of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837 CPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: hci1 hci_rx_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline] l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954 l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline] l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline] l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817 hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline] hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 5837: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860 l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline] hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726 hci_event_func net/bluetooth/hci_event.c:7473 [inline] hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525 hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 Freed by task 54: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2353 [inline] slab_free mm/slub.c:4613 [inline] kfree+0x196/0x430 mm/slub.c:4761 l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline] hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266 hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entr ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003486": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: x86/microcode/AMD: Fix out-of-bounds on systems with CPU-less NUMA nodes Currently, load_microcode_amd() iterates over all NUMA nodes, retrieves their CPU masks and unconditionally accesses per-CPU data for the first CPU of each mask. According to Documentation/admin-guide/mm/numaperf.rst: \"Some memory may share the same node as a CPU, and others are provided as memory only nodes.\" Therefore, some node CPU masks may be empty and wouldn't have a \"first CPU\". On a machine with far memory (and therefore CPU-less NUMA nodes): - cpumask_of_node(nid) is 0 - cpumask_first(0) is CONFIG_NR_CPUS - cpu_data(CONFIG_NR_CPUS) accesses the cpu_info per-CPU array at an index that is 1 out of bounds This does not have any security implications since flashing microcode is a privileged operation but I believe this has reliability implications by potentially corrupting memory while flashing a microcode update. When booting with CONFIG_UBSAN_BOUNDS=y on an AMD machine that flashes a microcode update. I get the following splat: UBSAN: array-index-out-of-bounds in arch/x86/kernel/cpu/microcode/amd.c:X:Y index 512 is out of range for type 'unsigned long[512]' [...] Call Trace: dump_stack __ubsan_handle_out_of_bounds load_microcode_amd request_microcode_amd reload_store kernfs_fop_write_iter vfs_write ksys_write do_syscall_64 entry_SYSCALL_64_after_hwframe Change the loop to go over only NUMA nodes which have CPUs before determining whether the first CPU on the respective node needs microcode update. [ bp: Massage commit message, fix typo. ]",
        "technologies": "Linux\nLinux Kernel 4.14.308 以上 4.15 未満\nLinux Kernel 4.19.276 以上 4.20 未満\nLinux Kernel 5.4.235 以上 5.5 未満\nLinux Kernel 5.10.173 以上 5.11 未満\nLinux Kernel 5.15.99 以上 5.16 未満\nLinux Kernel 6.1.16 以上 6.1.132 未満\nLinux Kernel 6.2.3 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003457": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: rapidio: fix an API misues when rio_add_net() fails rio_add_net() calls device_register() and fails when device_register() fails. Thus, put_device() should be used rather than kfree(). Add \"mport->net = NULL;\" to avoid a use after free issue.",
        "technologies": "Linux\nLinux Kernel 4.6 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003442": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix slab-use-after-free on hdcp_work [Why] A slab-use-after-free is reported when HDCP is destroyed but the property_validate_dwork queue is still running. [How] Cancel the delayed work when destroying workqueue. (cherry picked from commit 725a04ba5a95e89c89633d4322430cfbca7ce128)",
        "technologies": "Linux\nLinux Kernel 5.5 以上 5.10.236 未満\nLinux Kernel 5.11 以上 5.15.180 未満\nLinux Kernel 5.16 以上 6.1.132 未満\nLinux Kernel 6.2 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003362": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: hid-steam: Fix use-after-free when detaching device When a hid-steam device is removed it must clean up the client_hdev used for intercepting hidraw access. This can lead to scheduling deferred work to reattach the input device. Though the cleanup cancels the deferred work, this was done before the client_hdev itself is cleaned up, so it gets rescheduled. This patch fixes the ordering to make sure the deferred work is properly canceled.",
        "technologies": "Linux\nLinux Kernel 6.6.79 以上 6.6.83 未満\nLinux Kernel 6.12.16 以上 6.12.19 未満\nLinux Kernel 6.13.4 以上 6.13.7 未満"
    },
    "JVNDB-2025-003375": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: vlan: enforce underlying device type Currently, VLAN devices can be created on top of non-ethernet devices. Besides the fact that it doesn't make much sense, this also causes a bug which leaks the address of a kernel function to usermode. When creating a VLAN device, we initialize GARP (garp_init_applicant) and MRP (mrp_init_applicant) for the underlying device. As part of the initialization process, we add the multicast address of each applicant to the underlying device, by calling dev_mc_add. __dev_mc_add uses dev->addr_len to determine the length of the new multicast address. This causes an out-of-bounds read if dev->addr_len is greater than 6, since the multicast addresses provided by GARP and MRP are only 6 bytes long. This behaviour can be reproduced using the following commands: ip tunnel add gretest mode ip6gre local ::1 remote ::2 dev lo ip l set up dev gretest ip link add link gretest name vlantest type vlan id 100 Then, the following command will display the address of garp_pdu_rcv: ip maddr show | grep 01:80:c2:00:00:21 Fix the bug by enforcing the type of the underlying device during VLAN device initialization.",
        "technologies": "Linux\nLinux Kernel 2.6.35 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003363": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu() nvme_tcp_recv_pdu() doesn't check the validity of the header length. When header digests are enabled, a target might send a packet with an invalid header length (e.g. 255), causing nvme_tcp_verify_hdgst() to access memory outside the allocated area and cause memory corruptions by overwriting it with the calculated digest. Fix this by rejecting packets with an unexpected header length.",
        "technologies": "Linux\nLinux Kernel 5.0 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003361": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: proc: fix UAF in proc_get_inode() Fix race between rmmod and /proc/XXX's inode instantiation. The bug is that pde->proc_ops don't belong to /proc, it belongs to a module, therefore dereferencing it after /proc entry has been registered is a bug unless use_pde/unuse_pde() pair has been used. use_pde/unuse_pde can be avoided (2 atomic ops!) because pde->proc_ops never changes so information necessary for inode instantiation can be saved _before_ proc_register() in PDE itself and used later, avoiding pde->proc_ops->... dereference. rmmod lookup sys_delete_module proc_lookup_de pde_get(de); proc_get_inode(dir->i_sb, de); mod->exit() proc_remove remove_proc_subtree proc_entry_rundown(de); free_module(mod); if (S_ISREG(inode->i_mode)) if (de->proc_ops->proc_read_iter) --> As module is already freed, will trigger UAF BUG: unable to handle page fault for address: fffffbfff80a702b PGD 817fc4067 P4D 817fc4067 PUD 817fc0067 PMD 102ef4067 PTE 0 Oops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI CPU: 26 UID: 0 PID: 2667 Comm: ls Tainted: G Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) RIP: 0010:proc_get_inode+0x302/0x6e0 RSP: 0018:ffff88811c837998 EFLAGS: 00010a06 RAX: dffffc0000000000 RBX: ffffffffc0538140 RCX: 0000000000000007 RDX: 1ffffffff80a702b RSI: 0000000000000001 RDI: ffffffffc0538158 RBP: ffff8881299a6000 R08: 0000000067bbe1e5 R09: 1ffff11023906f20 R10: ffffffffb560ca07 R11: ffffffffb2b43a58 R12: ffff888105bb78f0 R13: ffff888100518048 R14: ffff8881299a6004 R15: 0000000000000001 FS: 00007f95b9686840(0000) GS:ffff8883af100000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: fffffbfff80a702b CR3: 0000000117dd2000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> proc_lookup_de+0x11f/0x2e0 __lookup_slow+0x188/0x350 walk_component+0x2ab/0x4f0 path_lookupat+0x120/0x660 filename_lookup+0x1ce/0x560 vfs_statx+0xac/0x150 __do_sys_newstat+0x96/0x110 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e [adobriyan@gmail.com: don't do 2 atomic ops on the common path]",
        "technologies": "Linux\nLinux Kernel 2.6.23 以上 6.1.132 未満\nLinux Kernel 6.2 以上 6.6.85 未満\nLinux Kernel 6.7 以上 6.12.21 未満\nLinux Kernel 6.13 以上 6.13.9 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003153": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net: atm: fix use after free in lec_send() The ->send() operation frees skb so save the length before calling ->send() to avoid a use after free.",
        "technologies": "Linux\nLinux Kernel 2.6.12 以上 6.1.132 未満\nLinux Kernel 6.2 以上 6.6.85 未満\nLinux Kernel 6.7 以上 6.12.21 未満\nLinux Kernel 6.13 以上 6.13.9 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003284": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: intel-ish-hid: Fix use-after-free issue in hid_ishtp_cl_remove() During the `rmmod` operation for the `intel_ishtp_hid` driver, a use-after-free issue can occur in the hid_ishtp_cl_remove() function. The function hid_ishtp_cl_deinit() is called before ishtp_hid_remove(), which can lead to accessing freed memory or resources during the removal process. Call Trace: ? ishtp_cl_send+0x168/0x220 [intel_ishtp] ? hid_output_report+0xe3/0x150 [hid] hid_ishtp_set_feature+0xb5/0x120 [intel_ishtp_hid] ishtp_hid_request+0x7b/0xb0 [intel_ishtp_hid] hid_hw_request+0x1f/0x40 [hid] sensor_hub_set_feature+0x11f/0x190 [hid_sensor_hub] _hid_sensor_power_state+0x147/0x1e0 [hid_sensor_trigger] hid_sensor_runtime_resume+0x22/0x30 [hid_sensor_trigger] sensor_hub_remove+0xa8/0xe0 [hid_sensor_hub] hid_device_remove+0x49/0xb0 [hid] hid_destroy_device+0x6f/0x90 [hid] ishtp_hid_remove+0x42/0x70 [intel_ishtp_hid] hid_ishtp_cl_remove+0x6b/0xb0 [intel_ishtp_hid] ishtp_cl_device_remove+0x4a/0x60 [intel_ishtp] ... Additionally, ishtp_hid_remove() is a HID level power off, which should occur before the ISHTP level disconnect. This patch resolves the issue by reordering the calls in hid_ishtp_cl_remove(). The function ishtp_hid_remove() is now called before hid_ishtp_cl_deinit().",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003210": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic() When performing an iSCSI boot using IPv6, iscsistart still reads the /sys/firmware/ibft/ethernetX/subnet-mask entry. Since the IPv6 prefix length is 64, this causes the shift exponent to become negative, triggering a UBSAN warning. As the concept of a subnet mask does not apply to IPv6, the value is set to ~0 to suppress the warning message.",
        "technologies": "Linux\nLinux Kernel 6.1.132 未満\nLinux Kernel 6.2 以上 6.6.84 未満\nLinux Kernel 6.7 以上 6.12.20 未満\nLinux Kernel 6.13 以上 6.13.8 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002984": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ovl: fix UAF in ovl_dentry_update_reval by moving dput() in ovl_link_up The issue was caused by dput(upper) being called before ovl_dentry_update_reval(), while upper->d_flags was still accessed in ovl_dentry_remote(). Move dput(upper) after its last use to prevent use-after-free. BUG: KASAN: slab-use-after-free in ovl_dentry_remote fs/overlayfs/util.c:162 [inline] BUG: KASAN: slab-use-after-free in ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0xc3/0x620 mm/kasan/report.c:488 kasan_report+0xd9/0x110 mm/kasan/report.c:601 ovl_dentry_remote fs/overlayfs/util.c:162 [inline] ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167 ovl_link_up fs/overlayfs/copy_up.c:610 [inline] ovl_copy_up_one+0x2105/0x3490 fs/overlayfs/copy_up.c:1170 ovl_copy_up_flags+0x18d/0x200 fs/overlayfs/copy_up.c:1223 ovl_rename+0x39e/0x18c0 fs/overlayfs/dir.c:1136 vfs_rename+0xf84/0x20a0 fs/namei.c:4893 ... </TASK>",
        "technologies": "Linux\nLinux Kernel 5.10.188 以上 5.11 未満\nLinux Kernel 5.15.121 以上 5.15.179 未満\nLinux Kernel 6.1.39 以上 6.1.130 未満\nLinux Kernel 6.3.13 以上 6.4 未満\nLinux Kernel 6.4.4 以上 6.6.81 未満\nLinux Kernel 6.7 以上 6.12.18 未満\nLinux Kernel 6.13 以上 6.13.6 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002992": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, test_run: Fix use-after-free issue in eth_skb_pkt_type() KMSAN reported a use-after-free issue in eth_skb_pkt_type()[1]. The cause of the issue was that eth_skb_pkt_type() accessed skb's data that didn't contain an Ethernet header. This occurs when bpf_prog_test_run_xdp() passes an invalid value as the user_data argument to bpf_test_init(). Fix this by returning an error when user_data is less than ETH_HLEN in bpf_test_init(). Additionally, remove the check for \"if (user_size > size)\" as it is unnecessary. [1] BUG: KMSAN: use-after-free in eth_skb_pkt_type include/linux/etherdevice.h:627 [inline] BUG: KMSAN: use-after-free in eth_type_trans+0x4ee/0x980 net/ethernet/eth.c:165 eth_skb_pkt_type include/linux/etherdevice.h:627 [inline] eth_type_trans+0x4ee/0x980 net/ethernet/eth.c:165 __xdp_build_skb_from_frame+0x5a8/0xa50 net/core/xdp.c:635 xdp_recv_frames net/bpf/test_run.c:272 [inline] xdp_test_run_batch net/bpf/test_run.c:361 [inline] bpf_test_run_xdp_live+0x2954/0x3330 net/bpf/test_run.c:390 bpf_prog_test_run_xdp+0x148e/0x1b10 net/bpf/test_run.c:1318 bpf_prog_test_run+0x5b7/0xa30 kernel/bpf/syscall.c:4371 __sys_bpf+0x6a6/0xe20 kernel/bpf/syscall.c:5777 __do_sys_bpf kernel/bpf/syscall.c:5866 [inline] __se_sys_bpf kernel/bpf/syscall.c:5864 [inline] __x64_sys_bpf+0xa4/0xf0 kernel/bpf/syscall.c:5864 x64_sys_call+0x2ea0/0x3d90 arch/x86/include/generated/asm/syscalls_64.h:322 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xd9/0x1d0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: free_pages_prepare mm/page_alloc.c:1056 [inline] free_unref_page+0x156/0x1320 mm/page_alloc.c:2657 __free_pages+0xa3/0x1b0 mm/page_alloc.c:4838 bpf_ringbuf_free kernel/bpf/ringbuf.c:226 [inline] ringbuf_map_free+0xff/0x1e0 kernel/bpf/ringbuf.c:235 bpf_map_free kernel/bpf/syscall.c:838 [inline] bpf_map_free_deferred+0x17c/0x310 kernel/bpf/syscall.c:862 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa2b/0x1b60 kernel/workqueue.c:3310 worker_thread+0xedf/0x1550 kernel/workqueue.c:3391 kthread+0x535/0x6b0 kernel/kthread.c:389 ret_from_fork+0x6e/0x90 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 CPU: 1 UID: 0 PID: 17276 Comm: syz.1.16450 Not tainted 6.12.0-05490-g9bb88c659673 #8 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014",
        "technologies": "Linux\nLinux Kernel 5.18 以上 6.1.130 未満\nLinux Kernel 6.2 以上 6.6.80 未満\nLinux Kernel 6.7 以上 6.12.17 未満\nLinux Kernel 6.13 以上 6.13.5 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002617": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netem: Update sch->q.qlen before qdisc_tree_reduce_backlog() qdisc_tree_reduce_backlog() notifies parent qdisc only if child qdisc becomes empty, therefore we need to reduce the backlog of the child qdisc before calling it. Otherwise it would miss the opportunity to call cops->qlen_notify(), in the case of DRR, it resulted in UAF since DRR uses ->qlen_notify() to maintain its active list.",
        "technologies": "Linux\nLinux Kernel 5.4.288 以上 5.4.291 未満\nLinux Kernel 5.10.232 以上 5.10.235 未満\nLinux Kernel 5.15.175 以上 5.15.179 未満\nLinux Kernel 6.1.121 以上 6.1.129 未満\nLinux Kernel 6.6.67 以上 6.6.78 未満\nLinux Kernel 6.12.6 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002671": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free when attempting to join an aborted transaction When we are trying to join the current transaction and if it's aborted, we read its 'aborted' field after unlocking fs_info->trans_lock and without holding any extra reference count on it. This means that a concurrent task that is aborting the transaction may free the transaction before we read its 'aborted' field, leading to a use-after-free. Fix this by reading the 'aborted' field while holding fs_info->trans_lock since any freeing task must first acquire that lock and set fs_info->running_transaction to NULL before freeing the transaction. This was reported by syzbot and Dmitry with the following stack traces from KASAN: ================================================================== BUG: KASAN: slab-use-after-free in join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278 Read of size 4 at addr ffff888011839024 by task kworker/u4:9/1128 CPU: 0 UID: 0 PID: 1128 Comm: kworker/u4:9 Not tainted 6.13.0-rc7-syzkaller-00019-gc45323b7560e #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Workqueue: events_unbound btrfs_async_reclaim_data_space Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278 start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697 flush_space+0x448/0xcf0 fs/btrfs/space-info.c:803 btrfs_async_reclaim_data_space+0x159/0x510 fs/btrfs/space-info.c:1321 process_one_work kernel/workqueue.c:3236 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317 worker_thread+0x870/0xd30 kernel/workqueue.c:3398 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 5315: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329 kmalloc_noprof include/linux/slab.h:901 [inline] join_transaction+0x144/0xda0 fs/btrfs/transaction.c:308 start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697 btrfs_create_common+0x1b2/0x2e0 fs/btrfs/inode.c:6572 lookup_open fs/namei.c:3649 [inline] open_last_lookups fs/namei.c:3748 [inline] path_openat+0x1c03/0x3590 fs/namei.c:3984 do_filp_open+0x27f/0x4e0 fs/namei.c:4014 do_sys_openat2+0x13e/0x1d0 fs/open.c:1402 do_sys_open fs/open.c:1417 [inline] __do_sys_creat fs/open.c:1495 [inline] __se_sys_creat fs/open.c:1489 [inline] __x64_sys_creat+0x123/0x170 fs/open.c:1489 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 5336: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2353 [inline] slab_free mm/slub.c:4613 [inline] kfree+0x196/0x430 mm/slub.c:4761 cleanup_transaction fs/btrfs/transaction.c:2063 [inline] btrfs_commit_transaction+0x2c97/0x3720 fs/btrfs/transaction.c:2598 insert_balance_item+0x1284/0x20b0 fs/btrfs/volumes.c:3757 btrfs_balance+0x992/ ---truncated---",
        "technologies": "Linux\nLinux Kernel 3.4 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.78 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002608": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: openvswitch: use RCU protection in ovs_vport_cmd_fill_info() ovs_vport_cmd_fill_info() can be called without RTNL or RCU. Use RCU protection and dev_net_rcu() to avoid potential UAF.",
        "technologies": "Linux\nLinux Kernel 4.15 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002607": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: mcast: extend RCU protection in igmp6_send() igmp6_send() can be called without RTNL or RCU being held. Extend RCU protection so that we can safely fetch the net pointer and avoid a potential UAF. Note that we no longer can use sock_alloc_send_skb() because ipv6.igmp_sk uses GFP_KERNEL allocations which can sleep. Instead use alloc_skb() and charge the net->ipv6.igmp_sk socket under RCU protection.",
        "technologies": "Linux\nLinux Kernel 2.6.26 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002559": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: padata: avoid UAF for reorder_work Although the previous patch can avoid ps and ps UAF for _do_serial, it can not avoid potential UAF issue for reorder_work. This issue can happen just as below: crypto_request crypto_request crypto_del_alg padata_do_serial ... padata_reorder // processes all remaining // requests then breaks while (1) { if (!padata) break; ... } padata_do_serial // new request added list_add // sees the new request queue_work(reorder_work) padata_reorder queue_work_on(squeue->work) ... <kworker context> padata_serial_worker // completes new request, // no more outstanding // requests crypto_del_alg // free pd <kworker context> invoke_padata_reorder // UAF of pd To avoid UAF for 'reorder_work', get 'pd' ref before put 'reorder_work' into the 'serial_wq' and put 'pd' ref until the 'serial_wq' finish.",
        "technologies": "Linux\nLinux Kernel 5.4.19 以上 5.5 未満\nLinux Kernel 5.5.3 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.79 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.76 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.2 未満"
    },
    "JVNDB-2025-003667": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free on inode when scanning root during em shrinking At btrfs_scan_root() we are accessing the inode's root (and fs_info) in a call to btrfs_fs_closing() after we have scheduled the inode for a delayed iput, and that can result in a use-after-free on the inode in case the cleaner kthread does the iput before we dereference the inode in the call to btrfs_fs_closing(). Fix this by using the fs_info stored already in a local variable instead of doing inode->root->fs_info.",
        "technologies": "Linux\nLinux Kernel 6.13 以上 6.13.6 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-003911": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In wlan STA driver, there is a possible out of bounds write due to improper input validation. This could lead to remote (proximal/adjacent) code execution with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: WCNCR00389496 / ALPS09137491; Issue ID: MSV-1835.",
        "technologies": "Google\nAndroid 13.0\nAndroid 14.0\nAndroid 15.0\nLinux Foundation\nYocto 3.3\nYocto 4.0\nYocto 5.0\nOpenWrt Project\nOpenWrt 23.05\nメディアテック\nsoftware development kit 2.5 およびそれ以前"
    },
    "JVNDB-2025-004047": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HID: intel-ish-hid: Fix use-after-free issue in ishtp_hid_remove() The system can experience a random crash a few minutes after the driver is removed. This issue occurs due to improper handling of memory freeing in the ishtp_hid_remove() function. The function currently frees the `driver_data` directly within the loop that destroys the HID devices, which can lead to accessing freed memory. Specifically, `hid_destroy_device()` uses `driver_data` when it calls `hid_ishtp_set_feature()` to power off the sensor, so freeing `driver_data` beforehand can result in accessing invalid memory. This patch resolves the issue by storing the `driver_data` in a temporary variable before calling `hid_destroy_device()`, and then freeing the `driver_data` after the device is destroyed.",
        "technologies": "Linux\nLinux Kernel 4.9 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-002606": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: HWS, change error flow on matcher disconnect Currently, when firmware failure occurs during matcher disconnect flow, the error flow of the function reconnects the matcher back and returns an error, which continues running the calling function and eventually frees the matcher that is being disconnected. This leads to a case where we have a freed matcher on the matchers list, which in turn leads to use-after-free and eventual crash. This patch fixes that by not trying to reconnect the matcher back when some FW command fails during disconnect. Note that we're dealing here with FW error. We can't overcome this problem. This might lead to bad steering state (e.g. wrong connection between matchers), and will also lead to resource leakage, as it is the case with any other error handling during resource destruction. However, the goal here is to allow the driver to continue and not crash the machine with use-after-free error.",
        "technologies": "Linux\nLinux Kernel 6.13.3 未満"
    },
    "JVNDB-2025-003992": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: keys: Fix UAF in key_put() Once a key's reference count has been reduced to 0, the garbage collector thread may destroy it at any time and so key_put() is not allowed to touch the key after that point. The most key_put() is normally allowed to do is to touch key_gc_work as that's a static global variable. However, in an effort to speed up the reclamation of quota, this is now done in key_put() once the key's usage is reduced to 0 - but now the code is looking at the key after the deadline, which is forbidden. Fix this by using a flag to indicate that a key can be gc'd now rather than looking at the key's refcount in the garbage collector.",
        "technologies": "Linux\nLinux Kernel 6.10 以上 6.12.21 未満\nLinux Kernel 6.13 以上 6.13.9 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-004170": {
        "title": "Linux の Linux Kernel における競合状態に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: exfat: fix random stack corruption after get_block When get_block is called with a buffer_head allocated on the stack, such as do_mpage_readpage, stack corruption due to buffer_head UAF may occur in the following race condition situation. <CPU 0> <CPU 1> mpage_read_folio <<bh on stack>> do_mpage_readpage exfat_get_block bh_read __bh_read get_bh(bh) submit_bh wait_on_buffer ... end_buffer_read_sync __end_buffer_read_notouch unlock_buffer <<keep going>> ... ... ... ... <<bh is not valid out of mpage_read_folio>> . . another_function <<variable A on stack>> put_bh(bh) atomic_dec(bh->b_count) * stack corruption here * This patch returns -EAGAIN if a folio does not have buffers when bh_read needs to be called. By doing this, the caller can fallback to functions like block_read_full_folio(), create a buffer_head in the folio, and then call get_block again. Let's do not call bh_read() with on-stack buffer_head.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004074": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vkms: Fix use after free and double free on init error If the driver initialization fails, the vkms_exit() function might access an uninitialized or freed default_config pointer and it might double free it. Fix both possible errors by initializing default_config only when the driver initialization succeeded.",
        "technologies": "Linux\nLinux Kernel 5.12 以上 5.15.180 未満\nLinux Kernel 5.16 以上 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004033": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in smb2_lock If smb_lock->zero_len has value, ->llist of smb_lock is not delete and flock is old one. It will cause use-after-free on error handling routine.",
        "technologies": "Linux\nLinux Kernel 5.15 以上 6.1.131 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-004075": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/erdma: Prevent use-after-free in erdma_accept_newconn() After the erdma_cep_put(new_cep) being called, new_cep will be freed, and the following dereference will cause a UAF problem. Fix this issue.",
        "technologies": "Linux\nLinux Kernel 6.0 以上 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004136": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: iio: light: Add check for array bounds in veml6075_read_int_time_ms The array contains only 5 elements, but the index calculated by veml6075_read_int_time_index can range from 0 to 7, which could lead to out-of-bounds access. The check prevents this issue. Coverity Issue CID 1574309: (#1 of 1): Out-of-bounds read (OVERRUN) overrun-local: Overrunning array veml6075_it_ms of 5 4-byte elements at element index 7 (byte offset 31) using index int_index (which evaluates to 7) This is hardening against potentially broken hardware. Good to have but not necessary to backport.",
        "technologies": "Linux\nLinux Kernel 6.8 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004073": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/core: Fix use-after-free when rename device name Syzbot reported a slab-use-after-free with the following call trace: ================================================================== BUG: KASAN: slab-use-after-free in nla_put+0xd3/0x150 lib/nlattr.c:1099 Read of size 5 at addr ffff888140ea1c60 by task syz.0.988/10025 CPU: 0 UID: 0 PID: 10025 Comm: syz.0.988 Not tainted 6.14.0-rc4-syzkaller-00859-gf77f12010f67 #0 Hardware name: Google Compute Engine, BIOS Google 02/12/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0x16e/0x5b0 mm/kasan/report.c:521 kasan_report+0x143/0x180 mm/kasan/report.c:634 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189 __asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105 nla_put+0xd3/0x150 lib/nlattr.c:1099 nla_put_string include/net/netlink.h:1621 [inline] fill_nldev_handle+0x16e/0x200 drivers/infiniband/core/nldev.c:265 rdma_nl_notify_event+0x561/0xef0 drivers/infiniband/core/nldev.c:2857 ib_device_notify_register+0x22/0x230 drivers/infiniband/core/device.c:1344 ib_register_device+0x1292/0x1460 drivers/infiniband/core/device.c:1460 rxe_register_device+0x233/0x350 drivers/infiniband/sw/rxe/rxe_verbs.c:1540 rxe_net_add+0x74/0xf0 drivers/infiniband/sw/rxe/rxe_net.c:550 rxe_newlink+0xde/0x1a0 drivers/infiniband/sw/rxe/rxe.c:212 nldev_newlink+0x5ea/0x680 drivers/infiniband/core/nldev.c:1795 rdma_nl_rcv_skb drivers/infiniband/core/netlink.c:239 [inline] rdma_nl_rcv+0x6dd/0x9e0 drivers/infiniband/core/netlink.c:259 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline] netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1339 netlink_sendmsg+0x8de/0xcb0 net/netlink/af_netlink.c:1883 sock_sendmsg_nosec net/socket.c:709 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:724 ____sys_sendmsg+0x53a/0x860 net/socket.c:2564 ___sys_sendmsg net/socket.c:2618 [inline] __sys_sendmsg+0x269/0x350 net/socket.c:2650 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f42d1b8d169 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 ... RSP: 002b:00007f42d2960038 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f42d1da6320 RCX: 00007f42d1b8d169 RDX: 0000000000000000 RSI: 00004000000002c0 RDI: 000000000000000c RBP: 00007f42d1c0e2a0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f42d1da6320 R15: 00007ffe399344a8 </TASK> Allocated by task 10025: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4294 [inline] __kmalloc_node_track_caller_noprof+0x28b/0x4c0 mm/slub.c:4313 __kmemdup_nul mm/util.c:61 [inline] kstrdup+0x42/0x100 mm/util.c:81 kobject_set_name_vargs+0x61/0x120 lib/kobject.c:274 dev_set_name+0xd5/0x120 drivers/base/core.c:3468 assign_name drivers/infiniband/core/device.c:1202 [inline] ib_register_device+0x178/0x1460 drivers/infiniband/core/device.c:1384 rxe_register_device+0x233/0x350 drivers/infiniband/sw/rxe/rxe_verbs.c:1540 rxe_net_add+0x74/0xf0 drivers/infiniband/sw/rxe/rxe_net.c:550 rxe_newlink+0xde/0x1a0 drivers/infiniband/sw/rxe/rxe.c:212 nldev_newlink+0x5ea/0x680 drivers/infiniband/core/nldev.c:1795 rdma_nl_rcv_skb drivers/infiniband/core/netlink.c:239 [inline] rdma_nl_rcv+0x6dd/0x9e0 drivers/infiniband/core/netlink.c:259 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline] netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1339 netlink_sendmsg+0x8de/0xcb0 net ---truncated---",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-003895": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における境界外書き込みに関する脆弱性",
        "description": "In wlan STA FW, there is a possible out of bounds write due to improper input validation. This could lead to remote (proximal/adjacent) code execution with no additional execution privileges needed. User interaction is not needed for exploitation. Patch ID: WCNCR00389045 / ALPS09136494; Issue ID: MSV-1796.",
        "technologies": "Google\nAndroid 13.0\nAndroid 14.0\nAndroid 15.0\nLinux Foundation\nYocto 3.3\nYocto 4.0\nYocto 5.0\nメディアテック\nsoftware development kit 2.4 およびそれ以前"
    },
    "JVNDB-2025-004072": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix session use-after-free in multichannel connection There is a race condition between session setup and ksmbd_sessions_deregister. The session can be freed before the connection is added to channel list of session. This patch check reference count of session before freeing it.",
        "technologies": "Linux\nLinux Kernel 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004174": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix OOB read when checking dotdot dir Mounting a corrupted filesystem with directory which contains '.' dir entry with rec_len == block size results in out-of-bounds read (later on, when the corrupted directory is removed). ext4_empty_dir() assumes every ext4 directory contains at least '.' and '..' as directory entries in the first data block. It first loads the '.' dir entry, performs sanity checks by calling ext4_check_dir_entry() and then uses its rec_len member to compute the location of '..' dir entry (in ext4_next_entry). It assumes the '..' dir entry fits into the same data block. If the rec_len of '.' is precisely one block (4KB), it slips through the sanity checks (it is considered the last directory entry in the data block) and leaves \"struct ext4_dir_entry_2 *de\" point exactly past the memory slot allocated to the data block. The following call to ext4_check_dir_entry() on new value of de then dereferences this pointer which results in out-of-bounds mem access. Fix this by extending __ext4_check_dir_entry() to check for '.' dir entries that reach the end of data block. Make sure to ignore the phony dir entries for checksum (by checking name_len for non-zero). Note: This is reported by KASAN as use-after-free in case another structure was recently freed from the slot past the bound, but it is really an OOB read. This issue was found by syzkaller tool. Call Trace: [ 38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710 [ 38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375 [ 38.595158] [ 38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1 [ 38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 [ 38.595304] Call Trace: [ 38.595308] <TASK> [ 38.595311] dump_stack_lvl+0xa7/0xd0 [ 38.595325] print_address_description.constprop.0+0x2c/0x3f0 [ 38.595339] ? __ext4_check_dir_entry+0x67e/0x710 [ 38.595349] print_report+0xaa/0x250 [ 38.595359] ? __ext4_check_dir_entry+0x67e/0x710 [ 38.595368] ? kasan_addr_to_slab+0x9/0x90 [ 38.595378] kasan_report+0xab/0xe0 [ 38.595389] ? __ext4_check_dir_entry+0x67e/0x710 [ 38.595400] __ext4_check_dir_entry+0x67e/0x710 [ 38.595410] ext4_empty_dir+0x465/0x990 [ 38.595421] ? __pfx_ext4_empty_dir+0x10/0x10 [ 38.595432] ext4_rmdir.part.0+0x29a/0xd10 [ 38.595441] ? __dquot_initialize+0x2a7/0xbf0 [ 38.595455] ? __pfx_ext4_rmdir.part.0+0x10/0x10 [ 38.595464] ? __pfx___dquot_initialize+0x10/0x10 [ 38.595478] ? down_write+0xdb/0x140 [ 38.595487] ? __pfx_down_write+0x10/0x10 [ 38.595497] ext4_rmdir+0xee/0x140 [ 38.595506] vfs_rmdir+0x209/0x670 [ 38.595517] ? lookup_one_qstr_excl+0x3b/0x190 [ 38.595529] do_rmdir+0x363/0x3c0 [ 38.595537] ? __pfx_do_rmdir+0x10/0x10 [ 38.595544] ? strncpy_from_user+0x1ff/0x2e0 [ 38.595561] __x64_sys_unlinkat+0xf0/0x130 [ 38.595570] do_syscall_64+0x5b/0x180 [ 38.595583] entry_SYSCALL_64_after_hwframe+0x76/0x7e",
        "technologies": "Linux\nLinux Kernel 2.6.19 以上 5.10.236 未満\nLinux Kernel 5.11 以上 5.15.180 未満\nLinux Kernel 5.16 以上 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-003659": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: cdx: Fix possible UAF error in driver_override_show() Fixed a possible UAF problem in driver_override_show() in drivers/cdx/cdx.c This function driver_override_show() is part of DEVICE_ATTR_RW, which includes both driver_override_show() and driver_override_store(). These functions can be executed concurrently in sysfs. The driver_override_store() function uses driver_set_override() to update the driver_override value, and driver_set_override() internally locks the device (device_lock(dev)). If driver_override_show() reads cdx_dev->driver_override without locking, it could potentially access a freed pointer if driver_override_store() frees the string concurrently. This could lead to printing a kernel address, which is a security risk since DEVICE_ATTR can be read by all users. Additionally, a similar pattern is used in drivers/amba/bus.c, as well as many other bus drivers, where device_lock() is taken in the show function, and it has been working without issues. This potential bug was detected by our experimental static analysis tool, which analyzes locking APIs and paired functions to identify data races and atomicity violations.",
        "technologies": "Linux\nLinux Kernel 5.10 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.19 未満\nLinux Kernel 6.13 以上 6.13.7 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-004253": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: validate zero num_subauth before sub_auth is accessed Access psid->sub_auth[psid->num_subauth - 1] without checking if num_subauth is non-zero leads to an out-of-bounds read. This patch adds a validation step to ensure num_subauth != 0 before sub_auth is accessed.",
        "technologies": "Linux\nLinux Kernel 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004172": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show() The csts_state_names[] array only has six sparse entries, but the iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a potential out-of-bounds stack read. Fix that. Fixes the following warning with an UBSAN kernel: vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section",
        "technologies": "Linux\nLinux Kernel 6.11 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004257": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: objtool, spi: amd: Fix out-of-bounds stack access in amd_set_spi_freq() If speed_hz < AMD_SPI_MIN_HZ, amd_set_spi_freq() iterates over the entire amd_spi_freq array without breaking out early, causing 'i' to go beyond the array bounds. Fix that by stopping the loop when it gets to the last entry, so the low speed_hz value gets clamped up to AMD_SPI_MIN_HZ. Fixes the following warning with an UBSAN kernel: drivers/spi/spi-amd.o: error: objtool: amd_set_spi_freq() falls through to next function amd_spi_set_opcode()",
        "technologies": "Linux\nLinux Kernel 6.1 以上 6.14.2 未満"
    },
    "JVNDB-2025-004269": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: tracing: Fix use-after-free in print_graph_function_flags during tracer switching Kairui reported a UAF issue in print_graph_function_flags() during ftrace stress testing [1]. This issue can be reproduced if puting a 'mdelay(10)' after 'mutex_unlock(&trace_types_lock)' in s_start(), and executing the following script: $ echo function_graph > current_tracer $ cat trace > /dev/null & $ sleep 5 # Ensure the 'cat' reaches the 'mdelay(10)' point $ echo timerlat > current_tracer The root cause lies in the two calls to print_graph_function_flags within print_trace_line during each s_show(): * One through 'iter->trace->print_line()'; * Another through 'event->funcs->trace()', which is hidden in print_trace_fmt() before print_trace_line returns. Tracer switching only updates the former, while the latter continues to use the print_line function of the old tracer, which in the script above is print_graph_function_flags. Moreover, when switching from the 'function_graph' tracer to the 'timerlat' tracer, s_start only calls graph_trace_close of the 'function_graph' tracer to free 'iter->private', but does not set it to NULL. This provides an opportunity for 'event->funcs->trace()' to use an invalid 'iter->private'. To fix this issue, set 'iter->private' to NULL immediately after freeing it in graph_trace_close(), ensuring that an invalid pointer is not passed to other tracers. Additionally, clean up the unnecessary 'iter->private = NULL' during each 'cat trace' when using wakeup and irqsoff tracers. [1] https://lore.kernel.org/all/20231112150030.84609-1-ryncsn@gmail.com/",
        "technologies": "Linux\nLinux Kernel 4.14.324 以上 4.15 未満\nLinux Kernel 4.19.293 以上 4.20 未満\nLinux Kernel 5.4.255 以上 5.4.292 未満\nLinux Kernel 5.10.193 以上 5.10.236 未満\nLinux Kernel 5.15.129 以上 5.15.180 未満\nLinux Kernel 6.1.50 以上 6.1.134 未満\nLinux Kernel 6.4.13 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004254": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_tunnel: fix geneve_opt type confusion addition When handling multiple NFTA_TUNNEL_KEY_OPTS_GENEVE attributes, the parsing logic should place every geneve_opt structure one by one compactly. Hence, when deciding the next geneve_opt position, the pointer addition should be in units of char *. However, the current implementation erroneously does type conversion before the addition, which will lead to heap out-of-bounds write. [ 6.989857] ================================================================== [ 6.990293] BUG: KASAN: slab-out-of-bounds in nft_tunnel_obj_init+0x977/0xa70 [ 6.990725] Write of size 124 at addr ffff888005f18974 by task poc/178 [ 6.991162] [ 6.991259] CPU: 0 PID: 178 Comm: poc-oob-write Not tainted 6.1.132 #1 [ 6.991655] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 [ 6.992281] Call Trace: [ 6.992423] <TASK> [ 6.992586] dump_stack_lvl+0x44/0x5c [ 6.992801] print_report+0x184/0x4be [ 6.993790] kasan_report+0xc5/0x100 [ 6.994252] kasan_check_range+0xf3/0x1a0 [ 6.994486] memcpy+0x38/0x60 [ 6.994692] nft_tunnel_obj_init+0x977/0xa70 [ 6.995677] nft_obj_init+0x10c/0x1b0 [ 6.995891] nf_tables_newobj+0x585/0x950 [ 6.996922] nfnetlink_rcv_batch+0xdf9/0x1020 [ 6.998997] nfnetlink_rcv+0x1df/0x220 [ 6.999537] netlink_unicast+0x395/0x530 [ 7.000771] netlink_sendmsg+0x3d0/0x6d0 [ 7.001462] __sock_sendmsg+0x99/0xa0 [ 7.001707] ____sys_sendmsg+0x409/0x450 [ 7.002391] ___sys_sendmsg+0xfd/0x170 [ 7.003145] __sys_sendmsg+0xea/0x170 [ 7.004359] do_syscall_64+0x5e/0x90 [ 7.005817] entry_SYSCALL_64_after_hwframe+0x6e/0xd8 [ 7.006127] RIP: 0033:0x7ec756d4e407 [ 7.006339] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 faf [ 7.007364] RSP: 002b:00007ffed5d46760 EFLAGS: 00000202 ORIG_RAX: 000000000000002e [ 7.007827] RAX: ffffffffffffffda RBX: 00007ec756cc4740 RCX: 00007ec756d4e407 [ 7.008223] RDX: 0000000000000000 RSI: 00007ffed5d467f0 RDI: 0000000000000003 [ 7.008620] RBP: 00007ffed5d468a0 R08: 0000000000000000 R09: 0000000000000000 [ 7.009039] R10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000000 [ 7.009429] R13: 00007ffed5d478b0 R14: 00007ec756ee5000 R15: 00005cbd4e655cb8 Fix this bug with correct pointer addition and conversion in parse and dump code.",
        "technologies": "Linux\nLinux Kernel 5.7 以上 5.10.236 未満\nLinux Kernel 5.11 以上 5.15.180 未満\nLinux Kernel 5.16 以上 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004268": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in ksmbd_sessions_deregister() In multichannel mode, UAF issue can occur in session_deregister when the second channel sets up a session through the connection of the first channel. session that is freed through the global session table can be accessed again through ->sessions of connection.",
        "technologies": "Linux\nLinux Kernel 6.1.134 未満\nLinux Kernel 6.2 以上 6.6.87 未満\nLinux Kernel 6.7 以上 6.12.13 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004397": {
        "title": "Linux の Linux Kernel における配列インデックスの検証に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: spi: cadence: Fix out-of-bounds array access in cdns_mrvl_xspi_setup_clock() If requested_clk > 128, cdns_mrvl_xspi_setup_clock() iterates over the entire cdns_mrvl_xspi_clk_div_list array without breaking out early, causing 'i' to go beyond the array bounds. Fix that by stopping the loop when it gets to the last entry, clamping the clock to the minimum 6.25 MHz. Fixes the following warning with an UBSAN kernel: vmlinux.o: warning: objtool: cdns_mrvl_xspi_setup_clock: unexpected end of section .text.cdns_mrvl_xspi_setup_clock",
        "technologies": "Linux\nLinux Kernel 6.12 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004528": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: ublk: make sure ubq->canceling is set when queue is frozen Now ublk driver depends on `ubq->canceling` for deciding if the request can be dispatched via uring_cmd & io_uring_cmd_complete_in_task(). Once ubq->canceling is set, the uring_cmd can be done via ublk_cancel_cmd() and io_uring_cmd_done(). So set ubq->canceling when queue is frozen, this way makes sure that the flag can be observed from ublk_queue_rq() reliably, and avoids use-after-free on uring_cmd.",
        "technologies": "Linux\nLinux Kernel 6.7 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004289": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix slab-out-of-bounds read in ea_get() During the \"size_check\" label in ea_get(), the code checks if the extended attribute list (xattr) size matches ea_size. If not, it logs \"ea_get: invalid extended attribute\" and calls print_hex_dump(). Here, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds INT_MAX (2,147,483,647). Then ea_size is clamped: int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr)); Although clamp_t aims to bound ea_size between 0 and 4110417968, the upper limit is treated as an int, causing an overflow above 2^31 - 1. This leads \"size\" to wrap around and become negative (-184549328). The \"size\" is then passed to print_hex_dump() (called \"len\" in print_hex_dump()), it is passed as type size_t (an unsigned type), this is then stored inside a variable called \"int remaining\", which is then assigned to \"int linelen\" which is then passed to hex_dump_to_buffer(). In print_hex_dump() the for loop, iterates through 0 to len-1, where len is 18446744073525002176, calling hex_dump_to_buffer() on each iteration: for (i = 0; i < len; i += rowsize) { linelen = min(remaining, rowsize); remaining -= rowsize; hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize, linebuf, sizeof(linebuf), ascii); ... } The expected stopping condition (i < len) is effectively broken since len is corrupted and very large. This eventually leads to the \"ptr+i\" being passed to hex_dump_to_buffer() to get closer to the end of the actual bounds of \"ptr\", eventually an out of bounds access is done in hex_dump_to_buffer() in the following for loop: for (j = 0; j < len; j++) { if (linebuflen < lx + 2) goto overflow2; ch = ptr[j]; ... } To fix this we should validate \"EALIST_SIZE(ea_buf->xattr)\" before it is utilised.",
        "technologies": "Linux\nLinux Kernel 4.19.325 以上 4.20 未満\nLinux Kernel 5.4.287 以上 5.4.292 未満\nLinux Kernel 5.10.231 以上 5.10.236 未満\nLinux Kernel 5.15.174 以上 5.15.180 未満\nLinux Kernel 6.1.120 以上 6.1.134 未満\nLinux Kernel 6.6.64 以上 6.6.87 未満\nLinux Kernel 6.11.11 以上 6.12 未満\nLinux Kernel 6.12.2 以上 6.12.23 未満\nLinux Kernel 6.13 以上 6.13.11 未満\nLinux Kernel 6.14 以上 6.14.2 未満"
    },
    "JVNDB-2025-004271": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: HSI: ssi_protocol: Fix use after free vulnerability in ssi_protocol Driver Due to Race Condition In the ssi_protocol_probe() function, &ssi->work is bound with ssip_xmit_work(), In ssip_pn_setup(), the ssip_pn_xmit() function within the ssip_pn_ops structure is capable of starting the work. If we remove the module which will call ssi_protocol_remove() to make a cleanup, it will free ssi through kfree(ssi), while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | ssip_xmit_work ssi_protocol_remove | kfree(ssi); | | struct hsi_client *cl = ssi->cl; | // use ssi Fix it by ensuring that the work is canceled before proceeding with the cleanup in ssi_protocol_remove().",
        "technologies": "Linux\nLinux Kernel 6.1.135 未満\nLinux Kernel 6.2 以上 6.6.88 未満\nLinux Kernel 6.7 以上 6.12.24 未満\nLinux Kernel 6.13 以上 6.13.12 未満\nLinux Kernel 6.14 以上 6.14.3 未満"
    },
    "JVNDB-2025-005907": {
        "title": "Linux Foundation の Python 用 pytorch における信頼できないデータのデシリアライゼーションに関する脆弱性",
        "description": "PyTorch is a Python package that provides tensor computation with strong GPU acceleration and deep neural networks built on a tape-based autograd system. In version 2.5.1 and prior, a Remote Command Execution (RCE) vulnerability exists in PyTorch when loading a model using torch.load with weights_only=True. This issue has been patched in version 2.6.0.",
        "technologies": "Linux Foundation\npytorch 2.6.0 未満"
    },
    "JVNDB-2025-006441": {
        "title": "Linux の Linux Kernel における古典的バッファオーバーフローの脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: udmabuf: fix a buf size overflow issue during udmabuf creation by casting size_limit_mb to u64 when calculate pglimit.",
        "technologies": "Linux\nLinux Kernel 5.4.293 未満\nLinux Kernel 5.5 以上 5.10.237 未満\nLinux Kernel 5.11 以上 5.15.181 未満\nLinux Kernel 5.16 以上 6.1.136 未満\nLinux Kernel 6.2 以上 6.6.89 未満\nLinux Kernel 6.7 以上 6.14.5 未満\nLinux Kernel 6.15"
    },
    "JVNDB-2025-004788": {
        "title": "ソフォスの Linux 用 Taegis Endpoint Agent におけるコードインジェクションの脆弱性",
        "description": "A code injection vulnerability in the Debian package component of Taegis Endpoint Agent (Linux) versions older than 1.3.10 allows local users arbitrary code execution as root. Redhat-based systems using RPM packages are not affected.",
        "technologies": "ソフォス\nTaegis Endpoint Agent 1.3.10 未満"
    },
    "JVNDB-2025-006348": {
        "title": "Linux Foundation の DocArray におけるオブジェクトプロトタイプ属性の不適切に制御された変更に関する脆弱性",
        "description": "A vulnerability was found in docarray up to 0.40.1. It has been rated as critical. Affected by this issue is the function __getitem__ of the file /docarray/data/torch_dataset.py of the component Web API. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
        "technologies": "Linux Foundation\nDocArray 0.40.1 およびそれ以前"
    },
    "JVNDB-2025-004598": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: memstick: rtsx_usb_ms: Fix slab-use-after-free in rtsx_usb_ms_drv_remove This fixes the following crash: ================================================================== BUG: KASAN: slab-use-after-free in rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms] Read of size 8 at addr ffff888136335380 by task kworker/6:0/140241 CPU: 6 UID: 0 PID: 140241 Comm: kworker/6:0 Kdump: loaded Tainted: G E 6.14.0-rc6+ #1 Tainted: [E]=UNSIGNED_MODULE Hardware name: LENOVO 30FNA1V7CW/1057, BIOS S0EKT54A 07/01/2024 Workqueue: events rtsx_usb_ms_poll_card [rtsx_usb_ms] Call Trace: <TASK> dump_stack_lvl+0x51/0x70 print_address_description.constprop.0+0x27/0x320 ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms] print_report+0x3e/0x70 kasan_report+0xab/0xe0 ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms] rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms] ? __pfx_rtsx_usb_ms_poll_card+0x10/0x10 [rtsx_usb_ms] ? __pfx___schedule+0x10/0x10 ? kick_pool+0x3b/0x270 process_one_work+0x357/0x660 worker_thread+0x390/0x4c0 ? __pfx_worker_thread+0x10/0x10 kthread+0x190/0x1d0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2d/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 161446: kasan_save_stack+0x20/0x40 kasan_save_track+0x10/0x30 __kasan_kmalloc+0x7b/0x90 __kmalloc_noprof+0x1a7/0x470 memstick_alloc_host+0x1f/0xe0 [memstick] rtsx_usb_ms_drv_probe+0x47/0x320 [rtsx_usb_ms] platform_probe+0x60/0xe0 call_driver_probe+0x35/0x120 really_probe+0x123/0x410 __driver_probe_device+0xc7/0x1e0 driver_probe_device+0x49/0xf0 __device_attach_driver+0xc6/0x160 bus_for_each_drv+0xe4/0x160 __device_attach+0x13a/0x2b0 bus_probe_device+0xbd/0xd0 device_add+0x4a5/0x760 platform_device_add+0x189/0x370 mfd_add_device+0x587/0x5e0 mfd_add_devices+0xb1/0x130 rtsx_usb_probe+0x28e/0x2e0 [rtsx_usb] usb_probe_interface+0x15c/0x460 call_driver_probe+0x35/0x120 really_probe+0x123/0x410 __driver_probe_device+0xc7/0x1e0 driver_probe_device+0x49/0xf0 __device_attach_driver+0xc6/0x160 bus_for_each_drv+0xe4/0x160 __device_attach+0x13a/0x2b0 rebind_marked_interfaces.isra.0+0xcc/0x110 usb_reset_device+0x352/0x410 usbdev_do_ioctl+0xe5c/0x1860 usbdev_ioctl+0xa/0x20 __x64_sys_ioctl+0xc5/0xf0 do_syscall_64+0x59/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 161506: kasan_save_stack+0x20/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x36/0x60 __kasan_slab_free+0x34/0x50 kfree+0x1fd/0x3b0 device_release+0x56/0xf0 kobject_cleanup+0x73/0x1c0 rtsx_usb_ms_drv_remove+0x13d/0x220 [rtsx_usb_ms] platform_remove+0x2f/0x50 device_release_driver_internal+0x24b/0x2e0 bus_remove_device+0x124/0x1d0 device_del+0x239/0x530 platform_device_del.part.0+0x19/0xe0 platform_device_unregister+0x1c/0x40 mfd_remove_devices_fn+0x167/0x170 device_for_each_child_reverse+0xc9/0x130 mfd_remove_devices+0x6e/0xa0 rtsx_usb_disconnect+0x2e/0xd0 [rtsx_usb] usb_unbind_interface+0xf3/0x3f0 device_release_driver_internal+0x24b/0x2e0 proc_disconnect_claim+0x13d/0x220 usbdev_do_ioctl+0xb5e/0x1860 usbdev_ioctl+0xa/0x20 __x64_sys_ioctl+0xc5/0xf0 do_syscall_64+0x59/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Last potentially related work creation: kasan_save_stack+0x20/0x40 kasan_record_aux_stack+0x85/0x90 insert_work+0x29/0x100 __queue_work+0x34a/0x540 call_timer_fn+0x2a/0x160 expire_timers+0x5f/0x1f0 __run_timer_base.part.0+0x1b6/0x1e0 run_timer_softirq+0x8b/0xe0 handle_softirqs+0xf9/0x360 __irq_exit_rcu+0x114/0x130 sysvec_apic_timer_interrupt+0x72/0x90 asm_sysvec_apic_timer_interrupt+0x16/0x20 Second to last potentially related work creation: kasan_save_stack+0x20/0x40 kasan_record_aux_stack+0x85/0x90 insert_work+0x29/0x100 __queue_work+0x34a/0x540 call_timer_fn+0x2a/0x160 expire_timers+0x5f/0x1f0 __run_timer_base.part.0+0x1b6/0x1e0 run_timer_softirq+0x8b/0xe0 handle_softirqs+0xf9/0x ---truncated---",
        "technologies": "Linux\nLinux Kernel 5.0 以上 5.4.292 未満\nLinux Kernel 5.5 以上 5.10.236 未満\nLinux Kernel 5.11 以上 5.15.180 未満\nLinux Kernel 5.16 以上 6.1.133 未満\nLinux Kernel 6.2 以上 6.6.86 未満\nLinux Kernel 6.7 以上 6.12.22 未満\nLinux Kernel 6.13 以上 6.13.10 未満\nLinux Kernel 6.14 以上 6.14.1 未満"
    },
    "JVNDB-2025-009323": {
        "title": "マイクロソフトの複数の Microsoft Windows 製品における権限を昇格される脆弱性",
        "description": "Out-of-bounds read in Windows Subsystem for Linux allows an authorized attacker to elevate privileges locally.",
        "technologies": "マイクロソフト\nMicrosoft Windows 10 Version 21H2 for 32-bit Systems\nMicrosoft Windows 10 Version 21H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 21H2 for x64-based Systems\nMicrosoft Windows 10 Version 22H2 for 32-bit Systems\nMicrosoft Windows 10 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 10 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 Version 23H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 23H2 for x64-based Systems\nMicrosoft Windows 11 Version 24H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 24H2 for x64-based Systems\nMicrosoft Windows Server 2022 (Server Core installation)\nMicrosoft Windows Server 2022 , 23H2 Edition (Server Core installation)\nMicrosoft Windows Server 2022\nMicrosoft Windows Server 2025 (Server Core installation)\nMicrosoft Windows Server 2025"
    },
    "JVNDB-2025-010808": {
        "title": "Zoom Video Communications, Inc. の Linux 用 Zoom Workplace Desktop における証明書検証に関する脆弱性",
        "description": "Improper certificate validation in Zoom Workplace for Linux before version 6.4.13 may allow an unauthorized user to conduct an information disclosure via network access.",
        "technologies": "Zoom Video Communications, Inc.\nZoom Workplace Desktop 6.4.13 未満"
    },
    "JVNDB-2025-010900": {
        "title": "IBM の Linux 用 IBM DB2 におけるデッドロックに関する脆弱性",
        "description": "IBM Db2 for Linux 12.1.0, 12.1.1, and 12.1.2 could allow an unauthenticated user to cause a denial of service due to executable segments that are waiting for each other to release a necessary lock.",
        "technologies": "IBM\nIBM DB2 12.1.0\nIBM DB2 12.1.1\nIBM DB2 12.1.2"
    },
    "JVNDB-2025-010901": {
        "title": "IBM の Linux 用 IBM DB2 におけるデータクエリロジックの特殊要素の不適切な中立化に関する脆弱性",
        "description": "IBM Db2 for Linux 12.1.0, 12.1.1, and 12.1.2 is vulnerable to denial of service with a specially crafted query under certain non-default conditions.",
        "technologies": "IBM\nIBM DB2 12.1.0\nIBM DB2 12.1.1\nIBM DB2 12.1.2"
    },
    "JVNDB-2025-012002": {
        "title": "Linux Foundation の MaterialX におけるスタックベースのバッファオーバーフローの脆弱性",
        "description": "MaterialX is an open standard for the exchange of rich material and look-development content across applications and renderers. In versions 1.39.2 and below, when parsing an MTLX file with multiple nested nodegraph implementations, the MaterialX XML parsing logic can potentially crash due to stack exhaustion. An attacker could intentionally crash a target program that uses OpenEXR by sending a malicious MTLX file. This is fixed in version 1.39.3.",
        "technologies": "Linux Foundation\nMaterialX 1.39.2"
    },
    "JVNDB-2025-011840": {
        "title": "マイクロソフトの Windows Subsystem for Linux における権限を昇格される脆弱性",
        "description": "Time-of-check time-of-use (toctou) race condition in Windows Subsystem for Linux allows an authorized attacker to elevate privileges locally.",
        "technologies": "マイクロソフト\nWindows Subsystem for Linux (WSL2)"
    },
    "JVNDB-2025-010842": {
        "title": "IBM の Linux 用 IBM DB2 におけるスタックベースのバッファオーバーフローの脆弱性",
        "description": "IBM Db2 for Linux 12.1.0, 12.1.1, and 12.1.2 is vulnerable to a stack-based buffer overflow in db2fm, caused by improper bounds checking. A local user could overflow the buffer and execute arbitrary code on the system.",
        "technologies": "IBM\nIBM DB2 12.1.0\nIBM DB2 12.1.1\nIBM DB2 12.1.2"
    },
    "JVNDB-2025-010843": {
        "title": "IBM の Linux 用 IBM DB2 における過剰なサイズ値のメモリ割り当てに関する脆弱性",
        "description": "IBM Db2 for Linux 12.1.0, 12.1.1, and 12.1.2 is vulnerable to a denial of service as the server may crash under certain conditions with a specially crafted query.",
        "technologies": "IBM\nIBM DB2 12.1.0\nIBM DB2 12.1.1\nIBM DB2 12.1.2"
    },
    "JVNDB-2025-008246": {
        "title": "マイクロソフトの Microsoft Windows 11 および Windows Server におけるリモートでコードを実行される脆弱性",
        "description": "Untrusted pointer dereference in Windows Subsystem for Linux allows an unauthorized attacker to execute code locally.",
        "technologies": "マイクロソフト\nMicrosoft Windows 11 Version 22H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 22H2 for x64-based Systems\nMicrosoft Windows 11 Version 23H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 23H2 for x64-based Systems\nMicrosoft Windows 11 Version 24H2 for ARM64-based Systems\nMicrosoft Windows 11 Version 24H2 for x64-based Systems\nMicrosoft Windows Server 2022 (Server Core installation)\nMicrosoft Windows Server 2022 , 23H2 Edition (Server Core installation)\nMicrosoft Windows Server 2022\nMicrosoft Windows Server 2025 (Server Core installation)\nMicrosoft Windows Server 2025"
    },
    "JVNDB-2025-014344": {
        "title": "Linux Foundation の containerd における不適切な権限設定に関する脆弱性",
        "description": "containerd is an open-source container runtime. A bug was found in the containerd's CRI implementation where containerd, starting in version 2.0.1 and prior to version 2.0.5, doesn't put usernamespaced containers under the Kubernetes' cgroup hierarchy, therefore some Kubernetes limits are not honored. This may cause a denial of service of the Kubernetes node. This bug has been fixed in containerd 2.0.5+ and 2.1.0+. Users should update to these versions to resolve the issue. As a workaround, disable usernamespaced pods in Kubernetes temporarily.",
        "technologies": "Linux Foundation\ncontainerd 2.0.1 以上 2.0.5 未満"
    },
    "JVNDB-2025-014182": {
        "title": "Linux Foundation の Go 用 Dragonfly における初期化されていない変数の使用に関する脆弱性",
        "description": "Dragonfly is an open source P2P-based file distribution and image acceleration system. Prior to 2.1.0, the processPieceFromSource method does not update the structure’s usedTraffic field, because an uninitialized variable n is used as a guard to the AddTraffic method call, instead of the result.Size variable. A task is processed by a peer. The usedTraffic metadata is not updated during the processing. Rate limiting is incorrectly applied, leading to a denial-of-service condition for the peer. This vulnerability is fixed in 2.1.0.",
        "technologies": "Linux Foundation\nDragonfly 2.1.0 未満"
    },
    "JVNDB-2025-014508": {
        "title": "Linux Foundation の Go 用 Dragonfly におけるパストラバーサルの脆弱性",
        "description": "Dragonfly is an open source P2P-based file distribution and image acceleration system. Prior to 2.1.0, the gRPC API and HTTP APIs allow peers to send requests that force the recipient peer to create files in arbitrary file system locations, and to read arbitrary files. This allows peers to steal other peers’ secret data and to gain remote code execution (RCE) capabilities on the peer’s machine.This vulnerability is fixed in 2.1.0.",
        "technologies": "Linux Foundation\nDragonfly 2.1.0 未満"
    },
    "JVNDB-2025-014468": {
        "title": "Linux Foundation の Go 用 Dragonfly における証明書検証に関する脆弱性",
        "description": "Dragonfly is an open source P2P-based file distribution and image acceleration system. Prior to 2.1.0, a peer can obtain a valid TLS certificate for arbitrary IP addresses, effectively rendering the mTLS authentication useless. The issue is that the Manager’s Certificate gRPC service does not validate if the requested IP addresses “belong to” the peer requesting the certificate—that is, if the peer connects from the same IP address as the one provided in the certificate request. This vulnerability is fixed in 2.1.0.",
        "technologies": "Linux Foundation\nDragonfly 2.1.0 未満"
    },
    "JVNDB-2025-013285": {
        "title": "Linux の Linux Kernel における Time-of-check Time-of-use (TOCTOU) 競合状態の脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: posix-cpu-timers: fix race between handle_posix_cpu_timers() and posix_cpu_timer_del() If an exiting non-autoreaping task has already passed exit_notify() and calls handle_posix_cpu_timers() from IRQ, it can be reaped by its parent or debugger right after unlock_task_sighand(). If a concurrent posix_cpu_timer_del() runs at that moment, it won't be able to detect timer->it.cpu.firing != 0: cpu_timer_task_rcu() and/or lock_task_sighand() will fail. Add the tsk->exit_state check into run_posix_cpu_timers() to fix this. This fix is not needed if CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y, because exit_task_work() is called before exit_notify(). But the check still makes sense, task_work_add(&tsk->posix_cputimers_work.work) will fail anyway in this case.",
        "technologies": "Linux\nLinux Kernel 2.6.36 以上 5.4.295 未満\nLinux Kernel 5.5 以上 5.10.239 未満\nLinux Kernel 5.11 以上 5.15.186 未満\nLinux Kernel 5.16 以上 6.1.142 未満\nLinux Kernel 6.2 以上 6.6.94 未満\nLinux Kernel 6.7 以上 6.12.34 未満\nLinux Kernel 6.13 以上 6.15.3 未満\nLinux Kernel 6.16"
    },
    "JVNDB-2025-014635": {
        "title": "Linux の Linux Kernel における境界外書き込みに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: usb: cdc-acm: Check control transfer buffer size before access If the first fragment is shorter than struct usb_cdc_notification, we can't calculate an expected_size. Log an error and discard the notification instead of reading lengths from memory outside the received data, which can lead to memory corruption when the expected_size decreases between fragments, causing `expected_size - acm->nb_index` to wrap. This issue has been present since the beginning of git history; however, it only leads to memory corruption since commit ea2583529cd1 (\"cdc-acm: reassemble fragmented notifications\"). A mitigating factor is that acm_ctrl_irq() can only execute after userspace has opened /dev/ttyACM*; but if ModemManager is running, ModemManager will do that automatically depending on the USB device's vendor/product IDs and its other interfaces.",
        "technologies": "Linux\nLinux Kernel 2.6.13 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.129 未満\nLinux Kernel 6.2 以上 6.6.79 未満\nLinux Kernel 6.7 以上 6.12.16 未満\nLinux Kernel 6.13 以上 6.13.4 未満\nLinux Kernel 2.6.12\nLinux Kernel 6.14"
    },
    "JVNDB-2025-015160": {
        "title": "Linux の Linux Kernel における境界外読み取りに関する脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: sched: sch_cake: add bounds checks to host bulk flow fairness counts Even though we fixed a logic error in the commit cited below, syzbot still managed to trigger an underflow of the per-host bulk flow counters, leading to an out of bounds memory access. To avoid any such logic errors causing out of bounds memory accesses, this commit factors out all accesses to the per-host bulk flow counters to a series of helpers that perform bounds-checking before any increments and decrements. This also has the benefit of improving readability by moving the conditional checks for the flow mode into these helpers, instead of having them spread out throughout the code (which was the cause of the original logic error). As part of this change, the flow quantum calculation is consolidated into a helper function, which means that the dithering applied to the ost load scaling is now applied both in the DRR rotation and when a sparse flow's quantum is first initiated. The only user-visible effect of this is that the maximum packet size that can be sent while a flow stays sparse will now vary with +/- one byte in some cases. This should not make a noticeable difference in practice, and thus it's not worth complicating the code to preserve the old behaviour.",
        "technologies": "Linux\nLinux Kernel 5.4.284 以上 5.4.291 未満\nLinux Kernel 5.10.226 以上 5.10.235 未満\nLinux Kernel 5.15.167 以上 5.15.179 未満\nLinux Kernel 6.1.110 以上 6.1.125 未満\nLinux Kernel 6.6.51 以上 6.6.72 未満\nLinux Kernel 6.10.10 以上 6.11 未満\nLinux Kernel 6.11.1 以上 6.12.10 未満\nLinux Kernel 6.11\nLinux Kernel 6.13"
    },
    "JVNDB-2025-012390": {
        "title": "Linux Foundation の MaterialX における NULL ポインタデリファレンスに関する脆弱性",
        "description": "MaterialX is an open standard for the exchange of rich material and look-development content across applications and renderers. In version 1.39.2, when parsing shader nodes in a MTLX file, the MaterialXCore code accesses a potentially null pointer, which can lead to crashes with maliciously crafted files. An attacker could intentionally crash a target program that uses OpenEXR by sending a malicious MTLX file. This is fixed in version 1.39.3.",
        "technologies": "Linux Foundation\nMaterialX 1.39.2"
    },
    "JVNDB-2025-012920": {
        "title": "Linux Foundation の Yocto 等複数ベンダの製品における解放済みメモリの使用に関する脆弱性",
        "description": "In monitor_hang, there is a possible memory corruption due to use after free. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. Patch ID: ALPS09989078; Issue ID: MSV-3964.",
        "technologies": "Google\nAndroid 13.0\nAndroid 14.0\nAndroid 15.0\nAndroid 16.0\nLinux Foundation\nYocto 2.6\nOpenWrt Project\nOpenWrt 19.07.0\nOpenWrt 21.02.0"
    },
    "JVNDB-2025-012389": {
        "title": "Linux Foundation の MaterialX における NULL ポインタデリファレンスに関する脆弱性",
        "description": "MaterialX is an open standard for the exchange of rich material and look-development content across applications and renderers. In version 1.39.2, when parsing shader nodes in a MTLX file, the MaterialXCore code accesses a potentially null pointer, which can lead to crashes with maliciously crafted files. An attacker could intentionally crash a target program that uses MaterialX by sending a malicious MTLX file. This is fixed in version 1.39.3.",
        "technologies": "Linux Foundation\nMaterialX 1.39.2"
    },
    "JVNDB-2025-015191": {
        "title": "Linux Foundation の Python 用 pytorch における脆弱性",
        "description": "A syntax error in the component proxy_tensor.py of pytorch v2.7.0 allows attackers to cause a Denial of Service (DoS).",
        "technologies": "Linux Foundation\npytorch 2.7.0 およびそれ以前"
    },
    "JVNDB-2025-015223": {
        "title": "Linux Foundation の Python 用 pytorch における脆弱性",
        "description": "An issue in the component torch.linalg.lu of pytorch v2.8.0 allows attackers to cause a Denial of Service (DoS) when performing a slice operation.",
        "technologies": "Linux Foundation\npytorch 2.8.0 およびそれ以前"
    },
    "JVNDB-2025-015580": {
        "title": "Linux Foundation の Python 用 pytorch における整数オーバーフローの脆弱性",
        "description": "pytorch v2.8.0 was discovered to display unexpected behavior when the components torch.rot90 and torch.randn_like are used together.",
        "technologies": "Linux Foundation\npytorch 2.8.0 およびそれ以前"
    },
    "JVNDB-2025-015579": {
        "title": "Linux Foundation の Python 用 pytorch における脆弱性",
        "description": "A Name Error occurs in pytorch v2.7.0 when a PyTorch model consists of torch.cummin and is compiled by Inductor, leading to a Denial of Service (DoS).",
        "technologies": "Linux Foundation\npytorch 2.7.0 およびそれ以前"
    },
    "JVNDB-2025-015662": {
        "title": "Linux Foundation の ONNX におけるパストラバーサルの脆弱性",
        "description": "Path Traversal vulnerability in onnx.external_data_helper.save_external_data in ONNX 1.17.0 allows attackers to overwrite arbitrary files by supplying crafted external_data.location paths containing traversal sequences, bypassing intended directory restrictions.",
        "technologies": "Linux Foundation\nONNX 1.17.0"
    },
    "JVNDB-2025-015967": {
        "title": "escanav の Linux 用 escan anti-virus におけるバッファエラーの脆弱性",
        "description": "A vulnerability was found in MicroWord eScan Antivirus 7.0.32 on Linux and classified as critical. Affected by this issue is the function strcpy of the component VirusPopUp. The manipulation leads to stack-based buffer overflow. The attack needs to be approached locally. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
        "technologies": "escanav\nescan anti-virus 7.0.32"
    },
    "JVNDB-2025-016156": {
        "title": "Linux Foundation の Python 用 pytorch における脆弱性",
        "description": "An issue in pytorch v2.7.0 can lead to a Denial of Service (DoS) when a PyTorch model consists of torch.Tensor.to_sparse() and torch.Tensor.to_dense() and is compiled by Inductor.",
        "technologies": "Linux Foundation\npytorch 2.7.0 およびそれ以前"
    },
    "JVNDB-2025-015916": {
        "title": "escanav の Linux 用 escan anti-virus におけるコマンドインジェクションの脆弱性",
        "description": "A vulnerability was found in MicroWorld eScan Antivirus 7.0.32 on Linux. It has been rated as critical. This issue affects some unknown processing of the file rtscanner of the component Quarantine Handler. The manipulation leads to os command injection. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
        "technologies": "escanav\nescan anti-virus 7.0.32"
    },
    "JVNDB-2025-002557": {
        "title": "Linux の Linux Kernel における解放済みメモリの使用に関する脆弱性",
        "description": "",
        "technologies": "Linux\nLinux Kernel 6.9 以上 6.12.10 未満\nLinux Kernel 6.13"
    },
    "JVNDB-2025-015691": {
        "title": "Linux Foundation の Go 用 Dragonfly における重要な機能に対する認証の欠如に関する脆弱性",
        "description": "Dragonfly is an open source P2P-based file distribution and image acceleration system. Prior to 2.1.0, The /api/v1/jobs and /preheats endpoints in Manager web UI are accessible without authentication. Any user with network access to the Manager can create, delete, and modify jobs, and create preheat jobs. An unauthenticated adversary with network access to a Manager web UI uses /api/v1/jobs endpoint to create hundreds of useless jobs. The Manager is in a denial-of-service state, and stops accepting requests from valid administrators. This vulnerability is fixed in 2.1.0.",
        "technologies": "Linux Foundation\nDragonfly 2.1.10 未満"
    },
    "JVNDB-2025-017091": {
        "title": "Linux の Linux Kernel における脆弱性",
        "description": "In the Linux kernel, the following vulnerability has been resolved: pfifo_tail_enqueue: Drop new packet when sch->limit == 0 Expected behaviour: In case we reach scheduler's limit, pfifo_tail_enqueue() will drop a packet in scheduler's queue and decrease scheduler's qlen by one. Then, pfifo_tail_enqueue() enqueue new packet and increase scheduler's qlen by one. Finally, pfifo_tail_enqueue() return `NET_XMIT_CN` status code. Weird behaviour: In case we set `sch->limit == 0` and trigger pfifo_tail_enqueue() on a scheduler that has no packet, the 'drop a packet' step will do nothing. This means the scheduler's qlen still has value equal 0. Then, we continue to enqueue new packet and increase scheduler's qlen by one. In summary, we can leverage pfifo_tail_enqueue() to increase qlen by one and return `NET_XMIT_CN` status code. The problem is: Let's say we have two qdiscs: Qdisc_A and Qdisc_B. - Qdisc_A's type must have '->graft()' function to create parent/child relationship. Let's say Qdisc_A's type is `hfsc`. Enqueue packet to this qdisc will trigger `hfsc_enqueue`. - Qdisc_B's type is pfifo_head_drop. Enqueue packet to this qdisc will trigger `pfifo_tail_enqueue`. - Qdisc_B is configured to have `sch->limit == 0`. - Qdisc_A is configured to route the enqueued's packet to Qdisc_B. Enqueue packet through Qdisc_A will lead to: - hfsc_enqueue(Qdisc_A) -> pfifo_tail_enqueue(Qdisc_B) - Qdisc_B->q.qlen += 1 - pfifo_tail_enqueue() return `NET_XMIT_CN` - hfsc_enqueue() check for `NET_XMIT_SUCCESS` and see `NET_XMIT_CN` => hfsc_enqueue() don't increase qlen of Qdisc_A. The whole process lead to a situation where Qdisc_A->q.qlen == 0 and Qdisc_B->q.qlen == 1. Replace 'hfsc' with other type (for example: 'drr') still lead to the same problem. This violate the design where parent's qlen should equal to the sum of its childrens'qlen. Bug impact: This issue can be used for user->kernel privilege escalation when it is reachable.",
        "technologies": "Linux\nLinux Kernel 2.6.34 以上 5.4.291 未満\nLinux Kernel 5.5 以上 5.10.235 未満\nLinux Kernel 5.11 以上 5.15.179 未満\nLinux Kernel 5.16 以上 6.1.130 未満\nLinux Kernel 6.2 以上 6.6.83 未満\nLinux Kernel 6.7 以上 6.12.14 未満\nLinux Kernel 6.13 以上 6.13.3 未満\nLinux Kernel 6.14"
    },
    "JVNDB-2025-015857": {
        "title": "escanav の Linux 用 escan anti-virus における不適切な権限設定に関する脆弱性",
        "description": "A vulnerability was found in MicroWorld eScan Antivirus 7.0.32 on Linux. It has been rated as critical. Affected by this issue is some unknown functionality of the file /opt/MicroWorld/var/ of the component Installation Handler. The manipulation leads to incorrect default permissions. The attack needs to be approached locally. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
        "technologies": "escanav\nescan anti-virus 7.0.32"
    },
    "JVNDB-2025-015781": {
        "title": "Linux Foundation の Python 用 pytorch におけるリソースの枯渇に関する脆弱性",
        "description": "A buffer overflow occurs in pytorch v2.7.0 when a PyTorch model consists of torch.nn.Conv2d, torch.nn.functional.hardshrink, and torch.Tensor.view-torch.mv() and is compiled by Inductor, leading to a Denial of Service (DoS).",
        "technologies": "Linux Foundation\npytorch 2.7.0 およびそれ以前"
    }
}